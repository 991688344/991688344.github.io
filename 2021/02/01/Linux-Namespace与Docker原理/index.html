<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Linux Namespace与Docker原理 | Rick</title><meta name="author" content="LYC"><meta name="copyright" content="LYC"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="namespace 初识 Docker 是一个基于 namespace、cgroup、Union FS 等等技术的一个开源容器引擎，很多人都会觉得 Docker  是个新兴技术，其实不然，其主要隔离技术 Namespace 技术早在 Linux 内核版本为 2.6 时候就差不多完成了（像 Ubuntu  16.04 发行版本的内核基本上都是 4.4，CentOS 7 则普遍 3.10 ）。 Lin">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux Namespace与Docker原理">
<meta property="og:url" content="http://991688344.github.io/2021/02/01/Linux-Namespace%E4%B8%8EDocker%E5%8E%9F%E7%90%86/index.html">
<meta property="og:site_name" content="Rick">
<meta property="og:description" content="namespace 初识 Docker 是一个基于 namespace、cgroup、Union FS 等等技术的一个开源容器引擎，很多人都会觉得 Docker  是个新兴技术，其实不然，其主要隔离技术 Namespace 技术早在 Linux 内核版本为 2.6 时候就差不多完成了（像 Ubuntu  16.04 发行版本的内核基本上都是 4.4，CentOS 7 则普遍 3.10 ）。 Lin">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://991688344.github.io/images/Wallpaper/rainbowcat.gif">
<meta property="article:published_time" content="2021-02-01T13:00:34.000Z">
<meta property="article:modified_time" content="2024-03-19T01:32:36.446Z">
<meta property="article:author" content="LYC">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="Docker">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://991688344.github.io/images/Wallpaper/rainbowcat.gif"><link rel="shortcut icon" href="/images/Wallpaper/favicon.ico"><link rel="canonical" href="http://991688344.github.io/2021/02/01/Linux-Namespace%E4%B8%8EDocker%E5%8E%9F%E7%90%86/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/content.json","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Linux Namespace与Docker原理',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><link rel="stylesheet" href="/mycss/my_background.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-color: #F7F9FE;"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/images/head.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">251</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">37</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">49</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-paper-plane"></i><span> 留言板</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/images/Wallpaper/rainbowcat.gif);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Rick</span></a><a class="nav-page-title" href="/"><span class="site-name">Linux Namespace与Docker原理</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-paper-plane"></i><span> 留言板</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Linux Namespace与Docker原理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-02-01T13:00:34.000Z" title="发表于 2021-02-01 21:00:34">2021-02-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-03-19T01:32:36.446Z" title="更新于 2024-03-19 09:32:36">2024-03-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Docker/">Docker</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">4.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>19分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="namespace-初识">namespace 初识</h2>
<p>Docker 是一个基于 namespace、cgroup、Union FS 等等技术的一个开源容器引擎，很多人都会觉得 Docker  是个新兴技术，其实不然，其主要隔离技术 Namespace 技术早在 Linux 内核版本为 2.6 时候就差不多完成了（像 Ubuntu  16.04 发行版本的内核基本上都是 4.4，CentOS 7 则普遍 3.10 ）。</p>
<p>Linux Namespace 是 Linux 提供的一种内核级别环境隔离的方法。</p>
<p>要想实现隔离的效果，需要完成的东西又有哪些呢？其实如果你安装了 gcc 工具链（安装 golang 之后就会有了），那么使用 <code>man namespaces</code> 命令就可以了解到 namespace 技术的大概，也可查看<a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man7/namespaces.7.html">在线手册</a>。</p>
<p>这里简单地搬运了些知识点，首先是 Linux 提供的具体的隔离内容：</p>
<table>
<thead>
<tr>
<th>Namespace</th>
<th>系统调用参数</th>
<th>内核版本</th>
<th>隔离内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>UTS (Unix Time-sharing System)</td>
<td>CLONE_NEWUTS</td>
<td>Linux 2.4.19</td>
<td>主机名与域名</td>
</tr>
<tr>
<td>IPC (Inter-Process Communication)</td>
<td>CLONE_NEWIPC</td>
<td>Linux 2.6.19</td>
<td>信号量、消息队列和共享内存</td>
</tr>
<tr>
<td>PID (Process ID)</td>
<td>CLONE_NEWPID</td>
<td>Linux 2.6.19</td>
<td>进程编号</td>
</tr>
<tr>
<td>Network</td>
<td>CLONE_NEWNET</td>
<td>Linux 2.6.24</td>
<td>网络设备、网络栈、端口等等</td>
</tr>
<tr>
<td>Mount</td>
<td>CLONE_NEWNS</td>
<td>Linux 2.6.29</td>
<td>挂载点（文件系统）</td>
</tr>
<tr>
<td>User</td>
<td>CLONE_NEWUSER</td>
<td>Linux 3.8</td>
<td>用户和用户组</td>
</tr>
</tbody>
</table>
<p>还设计到三个系统调用(system call)的 API：</p>
<ul>
<li>clone()：用来创建新进程，与 fork 创建新进程不同的是，clone 创建进程时候运行传递如 CLONE_NEW* 的 namespace 隔离参数，来控制子进程所共享的内容，更多内容请查看<a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/clone.2.html">clone 手册</a></li>
<li>setns()：让某个进程脱离某个 namespace</li>
<li>unshare()：让某个进程加入某个 namespace 之中</li>
</ul>
<h3 id="查看进程-namespace">查看进程 namespace</h3>
<p><code>/proc/[pid]/ns/</code> 目录下包含了某个进程的 namespace 所属，在 shell 中 <code>$$</code> 为当前进程 PID 所以可以：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l /proc/$$/ns</span></span><br><span class="line">total 0</span><br><span class="line">lrwxrwxrwx 1 root root 0 Jan  5 00:13 cgroup -&gt; cgroup:[4026531835]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Jan  4 06:18 ipc -&gt; ipc:[4026531839]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Jan  4 06:18 mnt -&gt; mnt:[4026531840]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Jan  4 06:18 net -&gt; net:[4026531957]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Jan  4 06:18 pid -&gt; pid:[4026531836]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Jan  4 06:18 user -&gt; user:[4026531837]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Jan  4 06:18 uts -&gt; uts:[4026531838]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">readlink</span> /proc/$$/ns/uts</span></span><br><span class="line">uts:[4026531838]</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">readlink</span> /proc/<span class="variable">$PPID</span>/ns/uts</span></span><br><span class="line">uts:[4026531838]</span><br></pre></td></tr></table></figure>
<p><code>/proc/[pid]/mounts</code> 目录展现了进程的挂载点，而 <code>/proc/[pid]/mountinfo</code> 里的内容更详细。</p>
<h3 id="Linux-系统调用">Linux 系统调用</h3>
<p>操作系统的进程空间可分为用户空间和内核空间，它们需要不同的执行权限。其中系统调用运行在内核空间。</p>
<p>系统调用，指运行在用户空间的程序向操作系统内核请求需要更高权限运行的服务。系统调用提供用户程序与操作系统之间的接口。大多数系统交互式操作需求在内核态运行。如设备IO操作或者进程间通信。</p>
<p><a target="_blank" rel="noopener" href="https://creaink.github.io/post/Computer/Linux/imgs/Linux_kernel_System_Call_Interface_and_glibc.png"><img src="/2021/02/01/Linux-Namespace%E4%B8%8EDocker%E5%8E%9F%E7%90%86/Linux_kernel_System_Call_Interface_and_glibc.png" alt="维基百科图"></a></p>
<p>也就是说，如果自己程序生成的可执行文件，除了一些简单的变量加来加去之外，大多数有意思的功能都是通过系统调用来完成的，平时没有感知到，是因为库函数、动态链接库封装屏蔽了这些。</p>
<p><strong>程序设计中没有什么是加一层解决不了的，如果有那就再加一层</strong>。所以 syscall 可以作为一个兼容层、移植层，可以通过实现一组 syscall 接口，用来来模拟 Linux。</p>
<p>Linux 中提供了两个工具： <code>starce</code> 和 <code>ptrace</code> 用来调试监控某个进程的系统调用。</p>
<h3 id="Linux-进程">Linux 进程</h3>
<p>Linux 下可以通过 <code>ps -ef</code> 命令打印出当前操作系统中正在执行的进程，其实还有一个更有意思的命令 <code>pstree</code> ，这个命令会以树的形式输出当前的进程。</p>
<p>为什么这些进程会形成一个树的形状？这是因为在 Linux 内核启动之后只会有一个 pid 为 0 的 运行在内核态的 <code>idle</code> 进程，随后在系统启动过程中，会通过该进程 fork 出 PID 为 1 的 <code>init</code> 进程和 PID 为 2 的 <code>kthreadd</code> 进程。</p>
<p><code>init</code> 进程负责初始化系统，并最后运行在用户空间。在系统启动完成完成后，init将变为守护进程监视系统其他进程。<code>init</code> 有不同实现，如最初的 init 到 System V 再到 Systemd，常用的 service 命令就是最初由 init 实现的，用来管理各种服务的守护进程，关于 init 的演进可以参考 <a target="_blank" rel="noopener" href="https://creaink.github.io/Computer/Linux/Linux-init.md">linux 系统管理程序</a>。</p>
<p><code>kthreadd</code> 内核线程都是直接或者间接的以 kthreadd 为父进程，该进程负责管理和调度其他的内核进程。</p>
<p>在 <code>ps -ef</code> 命令下可以看到这些进程， <code>pstree</code> 可以看到用户进程，还有一个知识点就是用户空间的进程 PID 都是大于 1000 的。</p>
<p>Uinx 的哲学中接口的设计都是高度正交的，通过 fork 和 exec系列的组合就可以完成多进程的操作。</p>
<p><code>fork()</code> 默认会进程复制当前进程自身（代码段、数据段、环境变量等等）来快速创建子进程，子进程会从调用  fork() 的地方开始执行，也就是在代码的 fork() 处进行了分叉。fork() 返回值在父进程中为创建的子进程的 PID，在子进程返回 0 ，出现错误返回负值，可以通过返回值来进行区别操作（如父进程里 wait 子进程）。</p>
<p><code>exec 系列</code> 会用一个新的程序来替换现在的整个进程，其会将程序整个加载到现在的进程中，然后从头开始运行，如更新了 bash 的某些配置之后可以用 <code>exec bash</code> 命令来利用新 bash 线程替换掉当前的进程。</p>
<p>此外还有两个<strong>有名的进程</strong>：</p>
<p><strong>孤儿进程</strong>：个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被 init 进程(进程号为1)所收养，并由 init 进程对它们完成状态收集工作。</p>
<p><strong>僵尸进程</strong>：一个进程使用 fork 创建子进程，如果子进程退出，而父进程并没有调用 wait 或 waitpid 获取（处理）子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程，在 <code>top</code> 命令里是可以看到。</p>
<p>所以通过一顿高度正交的 fork exec 操作，会形成一颗进程树，这里可以通过 pstree 演示下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pstree -pa $$</span></span><br><span class="line">zsh,1680</span><br><span class="line">  └─pstree,130454 -pa 1680</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sleep</span> 10s &amp;</span></span><br><span class="line">[1] 130554</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pstree -pa $$</span></span><br><span class="line">zsh,1680</span><br><span class="line">  ├─pstree,130562 -pa 1680</span><br><span class="line">  └─sleep,130554 10s</span><br></pre></td></tr></table></figure>
<p>其实在执行 <code>pstree -pa $$</code> 就可以看到他是基于当前终端的子进程。</p>
<h2 id="namespace-实践">namespace 实践</h2>
<p>为了最好的体验还是在 Linux 内核 3.8 以上的系统上进行（这里使用的 Ubuntu server 16.04, Linux  4.4）。为什么不用 docker for windows 或者 docker for mac 呢？因为这两个其实还是是在 linux  虚拟机上运行 docker 的，docker for windows 需要将 linux 虚拟机装在开启 hyper-v 的 win10  专业版上，而 docker for mac 使用通过 <a target="_blank" rel="noopener" href="https://github.com/moby/hyperkit">HyperKit</a> 运行 linux 虚拟机。为了方便，使用 golang 来演示循序渐进的达到 Docker 的体验。</p>
<h3 id="docker-是虚拟机吗">docker 是虚拟机吗</h3>
<p>由前面的 namespace 的知识可以知道 Docker 是比虚拟机的虚拟化程度更弱、效率更高的线程级别的隔离，下面的示例可以验证这一点。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run alpine <span class="built_in">sleep</span> 1m &amp;</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pstree -pa $$</span></span><br><span class="line">zsh,1680</span><br><span class="line">  ├─docker,7314 run alpine sleep 1m</span><br><span class="line">  │   ├─&#123;docker&#125;,7315</span><br><span class="line">  │   ├─&#123;docker&#125;,7316</span><br><span class="line">  │   ├─&#123;docker&#125;,7317</span><br><span class="line">  │   ├─&#123;docker&#125;,7318</span><br><span class="line">  │   ├─&#123;docker&#125;,7321</span><br><span class="line">  │   ├─&#123;docker&#125;,7324</span><br><span class="line">  │   └─&#123;docker&#125;,7325</span><br><span class="line">  └─pstree,7431 -pa 1680</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ps -ef |grep <span class="string">&quot;sleep 1m&quot;</span></span></span><br><span class="line">creaink    7314   1680  0 03:56 pts/1    00:00:00 docker run alpine sleep 1m</span><br><span class="line">root       7362   7344  0 03:56 ?        00:00:00 sleep 1m</span><br></pre></td></tr></table></figure>
<p>上面的例子使用 alpine 镜像运行了 <code>sleep 1m</code> 这个命令即休眠一分钟，直接使用 <code>pstree</code> 可以证实最后其虚拟化程度也就是线程级别的。后面的 <code>ps</code> 命令揭示的是其实这里有两个命令运行着 <code>sleep 1m</code>，这是因为 docker 分为 docker daemon 和 docker client，docker(docker client) 命令通过 REST API 将用户的命令传递给 dockerd(docker daemon)，也就是最后的实际工作的进程是 dockerd  下的子进程，这就是为什么在终端里运行 docker 运行容器之后，而关闭终端（父进程）容器也不会被终止掉。</p>
<h3 id="版本-zero">版本 zero</h3>
<p>先来一个基础的版本，实现一个简单的功能：将传递给程序的命令利用子进程运行：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;os/exec&quot;</span></span><br><span class="line">    <span class="string">&quot;syscall&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> os.Args[<span class="number">1</span>] &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;run&quot;</span>:</span><br><span class="line">        run()</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;do nothing, exit!!!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;running %v\n&quot;</span>, os.Args[<span class="number">2</span>:])</span><br><span class="line">    cmd := exec.Command(os.Args[<span class="number">2</span>], os.Args[<span class="number">3</span>:]...)</span><br><span class="line">    cmd.Stdin = os.Stdin</span><br><span class="line">    cmd.Stdout = os.Stdout</span><br><span class="line">    cmd.Stderr = os.Stderr</span><br><span class="line"></span><br><span class="line">    must(cmd.Run())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">must</span><span class="params">(err <span class="type">error</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>命名该程序为 docker-1.go 之后就可以使用 <code>go run docker-1.go run echo hello</code> 来 <em>代理</em> 运行命令一些命令。</p>
<p>甚至可以直接使用 <code>go run docker-1.go run /bin/bash</code> 来将子进程的 shell 衔接到当前终端上，注意 shell prompt 的变化（由 zsh 变为 bash 样式），在下面的例子中将尝试更改 hostname：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go run docker-0.go run /bin/bash</span></span><br><span class="line">running [/bin/bash]</span><br><span class="line">creaink@ubuntu:~/share$ hostname</span><br><span class="line">ubuntu</span><br><span class="line">creaink@ubuntu:~/share$ sudo hostname docker</span><br><span class="line">creaink@ubuntu:~/share$ hostname</span><br><span class="line">docker</span><br><span class="line">creaink@ubuntu:~/share$ exit</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这里的 hostname 也跟着变了</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hostname</span></span><br><span class="line">docker</span><br></pre></td></tr></table></figure>
<p>通过最后的命令可以看到 hostname 也跟着变了，这里就没有实现前面提到的 UTS 隔离。</p>
<h3 id="版本-one-增加UTS隔离">版本 one 增加UTS隔离</h3>
<p>可以为 cmd 加上 SysProcAttr，利用 CLONE_NEWUTS 参数来实现其子进程的 UTS 隔离，zero 版本更改的部分如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func run() &#123;</span><br><span class="line">    // ...</span><br><span class="line">    cmd.Stderr = os.Stderr</span><br><span class="line"></span><br><span class="line">    cmd.SysProcAttr = &amp;syscall.SysProcAttr&#123;</span><br><span class="line">        Cloneflags: syscall.CLONE_NEWUTS,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    must(cmd.Run())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述更改之后的文件存为 docker-1.go 然后探究：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> share go run docker-1.go run /bin/bash</span></span><br><span class="line">running [/bin/bash]</span><br><span class="line">root@ubuntu:~/share$ readlink /proc/$PPID/ns/uts</span><br><span class="line">uts:[4026531838]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">与父进程的 namespace uts 已经不同了</span></span><br><span class="line">root@ubuntu:~/share$ readlink /proc/$$/ns/uts</span><br><span class="line">uts:[4026532634]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">更改 hostname 也不会变化了</span></span><br><span class="line">root@ubuntu:~/share$ sudo hostname docker</span><br><span class="line">root@ubuntu:~/share$ hostname</span><br><span class="line">docker</span><br><span class="line">root@ubuntu:~/share$ exit</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hostname</span></span><br><span class="line">ubuntu</span><br></pre></td></tr></table></figure>
<p>通过上面的 <code>readlink /proc/[PID]/ns/uts</code> 和 hostname 可以看出来，在新的进程里已经实现了 UTS 的隔离了。那么 <code>CLONE_NEWUTS</code> 这个参数 go 是如何在创建子进程时候传入的呢？答案是利用了 clone 系统调用来完成的，这里可以简单的利用 strace 命令追踪下系统调用:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">go run 系统调用有干扰项，这里编译下</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go build docker-1.go</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这里我们只关心 <span class="built_in">clone</span>，利用 grep 过滤下</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">strace ./docker-1 run <span class="built_in">echo</span> hi |&amp; grep <span class="string">&quot;clone\|execv&quot;</span></span></span><br><span class="line">execve(&quot;./docker-1&quot;, [&quot;./docker-1&quot;, &quot;run&quot;, &quot;echo&quot;, &quot;hi&quot;], [/* 26 vars */]) = 0</span><br><span class="line">clone(child_stack=0xc820035fc0, flags=CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_THREAD) = 15932</span><br><span class="line">clone(child_stack=0xc820031fc0, flags=CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_THREAD) = 15933</span><br><span class="line">clone(child_stack=0xc820033fc0, flags=CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_THREAD) = 15934</span><br><span class="line">clone(child_stack=0, flags=CLONE_NEWUTS|SIGCHLD) = -1 EPERM (Operation not permitted)</span><br></pre></td></tr></table></figure>
<p>前面的三个 clone 其实是 go 创建的一些自己的进程（可能用 c 来实现会更干净些），可以在 root 用户下开两个终端一个 <code>strace ./docker-1 run sleep 10s |&amp; grep &quot;clone\|execv&quot;</code>， 另一个 <code>watch pstree -pa [PID]</code> （这里的 PID 是前面终端的 PID）观察验证。</p>
<p><img src="/2021/02/01/Linux-Namespace%E4%B8%8EDocker%E5%8E%9F%E7%90%86/image-20210201214317320.png" alt="image-20210201214317320"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">------SHELL1-----</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">strace ./docker-1 run <span class="built_in">sleep</span> 10s |&amp; grep <span class="string">&quot;clone\|execv&quot;</span></span></span><br><span class="line">execve(&quot;./docker-1&quot;, [&quot;./docker-1&quot;, &quot;run&quot;, &quot;sleep&quot;, &quot;10s&quot;], 0x7fff73ea0ed8 /* 67 vars */) = 0</span><br><span class="line">clone(child_stack=0xc000054000, flags=CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_THREAD|CLONE_SYSVSEM) = 90852</span><br><span class="line">clone(child_stack=0xc000056000, flags=CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_THREAD|CLONE_SYSVSEM) = 90853</span><br><span class="line">clone(child_stack=NULL, flags=CLONE_VM|CLONE_VFORK|CLONE_NEWUTS|SIGCHLD) = 90856</span><br><span class="line"></span><br><span class="line">------SHELL2-------</span><br><span class="line">Every 2.0s: pstree -pa 88148 </span><br><span class="line"></span><br><span class="line">zsh,88148</span><br><span class="line">  |-grep,91144 --color=auto --exclude-dir=.bzr --exclude-dir=CVS --exclude-dir=.git --exclude-dir=.hg ...</span><br><span class="line">  `-strace,91143 ./docker-1 run sleep 10s</span><br><span class="line">      `-docker-1,91147 run sleep 10s</span><br><span class="line">          |-sleep,91152 10s</span><br><span class="line">          |-&#123;docker-1&#125;,91148</span><br><span class="line">          |-&#123;docker-1&#125;,91149</span><br><span class="line">          |-&#123;docker-1&#125;,91150</span><br><span class="line">          `-&#123;docker-1&#125;,91151</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到这三个 clone 的调用采用的是默认的参数：<code>CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_THREAD</code>，其含义可在上面提到的 <strong>clone 手册</strong> 里查阅到。</p>
<p>最后的一个 clone 系统调用参数就很明显的是在程序里自行设定的 <code>CLONE_NEWUTS</code>，SIGCHLD 参数默认要添加上的：共享信号，即子进程的生命周期发生变化时候会通过 SIGCHLD 信号告知父进程。</p>
<h3 id="版本-two-增加PID隔离">版本 two  增加PID隔离</h3>
<p>这一版本要要在上个版本实现了 UTS 隔离的情况下进而实现 PID 隔离，很容易会想到在调用时候加上 <code>CLONE_NEWPID</code> 即可实现。为了检验，就需要在代理生成的子进程下再生成一个子进程：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// 在 main 中加上 child 的 case</span><br><span class="line">func main() &#123;</span><br><span class="line">    switch os.Args[1] &#123;</span><br><span class="line">    // ...</span><br><span class="line">    case &quot;child&quot;:</span><br><span class="line">        child()</span><br><span class="line">    // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// run 修改为下面</span><br><span class="line">func run() &#123;</span><br><span class="line">    cmd := exec.Command(&quot;/proc/self/exe&quot;, append([]string&#123;&quot;child&quot;&#125;, os.Args[2:]...)...)</span><br><span class="line">    cmd.Stdin = os.Stdin</span><br><span class="line">    cmd.Stdout = os.Stdout</span><br><span class="line">    cmd.Stderr = os.Stderr</span><br><span class="line"></span><br><span class="line">    cmd.SysProcAttr = &amp;syscall.SysProcAttr&#123;</span><br><span class="line">        Cloneflags: syscall.CLONE_NEWUTS | syscall.CLONE_NEWPID,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    must(cmd.Run())</span><br><span class="line">&#125;</span><br><span class="line">// 加一个函数 child</span><br><span class="line">func child() &#123;</span><br><span class="line">    fmt.Printf(&quot;running %v as pid: %d\n&quot;, os.Args[2:], os.Getpid())</span><br><span class="line">    cmd := exec.Command(os.Args[2], os.Args[3:]...)</span><br><span class="line">    cmd.Stdin = os.Stdin</span><br><span class="line">    cmd.Stdout = os.Stdout</span><br><span class="line">    cmd.Stderr = os.Stderr</span><br><span class="line"></span><br><span class="line">    must(syscall.Sethostname([]byte(&quot;InNamespace&quot;)))</span><br><span class="line"></span><br><span class="line">    must(cmd.Run())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的程序需要解释下的是 linux 系统中有个符号链接：<code>/proc/self/exe</code> 它代表当前程序，所以在 run 函数里面调用程序本身并加上 child 参数，以实现 <strong>隔一层</strong> 进程完成预设命令的指向，方便观察结果。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入到子进程所创建的 shell 中，输出当前 PID，可以看到已经实现隔离</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> go run docker-2.go run /bin/bash</span></span><br><span class="line">running [/bin/bash] as pid: 1</span><br><span class="line">root@InNamespace:~/share$ echo $$</span><br><span class="line">5</span><br><span class="line">root@InNamespace:~/share$ ps</span><br><span class="line">   PID TTY          TIME CMD</span><br><span class="line"> 18868 pts/1    00:00:00 sudo</span><br><span class="line"> 18869 pts/1    00:00:00 go</span><br><span class="line"> 18886 pts/1    00:00:00 docker-2</span><br><span class="line"> 18890 pts/1    00:00:00 exe</span><br><span class="line"> 18894 pts/1    00:00:00 bash</span><br><span class="line"> 18973 pts/1    00:00:00 ps</span><br></pre></td></tr></table></figure>
<p>上面出现了两个矛盾的结果： 运行输出了 <code>running [/bin/bash] as pid: 1</code> 和 <code>echo $$</code> 的 PID 明显是隔离出来的（用户空间的进程不可能小于 1000）而 ps 显示的进程 PID 明显是没有隔离出来的。</p>
<p>其实这时候是已经实现了隔离，而 <code>ps</code> 命令显示的 PID 不对，甚至 <code>ps -ef</code> 还可以查看到整个系统的所有进程，这是因为 <code>ps</code> 命令只是简单的查看了文件系统里的 <code>/proc</code> 目录而给出内容信息，这时候进程的文件系统是继承于父进程的，所以虽然已经位于新的 PID 命名空间了，但是 <code>ps</code> 还无法正常工作。</p>
<p>所以可以尝试挂载虚拟文件夹 proc 到本地一个文件夹下查看检验下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> go run docker-2.go run /bin/bash</span></span><br><span class="line">root@InNamespace:~/share$ mkdir proc</span><br><span class="line">root@InNamespace:~/share$ mount -t proc proc proc</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这时候 share/proc 里的内容是正常的，但是 ps 还是查看的 /proc 下的内容</span></span><br><span class="line">root@InNamespace:~/share$ ls proc</span><br><span class="line">1          cmdline    execdomains  kallsyms     loadavg  mtrr          slabinfo       timer_list         zoneinfo</span><br><span class="line">22         consoles   fb           kcore        locks    net           softirqs       timer_stats</span><br><span class="line">5          cpuinfo    filesystems  keys         mdstat   pagetypeinfo  stat           tty</span><br><span class="line">...</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">但是退出之后到宿主机（父进程）上查看其挂载点</span></span><br><span class="line">root@InNamespace:~/share$ exit</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">mount</span></span><br><span class="line">...</span><br><span class="line">proc on /mnt/hgfs/share/proc type proc (rw,relatime)</span><br><span class="line">proc on /mnt/hgfs/share/proc type proc (rw,relatime)</span><br></pre></td></tr></table></figure>
<p>自制容器（子进程）其内的挂载操作会直接影响宿主机（父进程）挂载点，并且 <code>/proc</code> 下的内容需要重新挂载，所以挂载点需要进行进一步地隔离。</p>
<h3 id="版本-three-增加挂载点隔离">版本 three 增加挂载点隔离</h3>
<p>自然的想到为 clone 进程时候加上 <code>CLONE_NEWNS</code> 即可达到挂载点隔离的效果，使用该参数之后创建子进程会复制一份父进程的挂载挂载点，之后子进程里的挂载操作不会影响到父进程的挂载点。但是同时要处理挂载 <code>/proc</code> 目录的问题，除了挂载点能不能直接更换所继承的文件系统？</p>
<p>从下面 Docker 分层文件系统中示意图可以看到，用户空间的文件系统(rootfs)是可以更换的，通过 chroot 系统调用可以更改(jail)当前正在运行的进程及其子进程的根目录。</p>
<p><a target="_blank" rel="noopener" href="https://creaink.github.io/post/Devtools/Docker/imgs/2018-11-08-15-33-50.png"><img src="/2021/02/01/Linux-Namespace%E4%B8%8EDocker%E5%8E%9F%E7%90%86/2018-11-08-15-33-50.png" alt="文件系统"></a></p>
<p>所以这里找来了一个非常精简的 <a target="_blank" rel="noopener" href="http://dl-cdn.alpinelinux.org/alpine/v3.8/releases/x86_64/alpine-minirootfs-3.8.2-x86_64.tar.gz">alpine rootfs</a>, 解压到 <code>/var/lib/alpine</code> 目录下以备后用。</p>
<p>所以更改之后的第三版本是这样的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">    cmd.SysProcAttr = &amp;syscall.SysProcAttr&#123;</span><br><span class="line">        Cloneflags: syscall.CLONE_NEWUTS | syscall.CLONE_NEWPID | syscall.CLONE_NEWNS,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">child</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">    must(syscall.Sethostname([]<span class="type">byte</span>(<span class="string">&quot;InNamespace&quot;</span>)))</span><br><span class="line"></span><br><span class="line">    must(syscall.Chroot(<span class="string">&quot;/var/lib/alpine&quot;</span>))</span><br><span class="line">    must(os.Chdir(<span class="string">&quot;/&quot;</span>))</span><br><span class="line">    must(syscall.Mount(<span class="string">&quot;proc&quot;</span>, <span class="string">&quot;proc&quot;</span>, <span class="string">&quot;proc&quot;</span>, <span class="number">0</span>, <span class="string">&quot;&quot;</span>))</span><br><span class="line"></span><br><span class="line">    must(cmd.Run())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更改之后的文件命名为 docker-3.go ，由于之前没隔离而有挂载 proc，所以需要记得 <code>umount proc</code>，随后：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行 bash 会出错，这是因为更换了 alpine 的 rootfs 之后只有没有了 bash 命令</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> go run docker-3.go run /bin/bash</span></span><br><span class="line">panic: fork/exec /bin/bash: no such file or directory</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> go run docker-3.go run /bin/sh</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入容器（子进程shell）后发现 PID 正常了，ps 能够直接使用</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">alpine 的 shell 提示符更改下</span></span><br><span class="line">/ # export PS1=&#x27;root@$(hostname):$(pwd)$ &#x27;</span><br><span class="line">root@InNamespace:/ $ ps</span><br><span class="line">PID   USER     TIME   COMMAND</span><br><span class="line">    1 root       0:00 /proc/self/exe child /bin/sh</span><br><span class="line">    6 root       0:00 /bin/sh</span><br><span class="line">    9 root       0:00 ps</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">mount 显示的挂载点也非常简单，也就是在程序里自行挂载的 proc，这时候 top 也是正常的</span></span><br><span class="line">root@InNamespace:/ $ cat /proc/self/mountinfo</span><br><span class="line">237 147 0:64 / /proc rw,relatime shared:88 - proc proc rw</span><br><span class="line">root@InNamespace:/ $ exit</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">mount</span></span><br><span class="line">...</span><br><span class="line">proc on /var/lib/alpine/proc type proc (rw,relatime)</span><br></pre></td></tr></table></figure>
<p>自制容器里 ps 已经能够正常工作了，但退出退出容器后，却发现容器内的挂载是会传播到父进程的，这是因为 systemd 将默认的 mount namespace 的事件传播机制定义成了 <code>MS_SHARED</code>，可以使用 <code>findmnt -o TARGET,PROPAGATION</code> 命令查看目录的 propagation。总体的有：共享挂载（shared mount）、从属挂载（slave mount）和私有挂载（private mount）</p>
<p>在 <code>sudo unshare --mount --uts /bin/bash</code> 里是可以的隔离挂载的，这是因为改变了 mount 的 propagation 为 private。如何改变呢，只需要利用 mount 系统调用更改下父目录，其下的子目录就会更变传播方式，如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">利用 root 用户探究下为什么可以实现挂载的隔离</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">strace unshare --mount --uts /bin/echo hi |&amp; grep mount</span></span><br><span class="line">execve(&quot;/usr/bin/unshare&quot;, [&quot;unshare&quot;, &quot;--mount&quot;, &quot;--uts&quot;, &quot;/bin/echo&quot;, &quot;hi&quot;], [/* 26 vars */]) = 0</span><br><span class="line">mount(&quot;none&quot;, &quot;/&quot;, NULL, MS_REC|MS_PRIVATE, NULL) = 0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">照葫芦画瓢</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">strace mount --make-rshared / |&amp; grep mount</span></span><br><span class="line">execve(&quot;/bin/mount&quot;, [&quot;mount&quot;, &quot;--make-rshared&quot;, &quot;/&quot;], [/* 21 vars */]) = 0</span><br><span class="line">open(&quot;/lib/x86_64-linux-gnu/libmount.so.1&quot;, O_RDONLY|O_CLOEXEC) = 3</span><br><span class="line">mount(&quot;none&quot;, &quot;/&quot;, NULL, MS_REC|MS_SHARED, NULL) = 0</span><br></pre></td></tr></table></figure>
<p>但是在 syscall 当中就需要手动的以 private 的方式 mount 一遍根目录以达到效果（要在 chroot 之前）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">child</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">    must(syscall.Sethostname([]<span class="type">byte</span>(<span class="string">&quot;InNamespace&quot;</span>)))</span><br><span class="line"></span><br><span class="line">    must(syscall.Mount(<span class="string">&quot;&quot;</span>, <span class="string">&quot;/&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="type">uintptr</span>(syscall.MS_PRIVATE|syscall.MS_REC), <span class="string">&quot;&quot;</span>))</span><br><span class="line">    must(syscall.Chroot(<span class="string">&quot;/var/lib/alpine&quot;</span>))</span><br><span class="line">    must(syscall.Mount(<span class="string">&quot;proc&quot;</span>, <span class="string">&quot;/proc&quot;</span>, <span class="string">&quot;proc&quot;</span>, <span class="number">0</span>, <span class="string">&quot;&quot;</span>))</span><br><span class="line">    must(os.Chdir(<span class="string">&quot;/&quot;</span>))</span><br><span class="line"></span><br><span class="line">    must(cmd.Run())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后运行一下是可以发现，隔离有效的，可以在其内使用 <code>mount --bind a b</code> 试试。处理 chroot 更换更目录还可以使用 PivotRoot + mount MS_BIND 的方式，<a target="_blank" rel="noopener" href="https://gist.github.com/julz/c0017fa7a40de0543001">参考</a>。</p>
<h3 id="版本-next">版本 next</h3>
<p>其实到最后会发现，容器就是一些按一定规则被限制继承父进程的某些资源的子进程。</p>
<p>如果后续继续完善其他的 namespace 然后再加以 cgroups 限制 CPU、内存、磁盘、网络等，然后在加上分层存储 Union FS，可能就是完成了一个真正意义上的简化的 Docker。</p>
<h2 id="参考">参考</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.yadutaf.fr/2013/12/22/introduction-to-linux-namespaces-part-1-uts/">C 版本的实践</a></li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000006912742">shell 版本的实践</a></li>
<li><a target="_blank" rel="noopener" href="https://woosley.github.io/2017/08/18/mount-namespace-in-golang.html">一个 go 版本实现</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/22889241/linux-understanding-the-mount-namespace-clone-clone-newns-flag">CLONE_NEWNS</a></li>
<li><a target="_blank" rel="noopener" href="https://gist.github.com/julz/c0017fa7a40de0543001">PivotRoot + mount</a></li>
<li><a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/mount.2.html">mount propagation</a></li>
<li><a target="_blank" rel="noopener" href="https://lwn.net/Articles/689856">mount propagation in namespace</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/45557831/golang-mount-namespace-mounted-volume-are-not-cleared-after-the-process-exits">stackoverflow mount share</a></li>
<li>《自己动手写Docker》</li>
</ul>
<hr>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/sparkdev/p/9365405.html">https://www.cnblogs.com/sparkdev/p/9365405.html</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://991688344.github.io">LYC</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://991688344.github.io/2021/02/01/Linux-Namespace%E4%B8%8EDocker%E5%8E%9F%E7%90%86/">http://991688344.github.io/2021/02/01/Linux-Namespace%E4%B8%8EDocker%E5%8E%9F%E7%90%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://991688344.github.io" target="_blank">Rick</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Linux/">Linux</a><a class="post-meta__tags" href="/tags/Docker/">Docker</a></div><div class="post-share"><div class="social-share" data-image="/images/Wallpaper/rainbowcat.gif" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2021/02/01/Docker%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F/" title="Docker网络模式"><img class="cover" src="/images/Wallpaper/rainbowcat.gif" onerror="onerror=null;src='/images/404.png'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Docker网络模式</div></div><div class="info-2"><div class="info-item-1">https://www.cnblogs.com/zuxing/articles/8780661.html Docker自身的4种网络工作方式，和一些自定义网络模式 安装Docker时，它会自动创建三个网络，bridge（创建容器默认连接到此网络）、 none 、host host：容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口。 Container：创建的容器不会创建自己的网卡，配置自己的IP，而是和一个指定的容器共享IP、端口范围。 None：该模式关闭了容器的网络功能。 Bridge：此模式会为每一个容器分配、设置IP等，并将容器连接到一个docker0虚拟网桥，通过docker0网桥以及Iptables nat表配置与宿主机通信。 以上都是不用动手的，真正需要配置的是自定义网络。 默认网络 当你安装Docker时，它会自动创建三个网络。你可以使用以下docker network ls命令列出这些网络： 12345$ docker network lsNETWORK ID          NAME               ...</div></div></div></a><a class="pagination-related" href="/2021/01/23/%E6%AD%A3%E5%90%91%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/" title="正向反向代理"><img class="cover" src="/images/Wallpaper/rainbowcat.gif" onerror="onerror=null;src='/images/404.png'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">正向反向代理</div></div><div class="info-2"><div class="info-item-1">应用 正向代理 网络加速，游戏加速，隐藏ip，过滤内容去广告 反向代理 负载均衡，隐藏服务端 </div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2023/08/29/4GPU%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%8F%8A%E7%BB%B4%E6%8A%A4/" title="4GPU服务器环境配置及维护"><img class="cover" src="/images/Wallpaper/rainbowcat.gif" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-29</div><div class="info-item-2">4GPU服务器环境配置及维护</div></div><div class="info-2"><div class="info-item-1">  ...</div></div></div></a><a class="pagination-related" href="/2019/11/16/Desktop%E6%96%87%E4%BB%B6/" title="Desktop文件"><img class="cover" src="/images/Wallpaper/rainbowcat.gif" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2019-11-16</div><div class="info-item-2">Desktop文件</div></div><div class="info-2"><div class="info-item-1">参考网址 %U	A list of URLs. Each URL is passed as a separate argument to the executable program. Local files may either be passed as file: URLs or as file path.   也就是说，加入了%U参数，可以传递多个URL给Chrome浏览器，浏览器会依次打开各URL。比如您在文件管理器中选择了多个html文件，然后在鼠标右键菜单中点击”Open with Google Chrome”，Chrome浏览器就会依次打开所选的网页。 Exec后面可以跟上执行参数,之后每次点击图标都会带着执行参数执行 例如 Exec typora --no-sandbax %U </div></div></div></a><a class="pagination-related" href="/2020/04/09/LD-PRELOAD/" title="LD_PRELOAD"><img class="cover" src="/images/Wallpaper/eatham.gif" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-04-09</div><div class="info-item-2">LD_PRELOAD</div></div><div class="info-2"><div class="info-item-1">一、LD_PRELOAD是什么  LD_PRELOAD是Linux系统的一个环境变量，它可以影响程序的运行时的链接（Runtime  linker），它允许你定义在程序运行前优先加载的动态链接库。这个功能主要就是用来有选择性的载入不同动态链接库中的相同函数。通过这个环境变量，我们可以在主程序和其动态链接库的中间加载别的动态链接库，甚至覆盖正常的函数库。一方面，我们可以以此功能来使用自己的或是更好的函数（无需别人的源码），而另一方面，我们也可以以向别人的程序注入程序，从而达到特定的目的。  二、程序调用流图  LA_PRELOAD替换前  LA_PRELOAD替换后   三、演示程序代码   主程序 1234567891011121314151617// myverifypasswd.c#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &quot;mystrcmp.h&quot; void main(int argc,char **argv) &#123;    char passwd[] =...</div></div></div></a><a class="pagination-related" href="/2020/03/26/Linux-Shell%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6%E6%B1%87%E6%80%BB/" title="Linux-Shell特殊字符汇总"><img class="cover" src="/images/Wallpaper/rainbowcat.gif" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-03-26</div><div class="info-item-2">Linux-Shell特殊字符汇总</div></div><div class="info-2"><div class="info-item-1">Shell符号及各种解释对照表：    Shell符号 使用方法及说明     # 注释符号(Hashmark[Comments])            1.在shell文件的行首，作为include标记，#!/bin/bash;             2. 其他地方作为注释使用，在一行中，#后面的内容并不会被执行，除非；             3. 但是用单/双引号包围时，#作为#号字符本身，不具有注释作用。   ; 作为多语句的分隔符(Command separator [semicolon])。多个语句要放在同一行的时候，可以使用分号分隔。注意，有时候分号需要转义。   ;; 连续分号(Terminator [double semicolon])。在使用case选项的时候，作为每个选项的终结符。在Bash version 4+ 的时候，还可以使用[;;&amp;], [;&amp;]   . 点号(dot command [period])。            1. 相当于bash内建命令source，如：           ...</div></div></div></a><a class="pagination-related" href="/2020/10/05/Linux-%E9%98%B2%E7%81%AB%E5%A2%99/" title="Linux-防火墙"><img class="cover" src="/images/Wallpaper/rainbowcat.gif" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-05</div><div class="info-item-2">Linux-防火墙</div></div><div class="info-2"><div class="info-item-1">8.1 防火墙管理工具 在RHEL 7系统中，firewalld防火墙取代了iptables防火墙。其实，iptables与firewalld都不是真正的防火墙，它们都只是用来定义防火墙策略的防火墙管理工具而已，或者说，它们只是一种服务。**iptables服务会把配置好的防火墙策略交由内核层面的netfilter网络过滤器来处理，而firewalld服务则是把配置好的防火墙策略交由内核层面的nftables包过滤框架来处理。**换句话说，当前在Linux系统中其实存在多个防火墙管理工具，旨在方便运维人员管理Linux系统中的防火墙策略，我们只需要配置妥当其中的一个就足够了。虽然这些工具各有优劣，但它们在防火墙策略的配置思路上是保持一致的。 8.2.1...</div></div></div></a><a class="pagination-related" href="/2022/05/09/Linux-chroot%E5%91%BD%E4%BB%A4/" title="Linux-chroot命令"><img class="cover" src="/2022/05/09/Linux-chroot%E5%91%BD%E4%BB%A4/cover.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-09</div><div class="info-item-2">Linux-chroot命令</div></div><div class="info-2"><div class="info-item-1">chroot 可以用来切换当前进程的根目录，它能够将当前进程能够访问的目录树结构限制在某个子目录中，同时由于当前进程创建的子进程将会继承父进程的根目录结构，所以子进程也随之被限定。 为什么要使用 chroot 命令 增加了系统的安全性，限制了用户的权力： 在经过 chroot 之后，在新根下将访问不到旧系统的根目录结构和文件，这样就增强了系统的安全性。一般会在用户登录前应用 chroot，把用户的访问能力控制在一定的范围之内。 建立一个与原系统隔离的系统目录结构，方便用户的开发： 使用 chroot 后，系统读取的是新根下的目录和文件，这是一个与原系统根下文件不相关的目录结构。在这个新的环境中，可以用来测试软件的静态编译以及一些与系统不相关的独立开发。 切换系统的根目录位置，引导 Linux 系统启动以及急救系统等： chroot 的作用就是切换系统的根位置，而这个作用最为明显的是在系统初始引导磁盘的处理过程中使用，从初始 RAM 磁盘 (initrd) 切换系统的根位置并执行真正的 init，本文的最后一个 demo 会详细的介绍这种用法。 通过 chroot...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="lv-container" data-id="city" data-uid="MTAyMC80NzA1My8yMzU1Mw=="></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/images/head.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">LYC</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">251</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">37</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">49</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#namespace-%E5%88%9D%E8%AF%86"><span class="toc-number">1.</span> <span class="toc-text">namespace 初识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B-namespace"><span class="toc-number">1.1.</span> <span class="toc-text">查看进程 namespace</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">1.2.</span> <span class="toc-text">Linux 系统调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.3.</span> <span class="toc-text">Linux 进程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#namespace-%E5%AE%9E%E8%B7%B5"><span class="toc-number">2.</span> <span class="toc-text">namespace 实践</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-%E6%98%AF%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%90%97"><span class="toc-number">2.1.</span> <span class="toc-text">docker 是虚拟机吗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%88%E6%9C%AC-zero"><span class="toc-number">2.2.</span> <span class="toc-text">版本 zero</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%88%E6%9C%AC-one-%E5%A2%9E%E5%8A%A0UTS%E9%9A%94%E7%A6%BB"><span class="toc-number">2.3.</span> <span class="toc-text">版本 one 增加UTS隔离</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%88%E6%9C%AC-two-%E5%A2%9E%E5%8A%A0PID%E9%9A%94%E7%A6%BB"><span class="toc-number">2.4.</span> <span class="toc-text">版本 two  增加PID隔离</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%88%E6%9C%AC-three-%E5%A2%9E%E5%8A%A0%E6%8C%82%E8%BD%BD%E7%82%B9%E9%9A%94%E7%A6%BB"><span class="toc-number">2.5.</span> <span class="toc-text">版本 three 增加挂载点隔离</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%88%E6%9C%AC-next"><span class="toc-number">2.6.</span> <span class="toc-text">版本 next</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">3.</span> <span class="toc-text">参考</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/08/29/4GPU%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%8F%8A%E7%BB%B4%E6%8A%A4/" title="4GPU服务器环境配置及维护"><img src="/images/Wallpaper/rainbowcat.gif" onerror="this.onerror=null;this.src='/images/404.png'" alt="4GPU服务器环境配置及维护"/></a><div class="content"><a class="title" href="/2023/08/29/4GPU%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%8F%8A%E7%BB%B4%E6%8A%A4/" title="4GPU服务器环境配置及维护">4GPU服务器环境配置及维护</a><time datetime="2023-08-29T12:00:26.000Z" title="发表于 2023-08-29 20:00:26">2023-08-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/29/UEFI-systemd%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/" title="UEFI+systemd开机启动流程"><img src="/images/Wallpaper/eatham.gif" onerror="this.onerror=null;this.src='/images/404.png'" alt="UEFI+systemd开机启动流程"/></a><div class="content"><a class="title" href="/2023/08/29/UEFI-systemd%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/" title="UEFI+systemd开机启动流程">UEFI+systemd开机启动流程</a><time datetime="2023-08-29T08:39:54.000Z" title="发表于 2023-08-29 16:39:54">2023-08-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/27/udev%E9%85%8D%E7%BD%AELinux%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3/" title="udev配置Linux网络接口"><img src="/images/Wallpaper/eatham.gif" onerror="this.onerror=null;this.src='/images/404.png'" alt="udev配置Linux网络接口"/></a><div class="content"><a class="title" href="/2023/08/27/udev%E9%85%8D%E7%BD%AELinux%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3/" title="udev配置Linux网络接口">udev配置Linux网络接口</a><time datetime="2023-08-27T12:49:29.000Z" title="发表于 2023-08-27 20:49:29">2023-08-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/27/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BD%91%E7%BB%9C%E8%BF%90%E7%BB%B4/" title="实验室服务器网络运维"><img src="/images/Wallpaper/eatham.gif" onerror="this.onerror=null;this.src='/images/404.png'" alt="实验室服务器网络运维"/></a><div class="content"><a class="title" href="/2023/08/27/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BD%91%E7%BB%9C%E8%BF%90%E7%BB%B4/" title="实验室服务器网络运维">实验室服务器网络运维</a><time datetime="2023-08-27T12:20:23.000Z" title="发表于 2023-08-27 20:20:23">2023-08-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/11/21/Attention%E6%9C%BA%E5%88%B6-transformer/" title="Attention机制_transformer"><img src="/images/Wallpaper/eatham.gif" onerror="this.onerror=null;this.src='/images/404.png'" alt="Attention机制_transformer"/></a><div class="content"><a class="title" href="/2022/11/21/Attention%E6%9C%BA%E5%88%B6-transformer/" title="Attention机制_transformer">Attention机制_transformer</a><time datetime="2022-11-21T11:55:15.000Z" title="发表于 2022-11-21 19:55:15">2022-11-21</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2024 By LYC</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(async () => {
  const showKatex = () => {
    document.querySelectorAll('#article-container .katex').forEach(el => el.classList.add('katex-show'))
  }

  if (!window.katex_js_css) {
    window.katex_js_css = true
    await btf.getCSS('https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css')
    if (true) {
      await btf.getScript('https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js')
    }
  }

  showKatex()
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.isShuoshuo

  const loadLivere = (el, path) => {
    window.livereOptions = {
      refer: path || location.pathname
    }

    if (isShuoshuo) {
      window.shuoshuoComment.destroyLivere = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    if (typeof LivereTower === 'object') window.LivereTower.init()
    else {
      (function(d, s) {
          var j, e = d.getElementsByTagName(s)[0];
          if (typeof LivereTower === 'function') { return; }
          j = d.createElement(s);
          j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
          j.async = true;
          e.parentNode.insertBefore(j, e);
      })(document, 'script');
    }
  }

  if (isShuoshuo) {
    'Livere' === 'Livere'
      ? window.shuoshuoComment = { loadComment: loadLivere }
      : window.loadOtherComment = loadLivere
    return
  }

  if ('Livere' === 'Livere' || !false) {
    if (false) btf.loadComment(document.getElementById('lv-container'), loadLivere)
    else loadLivere()
  } else {
    window.loadOtherComment = loadLivere
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>