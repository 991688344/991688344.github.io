<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>udev配置Linux网络接口 | Rick</title><meta name="author" content="LYC"><meta name="copyright" content="LYC"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一致的网络接口设备命名 Linux 内核通过将固定前缀与随着内核初始化网络设备而增加的数字连接在一起，来为网络接口分配名称。例如，eth0 代表启动时被探测的第一个设备。如果您在系统中添加另一个网卡，则内核设备名称的分配将不再是固定的。因此，重启后内核可能会以不同的方式为该设备命名。 要解决这个问题，&#96;udev&#96; 设备管理器支持几种不同的命名方案。默认情况下，&#96;udev&#96; 根据固件、拓扑和位置信息">
<meta property="og:type" content="article">
<meta property="og:title" content="udev配置Linux网络接口">
<meta property="og:url" content="http://991688344.github.io/2023/08/27/udev%E9%85%8D%E7%BD%AELinux%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3/index.html">
<meta property="og:site_name" content="Rick">
<meta property="og:description" content="一致的网络接口设备命名 Linux 内核通过将固定前缀与随着内核初始化网络设备而增加的数字连接在一起，来为网络接口分配名称。例如，eth0 代表启动时被探测的第一个设备。如果您在系统中添加另一个网卡，则内核设备名称的分配将不再是固定的。因此，重启后内核可能会以不同的方式为该设备命名。 要解决这个问题，&#96;udev&#96; 设备管理器支持几种不同的命名方案。默认情况下，&#96;udev&#96; 根据固件、拓扑和位置信息">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://991688344.github.io/images/Wallpaper/eatham.gif">
<meta property="article:published_time" content="2023-08-27T12:49:29.000Z">
<meta property="article:modified_time" content="2024-03-19T01:32:36.470Z">
<meta property="article:author" content="LYC">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="网络">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://991688344.github.io/images/Wallpaper/eatham.gif"><link rel="shortcut icon" href="/images/Wallpaper/favicon.ico"><link rel="canonical" href="http://991688344.github.io/2023/08/27/udev%E9%85%8D%E7%BD%AELinux%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/content.json","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'udev配置Linux网络接口',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><link rel="stylesheet" href="/mycss/my_background.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-color: #F7F9FE;"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/images/head.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">251</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">37</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">49</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-paper-plane"></i><span> 留言板</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/images/Wallpaper/eatham.gif);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Rick</span></a><a class="nav-page-title" href="/"><span class="site-name">udev配置Linux网络接口</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-paper-plane"></i><span> 留言板</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">udev配置Linux网络接口</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-08-27T12:49:29.000Z" title="发表于 2023-08-27 20:49:29">2023-08-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-03-19T01:32:36.470Z" title="更新于 2024-03-19 09:32:36">2024-03-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Linux/">Linux</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Linux/%E7%BD%91%E7%BB%9C/">网络</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">4.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>19分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1>一致的网络接口设备命名</h1>
<p>Linux 内核通过将固定前缀与随着内核初始化网络设备而增加的数字连接在一起，来为网络接口分配名称。例如，<code>eth0</code> 代表启动时被探测的第一个设备。如果您在系统中添加另一个网卡，则内核设备名称的分配将不再是固定的。因此，重启后内核可能会以不同的方式为该设备命名。</p>
<pre><code>要解决这个问题，`udev` 设备管理器支持几种不同的命名方案。默认情况下，`udev` 根据固件、拓扑和位置信息分配固定名称。它有以下优点： 	
</code></pre>
<ul>
<li>设备名称完全可预测。</li>
<li>即使添加或删除了硬件，设备名称也会保持不变，因为不会进行重新枚举。</li>
<li>因此，有问题的硬件可以被无缝地替换。</li>
</ul>
<h1>网络接口设备命名等级</h1>
<p>​	如果启用了一致的设备命名（在 Red Hat Enterprise Linux 中是默认设置），则 <code>udev</code> 设备管理器会根据以下方案生成设备名称：</p>
<table>
<thead>
<tr>
<th>方案</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>设备名称包含固件或者 BIOS 提供的索引号，用于板上的设备。如果此信息不可用或不适用，则 <code>udev</code> 将使用方案 2。</td>
<td><code>eno1</code></td>
</tr>
<tr>
<td>2</td>
<td>设备名称包含固件或 BIOS 提供的 PCI Express（PCIe）热插件插槽索引号。如果此信息不可用或不适用，则 <code>udev</code> 将使用方案 3。</td>
<td><code>ens1</code></td>
</tr>
<tr>
<td>3</td>
<td>设备名称包含硬件连接器的物理位置。如果此信息不可用或不适用，则 <code>udev</code> 将使用方案 5。</td>
<td><code>enp2s0</code></td>
</tr>
<tr>
<td>4</td>
<td>设备名称包含 MAC 地址。Red Hat Enterprise Linux 默认不使用这个方案，但管理员可选择性地使用它。</td>
<td><code>enx525400d5e0fb</code></td>
</tr>
<tr>
<td>5</td>
<td>传统的无法预计的内核命名方案。如果 <code>udev</code> 无法应用任何其他方案，则设备管理器使用这个方案。</td>
<td><code>eth0</code></td>
</tr>
</tbody>
</table>
<p>​	默认情况下，Red Hat Enterprise Linux 根据 <code>/usr/lib/systemd/network/99-default.link</code> 文件中的 <code>NamePolicy</code> 设置选择设备名称。<code>NamePolicy</code> 中值的顺序非常重要。Red Hat Enterprise Linux 使用文件中指定的和 <code>udev</code> 生成的第一个设备名称。</p>
<p>​	如果您手动配置 <code>udev</code> 规则来更改内核设备名称，则这些规则优先。</p>
<p>可以通过<code>udevadm test /sys/class/net/eth0</code>这个命令查看某个网卡使用了哪些命名规则。</p>
<p><img src="/2023/08/27/udev%E9%85%8D%E7%BD%AELinux%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3/image-20230827144703282.png" alt="image-20230827144703282"></p>
<p><img src="/2023/08/27/udev%E9%85%8D%E7%BD%AELinux%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3/image-20230827144723324.png" alt="image-20230827144723324"></p>
<h1>网络设备重命名是如何工作的</h1>
<p>​		默认情况下，在 Red Hat Enterprise Linux 中启用了一致的设备命名。<code>udev</code> 设备管理器会处理不同的规则来重命名设备。<code>udev</code> 服务按以下顺序处理这些规则：</p>
<ol>
<li>
<p><code>/usr/lib/udev/rules.d/60-net.rules</code> 文件定义了 <code>/lib/udev/rename_device</code> 帮助工具搜索 <code>/etc/sysconfig/network-scripts/ifcfg-*</code> 文件中的 <code>HWADDR</code> 参数。如果变量中设置的值与接口的 MAC 地址匹配，则帮助工具会将接口重命名为文件的 <code>DEVICE</code> 参数中设置的名称。</p>
</li>
<li>
<p><code>/usr/lib/udev/rules.d/71-biosdevname.rules</code> 文件定义了 <code>biosdevname</code> 工具根据其命名策略重命名接口，只要它在上一步中没有重命名。</p>
</li>
<li>
<p><code>/usr/lib/udev/rules.d/75-net-description.rules</code> 文件定义了 <code>udev</code> 检查网络接口设备，并在 <code>udev</code>-internal 变量中设置在下一步中将要处理的属性。请注意，其中一些属性可能没有定义。</p>
</li>
<li>
<p><code>/usr/lib/udev/rules.d/80-net-setup-link.rules</code> 文件调用内置的 <code>net_setup_link</code> <code>udev</code> ，然后应用策略。以下是存储在 <code>/usr/lib/systemd/network/99-default.link</code> 文件中的默认策略：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[Link]</span><br><span class="line">NamePolicy=kernel database onboard slot path</span><br><span class="line">MACAddressPolicy=persistent</span><br></pre></td></tr></table></figure>
<p>有了这个策略，如果内核使用持久名称，则 <code>udev</code> 不会重命名接口。如果内核不使用持久名称，则 <code>udev</code> 会将接口重命名为 <code>udev</code> 的硬件数据库提供的名称。如果这个数据库不可用，Red Hat Enterprise Linux 会回复到上述机制中。</p>
<p>另外，对于基于介质访问控制（MAC）地址的接口名称，将此文件中的 <code>NamePolicy</code> 参数设为 <code>mac</code>。</p>
</li>
<li>
<p><code>/usr/lib/udev/rules.d/80-net-setup-link.rules</code> 文件定义了 <code>udev</code> 按以下顺序，根据 <code>udev</code>-internal 参数重命名接口：</p>
<ol>
<li><code>ID_NET_NAME_ONBOARD</code></li>
<li><code>ID_NET_NAME_SLOT</code></li>
<li><code>ID_NET_NAME_PATH</code></li>
</ol>
<p>如果没有设置参数，则 <code>udev</code> 将使用下一个参数。如果没有设置任何参数，接口就不会被重命名。</p>
</li>
</ol>
<h1>使用 udev 规则分配用户定义的网络接口名称</h1>
<p><code>udev</code> 设备管理器支持一组规则来自定义接口名称。</p>
<p><strong>步骤</strong></p>
<ol>
<li>
<p>显示所有网络接口及其 MAC 地址：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ip link list</span></span><br><span class="line"></span><br><span class="line">enp6s0f0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP mode DEFAULT group default qlen 1000</span><br><span class="line">    <span class="built_in">link</span>/ether b4:96:91:14:ae:58 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">enp6s0f1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP mode DEFAULT group default qlen 1000</span><br><span class="line">    <span class="built_in">link</span>/ether b4:96:91:14:ae:5a brd ff:ff:ff:ff:ff:ff</span><br><span class="line">enp4s0f0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP mode DEFAULT group default qlen 1000</span><br><span class="line">    <span class="built_in">link</span>/ether 00:90:fa:6a:7d:90 brd ff:ff:ff:ff:ff:ff</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用以下内容创建文件 <code>/etc/udev/rules.d/70-custom-ifnames.rules</code> ：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SUBSYSTEM==<span class="string">&quot;net&quot;</span>,ACTION==<span class="string">&quot;add&quot;</span>,ATTR&#123;address&#125;==<span class="string">&quot;b4:96:91:14:ae:58&quot;</span>,ATTR&#123;<span class="built_in">type</span>&#125;==<span class="string">&quot;1&quot;</span>,NAME=<span class="string">&quot;provider0&quot;</span></span><br><span class="line">SUBSYSTEM==<span class="string">&quot;net&quot;</span>,ACTION==<span class="string">&quot;add&quot;</span>,ATTR&#123;address&#125;==<span class="string">&quot;b4:96:91:14:ae:5a&quot;</span>,ATTR&#123;<span class="built_in">type</span>&#125;==<span class="string">&quot;1&quot;</span>,NAME=<span class="string">&quot;provider1&quot;</span></span><br><span class="line">SUBSYSTEM==<span class="string">&quot;net&quot;</span>,ACTION==<span class="string">&quot;add&quot;</span>,ATTR&#123;address&#125;==<span class="string">&quot;00:90:fa:6a:7d:90&quot;</span>,ATTR&#123;<span class="built_in">type</span>&#125;==<span class="string">&quot;1&quot;</span>,NAME=<span class="string">&quot;dmz&quot;</span></span><br></pre></td></tr></table></figure>
<p>这些规则与网络接口的 MAC 地址相匹配，并将它们重命名为 <strong>NAME</strong> 属性中指定的名称。在这些示例中，<strong>ATTR{type}</strong> 参数值 <strong>1</strong> 定义了接口类型为 Ethernet。</p>
</li>
</ol>
<p><strong>验证</strong></p>
<ol>
<li>
<p>重启系统：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># reboot</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>验证每个 MAC 地址的接口名称是否与您在规则文件的 <code>NAME</code> 参数中设置的值相匹配：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ip link show</span></span><br><span class="line"></span><br><span class="line">provider0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP mode DEFAULT group default qlen 1000</span><br><span class="line">    <span class="built_in">link</span>/ether b4:96:91:14:ae:58 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">   altname enp6s0f0</span><br><span class="line">provider1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP mode DEFAULT group default qlen 1000</span><br><span class="line">    <span class="built_in">link</span>/ether b4:96:91:14:ae:5a brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    altname enp6s0f1</span><br><span class="line">dmz: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP mode DEFAULT group default qlen 1000</span><br><span class="line">    <span class="built_in">link</span>/ether 00:90:fa:6a:7d:90 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    altname enp4s0f0</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1>使用 systemd 链接文件分配用户定义的网络接口名称</h1>
<p>​	通过将网络接口重命名为 <code>provider0</code>来创建一个命名方案。</p>
<p><strong>流程</strong></p>
<ol>
<li>
<p>显示所有接口名称及其 MAC 地址：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ip link show</span></span><br><span class="line"></span><br><span class="line">enp6s0f0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP mode DEFAULT group default qlen 1000</span><br><span class="line">    <span class="built_in">link</span>/ether b4:96:91:14:ae:58 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">enp6s0f1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP mode DEFAULT group default qlen 1000</span><br><span class="line">    <span class="built_in">link</span>/ether b4:96:91:14:ae:5a brd ff:ff:ff:ff:ff:ff</span><br><span class="line">enp4s0f0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP mode DEFAULT group default qlen 1000</span><br><span class="line">    <span class="built_in">link</span>/ether 00:90:fa:6a:7d:90 brd ff:ff:ff:ff:ff:ff</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>创建 <code>/etc/systemd/network/</code> 目录：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mkdir /etc/systemd/network/</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>要将 MAC 地址为 <code>b4:96:91:14:ae:58</code> 的接口命名为 <code>provider0</code>，请创建包含以下内容的 <code>/etc/systemd/network/70-custom-ifnames.link</code> 文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[Match]</span><br><span class="line">MACAddress=b4:96:91:14:ae:58</span><br><span class="line"></span><br><span class="line">[Link]</span><br><span class="line">Name=provider0</span><br></pre></td></tr></table></figure>
<p>此链接文件与 MAC 地址相匹配，并将网络接口重命名为 <code>Name</code> 参数中设置的名称。</p>
</li>
</ol>
<p><strong>验证</strong></p>
<ol>
<li>
<p>重启系统：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># reboot</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>验证 MAC 地址为您在链接文件中指定的设备是否已分配给 <code>provider0</code> ：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ip link show</span></span><br><span class="line"></span><br><span class="line">provider0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP mode DEFAULT group default qlen 1000</span><br><span class="line">    <span class="built_in">link</span>/ether b4:96:91:14:ae:58 brd ff:ff:ff:ff:ff:ff</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1>使用 systemd 链接文件向网络接口分配额外的名称</h1>
<p>​	备用接口命名允许内核为网络接口设置备用名称。默认情况下，它提供与常规接口命名设置 - <code>NamePolicy</code> 相同的命名方案 。您可以使用 <code>AlternativeNamesPolicy</code> 或 <code>AlternativeName</code> 指令编写自定义 <code>systemd</code> 链接文件，来向您选择的网络接口提供备用名称。</p>
<p>​	备用接口命名的最新实现可让您：</p>
<ul>
<li>创建任意长度的备用名称。</li>
<li>同一网络接口有一个或多个备用名称。</li>
<li>使用备用名称作为命令的句柄。</li>
</ul>
<p><strong>先决条件</strong></p>
<ul>
<li>您知道介质访问控制(MAC)地址或其他网络接口标识符。详情请查看 <code>systemd.link(5)</code> 中的 [MATCH] SECTION OPTIONS 部分。</li>
</ul>
<p><strong>流程</strong></p>
<ol>
<li>
<p>使用以下内容创建 <code>/etc/systemd/network/10-altnames.link</code> 文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[Match]</span><br><span class="line">MACAddress=52:54:00:76:e0:2a</span><br><span class="line"></span><br><span class="line">[Link]</span><br><span class="line">AlternativeName=production_alias_of_arbitrary_length</span><br><span class="line">AlternativeName=PRD</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>重启系统以使更改生效。</p>
</li>
</ol>
<p><strong>验证</strong></p>
<ul>
<li>
<p>您可以使用备用名称来显示网络接口的状态：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ip address show production_alias_of_arbitrary_length</span></span><br><span class="line">2: enp1s0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000</span><br><span class="line">    <span class="built_in">link</span>/ether 52:54:00:76:e0:2a brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    altname production_alias_of_arbitrary_length</span><br><span class="line">    altname PRD</span><br><span class="line">    inet 192.0.2.1/24 brd 192.0.2.255 scope global dynamic noprefixroute enp1s0</span><br><span class="line">       valid_lft 2760sec preferred_lft 2760sec</span><br><span class="line">    inet6 2001:db8::/64 scope <span class="built_in">link</span> noprefixroute</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<p>Systemd is the rapidly evolving mother-ship of Linux initialisation  systems (and rather more besides) and one that most popular  distributions now use (in recent versions at least) including RHEL,  Fedora, CentOS, Debian, Ubuntu, Arch, and CoreOS. This brings us some  degree of ‘standardization’ in how we configure networking on these  distributions. It’s not complete and it’s a work in progress, but it  surely is progress.</p>
<p>Systemd 是 Linux  初始化系统（以及更多其他系统）快速发展的母舰，也是现在最流行的发行版（至少在最近的版本中）使用的系统，包括  RHEL、Fedora、CentOS、Debian、Ubuntu、Arch 和  CoreOS。这给我们在这些发行版上配置网络的方式带来了一定程度的“标准化”。它尚未完成，仍在进行中，但它确实是进步。</p>
<p>Systemd first touches the networking stack in relation to hardware, with the <strong>udev</strong> device manager, the core library of which was merged into systemd in  2012 (it used to be a separate project). You can do pretty much  everything you’d want with a network interface using udev, but it’s  jarring if you are used to the legacy configuration methods and it seems rather odd to be configuring IP addressing in a hardware device  configuration file, thus systemd-<strong>networkd</strong> was born.  I’ll cover networkd in a following piece, but suffice to say it deals  with things in a more logical, better-defined way. Why cover udev at all then? Well, networkd is pretty new and it’ll be a while before it’s  widespread so for now, udev is probably the best thing most have at  their disposal and it’s still very useful.</p>
<p>Systemd 首先通过 udev  设备管理器触及与硬件相关的网络堆栈，其核心库于 2012 年合并到 systemd 中（它曾经是一个单独的项目）。你可以使用 udev  通过网络接口做几乎所有你想做的事情，但是如果你习惯了传统的配置方法，那么它会很不和谐，并且在硬件设备配置文件中配置 IP 寻址似乎很奇怪，因此  systemd-networkd出生于。我将在下一篇文章中介绍网络，但足以说明它以更逻辑、更明确的方式处理事物。那么为什么要覆盖 udev  呢？嗯，网络是相当新的东西，它还需要一段时间才能广泛使用，所以就目前而言，udev 可能是大多数人可以使用的最好的东西，而且它仍然非常有用。</p>
<p>In essence, you can run any command you’d like to use to configure the interface via udev, such as <strong>ethtool</strong>, <a target="_blank" rel="noopener" href="https://packetpushers.net/linux-ip-command-ostensive-definition/"><strong>ip</strong> </a>and <strong>dhclient</strong>. Better yet, consistent network device naming is fully supported and you don’t  need to rely on MAC addresses for identification (despite the numerous  examples you’ll find via Google). I’m not aware of any Network Operating Systems (NOSs) using systemd at present, but I’m sure it’s in the  pipeline so I’ll continue and anyway, we all need to be silo free and  multi-disciplinary right?</p>
<p>本质上，您可以运行任何您想用来通过 udev 配置接口的命令，例如  ethtool、ip 和 dhclient。更好的是，完全支持一致的网络设备命名，并且您不需要依赖 MAC 地址进行识别（尽管您可以通过  Google 找到大量示例）。我目前不知道有任何网络操作系统 (NOS) 使用  systemd，但我确信它正在酝酿之中，所以我会继续，无论如何，我们都需要摆脱孤岛和多学科，对吗？</p>
<h3 id="Remove-Network-Manager">Remove Network Manager</h3>
<p>You might not even know it’s in use, but Network Manager can conflict with udev in strange and unusual ways so I prefer to simply remove it.  This isn’t strictly required and may not be necessary but if you hit  problems, its an extra complication. Be aware that doing so will  probably result in the host losing all network connectivity on reboot if udev encounters an error, but hey, we’re just doing this on a vm right? Here’s a few examples of how to do so, depending on your distribution  (further suggestions welcome):</p>
<p>您甚至可能不知道它正在使用，但网络管理器可能会以奇怪和不寻常的方式与  udev 发生冲突，因此我更愿意简单地将其删除。这不是严格要求的，也可能不是必要的，但如果你遇到问题，那就会变得更加复杂。请注意，如果 udev  遇到错误，这样做可能会导致主机在重新启动时丢失所有网络连接，但是嘿，我们只是在虚拟机上执行此操作，对吧？以下是一些如何执行此操作的示例，具体取决于您的发行版（欢迎进一步建议）：</p>
<h3 id="Consistent-Network-Device-Naming">Consistent Network Device Naming</h3>
<p>The bane of Linux for many a year, physical network interfaces were  typically named and numbered based on the order in which the kernel  detected them, which could be change on each boot. Imagine a switch  randomly assigning different numbers to its physical interfaces on each  boot. Fine if they are all configured the same, far from it if not. This issue was resolved around 2012 with the fairly widespread  implementation of the <strong>biosdevname</strong> module, based on a standard created in 2009. Things were slower back then right?</p>
<p>As I’ve mentioned, most examples I’ve seen when searching using  Google and others seem to rely on <strong>matching the interface using its MAC  address</strong>. This seems to be at <strong>odds</strong> with the whole point of consistent  naming and won’t work well with vm images, Vagrant or containers. Of  course, with <strong>embedded interfaces on physical servers it’s not a problem  because the MAC will never change.</strong></p>
<p>正如我所提到的，我在使用 Google  和其他搜索时看到的大多数示例似乎都依赖于使用 MAC 地址来匹配接口。这似乎与一致命名的整体要点相矛盾，并且不能很好地与 vm  镜像、Vagrant 或容器配合使用。当然，对于物理服务器上的嵌入式接口来说，这不是问题，因为 MAC 永远不会改变。</p>
<p>The match is used by udev to identify an interface to be configured, just to reiterate, it’s specified in this file:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/udev/rules.d/70-persistent-net.rules</span><br></pre></td></tr></table></figure>
<p>It’s taken me an age to find an alternative but the PCI bus  identifier seems rather more reliable than a MAC address. You can find  out what it is by using this command (you’ll probably have to install  the <strong>pciutils</strong> package to make this command available):</p>
<p>我花了很长时间才找到替代方案，但 PCI 总线标识符似乎比 MAC 地址更可靠。您可以使用此命令找出它是什么（您可能必须安装 pciutils 软件包才能使此命令可用）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lspci</span><br></pre></td></tr></table></figure>
<p>Here’s what the output looks like with a embedded interface on physical servers:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">00:19.0 Ethernet controller: Intel Corporation Ethernet Connection (2) I218-LM (rev 05)</span><br><span class="line">08:00.0 Ethernet controller: Intel Corporation I210 Gigabit Network Connection (rev 03)</span><br></pre></td></tr></table></figure>
<p><img src="/2023/08/27/udev%E9%85%8D%E7%BD%AELinux%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3/image-20230827132307358.png" alt="image-20230827132307358"></p>
<p>We can now use the data with an entry in the file like this:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SUBSYSTEM==<span class="string">&quot;net&quot;</span>, ACTION==<span class="string">&quot;add&quot;</span>, KERNELS==<span class="string">&quot;0000:08:00.0&quot;</span>, NAME==<span class="string">&quot;ethlab2&quot;</span></span><br></pre></td></tr></table></figure>
<p>To set the speed and duplex (scroll right):</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SUBSYSTEM==<span class="string">&quot;net&quot;</span>, ACTION==<span class="string">&quot;add&quot;</span>, KERNELS==<span class="string">&quot;0000:08:00.0&quot;</span>, NAME==<span class="string">&quot;ethlab&quot;</span>, RUN+=<span class="string">&quot;/sbin/ethtool -s &#x27;%k&#x27; speed 100 duplex full autoneg off&quot;</span></span><br></pre></td></tr></table></figure>
<p><strong>‘%k’</strong> Is a  variable that represents the device name udev has given to the network  interface. I know we’ve called it bingo already, but even if our  ‘rename’ fails, the ethtool and ip link commands will still succeed.</p>
<p>‘%k’ 是一个变量，表示 udev 赋予网络接口的设备名称。我知道我们已经将其称为 ethlab，但即使我们的“重命名”失败，ethtool 和 ip link 命令仍然会成功。</p>
<p>Let’s make use of DHCP too (and log things verbosely with <strong>-v</strong>):</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SUBSYSTEM==<span class="string">&quot;net&quot;</span>, ACTION==<span class="string">&quot;add&quot;</span>, KERNELS==<span class="string">&quot;0000:08:00.0&quot;</span>, NAME==<span class="string">&quot;ethlab&quot;</span>, RUN+=<span class="string">&quot;/sbin/ethtool -s &#x27;%k&#x27; speed 100 duplex full autoneg off&quot;</span>, RUN+=<span class="string">&quot;/sbin/ip link set mtu 1400 dev &#x27;%k&#x27;&quot;</span>, RUN+=<span class="string">&quot;dhclient -v &#x27;%k&#x27;&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="Testing">Testing</h3>
<p>You can force a reload of udevd and its functions with this command:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart systemd-udevd</span><br></pre></td></tr></table></figure>
<p>Note that if you’ve manually reconfigured an interface handled by  udev, this will revert those changes if the settings in question are  specified in a valid .rules file. Also note that restarting udev will  not bring an interface UP if it has been manually set to DOWN and there  is no command to bring it UP in a valid .rules file. A reboot however,  will.</p>
<p>请注意，如果您手动重新配置了由 udev 处理的接口，并且在有效的  .rules 文件中指定了相关设置，则这将恢复这些更改。另请注意，如果已手动将接口设置为 DOWN 并且在有效的 .rules  文件中没有命令将其恢复为 UP，则重新启动 udev 不会将其恢复为 UP。然而，重新启动就会。</p>
<p>You can also ‘test’ changes using this command, but I’ve found this isn’t too helpful (perhaps I’m wrong):</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">udevadm <span class="built_in">test</span> /sys/class/net/eth0 | less</span><br></pre></td></tr></table></figure>
<h3 id="Logging">Logging</h3>
<p>The logging level for udev can be controlled by editing this configuration file: <strong>/etc/udev/udev.conf</strong> like so:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dev_log=<span class="string">&quot;info&quot;</span> <span class="comment">#Change to err, debug etc. or a syslog number as required</span></span><br></pre></td></tr></table></figure>
<p>You can inspect the log entries generated by udev using this command (<strong>-b</strong> restricts things to boot time entries, remove it if you want everything):</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl -b |grep udev</span><br></pre></td></tr></table></figure>
<h1>Debug</h1>
<p>所有配置文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/usr/lib/udev/rules.d/</span><br><span class="line">/etc/udev/rules.d/</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> vim /etc/udev/rules.d/10-local.rules</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#SUBSYSTEM==&quot;net&quot;, ACTION==&quot;add&quot;, KERNELS==&quot;0000:08:00.0&quot;, NAME==&quot;ethlab2&quot;</span></span><br><span class="line">SUBSYSTEM==<span class="string">&quot;net&quot;</span>, ACTION==<span class="string">&quot;add&quot;</span>, ATTR&#123;address&#125;==<span class="string">&quot;fc:4d:d4:3e:cd:2d&quot;</span>,ATTR&#123;<span class="built_in">type</span>&#125;==<span class="string">&quot;1&quot;</span>, NAME=<span class="string">&quot;ethlab&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>查看某个网络设备的信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> udevadm <span class="built_in">test</span> /sys/class/net/eth0</span><br></pre></td></tr></table></figure>
<p>列出某个设备的所有属性</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">udevadm info -ap /devices/pci0000:00/0000:00:1c.2/0000:08:00.0/net/eth0</span><br></pre></td></tr></table></figure>
<p><img src="/2023/08/27/udev%E9%85%8D%E7%BD%AELinux%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3/image-20230827165659758.png" alt="image-20230827165659758"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl restart systemd-udevd &amp;&amp; <span class="built_in">sudo</span> systemctl status systemd-udevd</span><br><span class="line"><span class="built_in">sudo</span> udevadm control --reload-rules &amp;&amp; <span class="built_in">sudo</span> udevadm trigger</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl -b |grep udev</span><br></pre></td></tr></table></figure>
<hr>
<p><a target="_blank" rel="noopener" href="https://packetpushers.net/udev/">Linux Network Interface Configuration With udev</a></p>
<p><a target="_blank" rel="noopener" href="https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/8/html/configuring_and_managing_networking/consistent-network-interface-device-naming_configuring-and-managing-networking">Chapter 1. Consistent network interface device naming</a></p>
<p><a target="_blank" rel="noopener" href="https://howtovmlinux.com/articles/vmware/esxi/change-eth0-interface-name-and-reload-udev-rules-without-a-reboot/">Change “eth0” interface name and reload udev rules without a reboot</a></p>
<p><a target="_blank" rel="noopener" href="https://unix.stackexchange.com/questions/642684/what-is-wrong-with-my-udev-rule">What is wrong with my udev rule?</a></p>
<p><a target="_blank" rel="noopener" href="https://www.51cto.com/article/566468.html">在Linux中如何编写基本的udev规则</a></p>
<p><a target="_blank" rel="noopener" href="https://www.freedesktop.org/wiki/Software/systemd/PredictableNetworkInterfaceNames/">Predictable Network Interface Names</a></p>
<p><a target="_blank" rel="noopener" href="https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/7/html/networking_guide/sec-consistent_network_device_naming_using_biosdevname">使用 biosdevname 的一致网络设备命名</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://991688344.github.io">LYC</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://991688344.github.io/2023/08/27/udev%E9%85%8D%E7%BD%AELinux%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3/">http://991688344.github.io/2023/08/27/udev%E9%85%8D%E7%BD%AELinux%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://991688344.github.io" target="_blank">Rick</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Linux/">Linux</a><a class="post-meta__tags" href="/tags/%E7%BD%91%E7%BB%9C/">网络</a></div><div class="post-share"><div class="social-share" data-image="/images/Wallpaper/eatham.gif" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2023/08/29/UEFI-systemd%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/" title="UEFI+systemd开机启动流程"><img class="cover" src="/images/Wallpaper/eatham.gif" onerror="onerror=null;src='/images/404.png'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">UEFI+systemd开机启动流程</div></div><div class="info-2"><div class="info-item-1">  ...</div></div></div></a><a class="pagination-related" href="/2023/08/27/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BD%91%E7%BB%9C%E8%BF%90%E7%BB%B4/" title="实验室服务器网络运维"><img class="cover" src="/images/Wallpaper/eatham.gif" onerror="onerror=null;src='/images/404.png'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">实验室服务器网络运维</div></div><div class="info-2"><div class="info-item-1">1. 网卡重命名 Linux 内核通过将固定前缀与随着内核初始化网络设备而增加的数字连接在一起，来为网络接口分配名称。例如，eth0 代表启动时被探测的第一个设备。如果您在系统中添加另一个网卡，则内核设备名称的分配将不再是固定的。因此，重启后内核可能会以不同的方式为该设备命名。 要解决这个问题，`udev` 设备管理器支持几种不同的命名方案。默认情况下，`udev` 根据固件、拓扑和位置信息分配固定名称。它有以下优点： 	   设备名称完全可预测。 即使添加或删除了硬件，设备名称也会保持不变，因为不会进行重新枚举。 因此，有问题的硬件可以被无缝地替换。  查看某个网络设备的信息 1sudo udevadm test /sys/class/net/ethlab  列出某个设备的所有属性 1udevadm info -ap...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2022/06/27/%E8%B7%AF%E7%94%B1%E7%AD%96%E7%95%A5ip-rule/" title="路由策略ip rule"><img class="cover" src="/images/Wallpaper/eatham.gif" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-27</div><div class="info-item-2">路由策略ip rule</div></div><div class="info-2"><div class="info-item-1">一，路由策略（使用ip rule命令操作路由策略数据库） 基于策略的路由比传统路由在功能上更强大，使用更灵活，它使网络管理员不仅能够根据目的地址而且能够根据报文大小，应用或IP源地址等属性来选择转发路径。 ip rule命令： 1234567891011121314151617Usage: ip rule [ list | add | del ] SELECTOR ACTION （add 添加；del 删除； llist 列表） SELECTOR := [ from PREFIX 数据包源地址] [ to PREFIX 数据包目的地址] [ tos TOS 服务类型]            [ dev STRING 物理接口] [ pref NUMBER ] [fwmark MARK iptables 标签] ACTION := [ table TABLE_ID 指定所使用的路由表] [ nat ADDRESS 网络地址转换]          [ prohibit 丢弃该表| reject 拒绝该包| unreachable 丢弃该包] [ flowid CLASSID ]...</div></div></div></a><a class="pagination-related" href="/2023/08/29/4GPU%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%8F%8A%E7%BB%B4%E6%8A%A4/" title="4GPU服务器环境配置及维护"><img class="cover" src="/images/Wallpaper/rainbowcat.gif" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-29</div><div class="info-item-2">4GPU服务器环境配置及维护</div></div><div class="info-2"><div class="info-item-1">  ...</div></div></div></a><a class="pagination-related" href="/2019/11/16/Desktop%E6%96%87%E4%BB%B6/" title="Desktop文件"><img class="cover" src="/images/Wallpaper/rainbowcat.gif" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2019-11-16</div><div class="info-item-2">Desktop文件</div></div><div class="info-2"><div class="info-item-1">参考网址 %U	A list of URLs. Each URL is passed as a separate argument to the executable program. Local files may either be passed as file: URLs or as file path.   也就是说，加入了%U参数，可以传递多个URL给Chrome浏览器，浏览器会依次打开各URL。比如您在文件管理器中选择了多个html文件，然后在鼠标右键菜单中点击”Open with Google Chrome”，Chrome浏览器就会依次打开所选的网页。 Exec后面可以跟上执行参数,之后每次点击图标都会带着执行参数执行 例如 Exec typora --no-sandbax %U </div></div></div></a><a class="pagination-related" href="/2020/04/09/LD-PRELOAD/" title="LD_PRELOAD"><img class="cover" src="/images/Wallpaper/eatham.gif" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-04-09</div><div class="info-item-2">LD_PRELOAD</div></div><div class="info-2"><div class="info-item-1">一、LD_PRELOAD是什么  LD_PRELOAD是Linux系统的一个环境变量，它可以影响程序的运行时的链接（Runtime  linker），它允许你定义在程序运行前优先加载的动态链接库。这个功能主要就是用来有选择性的载入不同动态链接库中的相同函数。通过这个环境变量，我们可以在主程序和其动态链接库的中间加载别的动态链接库，甚至覆盖正常的函数库。一方面，我们可以以此功能来使用自己的或是更好的函数（无需别人的源码），而另一方面，我们也可以以向别人的程序注入程序，从而达到特定的目的。  二、程序调用流图  LA_PRELOAD替换前  LA_PRELOAD替换后   三、演示程序代码   主程序 1234567891011121314151617// myverifypasswd.c#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &quot;mystrcmp.h&quot; void main(int argc,char **argv) &#123;    char passwd[] =...</div></div></div></a><a class="pagination-related" href="/2020/03/26/Linux-Shell%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6%E6%B1%87%E6%80%BB/" title="Linux-Shell特殊字符汇总"><img class="cover" src="/images/Wallpaper/rainbowcat.gif" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-03-26</div><div class="info-item-2">Linux-Shell特殊字符汇总</div></div><div class="info-2"><div class="info-item-1">Shell符号及各种解释对照表：    Shell符号 使用方法及说明     # 注释符号(Hashmark[Comments])            1.在shell文件的行首，作为include标记，#!/bin/bash;             2. 其他地方作为注释使用，在一行中，#后面的内容并不会被执行，除非；             3. 但是用单/双引号包围时，#作为#号字符本身，不具有注释作用。   ; 作为多语句的分隔符(Command separator [semicolon])。多个语句要放在同一行的时候，可以使用分号分隔。注意，有时候分号需要转义。   ;; 连续分号(Terminator [double semicolon])。在使用case选项的时候，作为每个选项的终结符。在Bash version 4+ 的时候，还可以使用[;;&amp;], [;&amp;]   . 点号(dot command [period])。            1. 相当于bash内建命令source，如：           ...</div></div></div></a><a class="pagination-related" href="/2021/02/01/Linux-Namespace%E4%B8%8EDocker%E5%8E%9F%E7%90%86/" title="Linux Namespace与Docker原理"><img class="cover" src="/images/Wallpaper/rainbowcat.gif" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2021-02-01</div><div class="info-item-2">Linux Namespace与Docker原理</div></div><div class="info-2"><div class="info-item-1">namespace 初识 Docker 是一个基于 namespace、cgroup、Union FS 等等技术的一个开源容器引擎，很多人都会觉得 Docker  是个新兴技术，其实不然，其主要隔离技术 Namespace 技术早在 Linux 内核版本为 2.6 时候就差不多完成了（像 Ubuntu  16.04 发行版本的内核基本上都是 4.4，CentOS 7 则普遍 3.10 ）。 Linux Namespace 是 Linux 提供的一种内核级别环境隔离的方法。 要想实现隔离的效果，需要完成的东西又有哪些呢？其实如果你安装了 gcc 工具链（安装 golang 之后就会有了），那么使用 man namespaces 命令就可以了解到 namespace 技术的大概，也可查看在线手册。 这里简单地搬运了些知识点，首先是 Linux 提供的具体的隔离内容：    Namespace 系统调用参数 内核版本 隔离内容     UTS (Unix Time-sharing System) CLONE_NEWUTS Linux 2.4.19 主机名与域名   IPC...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="lv-container" data-id="city" data-uid="MTAyMC80NzA1My8yMzU1Mw=="></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/images/head.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">LYC</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">251</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">37</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">49</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">一致的网络接口设备命名</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">网络接口设备命名等级</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">网络设备重命名是如何工作的</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">使用 udev 规则分配用户定义的网络接口名称</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">使用 systemd 链接文件分配用户定义的网络接口名称</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">使用 systemd 链接文件向网络接口分配额外的名称</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Remove-Network-Manager"><span class="toc-number">6.0.1.</span> <span class="toc-text">Remove Network Manager</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Consistent-Network-Device-Naming"><span class="toc-number">6.0.2.</span> <span class="toc-text">Consistent Network Device Naming</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Testing"><span class="toc-number">6.0.3.</span> <span class="toc-text">Testing</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Logging"><span class="toc-number">6.0.4.</span> <span class="toc-text">Logging</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text">Debug</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/08/29/4GPU%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%8F%8A%E7%BB%B4%E6%8A%A4/" title="4GPU服务器环境配置及维护"><img src="/images/Wallpaper/rainbowcat.gif" onerror="this.onerror=null;this.src='/images/404.png'" alt="4GPU服务器环境配置及维护"/></a><div class="content"><a class="title" href="/2023/08/29/4GPU%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%8F%8A%E7%BB%B4%E6%8A%A4/" title="4GPU服务器环境配置及维护">4GPU服务器环境配置及维护</a><time datetime="2023-08-29T12:00:26.000Z" title="发表于 2023-08-29 20:00:26">2023-08-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/29/UEFI-systemd%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/" title="UEFI+systemd开机启动流程"><img src="/images/Wallpaper/eatham.gif" onerror="this.onerror=null;this.src='/images/404.png'" alt="UEFI+systemd开机启动流程"/></a><div class="content"><a class="title" href="/2023/08/29/UEFI-systemd%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/" title="UEFI+systemd开机启动流程">UEFI+systemd开机启动流程</a><time datetime="2023-08-29T08:39:54.000Z" title="发表于 2023-08-29 16:39:54">2023-08-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/27/udev%E9%85%8D%E7%BD%AELinux%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3/" title="udev配置Linux网络接口"><img src="/images/Wallpaper/eatham.gif" onerror="this.onerror=null;this.src='/images/404.png'" alt="udev配置Linux网络接口"/></a><div class="content"><a class="title" href="/2023/08/27/udev%E9%85%8D%E7%BD%AELinux%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3/" title="udev配置Linux网络接口">udev配置Linux网络接口</a><time datetime="2023-08-27T12:49:29.000Z" title="发表于 2023-08-27 20:49:29">2023-08-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/27/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BD%91%E7%BB%9C%E8%BF%90%E7%BB%B4/" title="实验室服务器网络运维"><img src="/images/Wallpaper/eatham.gif" onerror="this.onerror=null;this.src='/images/404.png'" alt="实验室服务器网络运维"/></a><div class="content"><a class="title" href="/2023/08/27/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BD%91%E7%BB%9C%E8%BF%90%E7%BB%B4/" title="实验室服务器网络运维">实验室服务器网络运维</a><time datetime="2023-08-27T12:20:23.000Z" title="发表于 2023-08-27 20:20:23">2023-08-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/11/21/Attention%E6%9C%BA%E5%88%B6-transformer/" title="Attention机制_transformer"><img src="/images/Wallpaper/eatham.gif" onerror="this.onerror=null;this.src='/images/404.png'" alt="Attention机制_transformer"/></a><div class="content"><a class="title" href="/2022/11/21/Attention%E6%9C%BA%E5%88%B6-transformer/" title="Attention机制_transformer">Attention机制_transformer</a><time datetime="2022-11-21T11:55:15.000Z" title="发表于 2022-11-21 19:55:15">2022-11-21</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2024 By LYC</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(async () => {
  const showKatex = () => {
    document.querySelectorAll('#article-container .katex').forEach(el => el.classList.add('katex-show'))
  }

  if (!window.katex_js_css) {
    window.katex_js_css = true
    await btf.getCSS('https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css')
    if (true) {
      await btf.getScript('https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js')
    }
  }

  showKatex()
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.isShuoshuo

  const loadLivere = (el, path) => {
    window.livereOptions = {
      refer: path || location.pathname
    }

    if (isShuoshuo) {
      window.shuoshuoComment.destroyLivere = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    if (typeof LivereTower === 'object') window.LivereTower.init()
    else {
      (function(d, s) {
          var j, e = d.getElementsByTagName(s)[0];
          if (typeof LivereTower === 'function') { return; }
          j = d.createElement(s);
          j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
          j.async = true;
          e.parentNode.insertBefore(j, e);
      })(document, 'script');
    }
  }

  if (isShuoshuo) {
    'Livere' === 'Livere'
      ? window.shuoshuoComment = { loadComment: loadLivere }
      : window.loadOtherComment = loadLivere
    return
  }

  if ('Livere' === 'Livere' || !false) {
    if (false) btf.loadComment(document.getElementById('lv-container'), loadLivere)
    else loadLivere()
  } else {
    window.loadOtherComment = loadLivere
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>