<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>CSRF漏洞 | Rick</title><meta name="author" content="LYC"><meta name="copyright" content="LYC"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="什么是CSRF ​      CSRF（Cross-site request forgery）跨站请求伪造，也被称为“one click attack”或者session riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。CSRF通过伪装来自受信任用户的请求来利用受信任的网站。与XSS攻击相比，CSRF攻击往往不大流行（因此对其进行防范的资源也相当稀少）和难以防范，所以被认为比">
<meta property="og:type" content="article">
<meta property="og:title" content="CSRF漏洞">
<meta property="og:url" content="http://991688344.github.io/2020/02/25/CSRF%E6%BC%8F%E6%B4%9E/index.html">
<meta property="og:site_name" content="Rick">
<meta property="og:description" content="什么是CSRF ​      CSRF（Cross-site request forgery）跨站请求伪造，也被称为“one click attack”或者session riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。CSRF通过伪装来自受信任用户的请求来利用受信任的网站。与XSS攻击相比，CSRF攻击往往不大流行（因此对其进行防范的资源也相当稀少）和难以防范，所以被认为比">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://991688344.github.io/images/Wallpaper/rainbowcat.gif">
<meta property="article:published_time" content="2020-02-24T20:04:35.000Z">
<meta property="article:modified_time" content="2024-03-19T01:32:36.456Z">
<meta property="article:author" content="LYC">
<meta property="article:tag" content="安全">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://991688344.github.io/images/Wallpaper/rainbowcat.gif"><link rel="shortcut icon" href="/images/Wallpaper/favicon.ico"><link rel="canonical" href="http://991688344.github.io/2020/02/25/CSRF%E6%BC%8F%E6%B4%9E/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/content.json","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'CSRF漏洞',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><link rel="stylesheet" href="/mycss/my_background.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-color: #F7F9FE;"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/images/head.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">251</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">37</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">49</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-paper-plane"></i><span> 留言板</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/images/Wallpaper/rainbowcat.gif);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Rick</span></a><a class="nav-page-title" href="/"><span class="site-name">CSRF漏洞</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-paper-plane"></i><span> 留言板</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">CSRF漏洞</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-02-24T20:04:35.000Z" title="发表于 2020-02-25 04:04:35">2020-02-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-03-19T01:32:36.456Z" title="更新于 2024-03-19 09:32:36">2024-03-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AE%89%E5%85%A8/">安全</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AE%89%E5%85%A8/Web/">Web</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">5.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>18分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1>什么是CSRF</h1>
<p>​      CSRF（Cross-site request forgery）跨站请求伪造，也被称为“one click attack”或者session riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。CSRF通过伪装来自受信任用户的请求来利用受信任的网站。与XSS攻击相比，CSRF攻击往往不大流行（因此对其进行防范的资源也相当稀少）和难以防范，所以被认为比XSS更具危险性。<br>
​<br>
​      下图是一次完整的CSRF攻击示意图。用户登录并访问了一正常网站，登录成功后，网站返回用户的身份标识Cookie给用户。当用户访问到恶意网站时，恶意网站强制用户去向正常网站发送恶意请求。由于用户此时拥有正常网站的Cookie，所以就相当于攻击者盗用了用户身份，去访问了正常（目标）网站。</p>
<p>一次完整的CSRF攻击，需要受害用户需要完成两个步骤：</p>
<p>​       1.登录正常网站，并在本地生成Cookie。<br>
​<br>
​       2.在不退出正常网站的情况下，访问恶意网站。</p>
<p><img src="/2020/02/25/CSRF%E6%BC%8F%E6%B4%9E/image-20200225040600339.png" alt="image-20200225040600339"></p>
<h2 id="CSRF-背景与介绍">CSRF 背景与介绍</h2>
<p>CSRF（Cross Site Request Forgery, 跨站域请求伪造）是一种网络的攻击方式，它在 2007 年曾被列为互联网 20 大安全隐患之一。其他安全隐患，比如 SQL  脚本注入，跨站域脚本攻击等在近年来已经逐渐为众人熟知，很多网站也都针对他们进行了防御。然而，对于大多数人来说，CSRF  却依然是一个陌生的概念。即便是大名鼎鼎的 Gmail, 在 2007 年底也存在着 CSRF 漏洞，从而被黑客攻击而使 Gmail  的用户造成巨大的损失。</p>
<h3 id="CSRF-攻击实例">CSRF 攻击实例</h3>
<p>CSRF  攻击可以在受害者毫不知情的情况下以受害者名义伪造请求发送给受攻击站点，从而在并未授权的情况下执行在权限保护之下的操作。比如说，受害者 Bob  在银行有一笔存款，通过对银行的网站发送请求  <a target="_blank" rel="noopener" href="http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=bob2">http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=bob2</a> 可以使 Bob 把 1000000 的存款转到 bob2 的账号下。通常情况下，该请求发送到网站后，服务器会先验证该请求是否来自一个合法的  session，并且该 session 的用户 Bob 已经成功登陆。黑客 Mallory 自己在该银行也有账户，他知道上文中的 URL  可以把钱进行转帐操作。Mallory  可以自己发送一个请求给银行：<a target="_blank" rel="noopener" href="http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory%E3%80%82%E4%BD%86%E6%98%AF%E8%BF%99%E4%B8%AA%E8%AF%B7%E6%B1%82%E6%9D%A5%E8%87%AA">http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory。但是这个请求来自</a> Mallory 而非 Bob，他不能通过安全认证，因此该请求不会起作用。这时，Mallory 想到使用 CSRF  的攻击方式，他先自己做一个网站，在网站中放入如下代码：  src=”<a target="_blank" rel="noopener" href="http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory">http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory</a> ”，并且通过广告等诱使 Bob 来访问他的网站。当 Bob 访问该网站时，上述 url 就会从 Bob 的浏览器发向银行，而这个请求会附带  Bob 浏览器中的 cookie 一起发向银行服务器。大多数情况下，该请求会失败，因为他要求 Bob 的认证信息。但是，如果 Bob  当时恰巧刚访问他的银行后不久，他的浏览器与银行网站之间的 session 尚未过期，浏览器的 cookie 之中含有 Bob  的认证信息。这时，悲剧发生了，这个 url 请求就会得到响应，钱将从 Bob 的账号转移到 Mallory 的账号，而 Bob  当时毫不知情。等以后 Bob  发现账户钱少了，即使他去银行查询日志，他也只能发现确实有一个来自于他本人的合法请求转移了资金，没有任何被攻击的痕迹。而 Mallory  则可以拿到钱后逍遥法外。</p>
<h3 id="CSRF-攻击的对象">CSRF 攻击的对象</h3>
<p>在讨论如何抵御 CSRF 之前，先要明确 CSRF 攻击的对象，也就是要保护的对象。从以上的例子可知，CSRF 攻击是黑客借助受害者的 cookie  骗取服务器的信任，但是黑客并不能拿到 cookie，也看不到 cookie  的内容。另外，对于服务器返回的结果，由于浏览器同源策略的限制，黑客也无法进行解析。因此，黑客无法从返回的结果中得到任何东西，他所能做的就是给服务器发送请求，以执行请求中所描述的命令，在服务器端直接改变数据的值，而非窃取服务器中的数据。所以，我们要保护的对象是那些可以直接产生数据改变的服务，而对于读取数据的服务，则不需要进行 CSRF 的保护。比如银行系统中转账的请求会直接改变账户的金额，会遭到 CSRF  攻击，需要保护。而查询余额是对金额的读取操作，不会改变数据，CSRF 攻击无法解析服务器返回的结果，无需保护。</p>
<h2 id="当前防御-CSRF-的几种策略">当前防御 CSRF 的几种策略</h2>
<p>在业界目前防御 CSRF 攻击主要有三种策略：验证 HTTP Referer 字段；在请求地址中添加 token 并验证；在 HTTP 头中自定义属性并验证。下面就分别对这三种策略进行详细介绍。</p>
<h3 id="验证-HTTP-Referer-字段">验证 HTTP Referer 字段</h3>
<p>根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP  请求的来源地址。在通常情况下，访问一个安全受限页面的请求来自于同一个网站，比如需要访问  <a target="_blank" rel="noopener" href="http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory%EF%BC%8C%E7%94%A8%E6%88%B7%E5%BF%85%E9%A1%BB%E5%85%88%E7%99%BB%E9%99%86">http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory，用户必须先登陆</a> bank.example，然后通过点击页面上的按钮来触发转账事件。这时，该转帐请求的 Referer 值就会是转账按钮所在的页面的  URL，通常是以 bank.example 域名开头的地址。而如果黑客要对银行网站实施 CSRF  攻击，他只能在他自己的网站构造请求，当用户通过黑客的网站发送请求到银行时，该请求的 Referer 是指向黑客自己的网站。因此，要防御 CSRF 攻击，银行网站只需要对于每一个转账请求验证其 Referer 值，如果是以 bank.example  开头的域名，则说明该请求是来自银行网站自己的请求，是合法的。如果 Referer 是其他网站的话，则有可能是黑客的 CSRF 攻击，拒绝该请求。</p>
<p>这种方法的显而易见的好处就是简单易行，网站的普通开发人员不需要操心 CSRF 的漏洞，只需要在最后给所有安全敏感的请求统一增加一个拦截器来检查 Referer  的值就可以。特别是对于当前现有的系统，不需要改变当前系统的任何已有代码和逻辑，没有风险，非常便捷。</p>
<p>然而，这种方法并非万无一失。Referer 的值是由浏览器提供的，虽然 HTTP 协议上有明确的要求，但是每个浏览器对于 Referer  的具体实现可能有差别，并不能保证浏览器自身没有安全漏洞。使用验证 Referer  值的方法，就是把安全性都依赖于第三方（即浏览器）来保障，从理论上来讲，这样并不安全。事实上，对于某些浏览器，比如 IE6 或  FF2，目前已经有一些方法可以篡改 Referer 值。如果 bank.example 网站支持 IE6 浏览器，黑客完全可以把用户浏览器的  Referer 值设为以 bank.example 域名开头的地址，这样就可以通过验证，从而进行 CSRF 攻击。</p>
<p>即便是使用最新的浏览器，黑客无法篡改 Referer 值，这种方法仍然有问题。因为 Referer  值会记录下用户的访问来源，有些用户认为这样会侵犯到他们自己的隐私权，特别是有些组织担心 Referer  值会把组织内网中的某些信息泄露到外网中。因此，用户自己可以设置浏览器使其在发送请求时不再提供  Referer。当他们正常访问银行网站时，网站会因为请求没有 Referer 值而认为是 CSRF 攻击，拒绝合法用户的访问。</p>
<h3 id="在请求地址中添加-token-并验证">在请求地址中添加 token 并验证</h3>
<p>CSRF 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 cookie  中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的 cookie 来通过安全验证。要抵御  CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。可以在 HTTP  请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。</p>
<p>这种方法要比检查 Referer 要安全一些，token  可以在用户登陆后产生并放于 session 之中，然后在每次请求时把 token 从 session 中拿出，与请求中的 token  进行比对，但这种方法的难点在于如何把 token 以参数的形式加入请求。对于 GET 请求，token 将附在请求地址之后，这样 URL 就变成 <a target="_blank" rel="noopener" href="http://url?csrftoken=tokenvalue%E3%80%82">http://url?csrftoken=tokenvalue。</a> 而对于 POST 请求来说，要在 form 的最后加上 <input type="”hidden”" name="”csrftoken”" value="”tokenvalue”/">，这样就把 token  以参数的形式加入请求了。但是，在一个网站中，可以接受请求的地方非常多，要对于每一个请求都加上 token  是很麻烦的，并且很容易漏掉，通常使用的方法就是在每次页面加载时，使用 javascript 遍历整个 dom 树，对于 dom 中所有的 a 和 form 标签后加入 token。这样可以解决大部分的请求，但是对于在页面加载之后动态生成的 html  代码，这种方法就没有作用，还需要程序员在编码时手动添加 token。</p>
<p>该方法还有一个缺点是难以保证 token  本身的安全。特别是在一些论坛之类支持用户自己发表内容的网站，黑客可以在上面发布自己个人网站的地址。由于系统也会在这个地址后面加上  token，黑客可以在自己的网站上得到这个 token，并马上就可以发动 CSRF 攻击。为了避免这一点，系统可以在添加 token  的时候增加一个判断，如果这个链接是链到自己本站的，就在后面添加 token，如果是通向外网则不加。不过，即使这个 csrftoken  不以参数的形式附加在请求之中，黑客的网站也同样可以通过 Referer 来得到这个 token 值以发动 CSRF  攻击。这也是一些用户喜欢手动关闭浏览器 Referer 功能的原因。</p>
<h3 id="在-HTTP-头中自定义属性并验证">在 HTTP 头中自定义属性并验证</h3>
<p>这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP  头中自定义的属性里。通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把  token 值放入其中。这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest  请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去。</p>
<p>然而这种方法的局限性非常大。XMLHttpRequest 请求通常用于 Ajax  方法中对于页面局部的异步刷新，并非所有的请求都适合用这个类来发起，而且通过该类请求得到的页面不能被浏览器所记录下，从而进行前进，后退，刷新，收藏等操作，给用户带来不便。另外，对于没有进行 CSRF 防护的遗留系统来说，要采用这种方法来进行防护，要把所有请求都改为 XMLHttpRequest  请求，这样几乎是要重写整个网站，这代价无疑是不能接受的。</p>
<h2 id="Java-代码示例">Java 代码示例</h2>
<p>下文将以 Java  为例，对上述三种方法分别用代码进行示例。无论使用何种方法，在服务器端的拦截器必不可少，它将负责检查到来的请求是否符合要求，然后视结果而决定是否继续请求或者丢弃。在 Java 中，拦截器是由 Filter 来实现的。我们可以编写一个 Filter，并在 web.xml 中对其进行配置，使其对于访问所有需要  CSRF 保护的资源的请求进行拦截。</p>
<p>在 filter 中对请求的 Referer 验证代码如下</p>
<h5 id="清单-1-在-Filter-中验证-Referer">清单 1. 在 Filter 中验证 Referer</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从 HTTP 头中取得 Referer 值</span></span><br><span class="line">String referer=request.getHeader(<span class="string">&quot;Referer&quot;</span>); </span><br><span class="line"><span class="comment">// 判断 Referer 是否以 bank.example 开头</span></span><br><span class="line"><span class="keyword">if</span>((referer!=<span class="literal">null</span>) &amp;&amp;(referer.trim().startsWith(“bank.example”)))&#123; </span><br><span class="line">   chain.doFilter(request, response); </span><br><span class="line">&#125;<span class="keyword">else</span>&#123; </span><br><span class="line">   request.getRequestDispatcher(“error.jsp”).forward(request,response); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码先取得 Referer 值，然后进行判断，当其非空并以 bank.example 开头时，则继续请求，否则的话可能是 CSRF 攻击，转到 error.jsp 页面。</p>
<p>以上代码先取得 Referer 值，然后进行判断，当其非空并以 bank.example 开头时，则继续请求，否则的话可能是 CSRF 攻击，转到 error.jsp 页面。</p>
<p>如果要进一步验证请求中的 token 值，代码如下</p>
<h5 id="清单-2-在-filter-中验证请求中的-token">清单 2. 在 filter 中验证请求中的 token</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HttpServletRequest</span> <span class="variable">req</span> <span class="operator">=</span> (HttpServletRequest)request; </span><br><span class="line"><span class="type">HttpSession</span> <span class="variable">s</span> <span class="operator">=</span> req.getSession(); </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 从 session 中得到 csrftoken 属性</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sToken</span> <span class="operator">=</span> (String)s.getAttribute(“csrftoken”); </span><br><span class="line"><span class="keyword">if</span>(sToken == <span class="literal">null</span>)&#123; </span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 产生新的 token 放入 session 中</span></span><br><span class="line">   sToken = generateToken(); </span><br><span class="line">   s.setAttribute(“csrftoken”,sToken); </span><br><span class="line">   chain.doFilter(request, response); </span><br><span class="line">&#125; <span class="keyword">else</span>&#123; </span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 从 HTTP 头中取得 csrftoken </span></span><br><span class="line">   <span class="type">String</span> <span class="variable">xhrToken</span> <span class="operator">=</span> req.getHeader(“csrftoken”); </span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 从请求参数中取得 csrftoken </span></span><br><span class="line">   <span class="type">String</span> <span class="variable">pToken</span> <span class="operator">=</span> req.getParameter(“csrftoken”); </span><br><span class="line">   <span class="keyword">if</span>(sToken != <span class="literal">null</span> &amp;&amp; xhrToken != <span class="literal">null</span> &amp;&amp; sToken.equals(xhrToken))&#123; </span><br><span class="line">       chain.doFilter(request, response); </span><br><span class="line">   &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sToken != <span class="literal">null</span> &amp;&amp; pToken != <span class="literal">null</span> &amp;&amp; sToken.equals(pToken))&#123; </span><br><span class="line">       chain.doFilter(request, response); </span><br><span class="line">   &#125;<span class="keyword">else</span>&#123; </span><br><span class="line">       request.getRequestDispatcher(“error.jsp”).forward(request,response); </span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先判断 session 中有没有 csrftoken，如果没有，则认为是第一次访问，session 是新建立的，这时生成一个新的  token，放于 session 之中，并继续执行请求。如果 session 中已经有  csrftoken，则说明用户已经与服务器之间建立了一个活跃的 session，这时要看这个请求中有没有同时附带这个  token，由于请求可能来自于常规的访问或是 XMLHttpRequest 异步访问，我们分别尝试从请求中获取 csrftoken 参数以及从  HTTP 头中获取 csrftoken 自定义属性并与 session 中的值进行比较，只要有一个地方带有有效  token，就判定请求合法，可以继续执行，否则就转到错误页面。生成 token 有很多种方法，任何的随机算法都可以使用，Java 的 UUID  类也是一个不错的选择。</p>
<p>除了在服务器端利用 filter 来验证 token 的值以外，我们还需要在客户端给每个请求附加上这个  token，这是利用 js 来给 html 中的链接和表单请求地址附加 csrftoken 代码，其中已定义 token 为全局变量，其值可以从 session 中得到。</p>
<h5 id="清单-3-在客户端对于请求附加-token">清单 3. 在客户端对于请求附加 token</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">function <span class="title function_">appendToken</span><span class="params">()</span>&#123; </span><br><span class="line">   updateForms(); </span><br><span class="line">   updateTags(); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">function <span class="title function_">updateForms</span><span class="params">()</span> &#123; </span><br><span class="line">   <span class="comment">// 得到页面中所有的 form 元素</span></span><br><span class="line">   <span class="type">var</span> <span class="variable">forms</span> <span class="operator">=</span> document.getElementsByTagName(<span class="string">&#x27;form&#x27;</span>); </span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;forms.length; i++) &#123; </span><br><span class="line">       <span class="type">var</span> <span class="variable">url</span> <span class="operator">=</span> forms[i].action; </span><br><span class="line"> </span><br><span class="line">       <span class="comment">// 如果这个 form 的 action 值为空，则不附加 csrftoken </span></span><br><span class="line">       <span class="keyword">if</span>(url == <span class="literal">null</span> || url == <span class="string">&quot;&quot;</span> ) <span class="keyword">continue</span>; </span><br><span class="line"> </span><br><span class="line">       <span class="comment">// 动态生成 input 元素，加入到 form 之后</span></span><br><span class="line">       <span class="type">var</span> <span class="variable">e</span> <span class="operator">=</span> document.createElement(<span class="string">&quot;input&quot;</span>); </span><br><span class="line">       e.name = <span class="string">&quot;csrftoken&quot;</span>; </span><br><span class="line">       e.value = token; </span><br><span class="line">       e.type=<span class="string">&quot;hidden&quot;</span>; </span><br><span class="line">       forms[i].appendChild(e); </span><br><span class="line">   &#125; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">function <span class="title function_">updateTags</span><span class="params">()</span> &#123; </span><br><span class="line">   <span class="type">var</span> <span class="variable">all</span> <span class="operator">=</span> document.getElementsByTagName(<span class="string">&#x27;a&#x27;</span>); </span><br><span class="line">   <span class="type">var</span> <span class="variable">len</span> <span class="operator">=</span> all.length; </span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 遍历所有 a 元素</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;len; i++) &#123; </span><br><span class="line">       <span class="type">var</span> <span class="variable">e</span> <span class="operator">=</span> all[i]; </span><br><span class="line">       updateTag(e, <span class="string">&#x27;href&#x27;</span>, token); </span><br><span class="line">   &#125; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">function <span class="title function_">updateTag</span><span class="params">(element, attr, token)</span> &#123; </span><br><span class="line">   <span class="type">var</span> <span class="variable">location</span> <span class="operator">=</span> element.getAttribute(attr); </span><br><span class="line">   <span class="keyword">if</span>(location != <span class="literal">null</span> &amp;&amp; location != <span class="string">&#x27;&#x27;</span> <span class="string">&#x27;&#x27;</span> ) &#123; </span><br><span class="line">       <span class="type">var</span> <span class="variable">fragmentIndex</span> <span class="operator">=</span> location.indexOf(<span class="string">&#x27;#&#x27;</span>); </span><br><span class="line">       <span class="type">var</span> <span class="variable">fragment</span> <span class="operator">=</span> <span class="literal">null</span>; </span><br><span class="line">       <span class="keyword">if</span>(fragmentIndex != -<span class="number">1</span>)&#123; </span><br><span class="line"> </span><br><span class="line">           <span class="comment">//url 中含有只相当页的锚标记</span></span><br><span class="line">           fragment = location.substring(fragmentIndex); </span><br><span class="line">           location = location.substring(<span class="number">0</span>,fragmentIndex); </span><br><span class="line">       &#125; </span><br><span class="line">        </span><br><span class="line">       <span class="type">var</span> <span class="variable">index</span> <span class="operator">=</span> location.indexOf(<span class="string">&#x27;?&#x27;</span>); </span><br><span class="line"> </span><br><span class="line">       <span class="keyword">if</span>(index != -<span class="number">1</span>) &#123; </span><br><span class="line">           <span class="comment">//url 中已含有其他参数</span></span><br><span class="line">           location = location + <span class="string">&#x27;&amp;csrftoken=&#x27;</span> + token; </span><br><span class="line">       &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">           <span class="comment">//url 中没有其他参数</span></span><br><span class="line">           location = location + <span class="string">&#x27;?csrftoken=&#x27;</span> + token; </span><br><span class="line">       &#125; </span><br><span class="line">       <span class="keyword">if</span>(fragment != <span class="literal">null</span>)&#123; </span><br><span class="line">           location += fragment; </span><br><span class="line">       &#125; </span><br><span class="line">        </span><br><span class="line">       element.setAttribute(attr, location); </span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在客户端 html 中，主要是有两个地方需要加上 token，一个是表单 form，另一个就是链接 a。这段代码首先遍历所有的  form，在 form 最后添加一隐藏字段，把 csrftoken 放入其中。然后，代码遍历所有的链接标记 a，在其 href 属性中加入  csrftoken 参数。注意对于 a.href 来说，可能该属性已经有参数，或者有锚标记。因此需要分情况讨论，以不同的格式把  csrftoken 加入其中。</p>
<p>如果你的网站使用 XMLHttpRequest，那么还需要在 HTTP 头中自定义 csrftoken 属性，利用 dojo.xhr 给 XMLHttpRequest 加上自定义属性代码如下：</p>
<h5 id="清单-4-在-HTTP-头中自定义属性">清单 4. 在 HTTP 头中自定义属性</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">plainXhr</span> <span class="operator">=</span> dojo.xhr; </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 重写 dojo.xhr 方法</span></span><br><span class="line">dojo.xhr = function(method,args,hasBody) &#123; </span><br><span class="line">   <span class="comment">// 确保 header 对象存在</span></span><br><span class="line">   args.headers = args.header || &#123;&#125;; </span><br><span class="line">        </span><br><span class="line">   tokenValue = <span class="string">&#x27;&lt;%=request.getSession(false).getAttribute(&quot;csrftoken&quot;)%&gt;&#x27;</span>; </span><br><span class="line">   <span class="type">var</span> <span class="variable">token</span> <span class="operator">=</span> dojo.getObject(<span class="string">&quot;tokenValue&quot;</span>); </span><br><span class="line">    </span><br><span class="line">   <span class="comment">// 把 csrftoken 属性放到头中</span></span><br><span class="line">   args.headers[<span class="string">&quot;csrftoken&quot;</span>] = (token) ? token : <span class="string">&quot;  &quot;</span>; </span><br><span class="line">   <span class="keyword">return</span> plainXhr(method,args,hasBody); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里改写了 dojo.xhr 的方法，首先确保 dojo.xhr 中存在 HTTP 头，然后在 args.headers 中添加 csrftoken 字段，并把 token 值从 session 里拿出放入字段中。</p>
<h2 id="CSRF-防御方法选择之道">CSRF 防御方法选择之道</h2>
<p>通过上文讨论可知，目前业界应对 CSRF  攻击有一些克制方法，但是每种方法都有利弊，没有一种方法是完美的。如何选择合适的方法非常重要。如果网站是一个现有系统，想要在最短时间内获得一定程度的 CSRF 的保护，那么验证 Referer 的方法是最方便的，要想增加安全性的话，可以选择不支持低版本浏览器，毕竟就目前来说，IE7+,  FF3+ 这类高版本浏览器的 Referer 值还无法被篡改。</p>
<p>如果系统必须支持 IE6，并且仍然需要高安全性。那么就要使用  token 来进行验证，在大部分情况下，使用 XmlHttpRequest 并不合适，token  只能以参数的形式放于请求之中，若你的系统不支持用户自己发布信息，那这种程度的防护已经足够，否则的话，你仍然难以防范 token  被黑客窃取并发动攻击。在这种情况下，你需要小心规划你网站提供的各种服务，从中间找出那些允许用户自己发布信息的部分，把它们与其他服务分开，使用不同的 token  进行保护，这样可以有效抵御黑客对于你关键服务的攻击，把危害降到最低。毕竟，删除别人一个帖子比直接从别人账号中转走大笔存款严重程度要轻的多。</p>
<p>如果是开发一个全新的系统，则抵御 CSRF 的选择要大得多。笔者建议对于重要的服务，可以尽量使用 XMLHttpRequest 来访问，这样增加 token  要容易很多。另外尽量避免在 js 代码中使用复杂逻辑来构造常规的同步请求来访问需要 CSRF 保护的资源，比如 window.location 和 document.createElement(“a”) 之类，这样也可以减少在附加 token 时产生的不必要的麻烦。</p>
<p>最后，要记住 CSRF 不是黑客唯一的攻击手段，无论你 CSRF 防范有多么严密，如果你系统有其他安全漏洞，比如跨站域脚本攻击 XSS，那么黑客就可以绕过你的安全防护，展开包括 CSRF 在内的各种攻击，你的防线将如同虚设。</p>
<h4 id="相关主题">相关主题</h4>
<ul>
<li>维基百科 CSRF，这里对 CSRF 有一个较为全面地介绍。 <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Cross-site_request_forgery">http://en.wikipedia.org/wiki/Cross-site_request_forgery</a></li>
<li>开源项目 CSRFGuard，介绍了如何使用在 HTTP 请求中加入 token 并验证的方法来抵御 CSRF。<a target="_blank" rel="noopener" href="http://www.owasp.org/index.php/Category:OWASP_CSRFGuard_Project">http://www.owasp.org/index.php/Category:OWASP_CSRFGuard_Project</a></li>
<li>Prevent Cross-site Request Forgery: PCRF。建议了一种在 PHP 中使用 token 来抵御 CSRF 的方法。  <a target="_blank" rel="noopener" href="http://userweb.cs.utexas.edu/~samuel/PCRF/Final_PCRF_paper.pdf">http://userweb.cs.utexas.edu/~samuel/PCRF/Final_PCRF_paper.pdf</a></li>
<li><a target="_blank" rel="noopener" href="http://www.adambarth.com/papers/2008/barth-jackson-mitchell-b.pdf">Robust Defenses for Cross-site Request Forgery</a>：分析了一些常用的 CSRF 抵御方法并独创性的提出增强浏览器的解决方案。</li>
<li><a target="_blank" rel="noopener" href="http://www.ibm.com/developerworks/cn/web/">developerWorks Web development                专区</a>：通过专门关于 Web 技术的文章和教程，扩展您在网站开发方面的技能。</li>
<li><a target="_blank" rel="noopener" href="http://www.ibm.com/developerworks/cn/ajax/">developerWorks Ajax 资源中心</a>：这是有关 Ajax 编程模型信息的一站式中心，包括很多文档、教程、论坛、blog、wiki 和新闻。任何 Ajax 的新信息都能在这里找到。</li>
<li><a target="_blank" rel="noopener" href="http://www.ibm.com/developerworks/cn/web20/">developerWorks Web 2.0 资源中心</a>，这是有关 Web 2.0 相关信息的一站式中心，包括大量 Web 2.0 技术文章、教程、下载和相关技术资源。您还可以通过 <a target="_blank" rel="noopener" href="http://www.ibm.com/developerworks/cn/web20/newto/">Web 2.0 新手入门</a> 栏目，迅速了解 Web 2.0 的相关概念。</li>
<li>查看 <a target="_blank" rel="noopener" href="http://www.ibm.com/developerworks/cn/web/lp/html5/">HTML5 专题</a>，了解更多和 HTML5 相关的知识和动向。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/web/1102_niugang_csrf/">https://www.ibm.com/developerworks/cn/web/1102_niugang_csrf/</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://991688344.github.io">LYC</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://991688344.github.io/2020/02/25/CSRF%E6%BC%8F%E6%B4%9E/">http://991688344.github.io/2020/02/25/CSRF%E6%BC%8F%E6%B4%9E/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://991688344.github.io" target="_blank">Rick</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%AE%89%E5%85%A8/">安全</a></div><div class="post-share"><div class="social-share" data-image="/images/Wallpaper/rainbowcat.gif" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2020/02/25/HCTF2018/" title="HCTF2018"><img class="cover" src="/images/Wallpaper/rainbowcat.gif" onerror="onerror=null;src='/images/404.png'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">HCTF2018</div></div><div class="info-2"><div class="info-item-1">WarmUp 题目原型是phpmyadmin4.8.1的任意文件包含漏洞 题目源码source.php 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 &lt;?php    highlight_file(__FILE__);    class emmm    &#123;        public static function checkFile(&amp;$page)        &#123;            $whitelist = [&quot;source&quot;=&gt;&quot;source.php&quot;,&quot;hint&quot;=&gt;&quot;hint.php&quot;];            if (! isset($page) || !is_string($page)) &#123;                echo &quot;you can&#x27;t see...</div></div></div></a><a class="pagination-related" href="/2020/02/25/XXE%E6%BC%8F%E6%B4%9E/" title="XXE漏洞"><img class="cover" src="/images/Wallpaper/rainbowcat.gif" onerror="onerror=null;src='/images/404.png'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">XXE漏洞</div></div><div class="info-2"><div class="info-item-1"> DTD:   //EMPTY关键字表示元素是个空元素   &lt;!ELEMENT root ANY&gt; //ANY关键字表示元素中可以出现任何内容,也可以为空   //下面这个声明表示root中可以有文本,也可以是空   &lt;!ELEMENT root (#PCDATA)&gt; //()表示一个分组,其中是放的允许在元素出现的内容,#PCDATA表示文本   &lt;!ELEMENT root (child)&gt; //child是子元素的名称,这个声明表示root中必须且只能有一个child元素   &lt;!ELEMENT root (child1,child2)&gt; //以逗号分隔,表示子元素依次出现   &lt;!ELEMENT root (child1|child2)&gt; //竖线与&quot;OR&quot;的意思相近,表示root元素中只能出现child1或child2   &lt;!ELEMENT root (child?)&gt; //root中child子元素可以出现一次,也可以不出现   &lt;!ELEMENT root...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2020/03/27/CORS%E4%B8%8Ejsonp/" title="CORS与jsonp"><img class="cover" src="/images/Wallpaper/rainbowcat.gif" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-03-27</div><div class="info-item-2">CORS与jsonp</div></div><div class="info-2"><div class="info-item-1">https://juejin.im/post/5cb5c40ff265da03a158210e </div></div></div></a><a class="pagination-related" href="/2020/05/07/CTF%E4%B8%AD%E7%9A%84htaccess/" title="CTF中的htaccess"><img class="cover" src="/images/Wallpaper/eatham.gif" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-05-07</div><div class="info-item-2">CTF中的htaccess</div></div><div class="info-2"><div class="info-item-1">服务器中间件为apache，因此想到了传.htaceess来解析php，通常我们用 .htaccess来解析非php后缀文件时用到 AddType application/x-httpd-php .ppp 或者 123&lt;FilesMatch &quot;shell.jpg&quot;&gt; SetHandler application/x-httpd-php&lt;/FilesMatch&gt; auto_append_file和auto_prepend_file 相关bypass 如果文件末尾被自动加上一句话,会导致服务器500错误,这时候可以在最后添加#\ 将换行转义成普通字符 如果特殊字符被实体编码, 可以通过特殊编码来绕过   相关比赛 XNUCA2019Qualifier </div></div></div></a><a class="pagination-related" href="/2022/05/18/CVE-2019-12422_Shiro_Remember%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/" title="CVE-2020-17523_Apache_Shiro身份认证绕过"><img class="cover" src="/images/Wallpaper/rainbowcat.gif" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-18</div><div class="info-item-2">CVE-2020-17523_Apache_Shiro身份认证绕过</div></div><div class="info-2"><div class="info-item-1">CVE-2019-12422 漏洞描述 Shiro RememberMe 反序列化漏洞 漏洞成因 由于Apache Shiro cookie中通过 AES-128-CBC 模式加密的rememberMe字段存在问题，用户可通过Padding  Oracle 加密生成的攻击代码来构造恶意的rememberMe字段，并重新请求网站，进行反序列化攻击，最终导致任意代码执行。 shiro对于Cookie处理做了如下实现： 123456789101112131415161718192021222324252627282930protected byte[] decrypt(byte[] encrypted) &#123;	byte[] serialized = encrypted;	CipherService cipherService = getCipherService();	if (cipherService != null) &#123;		ByteSource byteSource = cipherService.decrypt(encrypted,...</div></div></div></a><a class="pagination-related" href="/2022/05/18/CVE-2020-17523_Apache_Shiro%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E7%BB%95%E8%BF%87/" title="CVE-2020-17523_Apache_Shiro身份认证绕过"><img class="cover" src="/images/Wallpaper/eatham.gif" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-18</div><div class="info-item-2">CVE-2020-17523_Apache_Shiro身份认证绕过</div></div><div class="info-2"><div class="info-item-1">CVE-2020-17523 漏洞描述 Apache Shiro身份认证绕过漏洞 漏洞成因 Shiro中对于URL的获取及匹配在org.apache.shiro.web.filter.mgt.PathMatchingFilterChainResolver#getChain 先看下这个getChain方法： 12345678910111213141516171819202122232425262728293031323334353637public FilterChain getChain(ServletRequest request, ServletResponse response, FilterChain originalChain) &#123;        FilterChainManager filterChainManager = getFilterChainManager();        if (!filterChainManager.hasChains()) &#123;            return null;        &#125;     ...</div></div></div></a><a class="pagination-related" href="/2022/04/26/Cobalt-Strike%E4%BD%BF%E7%94%A8/" title="Cobalt Strike使用"><img class="cover" src="/2022/04/26/Cobalt-Strike%E4%BD%BF%E7%94%A8/cover.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-26</div><div class="info-item-2">Cobalt Strike使用</div></div><div class="info-2"><div class="info-item-1"> Cobalt Strike基础教程 Cobalt Strike使用教程一  https://zhuanlan.zhihu.com/p/359251293 </div></div></div></a><a class="pagination-related" href="/2020/10/30/DHCP%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%94%BB%E9%98%B2/" title="DHCP服务器攻防"><img class="cover" src="/images/Wallpaper/rainbowcat.gif" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-30</div><div class="info-item-2">DHCP服务器攻防</div></div><div class="info-2"><div class="info-item-1">DHCP服务器的防攻击手段 （一）、DHCP服务器面临的安全威胁 DHCP在设计上未充分考虑到安全因素，从而留下许多安全漏洞，使得DHCP很容易受到攻击。在实际网络中，针对DHCP攻击的手段主要有以下三种： 1、DHCP饿死攻击  【攻击原理】：攻击者持续大量地向DHCP服务器申请IP地址，直到耗尽DHCP服务器地址池的IP地址，使DHCP服务器无法再给正常的主机分配IP地址 在PC机给DHCP Server发送的DHCP Discover  报文中有一个CHADDR字段，该字段是由DHCP客户端填写的，用来表示客户端的硬件地址（MAC地址），而DHCP Server  也是根据CHADDR字段来分配IP地址的，对于不同的CHADDR，DHCP Server会分配不同的IP地址，因为DHCP Server  无法识别CHADDR的合法性，攻击者就利用这个漏洞，不断的改变CHADDR字段的值，来冒充不同的用户申请IP地址，使DHCP Server  中IP池枯竭，从而达到攻击目的。 2、仿冒DHCP Server攻击  【攻击原理】：当攻击者私自安装并运行DHCP Server...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="lv-container" data-id="city" data-uid="MTAyMC80NzA1My8yMzU1Mw=="></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/images/head.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">LYC</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">251</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">37</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">49</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">什么是CSRF</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#CSRF-%E8%83%8C%E6%99%AF%E4%B8%8E%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.1.</span> <span class="toc-text">CSRF 背景与介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CSRF-%E6%94%BB%E5%87%BB%E5%AE%9E%E4%BE%8B"><span class="toc-number">1.1.1.</span> <span class="toc-text">CSRF 攻击实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSRF-%E6%94%BB%E5%87%BB%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.1.2.</span> <span class="toc-text">CSRF 攻击的对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%93%E5%89%8D%E9%98%B2%E5%BE%A1-CSRF-%E7%9A%84%E5%87%A0%E7%A7%8D%E7%AD%96%E7%95%A5"><span class="toc-number">1.2.</span> <span class="toc-text">当前防御 CSRF 的几种策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81-HTTP-Referer-%E5%AD%97%E6%AE%B5"><span class="toc-number">1.2.1.</span> <span class="toc-text">验证 HTTP Referer 字段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E8%AF%B7%E6%B1%82%E5%9C%B0%E5%9D%80%E4%B8%AD%E6%B7%BB%E5%8A%A0-token-%E5%B9%B6%E9%AA%8C%E8%AF%81"><span class="toc-number">1.2.2.</span> <span class="toc-text">在请求地址中添加 token 并验证</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8-HTTP-%E5%A4%B4%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%E5%B9%B6%E9%AA%8C%E8%AF%81"><span class="toc-number">1.2.3.</span> <span class="toc-text">在 HTTP 头中自定义属性并验证</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.3.</span> <span class="toc-text">Java 代码示例</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B8%85%E5%8D%95-1-%E5%9C%A8-Filter-%E4%B8%AD%E9%AA%8C%E8%AF%81-Referer"><span class="toc-number">1.3.0.0.1.</span> <span class="toc-text">清单 1. 在 Filter 中验证 Referer</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B8%85%E5%8D%95-2-%E5%9C%A8-filter-%E4%B8%AD%E9%AA%8C%E8%AF%81%E8%AF%B7%E6%B1%82%E4%B8%AD%E7%9A%84-token"><span class="toc-number">1.3.0.0.2.</span> <span class="toc-text">清单 2. 在 filter 中验证请求中的 token</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B8%85%E5%8D%95-3-%E5%9C%A8%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AF%B9%E4%BA%8E%E8%AF%B7%E6%B1%82%E9%99%84%E5%8A%A0-token"><span class="toc-number">1.3.0.0.3.</span> <span class="toc-text">清单 3. 在客户端对于请求附加 token</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B8%85%E5%8D%95-4-%E5%9C%A8-HTTP-%E5%A4%B4%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7"><span class="toc-number">1.3.0.0.4.</span> <span class="toc-text">清单 4. 在 HTTP 头中自定义属性</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CSRF-%E9%98%B2%E5%BE%A1%E6%96%B9%E6%B3%95%E9%80%89%E6%8B%A9%E4%B9%8B%E9%81%93"><span class="toc-number">1.4.</span> <span class="toc-text">CSRF 防御方法选择之道</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E4%B8%BB%E9%A2%98"><span class="toc-number">1.4.0.1.</span> <span class="toc-text">相关主题</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/08/29/4GPU%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%8F%8A%E7%BB%B4%E6%8A%A4/" title="4GPU服务器环境配置及维护"><img src="/images/Wallpaper/rainbowcat.gif" onerror="this.onerror=null;this.src='/images/404.png'" alt="4GPU服务器环境配置及维护"/></a><div class="content"><a class="title" href="/2023/08/29/4GPU%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%8F%8A%E7%BB%B4%E6%8A%A4/" title="4GPU服务器环境配置及维护">4GPU服务器环境配置及维护</a><time datetime="2023-08-29T12:00:26.000Z" title="发表于 2023-08-29 20:00:26">2023-08-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/29/UEFI-systemd%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/" title="UEFI+systemd开机启动流程"><img src="/images/Wallpaper/eatham.gif" onerror="this.onerror=null;this.src='/images/404.png'" alt="UEFI+systemd开机启动流程"/></a><div class="content"><a class="title" href="/2023/08/29/UEFI-systemd%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/" title="UEFI+systemd开机启动流程">UEFI+systemd开机启动流程</a><time datetime="2023-08-29T08:39:54.000Z" title="发表于 2023-08-29 16:39:54">2023-08-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/27/udev%E9%85%8D%E7%BD%AELinux%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3/" title="udev配置Linux网络接口"><img src="/images/Wallpaper/eatham.gif" onerror="this.onerror=null;this.src='/images/404.png'" alt="udev配置Linux网络接口"/></a><div class="content"><a class="title" href="/2023/08/27/udev%E9%85%8D%E7%BD%AELinux%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3/" title="udev配置Linux网络接口">udev配置Linux网络接口</a><time datetime="2023-08-27T12:49:29.000Z" title="发表于 2023-08-27 20:49:29">2023-08-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/27/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BD%91%E7%BB%9C%E8%BF%90%E7%BB%B4/" title="实验室服务器网络运维"><img src="/images/Wallpaper/eatham.gif" onerror="this.onerror=null;this.src='/images/404.png'" alt="实验室服务器网络运维"/></a><div class="content"><a class="title" href="/2023/08/27/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BD%91%E7%BB%9C%E8%BF%90%E7%BB%B4/" title="实验室服务器网络运维">实验室服务器网络运维</a><time datetime="2023-08-27T12:20:23.000Z" title="发表于 2023-08-27 20:20:23">2023-08-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/11/21/Attention%E6%9C%BA%E5%88%B6-transformer/" title="Attention机制_transformer"><img src="/images/Wallpaper/eatham.gif" onerror="this.onerror=null;this.src='/images/404.png'" alt="Attention机制_transformer"/></a><div class="content"><a class="title" href="/2022/11/21/Attention%E6%9C%BA%E5%88%B6-transformer/" title="Attention机制_transformer">Attention机制_transformer</a><time datetime="2022-11-21T11:55:15.000Z" title="发表于 2022-11-21 19:55:15">2022-11-21</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2024 By LYC</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(async () => {
  const showKatex = () => {
    document.querySelectorAll('#article-container .katex').forEach(el => el.classList.add('katex-show'))
  }

  if (!window.katex_js_css) {
    window.katex_js_css = true
    await btf.getCSS('https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css')
    if (true) {
      await btf.getScript('https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js')
    }
  }

  showKatex()
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.isShuoshuo

  const loadLivere = (el, path) => {
    window.livereOptions = {
      refer: path || location.pathname
    }

    if (isShuoshuo) {
      window.shuoshuoComment.destroyLivere = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    if (typeof LivereTower === 'object') window.LivereTower.init()
    else {
      (function(d, s) {
          var j, e = d.getElementsByTagName(s)[0];
          if (typeof LivereTower === 'function') { return; }
          j = d.createElement(s);
          j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
          j.async = true;
          e.parentNode.insertBefore(j, e);
      })(document, 'script');
    }
  }

  if (isShuoshuo) {
    'Livere' === 'Livere'
      ? window.shuoshuoComment = { loadComment: loadLivere }
      : window.loadOtherComment = loadLivere
    return
  }

  if ('Livere' === 'Livere' || !false) {
    if (false) btf.loadComment(document.getElementById('lv-container'), loadLivere)
    else loadLivere()
  } else {
    window.loadOtherComment = loadLivere
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>