<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>docker镜像与分层 | Rick</title><meta name="author" content="LYC"><meta name="copyright" content="LYC"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="目录 *关于base镜像* 关于存储结构（About storage drivers） 先来创建一个自己的镜像 docker镜像的分层结构 容器的大小 修改时复制策略 copy-on-write (CoW) Copying makes containers efficient  关于base镜像 base 镜像有两层含义：  不依赖其他镜像，从 scratch 构建。 其他镜像可以之为基础进行扩">
<meta property="og:type" content="article">
<meta property="og:title" content="docker镜像与分层">
<meta property="og:url" content="http://991688344.github.io/2020/05/17/docker%E9%95%9C%E5%83%8F%E4%B8%8E%E5%88%86%E5%B1%82/index.html">
<meta property="og:site_name" content="Rick">
<meta property="og:description" content="目录 *关于base镜像* 关于存储结构（About storage drivers） 先来创建一个自己的镜像 docker镜像的分层结构 容器的大小 修改时复制策略 copy-on-write (CoW) Copying makes containers efficient  关于base镜像 base 镜像有两层含义：  不依赖其他镜像，从 scratch 构建。 其他镜像可以之为基础进行扩">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://991688344.github.io/images/Wallpaper/eatham.gif">
<meta property="article:published_time" content="2020-05-16T23:16:57.000Z">
<meta property="article:modified_time" content="2024-03-19T01:32:36.450Z">
<meta property="article:author" content="LYC">
<meta property="article:tag" content="Docker">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://991688344.github.io/images/Wallpaper/eatham.gif"><link rel="shortcut icon" href="/images/Wallpaper/favicon.ico"><link rel="canonical" href="http://991688344.github.io/2020/05/17/docker%E9%95%9C%E5%83%8F%E4%B8%8E%E5%88%86%E5%B1%82/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/content.json","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'docker镜像与分层',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><link rel="stylesheet" href="/mycss/my_background.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-color: #F7F9FE;"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/images/head.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">251</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">37</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">49</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-paper-plane"></i><span> 留言板</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/images/Wallpaper/eatham.gif);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Rick</span></a><a class="nav-page-title" href="/"><span class="site-name">docker镜像与分层</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-paper-plane"></i><span> 留言板</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">docker镜像与分层</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-05-16T23:16:57.000Z" title="发表于 2020-05-17 07:16:57">2020-05-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-03-19T01:32:36.450Z" title="更新于 2024-03-19 09:32:36">2024-03-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Docker/">Docker</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">3.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>17分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<h4 id="目录">目录</h4>
<p><em><strong>*关于base镜像*</strong></em></p>
<p><strong>关于存储结构（About storage drivers）</strong></p>
<p>先来创建一个自己的镜像</p>
<p>docker镜像的分层结构</p>
<p>容器的大小</p>
<p>修改时复制策略 copy-on-write (CoW)</p>
<p>Copying makes containers efficient</p>
</blockquote>
<h2 id="关于base镜像"><strong>关于base镜像</strong></h2>
<p>base 镜像有两层含义：</p>
<ul>
<li>不依赖其他镜像，从 scratch 构建。</li>
<li>其他镜像可以之为基础进行扩展。</li>
</ul>
<p>所以，能称作 base 镜像的通常都是各种 Linux 发行版的 Docker 镜像，比如 Ubuntu, Debian, CentOS 等。</p>
<p><strong>base 镜像提供的是最小安装的 Linux 发行版</strong>。</p>
<p>我们大部分镜像都将是基于base镜像构建的。所以，通常使用的是官方发布的base镜像。可以在docker hub里找到。比如centos：  <a target="_blank" rel="noopener" href="https://hub.docker.com/_/centos">https://hub.docker.com/_/centos</a></p>
<p>点击版本可以看到github里的Dockerfile</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FROM scratch</span><br><span class="line">ADD centos-7-docker.tar.xz /</span><br><span class="line"></span><br><span class="line">LABEL org.label-schema.schema-version=&quot;1.0&quot; \</span><br><span class="line">    org.label-schema.name=&quot;CentOS Base Image&quot; \</span><br><span class="line">    org.label-schema.vendor=&quot;CentOS&quot; \</span><br><span class="line">    org.label-schema.license=&quot;GPLv2&quot; \</span><br><span class="line">    org.label-schema.build-date=&quot;20181205&quot;</span><br><span class="line"></span><br><span class="line">CMD [&quot;/bin/bash&quot;]</span><br></pre></td></tr></table></figure>
<p>ADD命令将本地的centos7的tar包添加到镜像，并解压到根目录/下。生成/dev,/proc/,/bin等。</p>
<p>我们可以自己构建docker base镜像，也可以直接使用已有的base镜像。比如centos。我们可以直接从docker hub上拉取。</p>
<p>拉取</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull centos</span><br></pre></td></tr></table></figure>
<p>查看</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker images centos </span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">centos              latest              1e1148e4cc2c        2 months ago        202MB</span><br></pre></td></tr></table></figure>
<p>可以看到最新的centos镜像只有200mb，是不是觉得太小了？这是因为docker镜像在运行的时候直接使用docker宿主机器的kernel。</p>
<p>Linux操作系统由内核空间和用户空间组成。</p>
<p>内核空间是kernel，用户空间是rootfs, 不同Linux发行版的区别主要是rootfs.比如 Ubuntu 14.04 使用  upstart 管理服务，apt 管理软件包；而 CentOS 7 使用 systemd 和 yum。这些都是用户空间上的区别，Linux  kernel 差别不大。</p>
<p>所以 Docker 可以同时支持多种 Linux 镜像，模拟出多种操作系统环境。</p>
<p>需要注意的是：</p>
<ul>
<li>
<p>base镜像只是用户空间和发行版一致。kernel使用的是docker宿主机器的kernel。例如 CentOS 7 使用 3.x.x 的 kernel，如果 Docker Host 是 Ubuntu 16.04，那么在 CentOS 容器中使用的实际是是  Host 4.x.x 的 kernel。</p>
</li>
<li>
<p>① Host kernel 为 4.4.0-31</p>
</li>
<li>
<p>② 启动并进入 CentOS 容器</p>
</li>
<li>
<p>③ 验证容器是 CentOS 7</p>
</li>
<li>
<p>④ 容器的 kernel 版本与 Host 一致</p>
</li>
</ul>
<h2 id="关于存储结构（About-storage-drivers）">关于存储结构（About storage drivers）</h2>
<p>上文里展示了如何下载一个base镜像。我们通常是基于这份base镜像来构建我们自己的镜像。比如，在centos里添加一个nginx负载均衡。首先，得需要了解镜像的结构是什么。</p>
<p>官方文档：  <a target="_blank" rel="noopener" href="https://docs.docker.com/storage/storagedriver/">https://docs.docker.com/storage/storagedriver/</a></p>
<h3 id="先来创建一个自己的镜像">先来创建一个自己的镜像</h3>
<p>首先，base镜像是基于docker宿主机器kernel之上的Linux发行版。</p>
<p>现在，我们给这台机器安装一个vim，一个httpd. 基于Dockerfile来创建一个新的镜像。</p>
<p>我们的Dockerfile</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM centos:7</span><br><span class="line">RUN yum install -y vim</span><br><span class="line">RUN yum install -y httpd</span><br><span class="line">CMD [&quot;/bin/bash&quot;]</span><br></pre></td></tr></table></figure>
<p>含义：</p>
<ul>
<li>基于centos7的base镜像构建</li>
<li>安装vim</li>
<li>安装httpd</li>
<li>执行bash</li>
</ul>
<p>在当前目录下新建一个文件Dockerfile, 填充上述内容。然后执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># docker build -t ryan/httpd:v1.0 .</span><br><span class="line">Sending build context to Docker daemon  6.144kB</span><br><span class="line">Step 1/4 : FROM centos:7</span><br><span class="line"> ---&gt; 1e1148e4cc2c</span><br><span class="line">Step 2/4 : RUN yum install -y vim</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 74bdbea98f73</span><br><span class="line">Step 3/4 : RUN yum install -y httpd</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 17d8c4095dc4</span><br><span class="line">Step 4/4 : CMD /bin/bash</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; f2b58b1192de</span><br><span class="line">Successfully built f2b58b1192de</span><br><span class="line">Successfully tagged ryan/httpd:latest</span><br></pre></td></tr></table></figure>
<ul>
<li>-t 指定我们创建的镜像名称，镜像名称可以用<code>组织/id:version</code>的方式标记</li>
<li>最后一个参数是Dockerfile所在的路径<code>.</code>, 表示当前目录</li>
</ul>
<p>然后我们添加一个tag <code>latest</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag ryan/httpd:v1.0 ryan/httpd:latest</span><br></pre></td></tr></table></figure>
<ul>
<li>即给镜像<code>ryan/httpd:v1.0</code>标记为<code>ryan/httpd:latest</code></li>
</ul>
<p>构建完成之后，查看</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># docker images  | grep -E &#x27;(ryan|centos)&#x27;</span><br><span class="line">ryan/httpd                                                               latest                     f2b58b1192de        About an hour ago   444MB</span><br><span class="line">ryan/httpd                                                               v1.0                       f2b58b1192de        About an hour ago   444MB</span><br><span class="line">centos                                                                   7                          1e1148e4cc2c        2 months ago        202MB</span><br><span class="line">centos                                                                   latest                     1e1148e4cc2c        2 months ago        202MB</span><br></pre></td></tr></table></figure>
<p>可以运行我们创建的镜像：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># docker run -d  --privileged=true -it ryan/httpd:v1.0 /usr/sbin/init</span><br><span class="line">48a4a128cd7b6924149cd97670919d4e2af6cb96c73c901af60d05fe4478225a</span><br><span class="line"># docker ps | grep ryan</span><br><span class="line">48a4a128cd7b        ryan/httpd:v1.0                                                          &quot;/usr/sbin/init&quot;         8 seconds ago       Up 8 seconds       </span><br></pre></td></tr></table></figure>
<p>现在我们的基于原生base centos7的httpd服务器已经启动了。可以通过<code>docker exec -it zealous_kirch /bin/bash</code>来进入容器内部，查看启动httpd。</p>
<h3 id="docker镜像的分层结构">docker镜像的分层结构</h3>
<p>我们可以查看镜像的历史，用上一步的镜像id  f2b58b1192de</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker history f2b58b1192de</span></span><br><span class="line">IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT</span><br><span class="line">f2b58b1192de        About an hour ago   /bin/sh -c <span class="comment">#(nop)  CMD [&quot;/bin/bash&quot;]            0B                  </span></span><br><span class="line">17d8c4095dc4        About an hour ago   /bin/sh -c yum install -y httpd                 110MB               </span><br><span class="line">74bdbea98f73        About an hour ago   /bin/sh -c yum install -y vim                   133MB               </span><br><span class="line">1e1148e4cc2c        2 months ago        /bin/sh -c <span class="comment">#(nop)  CMD [&quot;/bin/bash&quot;]            0B                  </span></span><br><span class="line">&lt;missing&gt;           2 months ago        /bin/sh -c <span class="comment">#(nop)  LABEL org.label-schema....   0B                  </span></span><br><span class="line">&lt;missing&gt;           2 months ago        /bin/sh -c <span class="comment">#(nop) ADD file:6f877549795f479...   202MB   </span></span><br></pre></td></tr></table></figure>
<p>启动镜像的时候，一个新的可写层会加载到镜像的顶部。这一层通常称为“容器层”， 之下是“镜像层”。</p>
<p>容器层可以读写，容器所有发生文件变更写都发生在这一层。镜像层read-only,只允许读取。</p>
<p><img src="/2020/05/17/docker%E9%95%9C%E5%83%8F%E4%B8%8E%E5%88%86%E5%B1%82/container-layers.jpg" alt="img"></p>
<p>第一列是imageid, 最上面的id就是我们新创建ryan/httpd:latest. 下面几行都是我们dockerfile里定义的步骤堆栈。由此可以看出，每个步骤都将创建一个imgid, 一直追溯到<code>1e1148e4cc2c</code>正好是我们的base镜像的id。关于``的部分，则不在本机上。</p>
<p>最后一列是每一层的大小。最后一层只是启动<code>bash</code>，所以没有文件变更，大小是0. 我们创建的镜像是在base镜像之上的，并不是完全复制一份base，然后修改，而是共享base的内容。这时候，如果我们新建一个新的镜像，同样也是共享base镜像。</p>
<p>那修改了base镜像，会不会导致我们创建的镜像也被修改呢？ 不会！因为不允许修改历史镜像，只允许修改容器，而容器只可以在最上面的容器层进行写和变更。</p>
<blockquote>
<p><strong>Note</strong>: If you need multiple images to have shared access to the exact same data, store this data in a Docker volume and mount it into your containers.</p>
</blockquote>
<h3 id="容器的大小">容器的大小</h3>
<p>创建镜像的时候，分层可以让docker只保存我们添加和修改的部分内容。其他内容基于base镜像，不需要存储，读取base镜像即可。如此，当我们创建多个镜像的时候，所有的镜像共享base部分。节省了磁盘空间。</p>
<p><img src="/2020/05/17/docker%E9%95%9C%E5%83%8F%E4%B8%8E%E5%88%86%E5%B1%82/sharing-layers.jpg" alt="Containers sharing same image"></p>
<p>对于启动的容器，查看所需要的磁盘空间可以通过<code>docker ps  -s</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># docker run -d -it centos</span><br><span class="line">4b0df4bc3e705c540144d545441930689124ade087961d01f56c2ac55bfd986d</span><br><span class="line"># docker ps -s | grep -E &#x27;(ryan|centos)&#x27;</span><br><span class="line">4b0df4bc3e70        centos                                                                   &quot;/bin/bash&quot;              23 seconds ago      Up 23 seconds                           vigorous_elion                                                                                                                           0B (virtual 202MB)</span><br><span class="line">b36421d05005        ryan/httpd:v1.0                                                          &quot;/usr/sbin/init&quot;         32 minutes ago      Up 32 minutes                           gracious_swirles                                                                                                                         61.6kB (virtual 444MB)</span><br></pre></td></tr></table></figure>
<ul>
<li>首先启动一个base镜像用来对比</li>
<li>可以看到第一行就是base镜像centos，第2列的size是0和202MB, 0表示容器层可写层的大小，virtual则是容器层+镜像层的大小。这里对比可以看到一共202M,正好是最初centos镜像的大小。</li>
<li>第二行是我们自己创建的镜像。virtual达到了444MB。对比前面的history部分，可以发现这个数字是每一层大小之和。同时，由于共享base，其中的202M是和第一行的镜像共享的。</li>
</ul>
<h3 id="Sharing-promotes-smaller-images">Sharing promotes smaller images</h3>
<p>When you use <code>docker pull</code> to pull down an image from a repository, or when you create a container from an image that does not yet exist locally, each layer is pulled down separately, and stored in Docker’s local storage area, which is usually <code>/var/lib/docker/</code> on Linux hosts. You can see these layers being pulled in this example:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull ubuntu:18.04</span><br><span class="line">18.04: Pulling from library/ubuntu</span><br><span class="line">f476d66f5408: Pull complete</span><br><span class="line">8882c27f669e: Pull complete</span><br><span class="line">d9af21273955: Pull complete</span><br><span class="line">f5029279ec12: Pull complete</span><br><span class="line">Digest: sha256:ab6cb8de3ad7bb33e2534677f865008535427390b117d7939193f8d1a6613e34</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> ubuntu:18.04</span><br></pre></td></tr></table></figure>
<p>Each of these layers is stored in its own directory inside the Docker host’s local storage area. To examine the layers on the filesystem, list the contents of <code>/var/lib/docker/</code>. This example uses the <code>overlay2</code>  storage driver:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> /var/lib/docker/overlay2</span><br><span class="line">16802227a96c24dcbeab5b37821e2b67a9f921749cd9a2e386d5a6d5bc6fc6d3</span><br><span class="line">377d73dbb466e0bc7c9ee23166771b35ebdbe02ef17753d79fd3571d4ce659d7</span><br><span class="line">3f02d96212b03e3383160d31d7c6aeca750d2d8a1879965b89fe8146594c453d</span><br><span class="line">ec1ec45792908e90484f7e629330666e7eee599f08729c93890a7205a6ba35f5</span><br><span class="line">l</span><br></pre></td></tr></table></figure>
<p>The directory names do not correspond to the layer IDs (this has been true since Docker 1.10).</p>
<p>Now imagine that you have two different Dockerfiles. You use the first one to create an image called <code>acme/my-base-image:1.0</code>.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:18.04</span><br><span class="line">COPY . /app</span><br></pre></td></tr></table></figure>
<p>The second one is based on <code>acme/my-base-image:1.0</code>, but has some additional layers:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM acme/my-base-image:1.0</span><br><span class="line">CMD /app/hello.sh</span><br></pre></td></tr></table></figure>
<p>The second image contains all the layers from the first image, plus a new layer with the <code>CMD</code> instruction, and a read-write container layer. Docker already has all the layers from the first image, so it does not need to pull them again. The two images share any layers they have in common.</p>
<p>If you build images from the two Dockerfiles, you can use <code>docker image ls</code> and <code>docker history</code> commands to verify that the cryptographic IDs of the shared layers are the same.</p>
<ol>
<li>
<p>Make a new directory <code>cow-test/</code> and change into it.</p>
</li>
<li>
<p>Within <code>cow-test/</code>, create a new file called <code>hello.sh</code> with the following contents:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">echo &quot;Hello world&quot;</span><br></pre></td></tr></table></figure>
<p>Save the file, and make it executable:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x hello.sh</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Copy the contents of the first Dockerfile above into a new file called <code>Dockerfile.base</code>.</p>
</li>
<li>
<p>Copy the contents of the second Dockerfile above into a new file called <code>Dockerfile</code>.</p>
</li>
<li>
<p>Within the <code>cow-test/</code> directory, build the first image. Don’t forget to include the final <code>.</code> in the command. That sets the <code>PATH</code>, which tells Docker where to look for any files that need to be added to the image.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t acme/my-base-image:1.0 -f Dockerfile.base .</span><br><span class="line">Sending build context to Docker daemon  812.4MB</span><br><span class="line">Step 1/2 : FROM ubuntu:18.04</span><br><span class="line"> ---&gt; d131e0fa2585</span><br><span class="line">Step 2/2 : COPY . /app</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; bd09118bcef6</span><br><span class="line">Successfully built bd09118bcef6</span><br><span class="line">Successfully tagged acme/my-base-image:1.0</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Build the second image.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t acme/my-final-image:1.0 -f Dockerfile .</span><br><span class="line"></span><br><span class="line">Sending build context to Docker daemon  4.096kB</span><br><span class="line">Step 1/2 : FROM acme/my-base-image:1.0</span><br><span class="line"> ---&gt; bd09118bcef6</span><br><span class="line">Step 2/2 : CMD /app/hello.sh</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> a07b694759ba</span><br><span class="line"> ---&gt; dbf995fc07ff</span><br><span class="line">Removing intermediate container a07b694759ba</span><br><span class="line">Successfully built dbf995fc07ff</span><br><span class="line">Successfully tagged acme/my-final-image:1.0</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Check out the sizes of the images:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls</span><br><span class="line"></span><br><span class="line">REPOSITORY                         TAG                     IMAGE ID            CREATED             SIZE</span><br><span class="line">acme/my-final-image                1.0                     dbf995fc07ff        58 seconds ago      103MB</span><br><span class="line">acme/my-base-image                 1.0                     bd09118bcef6        3 minutes ago       103MB</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Check out the layers that comprise each image:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker history bd09118bcef6</span><br><span class="line">IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT</span><br><span class="line">bd09118bcef6        4 minutes ago       /bin/sh -c #(nop) COPY dir:35a7eb158c1504e...   100B                </span><br><span class="line">d131e0fa2585        3 months ago        /bin/sh -c #(nop)  CMD [&quot;/bin/bash&quot;]            0B                  </span><br><span class="line">&lt;missing&gt;           3 months ago        /bin/sh -c mkdir -p /run/systemd &amp;&amp; echo &#x27;...   7B                  </span><br><span class="line">&lt;missing&gt;           3 months ago        /bin/sh -c sed -i &#x27;s/^#\s*\(deb.*universe\...   2.78kB              </span><br><span class="line">&lt;missing&gt;           3 months ago        /bin/sh -c rm -rf /var/lib/apt/lists/*          0B                  </span><br><span class="line">&lt;missing&gt;           3 months ago        /bin/sh -c set -xe   &amp;&amp; echo &#x27;#!/bin/sh&#x27; &gt;...   745B                </span><br><span class="line">&lt;missing&gt;           3 months ago        /bin/sh -c #(nop) ADD file:eef57983bd66e3a...   103MB      </span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ docker history dbf995fc07ff</span><br><span class="line"></span><br><span class="line">IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT</span><br><span class="line">dbf995fc07ff        3 minutes ago       /bin/sh -c #(nop)  CMD [&quot;/bin/sh&quot; &quot;-c&quot; &quot;/a...   0B                  </span><br><span class="line">bd09118bcef6        5 minutes ago       /bin/sh -c #(nop) COPY dir:35a7eb158c1504e...   100B                </span><br><span class="line">d131e0fa2585        3 months ago        /bin/sh -c #(nop)  CMD [&quot;/bin/bash&quot;]            0B                  </span><br><span class="line">&lt;missing&gt;           3 months ago        /bin/sh -c mkdir -p /run/systemd &amp;&amp; echo &#x27;...   7B                  </span><br><span class="line">&lt;missing&gt;           3 months ago        /bin/sh -c sed -i &#x27;s/^#\s*\(deb.*universe\...   2.78kB              </span><br><span class="line">&lt;missing&gt;           3 months ago        /bin/sh -c rm -rf /var/lib/apt/lists/*          0B                  </span><br><span class="line">&lt;missing&gt;           3 months ago        /bin/sh -c set -xe   &amp;&amp; echo &#x27;#!/bin/sh&#x27; &gt;...   745B                </span><br><span class="line">&lt;missing&gt;           3 months ago        /bin/sh -c #(nop) ADD file:eef57983bd66e3a...   103MB  </span><br></pre></td></tr></table></figure>
<p>Notice that all the layers are identical except the top layer of the second image. All the other layers are shared between the two images, and are only stored once in <code>/var/lib/docker/</code>. The new layer actually doesn’t take any room at all, because it is not changing any files, but only running a command.</p>
<blockquote>
<p><strong>Note</strong>: The <code>&lt;missing&gt;</code> lines in the <code>docker history</code> output indicate that those layers were built on another system and are not available locally. This can be ignored.</p>
</blockquote>
</li>
</ol>
<h3 id="修改时复制策略-copy-on-write-CoW">修改时复制策略 copy-on-write (CoW)</h3>
<p>docker通过一个叫做copy-on-write (CoW) 的策略来保证base镜像的安全性，以及更高的性能和空间利用率。</p>
<blockquote>
<p>Copy-on-write is a strategy of sharing and copying files for maximum  efficiency. If a file or directory exists in a lower layer within the  image, and another layer (including the writable layer) needs read  access to it, it just uses the existing file. The first time another  layer needs to modify the file (when building the image or running the  container), the file is copied into that layer and modified. This  minimizes I/O and the size of each of the subsequent layers. These  advantages are explained in more depth below.</p>
<h3 id="Copying-makes-containers-efficient">Copying makes containers efficient</h3>
<p>When you start a container, a thin writable container layer is added  on top of the other layers. Any changes the container makes to the  filesystem are stored here. Any files the container does not change do  not get copied to this writable layer. This means that the writable  layer is as small as possible.</p>
<p>When an existing file in a container is modified, the storage driver  performs a copy-on-write operation. The specifics steps involved depend  on the specific storage driver. For the aufs, overlay, and overlay2  drivers, the copy-on-write operation follows this rough sequence:</p>
<p>Search through the image layers for the file to update. The process  starts at the newest layer and works down to the base layer one layer at a time. When results are found, they are added to a cache to speed  future operations.</p>
<p>Perform a copy_up operation on the first copy of the file that is found, to copy the file to the container’s writable layer.</p>
<p>Any modifications are made to this copy of the file, and the  container cannot see the read-only copy of the file that exists in the  lower layer.</p>
<p>Btrfs, ZFS, and other drivers handle the copy-on-write differently.  You can read more about the methods of these drivers later in their  detailed descriptions.</p>
<p>Containers that write a lot of data consume more space than  containers that do not. This is because most write operations consume  new space in the container’s thin writable top layer.</p>
</blockquote>
<p>简单的说，启动容器的时候，最上层容器层是可写层，之下的都是镜像层，只读层。</p>
<p><strong>当容器需要读取文件的时候</strong></p>
<p>从最上层镜像开始查找，往下找，找到文件后读取并放入内存，若已经在内存中了，直接使用。(即，同一台机器上运行的docker容器共享运行时相同的文件)。</p>
<p><strong>当容器需要添加文件的时候</strong></p>
<p>直接在最上面的容器层可写层添加文件，不会影响镜像层。</p>
<p><strong>当容器需要修改文件的时候</strong></p>
<p>从上往下层寻找文件，找到后，复制到容器可写层，然后，对容器来说，可以看到的是容器层的这个文件，看不到镜像层里的文件。容器在容器层修改这个文件。</p>
<p><strong>当容器需要删除文件的时候</strong></p>
<p>从上往下层寻找文件，找到后在容器中记录删除。即，并不会真正的删除文件，而是软删除。这将导致镜像体积只会增加，不会减少。</p>
<p>综上，Docker镜像通过分层实现了资源共享，通过copy-on-write实现了文件隔离。</p>
<p>对于文件只增加不减少问题，我们应当在同一层做增删操作，从而减少镜像体积。比如，如下测试。</p>
<p>Dockerfile.A: 分层删除文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FROM centos:7</span><br><span class="line">RUN yum install -y vim</span><br><span class="line">RUN yum install -y httpd</span><br><span class="line">WORKDIR /home</span><br><span class="line">RUN dd if=/dev/zero of=50M.file bs=1M count=50</span><br><span class="line">#创建大小为50M的测试文件</span><br><span class="line">RUN rm -rf 50M.file</span><br><span class="line">CMD [&quot;/bin/bash&quot;]</span><br></pre></td></tr></table></figure>
<p>构建</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t <span class="built_in">test</span>:a -f Dockerfile.A .</span><br></pre></td></tr></table></figure>
<p>Dockerfile.B: 同层删除</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM centos:7</span><br><span class="line">RUN yum install -y vim</span><br><span class="line">RUN yum install -y httpd</span><br><span class="line">WORKDIR /home</span><br><span class="line">RUN <span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=50M.file bs=1M count=50 &amp;&amp; <span class="built_in">rm</span> -rf 50M.file</span><br></pre></td></tr></table></figure>
<p>构建</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t <span class="built_in">test</span>:b -f Dockerfile.B .</span><br></pre></td></tr></table></figure>
<p>比较二者大小</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@sh-k8s-001 tmp]# docker images | grep <span class="built_in">test</span></span><br><span class="line"><span class="built_in">test</span>                                                                     a                          ae673aa7db48        9 minutes ago       497MB</span><br><span class="line"><span class="built_in">test</span>                                                                     b                          21b2bc49f0bd        12 minutes ago      444MB</span><br></pre></td></tr></table></figure>
<p>显然，分层删除操作并没有真正删除掉文件。</p>
<p><strong>来源</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/CloudMan6/p/6799197.html">https://www.cnblogs.com/CloudMan6/p/6799197.html</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/CloudMan6/p/6806193.html">https://www.cnblogs.com/CloudMan6/p/6806193.html</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/storage/storagedriver/">https://docs.docker.com/storage/storagedriver/</a></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://991688344.github.io">LYC</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://991688344.github.io/2020/05/17/docker%E9%95%9C%E5%83%8F%E4%B8%8E%E5%88%86%E5%B1%82/">http://991688344.github.io/2020/05/17/docker%E9%95%9C%E5%83%8F%E4%B8%8E%E5%88%86%E5%B1%82/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://991688344.github.io" target="_blank">Rick</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Docker/">Docker</a></div><div class="post-share"><div class="social-share" data-image="/images/Wallpaper/eatham.gif" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related  no-desc" href="/2020/05/17/nginx%E6%83%8A%E7%BE%A4/" title="nginx惊群"><img class="cover" src="/images/Wallpaper/rainbowcat.gif" onerror="onerror=null;src='/images/404.png'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">nginx惊群</div></div></div></a><a class="pagination-related" href="/2020/05/17/cat%E6%89%8B%E5%8A%A8%E8%BE%93%E5%85%A5/" title="cat手动输入"><img class="cover" src="/images/Wallpaper/rainbowcat.gif" onerror="onerror=null;src='/images/404.png'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">cat手动输入</div></div><div class="info-2"><div class="info-item-1">一 关于cat &lt;&lt; EOF语句的意思 在linux shell脚本中cat &lt;&lt; EOF的语句，起到什么作用？ 首先必须要说明的是EOF在这里没有特殊的含义，你可以使用FOE或OOO等（当然也不限制在三个字符或大写字符）。 接下来，简单描述一下几种常见的使用方式及其作用：   cat&lt;&lt;EOF，以EOF输入字符为标准输入结束：   cat&gt;filename，创建文件，并把标准输入输出到filename文件中，以ctrl+d作为输入结束：   cat&gt;filename&lt;&lt;EOF，以EOF作为输入结束，和ctrl+d的作用一样：   二 cat &lt;&lt;EOF与cat &lt;&lt;-EOF的区别 两个都是获取stdin,并在EOF处结束stdin，输出stdout。 但是&lt;&lt;-是什么意思呢？ 先来看man中的说明：  If the redirection operator is &lt;&lt;-, then all leading tab characters are stripped from...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2020/01/14/Docker-COmpose%E6%A8%A1%E6%9D%BF%E6%96%87%E4%BB%B6/" title="Docker-COmpose模板文件"><img class="cover" src="/images/Wallpaper/eatham.gif" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-01-14</div><div class="info-item-2">Docker-COmpose模板文件</div></div><div class="info-2"><div class="info-item-1">Docker官网 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263version: &#x27;2&#x27;services:  # 基本环境  nginx:    container_name: &quot;nginx&quot;    image: nginx    build: ./nginx    command: nginx -g &#x27;daemon off;&#x27;    restart: always    # 数据卷    volumes:      - &quot;$PWD/nginx/code:/usr/share/nginx/html&quot;      - &quot;$PWD/nginx/nginx.conf:/etc/nginx/nginx.conf&quot;      -...</div></div></div></a><a class="pagination-related" href="/2021/02/01/Docker%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F/" title="Docker网络模式"><img class="cover" src="/images/Wallpaper/rainbowcat.gif" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2021-02-01</div><div class="info-item-2">Docker网络模式</div></div><div class="info-2"><div class="info-item-1">https://www.cnblogs.com/zuxing/articles/8780661.html Docker自身的4种网络工作方式，和一些自定义网络模式 安装Docker时，它会自动创建三个网络，bridge（创建容器默认连接到此网络）、 none 、host host：容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口。 Container：创建的容器不会创建自己的网卡，配置自己的IP，而是和一个指定的容器共享IP、端口范围。 None：该模式关闭了容器的网络功能。 Bridge：此模式会为每一个容器分配、设置IP等，并将容器连接到一个docker0虚拟网桥，通过docker0网桥以及Iptables nat表配置与宿主机通信。 以上都是不用动手的，真正需要配置的是自定义网络。 默认网络 当你安装Docker时，它会自动创建三个网络。你可以使用以下docker network ls命令列出这些网络： 12345$ docker network lsNETWORK ID          NAME               ...</div></div></div></a><a class="pagination-related" href="/2021/02/01/Linux-Namespace%E4%B8%8EDocker%E5%8E%9F%E7%90%86/" title="Linux Namespace与Docker原理"><img class="cover" src="/images/Wallpaper/rainbowcat.gif" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2021-02-01</div><div class="info-item-2">Linux Namespace与Docker原理</div></div><div class="info-2"><div class="info-item-1">namespace 初识 Docker 是一个基于 namespace、cgroup、Union FS 等等技术的一个开源容器引擎，很多人都会觉得 Docker  是个新兴技术，其实不然，其主要隔离技术 Namespace 技术早在 Linux 内核版本为 2.6 时候就差不多完成了（像 Ubuntu  16.04 发行版本的内核基本上都是 4.4，CentOS 7 则普遍 3.10 ）。 Linux Namespace 是 Linux 提供的一种内核级别环境隔离的方法。 要想实现隔离的效果，需要完成的东西又有哪些呢？其实如果你安装了 gcc 工具链（安装 golang 之后就会有了），那么使用 man namespaces 命令就可以了解到 namespace 技术的大概，也可查看在线手册。 这里简单地搬运了些知识点，首先是 Linux 提供的具体的隔离内容：    Namespace 系统调用参数 内核版本 隔离内容     UTS (Unix Time-sharing System) CLONE_NEWUTS Linux 2.4.19 主机名与域名   IPC...</div></div></div></a><a class="pagination-related" href="/2022/05/08/docker-swarm%E9%9B%86%E7%BE%A4%E6%A6%82%E5%BF%B5/" title="docker-swarm集群概念"><img class="cover" src="/2022/05/08/docker-swarm%E9%9B%86%E7%BE%A4%E6%A6%82%E5%BF%B5/cover.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-08</div><div class="info-item-2">docker-swarm集群概念</div></div><div class="info-2"><div class="info-item-1">swarm简介 Docker Swarm 是 Docker 官方推出的容器集群管理工具，基于 Go 语言实现。代码开源在：https://github.com/docker/swarm 使用它可以将多个 Docker 主机封装为单个大型的虚拟 Docker 主机，快速打造一套容器云平台。 Docker Swarm 是生产环境中运行 Docker 应用程序最简单的方法。作为容器集群管理器，Swarm 最大的优势之一就是  100% 支持标准的 Docker API。各种基于标准 API 的工具比如 Compose、docker-py、各种管理软件，甚至  Docker 本身等都可以很容易的与 Swarm 进行集成。大大方便了用户将原先基于单节点的系统移植到 Swarm 上，同时 Swarm  内置了对 Docker 网络插件的支持，用户可以很容易地部署跨主机的容器集群服务。 Docker Swarm 和 Docker Compose 一样，都是 Docker 官方容器编排工具，但不同的是，Docker Compose 是一个在单个服务器或主机上创建多个容器的工具，而 Docker...</div></div></div></a><a class="pagination-related" href="/2022/04/20/docker%E5%B8%B8%E7%94%A8/" title="docker常用"><img class="cover" src="/2022/04/20/docker%E5%B8%B8%E7%94%A8/cover.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-20</div><div class="info-item-2">docker常用</div></div><div class="info-2"><div class="info-item-1">列出docker镜像 1docker images -a 列出docker网络 1docker network ls 列出所有容器基本信息 1docker ps -a 运行容器并进入容器内部 1234docker run -it -P --network localnet -v /var/www/html:/var/www/html fauria/lamp:v2  /bin/bash# -P 将容器内服务端口随机映射到主机端口# --network 将容器网络连接到指定网络，例如Host、bridge# -v 将主机的目录映射到容器内的某个目录 退出容器并保持容器后台运行 1键盘按键组合:  Ctrl+p+q 查看指定容器端口映射 1docker port	container_id 进入到正在运行的容器内部 1docker exec -it 0 /bin/bash 查看某个容器的详细配置 1docker inspect container_name  查看某个容器的PID 1docker inspect trusting_mayer -f...</div></div></div></a><a class="pagination-related" href="/2020/02/28/docker%E6%9E%84%E5%BB%BAweb%E7%8E%AF%E5%A2%83/" title="docker构建web环境"><img class="cover" src="/images/Wallpaper/eatham.gif" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-02-28</div><div class="info-item-2">docker构建web环境</div></div><div class="info-2"><div class="info-item-1">先简单理解 docker 的使用过程，它分为镜像构建与容器启动。   镜像构建：即创建一个镜像，它包含安装运行所需的环境、程序代码等。这个创建过程就是使用 dockerfile 来完成的。   容器启动：容器最终运行起来是通过拉取构建好的镜像，通过一系列运行指令（如端口映射、外部数据挂载、环境变量等）来启动服务的。针对单个容器，这可以通过 docker run 来运行。   而如果涉及多个容器的运行（如服务编排）就可以通过 docker-compose 来实现，它可以轻松的将多个容器作为 service 来运行（当然也可仅运行其中的某个），并且提供了 scale (服务扩容) 的功能。 简单总结： 1.dockerfile: 构建镜像； 2.docker run: 启动容器； 3.docker-compose: 启动服务； dockerfile的作用是从无到有的构建镜像。它包含安装运行所需的环境、程序代码等。这个创建过程就是使用 dockerfile  来完成的。Dockerfile - 为 docker build 命令准备的，用于建立一个独立的 image ，在...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="lv-container" data-id="city" data-uid="MTAyMC80NzA1My8yMzU1Mw=="></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/images/head.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">LYC</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">251</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">37</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">49</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95"><span class="toc-number">1.</span> <span class="toc-text">目录</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8Ebase%E9%95%9C%E5%83%8F"><span class="toc-number"></span> <span class="toc-text">关于base镜像</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%EF%BC%88About-storage-drivers%EF%BC%89"><span class="toc-number"></span> <span class="toc-text">关于存储结构（About storage drivers）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%88%E6%9D%A5%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%95%9C%E5%83%8F"><span class="toc-number"></span> <span class="toc-text">先来创建一个自己的镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#docker%E9%95%9C%E5%83%8F%E7%9A%84%E5%88%86%E5%B1%82%E7%BB%93%E6%9E%84"><span class="toc-number"></span> <span class="toc-text">docker镜像的分层结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-number"></span> <span class="toc-text">容器的大小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Sharing-promotes-smaller-images"><span class="toc-number"></span> <span class="toc-text">Sharing promotes smaller images</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E6%97%B6%E5%A4%8D%E5%88%B6%E7%AD%96%E7%95%A5-copy-on-write-CoW"><span class="toc-number"></span> <span class="toc-text">修改时复制策略 copy-on-write (CoW)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Copying-makes-containers-efficient"><span class="toc-number"></span> <span class="toc-text">Copying makes containers efficient</span></a></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/08/29/4GPU%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%8F%8A%E7%BB%B4%E6%8A%A4/" title="4GPU服务器环境配置及维护"><img src="/images/Wallpaper/rainbowcat.gif" onerror="this.onerror=null;this.src='/images/404.png'" alt="4GPU服务器环境配置及维护"/></a><div class="content"><a class="title" href="/2023/08/29/4GPU%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%8F%8A%E7%BB%B4%E6%8A%A4/" title="4GPU服务器环境配置及维护">4GPU服务器环境配置及维护</a><time datetime="2023-08-29T12:00:26.000Z" title="发表于 2023-08-29 20:00:26">2023-08-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/29/UEFI-systemd%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/" title="UEFI+systemd开机启动流程"><img src="/images/Wallpaper/eatham.gif" onerror="this.onerror=null;this.src='/images/404.png'" alt="UEFI+systemd开机启动流程"/></a><div class="content"><a class="title" href="/2023/08/29/UEFI-systemd%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/" title="UEFI+systemd开机启动流程">UEFI+systemd开机启动流程</a><time datetime="2023-08-29T08:39:54.000Z" title="发表于 2023-08-29 16:39:54">2023-08-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/27/udev%E9%85%8D%E7%BD%AELinux%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3/" title="udev配置Linux网络接口"><img src="/images/Wallpaper/eatham.gif" onerror="this.onerror=null;this.src='/images/404.png'" alt="udev配置Linux网络接口"/></a><div class="content"><a class="title" href="/2023/08/27/udev%E9%85%8D%E7%BD%AELinux%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3/" title="udev配置Linux网络接口">udev配置Linux网络接口</a><time datetime="2023-08-27T12:49:29.000Z" title="发表于 2023-08-27 20:49:29">2023-08-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/27/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BD%91%E7%BB%9C%E8%BF%90%E7%BB%B4/" title="实验室服务器网络运维"><img src="/images/Wallpaper/eatham.gif" onerror="this.onerror=null;this.src='/images/404.png'" alt="实验室服务器网络运维"/></a><div class="content"><a class="title" href="/2023/08/27/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BD%91%E7%BB%9C%E8%BF%90%E7%BB%B4/" title="实验室服务器网络运维">实验室服务器网络运维</a><time datetime="2023-08-27T12:20:23.000Z" title="发表于 2023-08-27 20:20:23">2023-08-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/11/21/Attention%E6%9C%BA%E5%88%B6-transformer/" title="Attention机制_transformer"><img src="/images/Wallpaper/eatham.gif" onerror="this.onerror=null;this.src='/images/404.png'" alt="Attention机制_transformer"/></a><div class="content"><a class="title" href="/2022/11/21/Attention%E6%9C%BA%E5%88%B6-transformer/" title="Attention机制_transformer">Attention机制_transformer</a><time datetime="2022-11-21T11:55:15.000Z" title="发表于 2022-11-21 19:55:15">2022-11-21</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2024 By LYC</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(async () => {
  const showKatex = () => {
    document.querySelectorAll('#article-container .katex').forEach(el => el.classList.add('katex-show'))
  }

  if (!window.katex_js_css) {
    window.katex_js_css = true
    await btf.getCSS('https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css')
    if (true) {
      await btf.getScript('https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js')
    }
  }

  showKatex()
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.isShuoshuo

  const loadLivere = (el, path) => {
    window.livereOptions = {
      refer: path || location.pathname
    }

    if (isShuoshuo) {
      window.shuoshuoComment.destroyLivere = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    if (typeof LivereTower === 'object') window.LivereTower.init()
    else {
      (function(d, s) {
          var j, e = d.getElementsByTagName(s)[0];
          if (typeof LivereTower === 'function') { return; }
          j = d.createElement(s);
          j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
          j.async = true;
          e.parentNode.insertBefore(j, e);
      })(document, 'script');
    }
  }

  if (isShuoshuo) {
    'Livere' === 'Livere'
      ? window.shuoshuoComment = { loadComment: loadLivere }
      : window.loadOtherComment = loadLivere
    return
  }

  if ('Livere' === 'Livere' || !false) {
    if (false) btf.loadComment(document.getElementById('lv-container'), loadLivere)
    else loadLivere()
  } else {
    window.loadOtherComment = loadLivere
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>